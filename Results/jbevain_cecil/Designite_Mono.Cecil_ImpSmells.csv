Implementation smell,Namespace,Class,File,Method,Description
Long Method,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The method has 342 lines of code.
Long Method,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The method has 259 lines of code.
Long Method,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetSize,The method has 165 lines of code.
Long Method,Mono.Cecil.Cil,OpCodeNames,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\OpCode.cs,OpCodeNames,The method has 1801 lines of code.
Long Method,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The method has 302 lines of code.
Long Method,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,WriteDOSHeader,The method has 135 lines of code.
Long Method,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,WriteOptionalHeaders,The method has 116 lines of code.
Complex Method,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,IsPrimitive,Cyclomatic complexity of the method is 15
Complex Method,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,IsTypeSpecification,Cyclomatic complexity of the method is 12
Complex Method,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,Cyclomatic complexity of the method is 44
Complex Method,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,Cyclomatic complexity of the method is 44
Complex Method,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetSize,Cyclomatic complexity of the method is 59
Complex Method,Mono.Cecil,AssemblyNameReference,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyNameReference.cs,Parse,Cyclomatic complexity of the method is 20
Complex Method,Mono.Cecil,ImmediateModuleReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,ReadType,Cyclomatic complexity of the method is 8
Complex Method,Mono.Cecil,MetadataReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,GetTypeReferenceScope,Cyclomatic complexity of the method is 10
Complex Method,Mono.Cecil,MetadataReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,GetFieldTypeSize,Cyclomatic complexity of the method is 31
Complex Method,Mono.Cecil,MetadataReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,ReadMethodSemantics,Cyclomatic complexity of the method is 20
Complex Method,Mono.Cecil,MetadataReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,LookupToken,Cyclomatic complexity of the method is 22
Complex Method,Mono.Cecil,MetadataReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,ReadMemberReference,Cyclomatic complexity of the method is 11
Complex Method,Mono.Cecil,MetadataReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,ReadExportedTypes,Cyclomatic complexity of the method is 8
Complex Method,Mono.Cecil,MetadataReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,GetExportedTypeScope,Cyclomatic complexity of the method is 10
Complex Method,Mono.Cecil,MetadataReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,ReadLocalScope,Cyclomatic complexity of the method is 8
Complex Method,Mono.Cecil,MetadataReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,ReadImportTarget,Cyclomatic complexity of the method is 34
Complex Method,Mono.Cecil,MetadataReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,GetCustomDebugInformation,Cyclomatic complexity of the method is 11
Complex Method,Mono.Cecil,SignatureReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,GetGenericParameter,Cyclomatic complexity of the method is 9
Complex Method,Mono.Cecil,SignatureReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,ReadArrayTypeSignature,Cyclomatic complexity of the method is 8
Complex Method,Mono.Cecil,SignatureReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,ReadTypeSignature,Cyclomatic complexity of the method is 24
Complex Method,Mono.Cecil,SignatureReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,ReadMethodSignature,Cyclomatic complexity of the method is 9
Complex Method,Mono.Cecil,SignatureReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,ReadCustomAttributeNamedArgument,Cyclomatic complexity of the method is 8
Complex Method,Mono.Cecil,SignatureReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,ReadPrimitiveValue,Cyclomatic complexity of the method is 14
Complex Method,Mono.Cecil,SignatureReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,GetPrimitiveType,Cyclomatic complexity of the method is 15
Complex Method,Mono.Cecil,SignatureReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,ReadMarshalInfo,Cyclomatic complexity of the method is 19
Complex Method,Mono.Cecil,ModuleWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,Write,Cyclomatic complexity of the method is 9
Complex Method,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,BuildModule,Cyclomatic complexity of the method is 12
Complex Method,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,AddResources,Cyclomatic complexity of the method is 12
Complex Method,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,AddType,Cyclomatic complexity of the method is 11
Complex Method,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,GetConstantType,Cyclomatic complexity of the method is 31
Complex Method,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,GetConstantType,Cyclomatic complexity of the method is 15
Complex Method,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,GetConstantSignature,Cyclomatic complexity of the method is 15
Complex Method,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,LookupToken,Cyclomatic complexity of the method is 14
Complex Method,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,AddCustomDebugInformations,Cyclomatic complexity of the method is 19
Complex Method,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,AddImportTarget,Cyclomatic complexity of the method is 34
Complex Method,Mono.Cecil,SignatureWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,WriteTypeSignature,Cyclomatic complexity of the method is 26
Complex Method,Mono.Cecil,SignatureWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,WriteArrayTypeSignature,Cyclomatic complexity of the method is 10
Complex Method,Mono.Cecil,SignatureWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,WriteCustomAttributeValue,Cyclomatic complexity of the method is 12
Complex Method,Mono.Cecil,SignatureWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,WritePrimitiveValue,Cyclomatic complexity of the method is 39
Complex Method,Mono.Cecil,SignatureWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,WriteCustomAttributeFieldOrPropType,Cyclomatic complexity of the method is 8
Complex Method,Mono.Cecil,SignatureWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,WriteMarshalInfo,Cyclomatic complexity of the method is 23
Complex Method,Mono.Cecil,SignatureWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,WriteSequencePoints,Cyclomatic complexity of the method is 9
Complex Method,Mono.Cecil,BaseAssemblyResolver,F:\newReposMay17\jbevain_cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetCorlib,Cyclomatic complexity of the method is 17
Complex Method,Mono.Cecil,MetadataImporter,F:\newReposMay17\jbevain_cecil\Mono.Cecil\Import.cs,ImportTypeSpecification,Cyclomatic complexity of the method is 47
Complex Method,Mono.Cecil,MetadataResolver,F:\newReposMay17\jbevain_cecil\Mono.Cecil\MetadataResolver.cs,Resolve,Cyclomatic complexity of the method is 10
Complex Method,Mono.Cecil,MetadataResolver,F:\newReposMay17\jbevain_cecil\Mono.Cecil\MetadataResolver.cs,GetMethod,Cyclomatic complexity of the method is 9
Complex Method,Mono.Cecil,MetadataSystem,F:\newReposMay17\jbevain_cecil\Mono.Cecil\MetadataSystem.cs,Clear,Cyclomatic complexity of the method is 20
Complex Method,Mono.Cecil,TypeParser,F:\newReposMay17\jbevain_cecil\Mono.Cecil\TypeParser.cs,ParseSpecs,Cyclomatic complexity of the method is 14
Complex Method,Mono.Cecil,TypeParser,F:\newReposMay17\jbevain_cecil\Mono.Cecil\TypeParser.cs,CreateSpecs,Cyclomatic complexity of the method is 18
Complex Method,Mono.Cecil,TypeParser,F:\newReposMay17\jbevain_cecil\Mono.Cecil\TypeParser.cs,AppendTypeSpecification,Cyclomatic complexity of the method is 27
Complex Method,Mono.Cecil,WindowsRuntimeProjections,F:\newReposMay17\jbevain_cecil\Mono.Cecil\WindowsRuntimeProjections.cs,Project,Cyclomatic complexity of the method is 10
Complex Method,Mono.Cecil,WindowsRuntimeProjections,F:\newReposMay17\jbevain_cecil\Mono.Cecil\WindowsRuntimeProjections.cs,ApplyProjection,Cyclomatic complexity of the method is 22
Complex Method,Mono.Cecil,WindowsRuntimeProjections,F:\newReposMay17\jbevain_cecil\Mono.Cecil\WindowsRuntimeProjections.cs,ApplyProjection,Cyclomatic complexity of the method is 10
Complex Method,Mono.Cecil,WindowsRuntimeProjections,F:\newReposMay17\jbevain_cecil\Mono.Cecil\WindowsRuntimeProjections.cs,Project,Cyclomatic complexity of the method is 22
Complex Method,Mono.Cecil,WindowsRuntimeProjections,F:\newReposMay17\jbevain_cecil\Mono.Cecil\WindowsRuntimeProjections.cs,ImplementsRedirectedInterface,Cyclomatic complexity of the method is 10
Complex Method,Mono.Cecil,WindowsRuntimeProjections,F:\newReposMay17\jbevain_cecil\Mono.Cecil\WindowsRuntimeProjections.cs,ApplyProjection,Cyclomatic complexity of the method is 16
Complex Method,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,ReadMethodBody,Cyclomatic complexity of the method is 13
Complex Method,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,ReadAsyncMethodBody,Cyclomatic complexity of the method is 8
Complex Method,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,ReadOperand,Cyclomatic complexity of the method is 27
Complex Method,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,ResolveBranches,Cyclomatic complexity of the method is 13
Complex Method,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,ReadExceptionHandlerSpecific,Cyclomatic complexity of the method is 9
Complex Method,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawMethodBody,Cyclomatic complexity of the method is 12
Complex Method,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,Cyclomatic complexity of the method is 43
Complex Method,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawExceptionHandlers,Cyclomatic complexity of the method is 9
Complex Method,Mono.Cecil.Cil,CodeWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeWriter.cs,WriteOperand,Cyclomatic complexity of the method is 51
Complex Method,Mono.Cecil.Cil,CodeWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeWriter.cs,ComputeExceptionHandlerStackSize,Cyclomatic complexity of the method is 8
Complex Method,Mono.Cecil.Cil,CodeWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeWriter.cs,CopyBranchStackSize,Cyclomatic complexity of the method is 10
Complex Method,Mono.Cecil.Cil,CodeWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeWriter.cs,ComputeStackDelta,Cyclomatic complexity of the method is 10
Complex Method,Mono.Cecil.Cil,CodeWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeWriter.cs,ComputePopDelta,Cyclomatic complexity of the method is 26
Complex Method,Mono.Cecil.Cil,CodeWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeWriter.cs,ComputePushDelta,Cyclomatic complexity of the method is 11
Complex Method,Mono.Cecil.Cil,CodeWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeWriter.cs,WriteExceptionHandlerSpecific,Cyclomatic complexity of the method is 9
Complex Method,Mono.Cecil.Cil,Instruction,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\Instruction.cs,GetSize,Cyclomatic complexity of the method is 19
Complex Method,Mono.Cecil.Cil,Instruction,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\Instruction.cs,ToString,Cyclomatic complexity of the method is 18
Complex Method,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ReadMetadataStream,Cyclomatic complexity of the method is 20
Complex Method,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,Cyclomatic complexity of the method is 163
Complex Method,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiKeyBlob,Cyclomatic complexity of the method is 8
Long Parameter List,Mono.Cecil,MetadataReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,ReadPointers,The method has 5 parameters.
Long Parameter List,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,MetadataBuilder,The method has 5 parameters.
Long Parameter List,Mono.Cecil,TypeReference,F:\newReposMay17\jbevain_cecil\Mono.Cecil\TypeReference.cs,TypeReference,The method has 5 parameters.
Long Parameter List,Mono.Cecil.Metadata,Row,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Metadata\Row.cs,Row,The method has 5 parameters.
Long Parameter List,Mono.Cecil.Metadata,Row,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Metadata\Row.cs,Row,The method has 6 parameters.
Long Parameter List,Mono.Cecil.Metadata,Row,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Metadata\Row.cs,Row,The method has 9 parameters.
Long Parameter List,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,ImageWriter,The method has 5 parameters.
Long Identifier,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,AddGenericParameters,The length of the parameter generic_param_constraint_table is 30.
Long Identifier,Mono.Cecil,WindowsRuntimeProjections,F:\newReposMay17\jbevain_cecil\Mono.Cecil\WindowsRuntimeProjections.cs,GetAssemblyReferences,The length of the parameter system_runtime_interopservices_windowsruntime is 45.
Long Identifier,Mono.Cecil,WindowsRuntimeProjections,F:\newReposMay17\jbevain_cecil\Mono.Cecil\WindowsRuntimeProjections.cs,GetAssemblyReferences,The length of the parameter system_runtime_windowsruntime_ui_xaml is 37.
Long Statement,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetCustomAttributes,The length of the statement  "	return module.HasImage () ? module.Read (ref variable' self' (provider' reader) => reader.ReadCustomAttributes (provider)) : variable = new Collection<CustomAttribute> (); " is 171.
Long Statement,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetGenericParameters,The length of the statement  "	return module.HasImage () ? module.Read (ref collection' self' (provider' reader) => reader.ReadGenericParameters (provider)) : collection = new GenericParameterCollection (self); " is 179.
Long Statement,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMarshalInfo,The length of the statement  "	return module.HasImage () ? module.Read (ref variable' self' (provider' reader) => reader.ReadMarshalInfo (provider)) : null; " is 125.
Long Statement,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetSecurityDeclarations,The length of the statement  "	return module.HasImage () ? module.Read (ref variable' self' (provider' reader) => reader.ReadSecurityDeclarations (provider)) : variable = new Collection<SecurityDeclaration> (); " is 179.
Long Statement,Mono.Cecil,ModuleReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,ReadSymbols,The length of the statement  "		var reader = parameters.SymbolStream != null ? symbol_reader_provider.GetSymbolReader (module' parameters.SymbolStream) : symbol_reader_provider.GetSymbolReader (module' module.FileName); " is 187.
Long Statement,Mono.Cecil,MetadataReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,ReadInterfaces,The length of the statement  "		interfaces.Add (new InterfaceImplementation (GetTypeDefOrRef (mapping [i].Col2)' new MetadataToken (TokenType.InterfaceImpl' mapping [i].Col1))); " is 145.
Long Statement,Mono.Cecil,MetadataReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,AddGenericConstraintMapping,The length of the statement  "	metadata.SetGenericConstraintMapping (generic_parameter' AddMapping (metadata.GenericConstraints' generic_parameter' constraint)); " is 130.
Long Statement,Mono.Cecil,MetadataReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,ReadXmlSecurityDeclaration,The length of the statement  "	var attribute = new SecurityAttribute (module.TypeSystem.LookupType ("System.Security.Permissions"' "PermissionSetAttribute")); " is 127.
Long Statement,Mono.Cecil,MetadataReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,ReadXmlSecurityDeclaration,The length of the statement  "	attribute.properties.Add (new CustomAttributeNamedArgument ("XML"' new CustomAttributeArgument (module.TypeSystem.String' ReadUnicodeStringBlob (signature)))); " is 159.
Long Statement,Mono.Cecil,MetadataReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,InitializeLocalScopes,The length of the statement  "		metadata.SetLocalScopes (method' AddMapping (metadata.LocalScopes' method' new Row<uint' Range' Range' uint' uint' uint> (import' variables' constants' scope_start' scope_length' i))); " is 184.
Long Statement,Mono.Cecil,MetadataReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,ReadLocalConstant,The length of the statement  "		value = new decimal (signature.ReadInt32 ()' signature.ReadInt32 ()' signature.ReadInt32 ()' (b & 0x80) != 0' (byte)(b & 0x7f)); " is 128.
Long Statement,Mono.Cecil,SignatureReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,ReadCustomAttributeElement,The length of the statement  "	return new CustomAttributeArgument (type' type.etype == ElementType.Object ? ReadCustomAttributeElement (ReadCustomAttributeFieldOrPropType ()) : ReadCustomAttributeElementValue (type)); " is 186.
Long Statement,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,BuildAssembly,The length of the statement  "	table.row = new AssemblyRow (name.HashAlgorithm' (ushort)name.Version.Major' (ushort)name.Version.Minor' (ushort)name.Version.Build' (ushort)name.Version.Revision' name.Attributes' GetBlobIndex (name.PublicKey)' GetStringIndex (name.Name)' GetStringIndex (name.Culture)); " is 271.
Long Statement,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,AddAssemblyReferences,The length of the statement  "		var rid = table.AddRow (new AssemblyRefRow ((ushort)version.Major' (ushort)version.Minor' (ushort)version.Build' (ushort)version.Revision' reference.Attributes' GetBlobIndex (key_or_token)' GetStringIndex (reference.Name)' GetStringIndex (reference.Culture)' GetBlobIndex (reference.Hash))); " is 291.
Long Statement,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,AddResources,The length of the statement  "			row.Col4 = CodedIndex.Implementation.CompressMetadataToken (new MetadataToken (TokenType.File' AddLinkedResource ((LinkedResource)resource))); " is 142.
Long Statement,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,AddLinkedResource,The length of the statement  "	return (uint)table.AddRow (new FileRow (FileAttributes.ContainsNoMetaData' GetStringIndex (resource.File)' GetBlobIndex (hash))); " is 129.
Long Statement,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,AddExportedTypes,The length of the statement  "		var rid = table.AddRow (new ExportedTypeRow (exported_type.Attributes' (uint)exported_type.Identifier' GetStringIndex (exported_type.Name)' GetStringIndex (exported_type.Namespace)' MakeCodedRID (GetExportedTypeScope (exported_type)' CodedIndex.Implementation))); " is 263.
Long Statement,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,CreateTypeRefRow,The length of the statement  "	return new TypeRefRow (MakeCodedRID (scope_token' CodedIndex.ResolutionScope)' GetStringIndex (type.Name)' GetStringIndex (type.Namespace)); " is 140.
Long Statement,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,AddType,The length of the statement  "	type_def_table.AddRow (new TypeDefRow (type.Attributes' GetStringIndex (type.Name)' GetStringIndex (type.Namespace)' MakeCodedRID (GetTypeToken (type.BaseType)' CodedIndex.TypeDefOrRef)' type.fields_range.Start' type.methods_range.Start)); " is 239.
Long Statement,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,AddGenericParameters,The length of the statement  "		var rid = generic_param_table.AddRow (new GenericParamRow ((ushort)generic_parameter.Position' generic_parameter.Attributes' MakeCodedRID (generic_parameter.Owner' CodedIndex.TypeOrMethodDef)' GetStringIndex (generic_parameter.Name))); " is 235.
Long Statement,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,AddConstraints,The length of the statement  "		table.AddRow (new GenericParamConstraintRow (rid' MakeCodedRID (GetTypeToken (constraints [i])' CodedIndex.TypeDefOrRef))); " is 123.
Long Statement,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,AddInterfaces,The length of the statement  "		var rid = iface_impl_table.AddRow (new InterfaceImplRow (type_rid' MakeCodedRID (GetTypeToken (iface_impl.InterfaceType)' CodedIndex.TypeDefOrRef))); " is 149.
Long Statement,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,AddField,The length of the statement  "	field_table.AddRow (new FieldRow (field.Attributes' GetStringIndex (field.Name)' GetBlobIndex (GetFieldSignature (field)))); " is 124.
Long Statement,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,AddMethod,The length of the statement  "	method_table.AddRow (new MethodRow (method.HasBody ? code.WriteMethodBody (method) : 0' method.ImplAttributes' method.Attributes' GetStringIndex (method.Name)' GetBlobIndex (GetMethodSignature (method))' param_rid)); " is 216.
Long Statement,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,AddPInvokeInfo,The length of the statement  "	table.AddRow (new ImplMapRow (pinvoke.Attributes' MakeCodedRID (method' CodedIndex.MemberForwarded)' GetStringIndex (pinvoke.EntryPoint)' pinvoke.Module.MetadataToken.RID)); " is 173.
Long Statement,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,AddOverrides,The length of the statement  "		table.AddRow (new MethodImplRow (method.DeclaringType.token.RID' MakeCodedRID (method' CodedIndex.MethodDefOrRef)' MakeCodedRID (LookupToken (overrides [i])' CodedIndex.MethodDefOrRef))); " is 187.
Long Statement,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,RequiresParameterRow,The length of the statement  "	return !string.IsNullOrEmpty (parameter.Name) || parameter.Attributes != ParameterAttributes.None || parameter.HasMarshalInfo || parameter.HasConstant || parameter.HasCustomAttributes; " is 184.
Long Statement,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,AddMarshalInfo,The length of the statement  "	table.AddRow (new FieldMarshalRow (MakeCodedRID (owner' CodedIndex.HasFieldMarshal)' GetBlobIndex (GetMarshalInfoSignature (owner)))); " is 134.
Long Statement,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,AddProperty,The length of the statement  "	property_table.AddRow (new PropertyRow (property.Attributes' GetStringIndex (property.Name)' GetBlobIndex (GetPropertySignature (property)))); " is 142.
Long Statement,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,AddEvent,The length of the statement  "	event_table.AddRow (new EventRow (@event.Attributes' GetStringIndex (@event.Name)' MakeCodedRID (GetTypeToken (@event.EventType)' CodedIndex.TypeDefOrRef))); " is 157.
Long Statement,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,AddConstant,The length of the statement  "	constant_table.AddRow (new ConstantRow (etype' MakeCodedRID (owner.MetadataToken' CodedIndex.HasConstant)' GetBlobIndex (GetConstantSignature (etype' constant)))); " is 163.
Long Statement,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,AddCustomAttributes,The length of the statement  "		custom_attribute_table.AddRow (new CustomAttributeRow (MakeCodedRID (owner' CodedIndex.HasCustomAttribute)' MakeCodedRID (LookupToken (attribute.Constructor)' CodedIndex.CustomAttributeType)' GetBlobIndex (GetCustomAttributeSignature (attribute)))); " is 249.
Long Statement,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,AddSecurityDeclarations,The length of the statement  "		declsec_table.AddRow (new DeclSecurityRow (declaration.Action' MakeCodedRID (owner' CodedIndex.HasDeclSecurity)' GetBlobIndex (GetSecurityDeclarationSignature (declaration)))); " is 176.
Long Statement,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,CreateMemberRefRow,The length of the statement  "	return new MemberRefRow (MakeCodedRID (GetTypeToken (member.DeclaringType)' CodedIndex.MemberRefParent)' GetStringIndex (member.Name)' GetBlobIndex (GetMemberRefSignature (member))); " is 182.
Long Statement,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,CreateMethodSpecRow,The length of the statement  "	return new MethodSpecRow (MakeCodedRID (LookupToken (method_spec.ElementMethod)' CodedIndex.MethodDefOrRef)' GetBlobIndex (GetMethodSpecSignature (method_spec))); " is 162.
Long Statement,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,CreateForeignMemberException,The length of the statement  "	return new ArgumentException (string.Format ("Member '{0}' is declared in another module and needs to be imported"' member)); " is 125.
Long Statement,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,AddStateMachineMethod,The length of the statement  "	state_machine_method_table.AddRow (new StateMachineMethodRow (method_info.Method.MetadataToken.RID' method_info.StateMachineKickOffMethod.MetadataToken.RID)); " is 158.
Long Statement,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,AddLocalScope,The length of the statement  "	var rid = local_scope_table.AddRow (new LocalScopeRow (method_info.Method.MetadataToken.RID' scope.import != null ? AddImportScope (scope.import) : 0' local_variable_rid' local_constant_rid' (uint)scope.Start.Offset' (uint)((scope.End.IsEndOfMethod ? method_info.code_size : scope.End.Offset) - scope.Start.Offset))); " is 317.
Long Statement,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,AddLocalVariables,The length of the statement  "		local_variable_table.AddRow (new LocalVariableRow (variable.Attributes' (ushort)variable.Index' GetStringIndex (variable.Name))); " is 129.
Long Statement,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,AddLocalConstants,The length of the statement  "		local_constant_table.AddRow (new LocalConstantRow (GetStringIndex (constant.Name)' GetBlobIndex (GetConstantSignature (constant)))); " is 132.
Long Statement,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,AddCustomDebugInformation,The length of the statement  "	var rid = custom_debug_information_table.AddRow (new CustomDebugInformationRow (MakeCodedRID (provider.MetadataToken' CodedIndex.HasCustomDebugInformation)' GetGuidIndex (custom_info.Identifier)' blob_index)); " is 209.
Long Statement,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,GetDocumentToken,The length of the statement  "	token = new MetadataToken (TokenType.Document' document_table.AddRow (new DocumentRow (GetBlobIndex (GetDocumentNameSignature (document))' GetGuidIndex (document.HashAlgorithm.ToGuid ())' GetBlobIndex (document.Hash)' GetGuidIndex (document.Language.ToGuid ())))); " is 264.
Long Statement,Mono.Cecil,SignatureWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,WriteMethodSignature,The length of the statement  "	var generic_arity = generic_provider != null && generic_provider.HasGenericParameters ? generic_provider.GenericParameters.Count : 0; " is 133.
Long Statement,Mono.Cecil,BaseAssemblyResolver,F:\newReposMay17\jbevain_cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetCurrentMonoGac,The length of the statement  "	return Path.Combine (Directory.GetParent (Path.GetDirectoryName (typeof(object).Module.FullyQualifiedName)).FullName' "gac"); " is 125.
Long Statement,Mono.Cecil,BaseAssemblyResolver,F:\newReposMay17\jbevain_cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetAssemblyFile,The length of the statement  "	return Path.Combine (Path.Combine (Path.Combine (gac' reference.Name)' gac_folder.ToString ())' reference.Name + ".dll"); " is 121.
Long Statement,Mono.Cecil,ReflectionImporter,F:\newReposMay17\jbevain_cecil\Mono.Cecil\Import.cs,ImportType,The length of the statement  "	var reference = new TypeReference (string.Empty' type.Name' module' ImportScope (type.Assembly ())' type.IsValueType ()); " is 121.
Long Statement,Mono.Cecil,ReflectionImporter,F:\newReposMay17\jbevain_cecil\Mono.Cecil\Import.cs,ImportMethod,The length of the statement  "		reference.ReturnType = method_info != null ? ImportType (method_info.ReturnType' context) : ImportType (typeof(void)' default(ImportGenericContext)); " is 149.
Long Statement,Mono.Cecil,ReflectionImporter,F:\newReposMay17\jbevain_cecil\Mono.Cecil\Import.cs,ImportReference,The length of the statement  "	return ImportType (type' ImportGenericContext.For (context)' context != null ? ImportGenericKind.Open : ImportGenericKind.Definition); " is 134.
Long Statement,Mono.Cecil,ReflectionImporter,F:\newReposMay17\jbevain_cecil\Mono.Cecil\Import.cs,ImportReference,The length of the statement  "	return ImportMethod (method' ImportGenericContext.For (context)' context != null ? ImportGenericKind.Open : ImportGenericKind.Definition); " is 138.
Long Statement,Mono.Cecil,ModuleDefinition,F:\newReposMay17\jbevain_cecil\Mono.Cecil\ModuleDefinition.cs,ReadModule,The length of the statement  "	var stream = GetFileStream (fileName' FileMode.Open' parameters.ReadWrite ? FileAccess.ReadWrite : FileAccess.Read' FileShare.Read); " is 132.
Long Statement,Mono.Cecil,WindowsRuntimeProjections,F:\newReposMay17\jbevain_cecil\Mono.Cecil\WindowsRuntimeProjections.cs,GetWellKnownTypeDefinitionTreatment,The length of the statement  "	var treatment = info.Attribute ? TypeDefinitionTreatment.RedirectToClrAttribute : TypeDefinitionTreatment.RedirectToClrType; " is 124.
Long Statement,Mono.Cecil,WindowsRuntimeProjections,F:\newReposMay17\jbevain_cecil\Mono.Cecil\WindowsRuntimeProjections.cs,Project,The length of the statement  "			if (@override.MetadataToken.TokenType == TokenType.MemberRef && ImplementsRedirectedInterface (@override' out disposable)) { " is 124.
Long Statement,Mono.Cecil,WindowsRuntimeProjections,F:\newReposMay17\jbevain_cecil\Mono.Cecil\WindowsRuntimeProjections.cs,Project,The length of the statement  "			treatment = MethodDefinitionTreatment.Runtime | MethodDefinitionTreatment.InternalCall | MethodDefinitionTreatment.Private; " is 123.
Long Statement,Mono.Cecil,WindowsRuntimeProjections,F:\newReposMay17\jbevain_cecil\Mono.Cecil\WindowsRuntimeProjections.cs,Project,The length of the statement  "	if (declaring_type.Module.MetadataKind == MetadataKind.WindowsMetadata && field.IsRuntimeSpecialName && field.Name == "value__") { " is 130.
Long Statement,Mono.Cecil,WindowsRuntimeProjections,F:\newReposMay17\jbevain_cecil\Mono.Cecil\WindowsRuntimeProjections.cs,GetAssemblyReferences,The length of the statement  "	var system_runtime_interopservices_windowsruntime = new AssemblyNameReference ("System.Runtime.InteropServices.WindowsRuntime"' version); " is 137.
Long Statement,Mono.Cecil,WindowsRuntimeProjections,F:\newReposMay17\jbevain_cecil\Mono.Cecil\WindowsRuntimeProjections.cs,GetAssemblyReferences,The length of the statement  "	var system_runtime_windowsruntime_ui_xaml = new AssemblyNameReference ("System.Runtime.WindowsRuntime.UI.Xaml"' version); " is 121.
Long Statement,Mono.Cecil,WindowsRuntimeProjections,F:\newReposMay17\jbevain_cecil\Mono.Cecil\WindowsRuntimeProjections.cs,GetAssemblyReferences,The length of the statement  "		system_runtime.PublicKey = system_runtime_interopservices_windowsruntime.PublicKey = system_objectmodel.PublicKey = system_numerics_vectors.PublicKey = contract_pk; " is 164.
Long Statement,Mono.Cecil,WindowsRuntimeProjections,F:\newReposMay17\jbevain_cecil\Mono.Cecil\WindowsRuntimeProjections.cs,GetAssemblyReferences,The length of the statement  "		system_runtime_windowsruntime.PublicKeyToken = system_runtime_windowsruntime_ui_xaml.PublicKeyToken = corlib.PublicKeyToken; " is 124.
Long Statement,Mono.Cecil,WindowsRuntimeProjections,F:\newReposMay17\jbevain_cecil\Mono.Cecil\WindowsRuntimeProjections.cs,GetAssemblyReferences,The length of the statement  "		system_runtime.PublicKeyToken = system_runtime_interopservices_windowsruntime.PublicKeyToken = system_objectmodel.PublicKeyToken = system_numerics_vectors.PublicKeyToken = contract_pk_token; " is 190.
Long Statement,Mono.Cecil,WindowsRuntimeProjections,F:\newReposMay17\jbevain_cecil\Mono.Cecil\WindowsRuntimeProjections.cs,IsWindowsAttributeUsageAttribute,The length of the statement  "	return declaring_type.Name == "AttributeUsageAttribute" && declaring_type.Namespace == /*"Windows.Foundation.Metadata"*/"System"; " is 129.
Long Statement,Mono.Cecil,WindowsRuntimeProjections,F:\newReposMay17\jbevain_cecil\Mono.Cecil\WindowsRuntimeProjections.cs,ApplyProjection,The length of the statement  "	attribute.ConstructorArguments [0] = new CustomAttributeArgument (attribute.ConstructorArguments [0].Type' attribute_targets); " is 126.
Long Statement,Mono.Cecil,WindowsRuntimeProjections,F:\newReposMay17\jbevain_cecil\Mono.Cecil\WindowsRuntimeProjections.cs,ApplyProjection,The length of the statement  "	attribute.Properties.Add (new CustomAttributeNamedArgument ("AllowMultiple"' new CustomAttributeArgument (attribute.Module.TypeSystem.Boolean' multiple))); " is 155.
Long Statement,Mono.Cecil,WindowsRuntimeProjections,F:\newReposMay17\jbevain_cecil\Mono.Cecil\WindowsRuntimeProjections.cs,RemoveProjection,The length of the statement  "	attribute.ConstructorArguments [0] = new CustomAttributeArgument (attribute.ConstructorArguments [0].Type' projection.Targets); " is 127.
Long Statement,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The length of the statement  "			buffer.WriteUInt32 (new MetadataToken (TokenType.String' metadata.user_string_heap.GetStringIndex (@string)).ToUInt32 ()); " is 122.
Long Statement,Mono.Cecil.Cil,CodeWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeWriter.cs,WriteOperand,The length of the statement  "	if (operand == null && !(operand_type == OperandType.InlineBrTarget || operand_type == OperandType.ShortInlineBrTarget)) { " is 122.
Long Statement,Mono.Cecil.Cil,CodeWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeWriter.cs,RequiresFatHeader,The length of the statement  "	return body.CodeSize >= 64 || body.InitLocals || body.HasVariables || body.HasExceptionHandlers || body.MaxStackSize > 8; " is 121.
Long Statement,Mono.Cecil.Cil,EmbeddedPortablePdbReaderProvider,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\PortablePdb.cs,GetSymbolReader,The length of the statement  "	return new EmbeddedPortablePdbReader ((PortablePdbReader)new PortablePdbReaderProvider ().GetSymbolReader (module' GetPortablePdbStream (entry))); " is 146.
Long Statement,Mono.Cecil.Cil,DefaultSymbolReaderProvider,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\Symbols.cs,GetSymbolReader,The length of the statement  "		return Mixin.IsPortablePdb (Mixin.GetPdbFileName (fileName)) ? new PortablePdbReaderProvider ().GetSymbolReader (module' fileName) : SymbolProvider.GetReaderProvider (SymbolKind.NativePdb).GetSymbolReader (module' fileName); " is 224.
Long Statement,Mono.Cecil.Metadata,UserStringHeapBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Metadata\Buffers.cs,WriteString,The length of the statement  "			if (@char > 0x7e || (@char >= 0x01 && @char <= 0x08) || (@char >= 0x0e && @char <= 0x1f) || @char == 0x27 || @char == 0x2d) { " is 125.
Long Statement,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,ReadUInt32,The length of the statement  "	uint value = (uint)(buffer [position] | (buffer [position + 1] << 8) | (buffer [position + 2] << 16) | (buffer [position + 3] << 24)); " is 134.
Long Statement,Mono.Cecil.PE,Image,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\Image.cs,HasDebugTables,The length of the statement  "	return HasTable (Table.Document) || HasTable (Table.MethodDebugInformation) || HasTable (Table.LocalScope) || HasTable (Table.LocalVariable) || HasTable (Table.LocalConstant) || HasTable (Table.StateMachineMethod) || HasTable (Table.CustomDebugInformation); " is 257.
Long Statement,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,GetWin32Resources,The length of the statement  "	win32_resources = module.Image.GetReaderAt (rsrc.VirtualAddress' rsrc.SizeOfRawData' (s' reader) => new ByteBuffer (reader.ReadBytes ((int)s))); " is 144.
Long Statement,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,CreateSection,The length of the statement  "		VirtualAddress = previous != null ? previous.VirtualAddress + Align (previous.VirtualSize' section_alignment) : text_rva' " is 121.
Long Statement,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,CreateSection,The length of the statement  "		PointerToRawData = previous != null ? previous.PointerToRawData + previous.SizeOfRawData : Align (GetHeaderSize ()' file_alignment)' " is 132.
Long Statement,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,GetRuntimeMain,The length of the statement  "	return module.Kind == ModuleKind.Dll || module.Kind == ModuleKind.NetModule ? GetSimpleString ("_CorDllMain") : GetSimpleString ("_CorExeMain"); " is 144.
Long Statement,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,BuildTextMap,The length of the statement  "	startup_stub_rva = module.Architecture == TargetArchitecture.IA64 ? (startup_stub_rva + 15u) & ~15u : 2 + ((startup_stub_rva + 3u) & ~3u); " is 138.
Complex Conditional,Mono.Cecil.Metadata,UserStringHeapBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Metadata\Buffers.cs,WriteString,The conditional expression  "@char > 0x7e || (@char >= 0x01 && @char <= 0x08) || (@char >= 0x0e && @char <= 0x1f) || @char == 0x27 || @char == 0x2d"  is complex.
Complex Conditional,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The conditional expression  "(blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352)"  is complex.
Complex Conditional,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The conditional expression  "(blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352)"  is complex.
Empty Catch Block,Mono.Cecil.Cil,SymbolProvider,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\Symbols.cs,GetSymbolType,The method has an empty catch block.
Empty Catch Block,Mono.Cecil.Cil,SymbolProvider,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\Symbols.cs,GetSymbolType,The method has an empty catch block.
Empty Catch Block,Mono.Collections.Generic,Collection,F:\newReposMay17\jbevain_cecil\Mono.Collections.Generic\Collection.cs,Add,The method has an empty catch block.
Empty Catch Block,Mono.Collections.Generic,Collection,F:\newReposMay17\jbevain_cecil\Mono.Collections.Generic\Collection.cs,Add,The method has an empty catch block.
Empty Catch Block,Mono.Collections.Generic,Collection,F:\newReposMay17\jbevain_cecil\Mono.Collections.Generic\Collection.cs,IndexOf,The method has an empty catch block.
Empty Catch Block,Mono.Collections.Generic,Collection,F:\newReposMay17\jbevain_cecil\Mono.Collections.Generic\Collection.cs,IndexOf,The method has an empty catch block.
Empty Catch Block,Mono.Collections.Generic,Collection,F:\newReposMay17\jbevain_cecil\Mono.Collections.Generic\Collection.cs,Insert,The method has an empty catch block.
Empty Catch Block,Mono.Collections.Generic,Collection,F:\newReposMay17\jbevain_cecil\Mono.Collections.Generic\Collection.cs,Insert,The method has an empty catch block.
Empty Catch Block,Mono.Collections.Generic,Collection,F:\newReposMay17\jbevain_cecil\Mono.Collections.Generic\Collection.cs,Remove,The method has an empty catch block.
Empty Catch Block,Mono.Collections.Generic,Collection,F:\newReposMay17\jbevain_cecil\Mono.Collections.Generic\Collection.cs,Remove,The method has an empty catch block.
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetTimestamp,The following statement contains a magic number: return (uint)DateTime.UtcNow.Subtract (new DateTime (1970' 1' 1)).TotalSeconds;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,ParseRuntime,The following statement contains a magic number: switch (self [1]) {  case '1':  	return self [3] == '0' ? TargetRuntime.Net_1_0 : TargetRuntime.Net_1_1;  case '2':  	return TargetRuntime.Net_2_0;  case '4':  default:  	return TargetRuntime.Net_4_0;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,ParseRuntime,The following statement contains a magic number: return self [3] == '0' ? TargetRuntime.Net_1_0 : TargetRuntime.Net_1_1;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,IsPortablePdb,The following statement contains a magic number: if (stream.Length < 4)  	return false;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((data [position] & 0x80) == 0) {  	integer = data [position];  	position++;  } else if ((data [position] & 0x40) == 0) {  	integer = (uint)(data [position] & ~0x80) << 8;  	integer |= data [position + 1];  	position += 2;  } else {  	integer = (uint)(data [position] & ~0xc0) << 24;  	integer |= (uint)data [position + 1] << 16;  	integer |= (uint)data [position + 2] << 8;  	integer |= (uint)data [position + 3];  	position += 4;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((data [position] & 0x80) == 0) {  	integer = data [position];  	position++;  } else if ((data [position] & 0x40) == 0) {  	integer = (uint)(data [position] & ~0x80) << 8;  	integer |= data [position + 1];  	position += 2;  } else {  	integer = (uint)(data [position] & ~0xc0) << 24;  	integer |= (uint)data [position + 1] << 16;  	integer |= (uint)data [position + 2] << 8;  	integer |= (uint)data [position + 3];  	position += 4;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((data [position] & 0x80) == 0) {  	integer = data [position];  	position++;  } else if ((data [position] & 0x40) == 0) {  	integer = (uint)(data [position] & ~0x80) << 8;  	integer |= data [position + 1];  	position += 2;  } else {  	integer = (uint)(data [position] & ~0xc0) << 24;  	integer |= (uint)data [position + 1] << 16;  	integer |= (uint)data [position + 2] << 8;  	integer |= (uint)data [position + 3];  	position += 4;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((data [position] & 0x80) == 0) {  	integer = data [position];  	position++;  } else if ((data [position] & 0x40) == 0) {  	integer = (uint)(data [position] & ~0x80) << 8;  	integer |= data [position + 1];  	position += 2;  } else {  	integer = (uint)(data [position] & ~0xc0) << 24;  	integer |= (uint)data [position + 1] << 16;  	integer |= (uint)data [position + 2] << 8;  	integer |= (uint)data [position + 3];  	position += 4;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((data [position] & 0x80) == 0) {  	integer = data [position];  	position++;  } else if ((data [position] & 0x40) == 0) {  	integer = (uint)(data [position] & ~0x80) << 8;  	integer |= data [position + 1];  	position += 2;  } else {  	integer = (uint)(data [position] & ~0xc0) << 24;  	integer |= (uint)data [position + 1] << 16;  	integer |= (uint)data [position + 2] << 8;  	integer |= (uint)data [position + 3];  	position += 4;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((data [position] & 0x80) == 0) {  	integer = data [position];  	position++;  } else if ((data [position] & 0x40) == 0) {  	integer = (uint)(data [position] & ~0x80) << 8;  	integer |= data [position + 1];  	position += 2;  } else {  	integer = (uint)(data [position] & ~0xc0) << 24;  	integer |= (uint)data [position + 1] << 16;  	integer |= (uint)data [position + 2] << 8;  	integer |= (uint)data [position + 3];  	position += 4;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((data [position] & 0x80) == 0) {  	integer = data [position];  	position++;  } else if ((data [position] & 0x40) == 0) {  	integer = (uint)(data [position] & ~0x80) << 8;  	integer |= data [position + 1];  	position += 2;  } else {  	integer = (uint)(data [position] & ~0xc0) << 24;  	integer |= (uint)data [position + 1] << 16;  	integer |= (uint)data [position + 2] << 8;  	integer |= (uint)data [position + 3];  	position += 4;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((data [position] & 0x80) == 0) {  	integer = data [position];  	position++;  } else if ((data [position] & 0x40) == 0) {  	integer = (uint)(data [position] & ~0x80) << 8;  	integer |= data [position + 1];  	position += 2;  } else {  	integer = (uint)(data [position] & ~0xc0) << 24;  	integer |= (uint)data [position + 1] << 16;  	integer |= (uint)data [position + 2] << 8;  	integer |= (uint)data [position + 3];  	position += 4;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((data [position] & 0x40) == 0) {  	integer = (uint)(data [position] & ~0x80) << 8;  	integer |= data [position + 1];  	position += 2;  } else {  	integer = (uint)(data [position] & ~0xc0) << 24;  	integer |= (uint)data [position + 1] << 16;  	integer |= (uint)data [position + 2] << 8;  	integer |= (uint)data [position + 3];  	position += 4;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((data [position] & 0x40) == 0) {  	integer = (uint)(data [position] & ~0x80) << 8;  	integer |= data [position + 1];  	position += 2;  } else {  	integer = (uint)(data [position] & ~0xc0) << 24;  	integer |= (uint)data [position + 1] << 16;  	integer |= (uint)data [position + 2] << 8;  	integer |= (uint)data [position + 3];  	position += 4;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((data [position] & 0x40) == 0) {  	integer = (uint)(data [position] & ~0x80) << 8;  	integer |= data [position + 1];  	position += 2;  } else {  	integer = (uint)(data [position] & ~0xc0) << 24;  	integer |= (uint)data [position + 1] << 16;  	integer |= (uint)data [position + 2] << 8;  	integer |= (uint)data [position + 3];  	position += 4;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((data [position] & 0x40) == 0) {  	integer = (uint)(data [position] & ~0x80) << 8;  	integer |= data [position + 1];  	position += 2;  } else {  	integer = (uint)(data [position] & ~0xc0) << 24;  	integer |= (uint)data [position + 1] << 16;  	integer |= (uint)data [position + 2] << 8;  	integer |= (uint)data [position + 3];  	position += 4;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((data [position] & 0x40) == 0) {  	integer = (uint)(data [position] & ~0x80) << 8;  	integer |= data [position + 1];  	position += 2;  } else {  	integer = (uint)(data [position] & ~0xc0) << 24;  	integer |= (uint)data [position + 1] << 16;  	integer |= (uint)data [position + 2] << 8;  	integer |= (uint)data [position + 3];  	position += 4;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((data [position] & 0x40) == 0) {  	integer = (uint)(data [position] & ~0x80) << 8;  	integer |= data [position + 1];  	position += 2;  } else {  	integer = (uint)(data [position] & ~0xc0) << 24;  	integer |= (uint)data [position + 1] << 16;  	integer |= (uint)data [position + 2] << 8;  	integer |= (uint)data [position + 3];  	position += 4;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((data [position] & 0x40) == 0) {  	integer = (uint)(data [position] & ~0x80) << 8;  	integer |= data [position + 1];  	position += 2;  } else {  	integer = (uint)(data [position] & ~0xc0) << 24;  	integer |= (uint)data [position + 1] << 16;  	integer |= (uint)data [position + 2] << 8;  	integer |= (uint)data [position + 3];  	position += 4;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((data [position] & 0x40) == 0) {  	integer = (uint)(data [position] & ~0x80) << 8;  	integer |= data [position + 1];  	position += 2;  } else {  	integer = (uint)(data [position] & ~0xc0) << 24;  	integer |= (uint)data [position + 1] << 16;  	integer |= (uint)data [position + 2] << 8;  	integer |= (uint)data [position + 3];  	position += 4;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,ReadCompressedUInt32,The following statement contains a magic number: integer = (uint)(data [position] & ~0x80) << 8;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,ReadCompressedUInt32,The following statement contains a magic number: position += 2;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,ReadCompressedUInt32,The following statement contains a magic number: integer = (uint)(data [position] & ~0xc0) << 24;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,ReadCompressedUInt32,The following statement contains a magic number: integer |= (uint)data [position + 1] << 16;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,ReadCompressedUInt32,The following statement contains a magic number: integer |= (uint)data [position + 2] << 8;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,ReadCompressedUInt32,The following statement contains a magic number: integer |= (uint)data [position + 2] << 8;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,ReadCompressedUInt32,The following statement contains a magic number: integer |= (uint)data [position + 3];  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,ReadCompressedUInt32,The following statement contains a magic number: position += 4;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	case 2:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Param;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	case 2:  		token_type = TokenType.Assembly;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	rid = data >> 3;  	switch (data & 7) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.TypeRef;  		goto ret;  	case 2:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 3:  		token_type = TokenType.Method;  		goto ret;  	case 4:  		token_type = TokenType.TypeSpec;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Event;  		goto ret;  	case 1:  		token_type = TokenType.Property;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.Field;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.File;  		goto ret;  	case 1:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 2:  		token_type = TokenType.ExportedType;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	rid = data >> 3;  	switch (data & 7) {  	case 2:  		token_type = TokenType.Method;  		goto ret;  	case 3:  		token_type = TokenType.MemberRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	rid = data >> 2;  	switch (data & 3) {  	case 0:  		token_type = TokenType.Module;  		goto ret;  	case 1:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 2:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeRef;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	rid = data >> 1;  	switch (data & 1) {  	case 0:  		token_type = TokenType.TypeDef;  		goto ret;  	case 1:  		token_type = TokenType.Method;  		goto ret;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	rid = data >> 5;  	switch (data & 31) {  	case 0:  		token_type = TokenType.Method;  		goto ret;  	case 1:  		token_type = TokenType.Field;  		goto ret;  	case 2:  		token_type = TokenType.TypeRef;  		goto ret;  	case 3:  		token_type = TokenType.TypeDef;  		goto ret;  	case 4:  		token_type = TokenType.Param;  		goto ret;  	case 5:  		token_type = TokenType.InterfaceImpl;  		goto ret;  	case 6:  		token_type = TokenType.MemberRef;  		goto ret;  	case 7:  		token_type = TokenType.Module;  		goto ret;  	case 8:  		token_type = TokenType.Permission;  		goto ret;  	case 9:  		token_type = TokenType.Property;  		goto ret;  	case 10:  		token_type = TokenType.Event;  		goto ret;  	case 11:  		token_type = TokenType.Signature;  		goto ret;  	case 12:  		token_type = TokenType.ModuleRef;  		goto ret;  	case 13:  		token_type = TokenType.TypeSpec;  		goto ret;  	case 14:  		token_type = TokenType.Assembly;  		goto ret;  	case 15:  		token_type = TokenType.AssemblyRef;  		goto ret;  	case 16:  		token_type = TokenType.File;  		goto ret;  	case 17:  		token_type = TokenType.ExportedType;  		goto ret;  	case 18:  		token_type = TokenType.ManifestResource;  		goto ret;  	case 19:  		token_type = TokenType.GenericParam;  		goto ret;  	case 20:  		token_type = TokenType.GenericParamConstraint;  		goto ret;  	case 21:  		token_type = TokenType.MethodSpec;  		goto ret;  	case 22:  		token_type = TokenType.Document;  		goto ret;  	case 23:  		token_type = TokenType.LocalScope;  		goto ret;  	case 24:  		token_type = TokenType.LocalVariable;  		goto ret;  	case 25:  		token_type = TokenType.LocalConstant;  		goto ret;  	case 26:  		token_type = TokenType.ImportScope;  		goto ret;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: rid = data >> 2;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 3) {  case 0:  	token_type = TokenType.TypeDef;  	goto ret;  case 1:  	token_type = TokenType.TypeRef;  	goto ret;  case 2:  	token_type = TokenType.TypeSpec;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 3) {  case 0:  	token_type = TokenType.TypeDef;  	goto ret;  case 1:  	token_type = TokenType.TypeRef;  	goto ret;  case 2:  	token_type = TokenType.TypeSpec;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: rid = data >> 2;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 3) {  case 0:  	token_type = TokenType.Field;  	goto ret;  case 1:  	token_type = TokenType.Param;  	goto ret;  case 2:  	token_type = TokenType.Property;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 3) {  case 0:  	token_type = TokenType.Field;  	goto ret;  case 1:  	token_type = TokenType.Param;  	goto ret;  case 2:  	token_type = TokenType.Property;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: rid = data >> 5;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: rid = data >> 2;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 3) {  case 0:  	token_type = TokenType.TypeDef;  	goto ret;  case 1:  	token_type = TokenType.Method;  	goto ret;  case 2:  	token_type = TokenType.Assembly;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 3) {  case 0:  	token_type = TokenType.TypeDef;  	goto ret;  case 1:  	token_type = TokenType.Method;  	goto ret;  case 2:  	token_type = TokenType.Assembly;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: rid = data >> 3;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 7) {  case 0:  	token_type = TokenType.TypeDef;  	goto ret;  case 1:  	token_type = TokenType.TypeRef;  	goto ret;  case 2:  	token_type = TokenType.ModuleRef;  	goto ret;  case 3:  	token_type = TokenType.Method;  	goto ret;  case 4:  	token_type = TokenType.TypeSpec;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 7) {  case 0:  	token_type = TokenType.TypeDef;  	goto ret;  case 1:  	token_type = TokenType.TypeRef;  	goto ret;  case 2:  	token_type = TokenType.ModuleRef;  	goto ret;  case 3:  	token_type = TokenType.Method;  	goto ret;  case 4:  	token_type = TokenType.TypeSpec;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 7) {  case 0:  	token_type = TokenType.TypeDef;  	goto ret;  case 1:  	token_type = TokenType.TypeRef;  	goto ret;  case 2:  	token_type = TokenType.ModuleRef;  	goto ret;  case 3:  	token_type = TokenType.Method;  	goto ret;  case 4:  	token_type = TokenType.TypeSpec;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 7) {  case 0:  	token_type = TokenType.TypeDef;  	goto ret;  case 1:  	token_type = TokenType.TypeRef;  	goto ret;  case 2:  	token_type = TokenType.ModuleRef;  	goto ret;  case 3:  	token_type = TokenType.Method;  	goto ret;  case 4:  	token_type = TokenType.TypeSpec;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: rid = data >> 2;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 3) {  case 0:  	token_type = TokenType.File;  	goto ret;  case 1:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 2:  	token_type = TokenType.ExportedType;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 3) {  case 0:  	token_type = TokenType.File;  	goto ret;  case 1:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 2:  	token_type = TokenType.ExportedType;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: rid = data >> 3;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 7) {  case 2:  	token_type = TokenType.Method;  	goto ret;  case 3:  	token_type = TokenType.MemberRef;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 7) {  case 2:  	token_type = TokenType.Method;  	goto ret;  case 3:  	token_type = TokenType.MemberRef;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 7) {  case 2:  	token_type = TokenType.Method;  	goto ret;  case 3:  	token_type = TokenType.MemberRef;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: rid = data >> 2;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 3) {  case 0:  	token_type = TokenType.Module;  	goto ret;  case 1:  	token_type = TokenType.ModuleRef;  	goto ret;  case 2:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 3:  	token_type = TokenType.TypeRef;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 3) {  case 0:  	token_type = TokenType.Module;  	goto ret;  case 1:  	token_type = TokenType.ModuleRef;  	goto ret;  case 2:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 3:  	token_type = TokenType.TypeRef;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 3) {  case 0:  	token_type = TokenType.Module;  	goto ret;  case 1:  	token_type = TokenType.ModuleRef;  	goto ret;  case 2:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 3:  	token_type = TokenType.TypeRef;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: rid = data >> 5;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  case 22:  	token_type = TokenType.Document;  	goto ret;  case 23:  	token_type = TokenType.LocalScope;  	goto ret;  case 24:  	token_type = TokenType.LocalVariable;  	goto ret;  case 25:  	token_type = TokenType.LocalConstant;  	goto ret;  case 26:  	token_type = TokenType.ImportScope;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  case 22:  	token_type = TokenType.Document;  	goto ret;  case 23:  	token_type = TokenType.LocalScope;  	goto ret;  case 24:  	token_type = TokenType.LocalVariable;  	goto ret;  case 25:  	token_type = TokenType.LocalConstant;  	goto ret;  case 26:  	token_type = TokenType.ImportScope;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  case 22:  	token_type = TokenType.Document;  	goto ret;  case 23:  	token_type = TokenType.LocalScope;  	goto ret;  case 24:  	token_type = TokenType.LocalVariable;  	goto ret;  case 25:  	token_type = TokenType.LocalConstant;  	goto ret;  case 26:  	token_type = TokenType.ImportScope;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  case 22:  	token_type = TokenType.Document;  	goto ret;  case 23:  	token_type = TokenType.LocalScope;  	goto ret;  case 24:  	token_type = TokenType.LocalVariable;  	goto ret;  case 25:  	token_type = TokenType.LocalConstant;  	goto ret;  case 26:  	token_type = TokenType.ImportScope;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  case 22:  	token_type = TokenType.Document;  	goto ret;  case 23:  	token_type = TokenType.LocalScope;  	goto ret;  case 24:  	token_type = TokenType.LocalVariable;  	goto ret;  case 25:  	token_type = TokenType.LocalConstant;  	goto ret;  case 26:  	token_type = TokenType.ImportScope;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  case 22:  	token_type = TokenType.Document;  	goto ret;  case 23:  	token_type = TokenType.LocalScope;  	goto ret;  case 24:  	token_type = TokenType.LocalVariable;  	goto ret;  case 25:  	token_type = TokenType.LocalConstant;  	goto ret;  case 26:  	token_type = TokenType.ImportScope;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  case 22:  	token_type = TokenType.Document;  	goto ret;  case 23:  	token_type = TokenType.LocalScope;  	goto ret;  case 24:  	token_type = TokenType.LocalVariable;  	goto ret;  case 25:  	token_type = TokenType.LocalConstant;  	goto ret;  case 26:  	token_type = TokenType.ImportScope;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  case 22:  	token_type = TokenType.Document;  	goto ret;  case 23:  	token_type = TokenType.LocalScope;  	goto ret;  case 24:  	token_type = TokenType.LocalVariable;  	goto ret;  case 25:  	token_type = TokenType.LocalConstant;  	goto ret;  case 26:  	token_type = TokenType.ImportScope;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  case 22:  	token_type = TokenType.Document;  	goto ret;  case 23:  	token_type = TokenType.LocalScope;  	goto ret;  case 24:  	token_type = TokenType.LocalVariable;  	goto ret;  case 25:  	token_type = TokenType.LocalConstant;  	goto ret;  case 26:  	token_type = TokenType.ImportScope;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  case 22:  	token_type = TokenType.Document;  	goto ret;  case 23:  	token_type = TokenType.LocalScope;  	goto ret;  case 24:  	token_type = TokenType.LocalVariable;  	goto ret;  case 25:  	token_type = TokenType.LocalConstant;  	goto ret;  case 26:  	token_type = TokenType.ImportScope;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  case 22:  	token_type = TokenType.Document;  	goto ret;  case 23:  	token_type = TokenType.LocalScope;  	goto ret;  case 24:  	token_type = TokenType.LocalVariable;  	goto ret;  case 25:  	token_type = TokenType.LocalConstant;  	goto ret;  case 26:  	token_type = TokenType.ImportScope;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  case 22:  	token_type = TokenType.Document;  	goto ret;  case 23:  	token_type = TokenType.LocalScope;  	goto ret;  case 24:  	token_type = TokenType.LocalVariable;  	goto ret;  case 25:  	token_type = TokenType.LocalConstant;  	goto ret;  case 26:  	token_type = TokenType.ImportScope;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  case 22:  	token_type = TokenType.Document;  	goto ret;  case 23:  	token_type = TokenType.LocalScope;  	goto ret;  case 24:  	token_type = TokenType.LocalVariable;  	goto ret;  case 25:  	token_type = TokenType.LocalConstant;  	goto ret;  case 26:  	token_type = TokenType.ImportScope;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  case 22:  	token_type = TokenType.Document;  	goto ret;  case 23:  	token_type = TokenType.LocalScope;  	goto ret;  case 24:  	token_type = TokenType.LocalVariable;  	goto ret;  case 25:  	token_type = TokenType.LocalConstant;  	goto ret;  case 26:  	token_type = TokenType.ImportScope;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  case 22:  	token_type = TokenType.Document;  	goto ret;  case 23:  	token_type = TokenType.LocalScope;  	goto ret;  case 24:  	token_type = TokenType.LocalVariable;  	goto ret;  case 25:  	token_type = TokenType.LocalConstant;  	goto ret;  case 26:  	token_type = TokenType.ImportScope;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  case 22:  	token_type = TokenType.Document;  	goto ret;  case 23:  	token_type = TokenType.LocalScope;  	goto ret;  case 24:  	token_type = TokenType.LocalVariable;  	goto ret;  case 25:  	token_type = TokenType.LocalConstant;  	goto ret;  case 26:  	token_type = TokenType.ImportScope;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  case 22:  	token_type = TokenType.Document;  	goto ret;  case 23:  	token_type = TokenType.LocalScope;  	goto ret;  case 24:  	token_type = TokenType.LocalVariable;  	goto ret;  case 25:  	token_type = TokenType.LocalConstant;  	goto ret;  case 26:  	token_type = TokenType.ImportScope;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  case 22:  	token_type = TokenType.Document;  	goto ret;  case 23:  	token_type = TokenType.LocalScope;  	goto ret;  case 24:  	token_type = TokenType.LocalVariable;  	goto ret;  case 25:  	token_type = TokenType.LocalConstant;  	goto ret;  case 26:  	token_type = TokenType.ImportScope;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  case 22:  	token_type = TokenType.Document;  	goto ret;  case 23:  	token_type = TokenType.LocalScope;  	goto ret;  case 24:  	token_type = TokenType.LocalVariable;  	goto ret;  case 25:  	token_type = TokenType.LocalConstant;  	goto ret;  case 26:  	token_type = TokenType.ImportScope;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  case 22:  	token_type = TokenType.Document;  	goto ret;  case 23:  	token_type = TokenType.LocalScope;  	goto ret;  case 24:  	token_type = TokenType.LocalVariable;  	goto ret;  case 25:  	token_type = TokenType.LocalConstant;  	goto ret;  case 26:  	token_type = TokenType.ImportScope;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  case 22:  	token_type = TokenType.Document;  	goto ret;  case 23:  	token_type = TokenType.LocalScope;  	goto ret;  case 24:  	token_type = TokenType.LocalVariable;  	goto ret;  case 25:  	token_type = TokenType.LocalConstant;  	goto ret;  case 26:  	token_type = TokenType.ImportScope;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  case 22:  	token_type = TokenType.Document;  	goto ret;  case 23:  	token_type = TokenType.LocalScope;  	goto ret;  case 24:  	token_type = TokenType.LocalVariable;  	goto ret;  case 25:  	token_type = TokenType.LocalConstant;  	goto ret;  case 26:  	token_type = TokenType.ImportScope;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  case 22:  	token_type = TokenType.Document;  	goto ret;  case 23:  	token_type = TokenType.LocalScope;  	goto ret;  case 24:  	token_type = TokenType.LocalVariable;  	goto ret;  case 25:  	token_type = TokenType.LocalConstant;  	goto ret;  case 26:  	token_type = TokenType.ImportScope;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  case 22:  	token_type = TokenType.Document;  	goto ret;  case 23:  	token_type = TokenType.LocalScope;  	goto ret;  case 24:  	token_type = TokenType.LocalVariable;  	goto ret;  case 25:  	token_type = TokenType.LocalConstant;  	goto ret;  case 26:  	token_type = TokenType.ImportScope;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  case 22:  	token_type = TokenType.Document;  	goto ret;  case 23:  	token_type = TokenType.LocalScope;  	goto ret;  case 24:  	token_type = TokenType.LocalVariable;  	goto ret;  case 25:  	token_type = TokenType.LocalConstant;  	goto ret;  case 26:  	token_type = TokenType.ImportScope;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The following statement contains a magic number: switch (data & 31) {  case 0:  	token_type = TokenType.Method;  	goto ret;  case 1:  	token_type = TokenType.Field;  	goto ret;  case 2:  	token_type = TokenType.TypeRef;  	goto ret;  case 3:  	token_type = TokenType.TypeDef;  	goto ret;  case 4:  	token_type = TokenType.Param;  	goto ret;  case 5:  	token_type = TokenType.InterfaceImpl;  	goto ret;  case 6:  	token_type = TokenType.MemberRef;  	goto ret;  case 7:  	token_type = TokenType.Module;  	goto ret;  case 8:  	token_type = TokenType.Permission;  	goto ret;  case 9:  	token_type = TokenType.Property;  	goto ret;  case 10:  	token_type = TokenType.Event;  	goto ret;  case 11:  	token_type = TokenType.Signature;  	goto ret;  case 12:  	token_type = TokenType.ModuleRef;  	goto ret;  case 13:  	token_type = TokenType.TypeSpec;  	goto ret;  case 14:  	token_type = TokenType.Assembly;  	goto ret;  case 15:  	token_type = TokenType.AssemblyRef;  	goto ret;  case 16:  	token_type = TokenType.File;  	goto ret;  case 17:  	token_type = TokenType.ExportedType;  	goto ret;  case 18:  	token_type = TokenType.ManifestResource;  	goto ret;  case 19:  	token_type = TokenType.GenericParam;  	goto ret;  case 20:  	token_type = TokenType.GenericParamConstraint;  	goto ret;  case 21:  	token_type = TokenType.MethodSpec;  	goto ret;  case 22:  	token_type = TokenType.Document;  	goto ret;  case 23:  	token_type = TokenType.LocalScope;  	goto ret;  case 24:  	token_type = TokenType.LocalVariable;  	goto ret;  case 25:  	token_type = TokenType.LocalConstant;  	goto ret;  case 26:  	token_type = TokenType.ImportScope;  	goto ret;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.TypeSpec:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasConstant:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	case TokenType.Property:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.HasCustomAttribute:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	default:  		goto exit;  	}  case CodedIndex.HasFieldMarshal:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Param:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasDeclSecurity:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	case TokenType.Assembly:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.MemberRefParent:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.TypeRef:  		return ret | 1;  	case TokenType.ModuleRef:  		return ret | 2;  	case TokenType.Method:  		return ret | 3;  	case TokenType.TypeSpec:  		return ret | 4;  	default:  		goto exit;  	}  case CodedIndex.HasSemantics:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Event:  		return ret | 0;  	case TokenType.Property:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MethodDefOrRef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.MemberRef:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.MemberForwarded:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.Field:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.Implementation:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.File:  		return ret | 0;  	case TokenType.AssemblyRef:  		return ret | 1;  	case TokenType.ExportedType:  		return ret | 2;  	default:  		goto exit;  	}  case CodedIndex.CustomAttributeType:  	ret = token.RID << 3;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 2;  	case TokenType.MemberRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.ResolutionScope:  	ret = token.RID << 2;  	switch (token.TokenType) {  	case TokenType.Module:  		return ret | 0;  	case TokenType.ModuleRef:  		return ret | 1;  	case TokenType.AssemblyRef:  		return ret | 2;  	case TokenType.TypeRef:  		return ret | 3;  	default:  		goto exit;  	}  case CodedIndex.TypeOrMethodDef:  	ret = token.RID << 1;  	switch (token.TokenType) {  	case TokenType.TypeDef:  		return ret | 0;  	case TokenType.Method:  		return ret | 1;  	default:  		goto exit;  	}  case CodedIndex.HasCustomDebugInformation:  	ret = token.RID << 5;  	switch (token.TokenType) {  	case TokenType.Method:  		return ret | 0;  	case TokenType.Field:  		return ret | 1;  	case TokenType.TypeRef:  		return ret | 2;  	case TokenType.TypeDef:  		return ret | 3;  	case TokenType.Param:  		return ret | 4;  	case TokenType.InterfaceImpl:  		return ret | 5;  	case TokenType.MemberRef:  		return ret | 6;  	case TokenType.Module:  		return ret | 7;  	case TokenType.Permission:  		return ret | 8;  	case TokenType.Property:  		return ret | 9;  	case TokenType.Event:  		return ret | 10;  	case TokenType.Signature:  		return ret | 11;  	case TokenType.ModuleRef:  		return ret | 12;  	case TokenType.TypeSpec:  		return ret | 13;  	case TokenType.Assembly:  		return ret | 14;  	case TokenType.AssemblyRef:  		return ret | 15;  	case TokenType.File:  		return ret | 16;  	case TokenType.ExportedType:  		return ret | 17;  	case TokenType.ManifestResource:  		return ret | 18;  	case TokenType.GenericParam:  		return ret | 19;  	case TokenType.GenericParamConstraint:  		return ret | 20;  	case TokenType.MethodSpec:  		return ret | 21;  	case TokenType.Document:  		return ret | 22;  	case TokenType.LocalScope:  		return ret | 23;  	case TokenType.LocalVariable:  		return ret | 24;  	case TokenType.LocalConstant:  		return ret | 25;  	case TokenType.ImportScope:  		return ret | 26;  	default:  		goto exit;  	}  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: ret = token.RID << 2;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.TypeDef:  	return ret | 0;  case TokenType.TypeRef:  	return ret | 1;  case TokenType.TypeSpec:  	return ret | 2;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 2;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: ret = token.RID << 2;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Field:  	return ret | 0;  case TokenType.Param:  	return ret | 1;  case TokenType.Property:  	return ret | 2;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 2;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: ret = token.RID << 5;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 2;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 3;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 4;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 5;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 6;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 7;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 8;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 9;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 10;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 11;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 12;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 13;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 14;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 15;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 16;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 17;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 18;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 19;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 20;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 21;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: ret = token.RID << 2;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.TypeDef:  	return ret | 0;  case TokenType.Method:  	return ret | 1;  case TokenType.Assembly:  	return ret | 2;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 2;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: ret = token.RID << 3;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.TypeDef:  	return ret | 0;  case TokenType.TypeRef:  	return ret | 1;  case TokenType.ModuleRef:  	return ret | 2;  case TokenType.Method:  	return ret | 3;  case TokenType.TypeSpec:  	return ret | 4;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.TypeDef:  	return ret | 0;  case TokenType.TypeRef:  	return ret | 1;  case TokenType.ModuleRef:  	return ret | 2;  case TokenType.Method:  	return ret | 3;  case TokenType.TypeSpec:  	return ret | 4;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.TypeDef:  	return ret | 0;  case TokenType.TypeRef:  	return ret | 1;  case TokenType.ModuleRef:  	return ret | 2;  case TokenType.Method:  	return ret | 3;  case TokenType.TypeSpec:  	return ret | 4;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 2;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 3;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 4;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: ret = token.RID << 2;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.File:  	return ret | 0;  case TokenType.AssemblyRef:  	return ret | 1;  case TokenType.ExportedType:  	return ret | 2;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 2;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: ret = token.RID << 3;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 2;  case TokenType.MemberRef:  	return ret | 3;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 2;  case TokenType.MemberRef:  	return ret | 3;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 2;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 3;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: ret = token.RID << 2;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Module:  	return ret | 0;  case TokenType.ModuleRef:  	return ret | 1;  case TokenType.AssemblyRef:  	return ret | 2;  case TokenType.TypeRef:  	return ret | 3;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Module:  	return ret | 0;  case TokenType.ModuleRef:  	return ret | 1;  case TokenType.AssemblyRef:  	return ret | 2;  case TokenType.TypeRef:  	return ret | 3;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 2;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 3;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: ret = token.RID << 5;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  case TokenType.Document:  	return ret | 22;  case TokenType.LocalScope:  	return ret | 23;  case TokenType.LocalVariable:  	return ret | 24;  case TokenType.LocalConstant:  	return ret | 25;  case TokenType.ImportScope:  	return ret | 26;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  case TokenType.Document:  	return ret | 22;  case TokenType.LocalScope:  	return ret | 23;  case TokenType.LocalVariable:  	return ret | 24;  case TokenType.LocalConstant:  	return ret | 25;  case TokenType.ImportScope:  	return ret | 26;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  case TokenType.Document:  	return ret | 22;  case TokenType.LocalScope:  	return ret | 23;  case TokenType.LocalVariable:  	return ret | 24;  case TokenType.LocalConstant:  	return ret | 25;  case TokenType.ImportScope:  	return ret | 26;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  case TokenType.Document:  	return ret | 22;  case TokenType.LocalScope:  	return ret | 23;  case TokenType.LocalVariable:  	return ret | 24;  case TokenType.LocalConstant:  	return ret | 25;  case TokenType.ImportScope:  	return ret | 26;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  case TokenType.Document:  	return ret | 22;  case TokenType.LocalScope:  	return ret | 23;  case TokenType.LocalVariable:  	return ret | 24;  case TokenType.LocalConstant:  	return ret | 25;  case TokenType.ImportScope:  	return ret | 26;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  case TokenType.Document:  	return ret | 22;  case TokenType.LocalScope:  	return ret | 23;  case TokenType.LocalVariable:  	return ret | 24;  case TokenType.LocalConstant:  	return ret | 25;  case TokenType.ImportScope:  	return ret | 26;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  case TokenType.Document:  	return ret | 22;  case TokenType.LocalScope:  	return ret | 23;  case TokenType.LocalVariable:  	return ret | 24;  case TokenType.LocalConstant:  	return ret | 25;  case TokenType.ImportScope:  	return ret | 26;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  case TokenType.Document:  	return ret | 22;  case TokenType.LocalScope:  	return ret | 23;  case TokenType.LocalVariable:  	return ret | 24;  case TokenType.LocalConstant:  	return ret | 25;  case TokenType.ImportScope:  	return ret | 26;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  case TokenType.Document:  	return ret | 22;  case TokenType.LocalScope:  	return ret | 23;  case TokenType.LocalVariable:  	return ret | 24;  case TokenType.LocalConstant:  	return ret | 25;  case TokenType.ImportScope:  	return ret | 26;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  case TokenType.Document:  	return ret | 22;  case TokenType.LocalScope:  	return ret | 23;  case TokenType.LocalVariable:  	return ret | 24;  case TokenType.LocalConstant:  	return ret | 25;  case TokenType.ImportScope:  	return ret | 26;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  case TokenType.Document:  	return ret | 22;  case TokenType.LocalScope:  	return ret | 23;  case TokenType.LocalVariable:  	return ret | 24;  case TokenType.LocalConstant:  	return ret | 25;  case TokenType.ImportScope:  	return ret | 26;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  case TokenType.Document:  	return ret | 22;  case TokenType.LocalScope:  	return ret | 23;  case TokenType.LocalVariable:  	return ret | 24;  case TokenType.LocalConstant:  	return ret | 25;  case TokenType.ImportScope:  	return ret | 26;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  case TokenType.Document:  	return ret | 22;  case TokenType.LocalScope:  	return ret | 23;  case TokenType.LocalVariable:  	return ret | 24;  case TokenType.LocalConstant:  	return ret | 25;  case TokenType.ImportScope:  	return ret | 26;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  case TokenType.Document:  	return ret | 22;  case TokenType.LocalScope:  	return ret | 23;  case TokenType.LocalVariable:  	return ret | 24;  case TokenType.LocalConstant:  	return ret | 25;  case TokenType.ImportScope:  	return ret | 26;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  case TokenType.Document:  	return ret | 22;  case TokenType.LocalScope:  	return ret | 23;  case TokenType.LocalVariable:  	return ret | 24;  case TokenType.LocalConstant:  	return ret | 25;  case TokenType.ImportScope:  	return ret | 26;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  case TokenType.Document:  	return ret | 22;  case TokenType.LocalScope:  	return ret | 23;  case TokenType.LocalVariable:  	return ret | 24;  case TokenType.LocalConstant:  	return ret | 25;  case TokenType.ImportScope:  	return ret | 26;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  case TokenType.Document:  	return ret | 22;  case TokenType.LocalScope:  	return ret | 23;  case TokenType.LocalVariable:  	return ret | 24;  case TokenType.LocalConstant:  	return ret | 25;  case TokenType.ImportScope:  	return ret | 26;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  case TokenType.Document:  	return ret | 22;  case TokenType.LocalScope:  	return ret | 23;  case TokenType.LocalVariable:  	return ret | 24;  case TokenType.LocalConstant:  	return ret | 25;  case TokenType.ImportScope:  	return ret | 26;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  case TokenType.Document:  	return ret | 22;  case TokenType.LocalScope:  	return ret | 23;  case TokenType.LocalVariable:  	return ret | 24;  case TokenType.LocalConstant:  	return ret | 25;  case TokenType.ImportScope:  	return ret | 26;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  case TokenType.Document:  	return ret | 22;  case TokenType.LocalScope:  	return ret | 23;  case TokenType.LocalVariable:  	return ret | 24;  case TokenType.LocalConstant:  	return ret | 25;  case TokenType.ImportScope:  	return ret | 26;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  case TokenType.Document:  	return ret | 22;  case TokenType.LocalScope:  	return ret | 23;  case TokenType.LocalVariable:  	return ret | 24;  case TokenType.LocalConstant:  	return ret | 25;  case TokenType.ImportScope:  	return ret | 26;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  case TokenType.Document:  	return ret | 22;  case TokenType.LocalScope:  	return ret | 23;  case TokenType.LocalVariable:  	return ret | 24;  case TokenType.LocalConstant:  	return ret | 25;  case TokenType.ImportScope:  	return ret | 26;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  case TokenType.Document:  	return ret | 22;  case TokenType.LocalScope:  	return ret | 23;  case TokenType.LocalVariable:  	return ret | 24;  case TokenType.LocalConstant:  	return ret | 25;  case TokenType.ImportScope:  	return ret | 26;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  case TokenType.Document:  	return ret | 22;  case TokenType.LocalScope:  	return ret | 23;  case TokenType.LocalVariable:  	return ret | 24;  case TokenType.LocalConstant:  	return ret | 25;  case TokenType.ImportScope:  	return ret | 26;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: switch (token.TokenType) {  case TokenType.Method:  	return ret | 0;  case TokenType.Field:  	return ret | 1;  case TokenType.TypeRef:  	return ret | 2;  case TokenType.TypeDef:  	return ret | 3;  case TokenType.Param:  	return ret | 4;  case TokenType.InterfaceImpl:  	return ret | 5;  case TokenType.MemberRef:  	return ret | 6;  case TokenType.Module:  	return ret | 7;  case TokenType.Permission:  	return ret | 8;  case TokenType.Property:  	return ret | 9;  case TokenType.Event:  	return ret | 10;  case TokenType.Signature:  	return ret | 11;  case TokenType.ModuleRef:  	return ret | 12;  case TokenType.TypeSpec:  	return ret | 13;  case TokenType.Assembly:  	return ret | 14;  case TokenType.AssemblyRef:  	return ret | 15;  case TokenType.File:  	return ret | 16;  case TokenType.ExportedType:  	return ret | 17;  case TokenType.ManifestResource:  	return ret | 18;  case TokenType.GenericParam:  	return ret | 19;  case TokenType.GenericParamConstraint:  	return ret | 20;  case TokenType.MethodSpec:  	return ret | 21;  case TokenType.Document:  	return ret | 22;  case TokenType.LocalScope:  	return ret | 23;  case TokenType.LocalVariable:  	return ret | 24;  case TokenType.LocalConstant:  	return ret | 25;  case TokenType.ImportScope:  	return ret | 26;  default:  	goto exit;  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 2;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 3;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 4;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 5;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 6;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 7;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 8;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 9;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 10;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 11;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 12;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 13;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 14;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 15;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 16;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 17;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 18;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 19;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 20;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 21;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 22;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 23;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 24;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 25;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The following statement contains a magic number: return ret | 26;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetSize,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	bits = 2;  	tables = new[] {  		Table.TypeDef'  		Table.TypeRef'  		Table.TypeSpec  	};  	break;  case CodedIndex.HasConstant:  	bits = 2;  	tables = new[] {  		Table.Field'  		Table.Param'  		Table.Property  	};  	break;  case CodedIndex.HasCustomAttribute:  	bits = 5;  	tables = new[] {  		Table.Method'  		Table.Field'  		Table.TypeRef'  		Table.TypeDef'  		Table.Param'  		Table.InterfaceImpl'  		Table.MemberRef'  		Table.Module'  		Table.DeclSecurity'  		Table.Property'  		Table.Event'  		Table.StandAloneSig'  		Table.ModuleRef'  		Table.TypeSpec'  		Table.Assembly'  		Table.AssemblyRef'  		Table.File'  		Table.ExportedType'  		Table.ManifestResource'  		Table.GenericParam'  		Table.GenericParamConstraint'  		Table.MethodSpec'  	};  	break;  case CodedIndex.HasFieldMarshal:  	bits = 1;  	tables = new[] {  		Table.Field'  		Table.Param  	};  	break;  case CodedIndex.HasDeclSecurity:  	bits = 2;  	tables = new[] {  		Table.TypeDef'  		Table.Method'  		Table.Assembly  	};  	break;  case CodedIndex.MemberRefParent:  	bits = 3;  	tables = new[] {  		Table.TypeDef'  		Table.TypeRef'  		Table.ModuleRef'  		Table.Method'  		Table.TypeSpec  	};  	break;  case CodedIndex.HasSemantics:  	bits = 1;  	tables = new[] {  		Table.Event'  		Table.Property  	};  	break;  case CodedIndex.MethodDefOrRef:  	bits = 1;  	tables = new[] {  		Table.Method'  		Table.MemberRef  	};  	break;  case CodedIndex.MemberForwarded:  	bits = 1;  	tables = new[] {  		Table.Field'  		Table.Method  	};  	break;  case CodedIndex.Implementation:  	bits = 2;  	tables = new[] {  		Table.File'  		Table.AssemblyRef'  		Table.ExportedType  	};  	break;  case CodedIndex.CustomAttributeType:  	bits = 3;  	tables = new[] {  		Table.Method'  		Table.MemberRef  	};  	break;  case CodedIndex.ResolutionScope:  	bits = 2;  	tables = new[] {  		Table.Module'  		Table.ModuleRef'  		Table.AssemblyRef'  		Table.TypeRef  	};  	break;  case CodedIndex.TypeOrMethodDef:  	bits = 1;  	tables = new[] {  		Table.TypeDef'  		Table.Method  	};  	break;  case CodedIndex.HasCustomDebugInformation:  	bits = 5;  	tables = new[] {  		Table.Method'  		Table.Field'  		Table.TypeRef'  		Table.TypeDef'  		Table.Param'  		Table.InterfaceImpl'  		Table.MemberRef'  		Table.Module'  		Table.DeclSecurity'  		Table.Property'  		Table.Event'  		Table.StandAloneSig'  		Table.ModuleRef'  		Table.TypeSpec'  		Table.Assembly'  		Table.AssemblyRef'  		Table.File'  		Table.ExportedType'  		Table.ManifestResource'  		Table.GenericParam'  		Table.GenericParamConstraint'  		Table.MethodSpec'  		Table.Document'  		Table.LocalScope'  		Table.LocalVariable'  		Table.LocalConstant'  		Table.ImportScope'  	};  	break;  default:  	throw new ArgumentException ();  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetSize,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	bits = 2;  	tables = new[] {  		Table.TypeDef'  		Table.TypeRef'  		Table.TypeSpec  	};  	break;  case CodedIndex.HasConstant:  	bits = 2;  	tables = new[] {  		Table.Field'  		Table.Param'  		Table.Property  	};  	break;  case CodedIndex.HasCustomAttribute:  	bits = 5;  	tables = new[] {  		Table.Method'  		Table.Field'  		Table.TypeRef'  		Table.TypeDef'  		Table.Param'  		Table.InterfaceImpl'  		Table.MemberRef'  		Table.Module'  		Table.DeclSecurity'  		Table.Property'  		Table.Event'  		Table.StandAloneSig'  		Table.ModuleRef'  		Table.TypeSpec'  		Table.Assembly'  		Table.AssemblyRef'  		Table.File'  		Table.ExportedType'  		Table.ManifestResource'  		Table.GenericParam'  		Table.GenericParamConstraint'  		Table.MethodSpec'  	};  	break;  case CodedIndex.HasFieldMarshal:  	bits = 1;  	tables = new[] {  		Table.Field'  		Table.Param  	};  	break;  case CodedIndex.HasDeclSecurity:  	bits = 2;  	tables = new[] {  		Table.TypeDef'  		Table.Method'  		Table.Assembly  	};  	break;  case CodedIndex.MemberRefParent:  	bits = 3;  	tables = new[] {  		Table.TypeDef'  		Table.TypeRef'  		Table.ModuleRef'  		Table.Method'  		Table.TypeSpec  	};  	break;  case CodedIndex.HasSemantics:  	bits = 1;  	tables = new[] {  		Table.Event'  		Table.Property  	};  	break;  case CodedIndex.MethodDefOrRef:  	bits = 1;  	tables = new[] {  		Table.Method'  		Table.MemberRef  	};  	break;  case CodedIndex.MemberForwarded:  	bits = 1;  	tables = new[] {  		Table.Field'  		Table.Method  	};  	break;  case CodedIndex.Implementation:  	bits = 2;  	tables = new[] {  		Table.File'  		Table.AssemblyRef'  		Table.ExportedType  	};  	break;  case CodedIndex.CustomAttributeType:  	bits = 3;  	tables = new[] {  		Table.Method'  		Table.MemberRef  	};  	break;  case CodedIndex.ResolutionScope:  	bits = 2;  	tables = new[] {  		Table.Module'  		Table.ModuleRef'  		Table.AssemblyRef'  		Table.TypeRef  	};  	break;  case CodedIndex.TypeOrMethodDef:  	bits = 1;  	tables = new[] {  		Table.TypeDef'  		Table.Method  	};  	break;  case CodedIndex.HasCustomDebugInformation:  	bits = 5;  	tables = new[] {  		Table.Method'  		Table.Field'  		Table.TypeRef'  		Table.TypeDef'  		Table.Param'  		Table.InterfaceImpl'  		Table.MemberRef'  		Table.Module'  		Table.DeclSecurity'  		Table.Property'  		Table.Event'  		Table.StandAloneSig'  		Table.ModuleRef'  		Table.TypeSpec'  		Table.Assembly'  		Table.AssemblyRef'  		Table.File'  		Table.ExportedType'  		Table.ManifestResource'  		Table.GenericParam'  		Table.GenericParamConstraint'  		Table.MethodSpec'  		Table.Document'  		Table.LocalScope'  		Table.LocalVariable'  		Table.LocalConstant'  		Table.ImportScope'  	};  	break;  default:  	throw new ArgumentException ();  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetSize,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	bits = 2;  	tables = new[] {  		Table.TypeDef'  		Table.TypeRef'  		Table.TypeSpec  	};  	break;  case CodedIndex.HasConstant:  	bits = 2;  	tables = new[] {  		Table.Field'  		Table.Param'  		Table.Property  	};  	break;  case CodedIndex.HasCustomAttribute:  	bits = 5;  	tables = new[] {  		Table.Method'  		Table.Field'  		Table.TypeRef'  		Table.TypeDef'  		Table.Param'  		Table.InterfaceImpl'  		Table.MemberRef'  		Table.Module'  		Table.DeclSecurity'  		Table.Property'  		Table.Event'  		Table.StandAloneSig'  		Table.ModuleRef'  		Table.TypeSpec'  		Table.Assembly'  		Table.AssemblyRef'  		Table.File'  		Table.ExportedType'  		Table.ManifestResource'  		Table.GenericParam'  		Table.GenericParamConstraint'  		Table.MethodSpec'  	};  	break;  case CodedIndex.HasFieldMarshal:  	bits = 1;  	tables = new[] {  		Table.Field'  		Table.Param  	};  	break;  case CodedIndex.HasDeclSecurity:  	bits = 2;  	tables = new[] {  		Table.TypeDef'  		Table.Method'  		Table.Assembly  	};  	break;  case CodedIndex.MemberRefParent:  	bits = 3;  	tables = new[] {  		Table.TypeDef'  		Table.TypeRef'  		Table.ModuleRef'  		Table.Method'  		Table.TypeSpec  	};  	break;  case CodedIndex.HasSemantics:  	bits = 1;  	tables = new[] {  		Table.Event'  		Table.Property  	};  	break;  case CodedIndex.MethodDefOrRef:  	bits = 1;  	tables = new[] {  		Table.Method'  		Table.MemberRef  	};  	break;  case CodedIndex.MemberForwarded:  	bits = 1;  	tables = new[] {  		Table.Field'  		Table.Method  	};  	break;  case CodedIndex.Implementation:  	bits = 2;  	tables = new[] {  		Table.File'  		Table.AssemblyRef'  		Table.ExportedType  	};  	break;  case CodedIndex.CustomAttributeType:  	bits = 3;  	tables = new[] {  		Table.Method'  		Table.MemberRef  	};  	break;  case CodedIndex.ResolutionScope:  	bits = 2;  	tables = new[] {  		Table.Module'  		Table.ModuleRef'  		Table.AssemblyRef'  		Table.TypeRef  	};  	break;  case CodedIndex.TypeOrMethodDef:  	bits = 1;  	tables = new[] {  		Table.TypeDef'  		Table.Method  	};  	break;  case CodedIndex.HasCustomDebugInformation:  	bits = 5;  	tables = new[] {  		Table.Method'  		Table.Field'  		Table.TypeRef'  		Table.TypeDef'  		Table.Param'  		Table.InterfaceImpl'  		Table.MemberRef'  		Table.Module'  		Table.DeclSecurity'  		Table.Property'  		Table.Event'  		Table.StandAloneSig'  		Table.ModuleRef'  		Table.TypeSpec'  		Table.Assembly'  		Table.AssemblyRef'  		Table.File'  		Table.ExportedType'  		Table.ManifestResource'  		Table.GenericParam'  		Table.GenericParamConstraint'  		Table.MethodSpec'  		Table.Document'  		Table.LocalScope'  		Table.LocalVariable'  		Table.LocalConstant'  		Table.ImportScope'  	};  	break;  default:  	throw new ArgumentException ();  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetSize,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	bits = 2;  	tables = new[] {  		Table.TypeDef'  		Table.TypeRef'  		Table.TypeSpec  	};  	break;  case CodedIndex.HasConstant:  	bits = 2;  	tables = new[] {  		Table.Field'  		Table.Param'  		Table.Property  	};  	break;  case CodedIndex.HasCustomAttribute:  	bits = 5;  	tables = new[] {  		Table.Method'  		Table.Field'  		Table.TypeRef'  		Table.TypeDef'  		Table.Param'  		Table.InterfaceImpl'  		Table.MemberRef'  		Table.Module'  		Table.DeclSecurity'  		Table.Property'  		Table.Event'  		Table.StandAloneSig'  		Table.ModuleRef'  		Table.TypeSpec'  		Table.Assembly'  		Table.AssemblyRef'  		Table.File'  		Table.ExportedType'  		Table.ManifestResource'  		Table.GenericParam'  		Table.GenericParamConstraint'  		Table.MethodSpec'  	};  	break;  case CodedIndex.HasFieldMarshal:  	bits = 1;  	tables = new[] {  		Table.Field'  		Table.Param  	};  	break;  case CodedIndex.HasDeclSecurity:  	bits = 2;  	tables = new[] {  		Table.TypeDef'  		Table.Method'  		Table.Assembly  	};  	break;  case CodedIndex.MemberRefParent:  	bits = 3;  	tables = new[] {  		Table.TypeDef'  		Table.TypeRef'  		Table.ModuleRef'  		Table.Method'  		Table.TypeSpec  	};  	break;  case CodedIndex.HasSemantics:  	bits = 1;  	tables = new[] {  		Table.Event'  		Table.Property  	};  	break;  case CodedIndex.MethodDefOrRef:  	bits = 1;  	tables = new[] {  		Table.Method'  		Table.MemberRef  	};  	break;  case CodedIndex.MemberForwarded:  	bits = 1;  	tables = new[] {  		Table.Field'  		Table.Method  	};  	break;  case CodedIndex.Implementation:  	bits = 2;  	tables = new[] {  		Table.File'  		Table.AssemblyRef'  		Table.ExportedType  	};  	break;  case CodedIndex.CustomAttributeType:  	bits = 3;  	tables = new[] {  		Table.Method'  		Table.MemberRef  	};  	break;  case CodedIndex.ResolutionScope:  	bits = 2;  	tables = new[] {  		Table.Module'  		Table.ModuleRef'  		Table.AssemblyRef'  		Table.TypeRef  	};  	break;  case CodedIndex.TypeOrMethodDef:  	bits = 1;  	tables = new[] {  		Table.TypeDef'  		Table.Method  	};  	break;  case CodedIndex.HasCustomDebugInformation:  	bits = 5;  	tables = new[] {  		Table.Method'  		Table.Field'  		Table.TypeRef'  		Table.TypeDef'  		Table.Param'  		Table.InterfaceImpl'  		Table.MemberRef'  		Table.Module'  		Table.DeclSecurity'  		Table.Property'  		Table.Event'  		Table.StandAloneSig'  		Table.ModuleRef'  		Table.TypeSpec'  		Table.Assembly'  		Table.AssemblyRef'  		Table.File'  		Table.ExportedType'  		Table.ManifestResource'  		Table.GenericParam'  		Table.GenericParamConstraint'  		Table.MethodSpec'  		Table.Document'  		Table.LocalScope'  		Table.LocalVariable'  		Table.LocalConstant'  		Table.ImportScope'  	};  	break;  default:  	throw new ArgumentException ();  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetSize,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	bits = 2;  	tables = new[] {  		Table.TypeDef'  		Table.TypeRef'  		Table.TypeSpec  	};  	break;  case CodedIndex.HasConstant:  	bits = 2;  	tables = new[] {  		Table.Field'  		Table.Param'  		Table.Property  	};  	break;  case CodedIndex.HasCustomAttribute:  	bits = 5;  	tables = new[] {  		Table.Method'  		Table.Field'  		Table.TypeRef'  		Table.TypeDef'  		Table.Param'  		Table.InterfaceImpl'  		Table.MemberRef'  		Table.Module'  		Table.DeclSecurity'  		Table.Property'  		Table.Event'  		Table.StandAloneSig'  		Table.ModuleRef'  		Table.TypeSpec'  		Table.Assembly'  		Table.AssemblyRef'  		Table.File'  		Table.ExportedType'  		Table.ManifestResource'  		Table.GenericParam'  		Table.GenericParamConstraint'  		Table.MethodSpec'  	};  	break;  case CodedIndex.HasFieldMarshal:  	bits = 1;  	tables = new[] {  		Table.Field'  		Table.Param  	};  	break;  case CodedIndex.HasDeclSecurity:  	bits = 2;  	tables = new[] {  		Table.TypeDef'  		Table.Method'  		Table.Assembly  	};  	break;  case CodedIndex.MemberRefParent:  	bits = 3;  	tables = new[] {  		Table.TypeDef'  		Table.TypeRef'  		Table.ModuleRef'  		Table.Method'  		Table.TypeSpec  	};  	break;  case CodedIndex.HasSemantics:  	bits = 1;  	tables = new[] {  		Table.Event'  		Table.Property  	};  	break;  case CodedIndex.MethodDefOrRef:  	bits = 1;  	tables = new[] {  		Table.Method'  		Table.MemberRef  	};  	break;  case CodedIndex.MemberForwarded:  	bits = 1;  	tables = new[] {  		Table.Field'  		Table.Method  	};  	break;  case CodedIndex.Implementation:  	bits = 2;  	tables = new[] {  		Table.File'  		Table.AssemblyRef'  		Table.ExportedType  	};  	break;  case CodedIndex.CustomAttributeType:  	bits = 3;  	tables = new[] {  		Table.Method'  		Table.MemberRef  	};  	break;  case CodedIndex.ResolutionScope:  	bits = 2;  	tables = new[] {  		Table.Module'  		Table.ModuleRef'  		Table.AssemblyRef'  		Table.TypeRef  	};  	break;  case CodedIndex.TypeOrMethodDef:  	bits = 1;  	tables = new[] {  		Table.TypeDef'  		Table.Method  	};  	break;  case CodedIndex.HasCustomDebugInformation:  	bits = 5;  	tables = new[] {  		Table.Method'  		Table.Field'  		Table.TypeRef'  		Table.TypeDef'  		Table.Param'  		Table.InterfaceImpl'  		Table.MemberRef'  		Table.Module'  		Table.DeclSecurity'  		Table.Property'  		Table.Event'  		Table.StandAloneSig'  		Table.ModuleRef'  		Table.TypeSpec'  		Table.Assembly'  		Table.AssemblyRef'  		Table.File'  		Table.ExportedType'  		Table.ManifestResource'  		Table.GenericParam'  		Table.GenericParamConstraint'  		Table.MethodSpec'  		Table.Document'  		Table.LocalScope'  		Table.LocalVariable'  		Table.LocalConstant'  		Table.ImportScope'  	};  	break;  default:  	throw new ArgumentException ();  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetSize,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	bits = 2;  	tables = new[] {  		Table.TypeDef'  		Table.TypeRef'  		Table.TypeSpec  	};  	break;  case CodedIndex.HasConstant:  	bits = 2;  	tables = new[] {  		Table.Field'  		Table.Param'  		Table.Property  	};  	break;  case CodedIndex.HasCustomAttribute:  	bits = 5;  	tables = new[] {  		Table.Method'  		Table.Field'  		Table.TypeRef'  		Table.TypeDef'  		Table.Param'  		Table.InterfaceImpl'  		Table.MemberRef'  		Table.Module'  		Table.DeclSecurity'  		Table.Property'  		Table.Event'  		Table.StandAloneSig'  		Table.ModuleRef'  		Table.TypeSpec'  		Table.Assembly'  		Table.AssemblyRef'  		Table.File'  		Table.ExportedType'  		Table.ManifestResource'  		Table.GenericParam'  		Table.GenericParamConstraint'  		Table.MethodSpec'  	};  	break;  case CodedIndex.HasFieldMarshal:  	bits = 1;  	tables = new[] {  		Table.Field'  		Table.Param  	};  	break;  case CodedIndex.HasDeclSecurity:  	bits = 2;  	tables = new[] {  		Table.TypeDef'  		Table.Method'  		Table.Assembly  	};  	break;  case CodedIndex.MemberRefParent:  	bits = 3;  	tables = new[] {  		Table.TypeDef'  		Table.TypeRef'  		Table.ModuleRef'  		Table.Method'  		Table.TypeSpec  	};  	break;  case CodedIndex.HasSemantics:  	bits = 1;  	tables = new[] {  		Table.Event'  		Table.Property  	};  	break;  case CodedIndex.MethodDefOrRef:  	bits = 1;  	tables = new[] {  		Table.Method'  		Table.MemberRef  	};  	break;  case CodedIndex.MemberForwarded:  	bits = 1;  	tables = new[] {  		Table.Field'  		Table.Method  	};  	break;  case CodedIndex.Implementation:  	bits = 2;  	tables = new[] {  		Table.File'  		Table.AssemblyRef'  		Table.ExportedType  	};  	break;  case CodedIndex.CustomAttributeType:  	bits = 3;  	tables = new[] {  		Table.Method'  		Table.MemberRef  	};  	break;  case CodedIndex.ResolutionScope:  	bits = 2;  	tables = new[] {  		Table.Module'  		Table.ModuleRef'  		Table.AssemblyRef'  		Table.TypeRef  	};  	break;  case CodedIndex.TypeOrMethodDef:  	bits = 1;  	tables = new[] {  		Table.TypeDef'  		Table.Method  	};  	break;  case CodedIndex.HasCustomDebugInformation:  	bits = 5;  	tables = new[] {  		Table.Method'  		Table.Field'  		Table.TypeRef'  		Table.TypeDef'  		Table.Param'  		Table.InterfaceImpl'  		Table.MemberRef'  		Table.Module'  		Table.DeclSecurity'  		Table.Property'  		Table.Event'  		Table.StandAloneSig'  		Table.ModuleRef'  		Table.TypeSpec'  		Table.Assembly'  		Table.AssemblyRef'  		Table.File'  		Table.ExportedType'  		Table.ManifestResource'  		Table.GenericParam'  		Table.GenericParamConstraint'  		Table.MethodSpec'  		Table.Document'  		Table.LocalScope'  		Table.LocalVariable'  		Table.LocalConstant'  		Table.ImportScope'  	};  	break;  default:  	throw new ArgumentException ();  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetSize,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	bits = 2;  	tables = new[] {  		Table.TypeDef'  		Table.TypeRef'  		Table.TypeSpec  	};  	break;  case CodedIndex.HasConstant:  	bits = 2;  	tables = new[] {  		Table.Field'  		Table.Param'  		Table.Property  	};  	break;  case CodedIndex.HasCustomAttribute:  	bits = 5;  	tables = new[] {  		Table.Method'  		Table.Field'  		Table.TypeRef'  		Table.TypeDef'  		Table.Param'  		Table.InterfaceImpl'  		Table.MemberRef'  		Table.Module'  		Table.DeclSecurity'  		Table.Property'  		Table.Event'  		Table.StandAloneSig'  		Table.ModuleRef'  		Table.TypeSpec'  		Table.Assembly'  		Table.AssemblyRef'  		Table.File'  		Table.ExportedType'  		Table.ManifestResource'  		Table.GenericParam'  		Table.GenericParamConstraint'  		Table.MethodSpec'  	};  	break;  case CodedIndex.HasFieldMarshal:  	bits = 1;  	tables = new[] {  		Table.Field'  		Table.Param  	};  	break;  case CodedIndex.HasDeclSecurity:  	bits = 2;  	tables = new[] {  		Table.TypeDef'  		Table.Method'  		Table.Assembly  	};  	break;  case CodedIndex.MemberRefParent:  	bits = 3;  	tables = new[] {  		Table.TypeDef'  		Table.TypeRef'  		Table.ModuleRef'  		Table.Method'  		Table.TypeSpec  	};  	break;  case CodedIndex.HasSemantics:  	bits = 1;  	tables = new[] {  		Table.Event'  		Table.Property  	};  	break;  case CodedIndex.MethodDefOrRef:  	bits = 1;  	tables = new[] {  		Table.Method'  		Table.MemberRef  	};  	break;  case CodedIndex.MemberForwarded:  	bits = 1;  	tables = new[] {  		Table.Field'  		Table.Method  	};  	break;  case CodedIndex.Implementation:  	bits = 2;  	tables = new[] {  		Table.File'  		Table.AssemblyRef'  		Table.ExportedType  	};  	break;  case CodedIndex.CustomAttributeType:  	bits = 3;  	tables = new[] {  		Table.Method'  		Table.MemberRef  	};  	break;  case CodedIndex.ResolutionScope:  	bits = 2;  	tables = new[] {  		Table.Module'  		Table.ModuleRef'  		Table.AssemblyRef'  		Table.TypeRef  	};  	break;  case CodedIndex.TypeOrMethodDef:  	bits = 1;  	tables = new[] {  		Table.TypeDef'  		Table.Method  	};  	break;  case CodedIndex.HasCustomDebugInformation:  	bits = 5;  	tables = new[] {  		Table.Method'  		Table.Field'  		Table.TypeRef'  		Table.TypeDef'  		Table.Param'  		Table.InterfaceImpl'  		Table.MemberRef'  		Table.Module'  		Table.DeclSecurity'  		Table.Property'  		Table.Event'  		Table.StandAloneSig'  		Table.ModuleRef'  		Table.TypeSpec'  		Table.Assembly'  		Table.AssemblyRef'  		Table.File'  		Table.ExportedType'  		Table.ManifestResource'  		Table.GenericParam'  		Table.GenericParamConstraint'  		Table.MethodSpec'  		Table.Document'  		Table.LocalScope'  		Table.LocalVariable'  		Table.LocalConstant'  		Table.ImportScope'  	};  	break;  default:  	throw new ArgumentException ();  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetSize,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	bits = 2;  	tables = new[] {  		Table.TypeDef'  		Table.TypeRef'  		Table.TypeSpec  	};  	break;  case CodedIndex.HasConstant:  	bits = 2;  	tables = new[] {  		Table.Field'  		Table.Param'  		Table.Property  	};  	break;  case CodedIndex.HasCustomAttribute:  	bits = 5;  	tables = new[] {  		Table.Method'  		Table.Field'  		Table.TypeRef'  		Table.TypeDef'  		Table.Param'  		Table.InterfaceImpl'  		Table.MemberRef'  		Table.Module'  		Table.DeclSecurity'  		Table.Property'  		Table.Event'  		Table.StandAloneSig'  		Table.ModuleRef'  		Table.TypeSpec'  		Table.Assembly'  		Table.AssemblyRef'  		Table.File'  		Table.ExportedType'  		Table.ManifestResource'  		Table.GenericParam'  		Table.GenericParamConstraint'  		Table.MethodSpec'  	};  	break;  case CodedIndex.HasFieldMarshal:  	bits = 1;  	tables = new[] {  		Table.Field'  		Table.Param  	};  	break;  case CodedIndex.HasDeclSecurity:  	bits = 2;  	tables = new[] {  		Table.TypeDef'  		Table.Method'  		Table.Assembly  	};  	break;  case CodedIndex.MemberRefParent:  	bits = 3;  	tables = new[] {  		Table.TypeDef'  		Table.TypeRef'  		Table.ModuleRef'  		Table.Method'  		Table.TypeSpec  	};  	break;  case CodedIndex.HasSemantics:  	bits = 1;  	tables = new[] {  		Table.Event'  		Table.Property  	};  	break;  case CodedIndex.MethodDefOrRef:  	bits = 1;  	tables = new[] {  		Table.Method'  		Table.MemberRef  	};  	break;  case CodedIndex.MemberForwarded:  	bits = 1;  	tables = new[] {  		Table.Field'  		Table.Method  	};  	break;  case CodedIndex.Implementation:  	bits = 2;  	tables = new[] {  		Table.File'  		Table.AssemblyRef'  		Table.ExportedType  	};  	break;  case CodedIndex.CustomAttributeType:  	bits = 3;  	tables = new[] {  		Table.Method'  		Table.MemberRef  	};  	break;  case CodedIndex.ResolutionScope:  	bits = 2;  	tables = new[] {  		Table.Module'  		Table.ModuleRef'  		Table.AssemblyRef'  		Table.TypeRef  	};  	break;  case CodedIndex.TypeOrMethodDef:  	bits = 1;  	tables = new[] {  		Table.TypeDef'  		Table.Method  	};  	break;  case CodedIndex.HasCustomDebugInformation:  	bits = 5;  	tables = new[] {  		Table.Method'  		Table.Field'  		Table.TypeRef'  		Table.TypeDef'  		Table.Param'  		Table.InterfaceImpl'  		Table.MemberRef'  		Table.Module'  		Table.DeclSecurity'  		Table.Property'  		Table.Event'  		Table.StandAloneSig'  		Table.ModuleRef'  		Table.TypeSpec'  		Table.Assembly'  		Table.AssemblyRef'  		Table.File'  		Table.ExportedType'  		Table.ManifestResource'  		Table.GenericParam'  		Table.GenericParamConstraint'  		Table.MethodSpec'  		Table.Document'  		Table.LocalScope'  		Table.LocalVariable'  		Table.LocalConstant'  		Table.ImportScope'  	};  	break;  default:  	throw new ArgumentException ();  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetSize,The following statement contains a magic number: switch (self) {  case CodedIndex.TypeDefOrRef:  	bits = 2;  	tables = new[] {  		Table.TypeDef'  		Table.TypeRef'  		Table.TypeSpec  	};  	break;  case CodedIndex.HasConstant:  	bits = 2;  	tables = new[] {  		Table.Field'  		Table.Param'  		Table.Property  	};  	break;  case CodedIndex.HasCustomAttribute:  	bits = 5;  	tables = new[] {  		Table.Method'  		Table.Field'  		Table.TypeRef'  		Table.TypeDef'  		Table.Param'  		Table.InterfaceImpl'  		Table.MemberRef'  		Table.Module'  		Table.DeclSecurity'  		Table.Property'  		Table.Event'  		Table.StandAloneSig'  		Table.ModuleRef'  		Table.TypeSpec'  		Table.Assembly'  		Table.AssemblyRef'  		Table.File'  		Table.ExportedType'  		Table.ManifestResource'  		Table.GenericParam'  		Table.GenericParamConstraint'  		Table.MethodSpec'  	};  	break;  case CodedIndex.HasFieldMarshal:  	bits = 1;  	tables = new[] {  		Table.Field'  		Table.Param  	};  	break;  case CodedIndex.HasDeclSecurity:  	bits = 2;  	tables = new[] {  		Table.TypeDef'  		Table.Method'  		Table.Assembly  	};  	break;  case CodedIndex.MemberRefParent:  	bits = 3;  	tables = new[] {  		Table.TypeDef'  		Table.TypeRef'  		Table.ModuleRef'  		Table.Method'  		Table.TypeSpec  	};  	break;  case CodedIndex.HasSemantics:  	bits = 1;  	tables = new[] {  		Table.Event'  		Table.Property  	};  	break;  case CodedIndex.MethodDefOrRef:  	bits = 1;  	tables = new[] {  		Table.Method'  		Table.MemberRef  	};  	break;  case CodedIndex.MemberForwarded:  	bits = 1;  	tables = new[] {  		Table.Field'  		Table.Method  	};  	break;  case CodedIndex.Implementation:  	bits = 2;  	tables = new[] {  		Table.File'  		Table.AssemblyRef'  		Table.ExportedType  	};  	break;  case CodedIndex.CustomAttributeType:  	bits = 3;  	tables = new[] {  		Table.Method'  		Table.MemberRef  	};  	break;  case CodedIndex.ResolutionScope:  	bits = 2;  	tables = new[] {  		Table.Module'  		Table.ModuleRef'  		Table.AssemblyRef'  		Table.TypeRef  	};  	break;  case CodedIndex.TypeOrMethodDef:  	bits = 1;  	tables = new[] {  		Table.TypeDef'  		Table.Method  	};  	break;  case CodedIndex.HasCustomDebugInformation:  	bits = 5;  	tables = new[] {  		Table.Method'  		Table.Field'  		Table.TypeRef'  		Table.TypeDef'  		Table.Param'  		Table.InterfaceImpl'  		Table.MemberRef'  		Table.Module'  		Table.DeclSecurity'  		Table.Property'  		Table.Event'  		Table.StandAloneSig'  		Table.ModuleRef'  		Table.TypeSpec'  		Table.Assembly'  		Table.AssemblyRef'  		Table.File'  		Table.ExportedType'  		Table.ManifestResource'  		Table.GenericParam'  		Table.GenericParamConstraint'  		Table.MethodSpec'  		Table.Document'  		Table.LocalScope'  		Table.LocalVariable'  		Table.LocalConstant'  		Table.ImportScope'  	};  	break;  default:  	throw new ArgumentException ();  }  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetSize,The following statement contains a magic number: bits = 2;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetSize,The following statement contains a magic number: bits = 2;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetSize,The following statement contains a magic number: bits = 5;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetSize,The following statement contains a magic number: bits = 2;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetSize,The following statement contains a magic number: bits = 3;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetSize,The following statement contains a magic number: bits = 2;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetSize,The following statement contains a magic number: bits = 3;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetSize,The following statement contains a magic number: bits = 2;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetSize,The following statement contains a magic number: bits = 5;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetSize,The following statement contains a magic number: return max < (1 << (16 - bits)) ? 2 : 4;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetSize,The following statement contains a magic number: return max < (1 << (16 - bits)) ? 2 : 4;  
Magic Number,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetSize,The following statement contains a magic number: return max < (1 << (16 - bits)) ? 2 : 4;  
Magic Number,Mono.Cecil,AssemblyNameReference,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyNameReference.cs,Parse,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	var token = tokens [i].Trim ();  	if (i == 0) {  		name.Name = token;  		continue;  	}  	var parts = token.Split ('=');  	if (parts.Length != 2)  		throw new ArgumentException ("Malformed name");  	switch (parts [0].ToLowerInvariant ()) {  	case "version":  		name.Version = new Version (parts [1]);  		break;  	case "culture":  		name.Culture = parts [1] == "neutral" ? "" : parts [1];  		break;  	case "publickeytoken":  		var pk_token = parts [1];  		if (pk_token == "null")  			break;  		name.PublicKeyToken = new byte[pk_token.Length / 2];  		for (int j = 0; j < name.PublicKeyToken.Length; j++)  			name.PublicKeyToken [j] = Byte.Parse (pk_token.Substring (j * 2' 2)' NumberStyles.HexNumber);  		break;  	}  }  
Magic Number,Mono.Cecil,AssemblyNameReference,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyNameReference.cs,Parse,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	var token = tokens [i].Trim ();  	if (i == 0) {  		name.Name = token;  		continue;  	}  	var parts = token.Split ('=');  	if (parts.Length != 2)  		throw new ArgumentException ("Malformed name");  	switch (parts [0].ToLowerInvariant ()) {  	case "version":  		name.Version = new Version (parts [1]);  		break;  	case "culture":  		name.Culture = parts [1] == "neutral" ? "" : parts [1];  		break;  	case "publickeytoken":  		var pk_token = parts [1];  		if (pk_token == "null")  			break;  		name.PublicKeyToken = new byte[pk_token.Length / 2];  		for (int j = 0; j < name.PublicKeyToken.Length; j++)  			name.PublicKeyToken [j] = Byte.Parse (pk_token.Substring (j * 2' 2)' NumberStyles.HexNumber);  		break;  	}  }  
Magic Number,Mono.Cecil,AssemblyNameReference,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyNameReference.cs,Parse,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	var token = tokens [i].Trim ();  	if (i == 0) {  		name.Name = token;  		continue;  	}  	var parts = token.Split ('=');  	if (parts.Length != 2)  		throw new ArgumentException ("Malformed name");  	switch (parts [0].ToLowerInvariant ()) {  	case "version":  		name.Version = new Version (parts [1]);  		break;  	case "culture":  		name.Culture = parts [1] == "neutral" ? "" : parts [1];  		break;  	case "publickeytoken":  		var pk_token = parts [1];  		if (pk_token == "null")  			break;  		name.PublicKeyToken = new byte[pk_token.Length / 2];  		for (int j = 0; j < name.PublicKeyToken.Length; j++)  			name.PublicKeyToken [j] = Byte.Parse (pk_token.Substring (j * 2' 2)' NumberStyles.HexNumber);  		break;  	}  }  
Magic Number,Mono.Cecil,AssemblyNameReference,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyNameReference.cs,Parse,The following statement contains a magic number: for (int i = 0; i < tokens.Length; i++) {  	var token = tokens [i].Trim ();  	if (i == 0) {  		name.Name = token;  		continue;  	}  	var parts = token.Split ('=');  	if (parts.Length != 2)  		throw new ArgumentException ("Malformed name");  	switch (parts [0].ToLowerInvariant ()) {  	case "version":  		name.Version = new Version (parts [1]);  		break;  	case "culture":  		name.Culture = parts [1] == "neutral" ? "" : parts [1];  		break;  	case "publickeytoken":  		var pk_token = parts [1];  		if (pk_token == "null")  			break;  		name.PublicKeyToken = new byte[pk_token.Length / 2];  		for (int j = 0; j < name.PublicKeyToken.Length; j++)  			name.PublicKeyToken [j] = Byte.Parse (pk_token.Substring (j * 2' 2)' NumberStyles.HexNumber);  		break;  	}  }  
Magic Number,Mono.Cecil,AssemblyNameReference,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyNameReference.cs,Parse,The following statement contains a magic number: if (parts.Length != 2)  	throw new ArgumentException ("Malformed name");  
Magic Number,Mono.Cecil,AssemblyNameReference,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyNameReference.cs,Parse,The following statement contains a magic number: switch (parts [0].ToLowerInvariant ()) {  case "version":  	name.Version = new Version (parts [1]);  	break;  case "culture":  	name.Culture = parts [1] == "neutral" ? "" : parts [1];  	break;  case "publickeytoken":  	var pk_token = parts [1];  	if (pk_token == "null")  		break;  	name.PublicKeyToken = new byte[pk_token.Length / 2];  	for (int j = 0; j < name.PublicKeyToken.Length; j++)  		name.PublicKeyToken [j] = Byte.Parse (pk_token.Substring (j * 2' 2)' NumberStyles.HexNumber);  	break;  }  
Magic Number,Mono.Cecil,AssemblyNameReference,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyNameReference.cs,Parse,The following statement contains a magic number: switch (parts [0].ToLowerInvariant ()) {  case "version":  	name.Version = new Version (parts [1]);  	break;  case "culture":  	name.Culture = parts [1] == "neutral" ? "" : parts [1];  	break;  case "publickeytoken":  	var pk_token = parts [1];  	if (pk_token == "null")  		break;  	name.PublicKeyToken = new byte[pk_token.Length / 2];  	for (int j = 0; j < name.PublicKeyToken.Length; j++)  		name.PublicKeyToken [j] = Byte.Parse (pk_token.Substring (j * 2' 2)' NumberStyles.HexNumber);  	break;  }  
Magic Number,Mono.Cecil,AssemblyNameReference,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyNameReference.cs,Parse,The following statement contains a magic number: switch (parts [0].ToLowerInvariant ()) {  case "version":  	name.Version = new Version (parts [1]);  	break;  case "culture":  	name.Culture = parts [1] == "neutral" ? "" : parts [1];  	break;  case "publickeytoken":  	var pk_token = parts [1];  	if (pk_token == "null")  		break;  	name.PublicKeyToken = new byte[pk_token.Length / 2];  	for (int j = 0; j < name.PublicKeyToken.Length; j++)  		name.PublicKeyToken [j] = Byte.Parse (pk_token.Substring (j * 2' 2)' NumberStyles.HexNumber);  	break;  }  
Magic Number,Mono.Cecil,AssemblyNameReference,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyNameReference.cs,Parse,The following statement contains a magic number: name.PublicKeyToken = new byte[pk_token.Length / 2];  
Magic Number,Mono.Cecil,AssemblyNameReference,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyNameReference.cs,Parse,The following statement contains a magic number: for (int j = 0; j < name.PublicKeyToken.Length; j++)  	name.PublicKeyToken [j] = Byte.Parse (pk_token.Substring (j * 2' 2)' NumberStyles.HexNumber);  
Magic Number,Mono.Cecil,AssemblyNameReference,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyNameReference.cs,Parse,The following statement contains a magic number: for (int j = 0; j < name.PublicKeyToken.Length; j++)  	name.PublicKeyToken [j] = Byte.Parse (pk_token.Substring (j * 2' 2)' NumberStyles.HexNumber);  
Magic Number,Mono.Cecil,AssemblyNameReference,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyNameReference.cs,Parse,The following statement contains a magic number: name.PublicKeyToken [j] = Byte.Parse (pk_token.Substring (j * 2' 2)' NumberStyles.HexNumber);  
Magic Number,Mono.Cecil,AssemblyNameReference,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyNameReference.cs,Parse,The following statement contains a magic number: name.PublicKeyToken [j] = Byte.Parse (pk_token.Substring (j * 2' 2)' NumberStyles.HexNumber);  
Magic Number,Mono.Cecil,MetadataReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,ReadByIndexSize,The following statement contains a magic number: if (size == 4)  	return ReadUInt32 ();  else  	return ReadUInt16 ();  
Magic Number,Mono.Cecil,MetadataReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,ReadBlob,The following statement contains a magic number: if (blob_heap == null) {  	position += 2;  	return Empty<byte>.Array;  }  
Magic Number,Mono.Cecil,MetadataReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,ReadBlob,The following statement contains a magic number: position += 2;  
Magic Number,Mono.Cecil,MetadataReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,ReadBlobIndex,The following statement contains a magic number: return ReadByIndexSize (blob_heap != null ? blob_heap.IndexSize : 2);  
Magic Number,Mono.Cecil,MetadataReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,Populate,The following statement contains a magic number: Advance (2);  
Magic Number,Mono.Cecil,MetadataReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,GetFieldTypeSize,The following statement contains a magic number: switch (type.etype) {  case ElementType.Boolean:  case ElementType.U1:  case ElementType.I1:  	size = 1;  	break;  case ElementType.U2:  case ElementType.I2:  case ElementType.Char:  	size = 2;  	break;  case ElementType.U4:  case ElementType.I4:  case ElementType.R4:  	size = 4;  	break;  case ElementType.U8:  case ElementType.I8:  case ElementType.R8:  	size = 8;  	break;  case ElementType.Ptr:  case ElementType.FnPtr:  	size = IntPtr.Size;  	break;  case ElementType.CModOpt:  case ElementType.CModReqD:  	return GetFieldTypeSize (((IModifierType)type).ElementType);  default:  	var field_type = type.Resolve ();  	if (field_type != null && field_type.HasLayoutInfo)  		size = field_type.ClassSize;  	break;  }  
Magic Number,Mono.Cecil,MetadataReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,GetFieldTypeSize,The following statement contains a magic number: switch (type.etype) {  case ElementType.Boolean:  case ElementType.U1:  case ElementType.I1:  	size = 1;  	break;  case ElementType.U2:  case ElementType.I2:  case ElementType.Char:  	size = 2;  	break;  case ElementType.U4:  case ElementType.I4:  case ElementType.R4:  	size = 4;  	break;  case ElementType.U8:  case ElementType.I8:  case ElementType.R8:  	size = 8;  	break;  case ElementType.Ptr:  case ElementType.FnPtr:  	size = IntPtr.Size;  	break;  case ElementType.CModOpt:  case ElementType.CModReqD:  	return GetFieldTypeSize (((IModifierType)type).ElementType);  default:  	var field_type = type.Resolve ();  	if (field_type != null && field_type.HasLayoutInfo)  		size = field_type.ClassSize;  	break;  }  
Magic Number,Mono.Cecil,MetadataReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,GetFieldTypeSize,The following statement contains a magic number: switch (type.etype) {  case ElementType.Boolean:  case ElementType.U1:  case ElementType.I1:  	size = 1;  	break;  case ElementType.U2:  case ElementType.I2:  case ElementType.Char:  	size = 2;  	break;  case ElementType.U4:  case ElementType.I4:  case ElementType.R4:  	size = 4;  	break;  case ElementType.U8:  case ElementType.I8:  case ElementType.R8:  	size = 8;  	break;  case ElementType.Ptr:  case ElementType.FnPtr:  	size = IntPtr.Size;  	break;  case ElementType.CModOpt:  case ElementType.CModReqD:  	return GetFieldTypeSize (((IModifierType)type).ElementType);  default:  	var field_type = type.Resolve ();  	if (field_type != null && field_type.HasLayoutInfo)  		size = field_type.ClassSize;  	break;  }  
Magic Number,Mono.Cecil,MetadataReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,GetFieldTypeSize,The following statement contains a magic number: size = 2;  
Magic Number,Mono.Cecil,MetadataReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,GetFieldTypeSize,The following statement contains a magic number: size = 4;  
Magic Number,Mono.Cecil,MetadataReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,GetFieldTypeSize,The following statement contains a magic number: size = 8;  
Magic Number,Mono.Cecil,MetadataReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,InitializeGenericParameters,The following statement contains a magic number: metadata.GenericParameters = InitializeRanges (Table.GenericParam' () => {  	Advance (4);  	var next = ReadMetadataToken (CodedIndex.TypeOrMethodDef);  	ReadStringIndex ();  	return next;  });  
Magic Number,Mono.Cecil,MetadataReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,InitializeGenericParameters,The following statement contains a magic number: Advance (4);  
Magic Number,Mono.Cecil,MetadataReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,GetCustomDebugInformation,The following statement contains a magic number: for (int i = 0; i < rows.Length; i++) {  	if (rows [i].Col1 == StateMachineScopeDebugInformation.KindIdentifier) {  		var signature = ReadSignature (rows [i].Col2);  		infos.Add (new StateMachineScopeDebugInformation (signature.ReadInt32 ()' signature.ReadInt32 ()));  	} else if (rows [i].Col1 == AsyncMethodBodyDebugInformation.KindIdentifier) {  		var signature = ReadSignature (rows [i].Col2);  		var catch_offset = signature.ReadInt32 () - 1;  		var yields = new Collection<InstructionOffset> ();  		var resumes = new Collection<InstructionOffset> ();  		uint move_next_rid = 0;  		while (signature.CanReadMore ()) {  			yields.Add (new InstructionOffset (signature.ReadInt32 ()));  			resumes.Add (new InstructionOffset (signature.ReadInt32 ()));  			move_next_rid = signature.ReadCompressedUInt32 ();  		}  		var async_body = new AsyncMethodBodyDebugInformation (catch_offset);  		async_body.yields = yields;  		async_body.resumes = resumes;  		async_body.move_next = GetMethodDefinition (move_next_rid);  		infos.Add (async_body);  	} else if (rows [i].Col1 == EmbeddedSourceDebugInformation.KindIdentifier) {  		var signature = ReadSignature (rows [i].Col2);  		var format = signature.ReadInt32 ();  		var length = signature.sig_length - 4;  		var info = null as CustomDebugInformation;  		if (format == 0) {  			info = new EmbeddedSourceDebugInformation (signature.ReadBytes ((int)length)' compress: false);  		} else if (format > 0) {  			var compressed_stream = new MemoryStream (signature.ReadBytes ((int)length));  			var decompressed_stream = new MemoryStream (format);  			using (var deflate_stream = new DeflateStream (compressed_stream' CompressionMode.Decompress' leaveOpen: true))  				deflate_stream.CopyTo (decompressed_stream);  			info = new EmbeddedSourceDebugInformation (decompressed_stream.GetBuffer ()' compress: true);  		} else if (format < 0) {  			info = new BinaryCustomDebugInformation (rows [i].Col1' ReadBlob (rows [i].Col2));  		}  		infos.Add (info);  	} else if (rows [i].Col1 == SourceLinkDebugInformation.KindIdentifier) {  		infos.Add (new SourceLinkDebugInformation (Encoding.UTF8.GetString (ReadBlob (rows [i].Col2))));  	} else {  		infos.Add (new BinaryCustomDebugInformation (rows [i].Col1' ReadBlob (rows [i].Col2)));  	}  	infos [i].token = new MetadataToken (TokenType.CustomDebugInformation' rows [i].Col3);  }  
Magic Number,Mono.Cecil,MetadataReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,GetCustomDebugInformation,The following statement contains a magic number: if (rows [i].Col1 == StateMachineScopeDebugInformation.KindIdentifier) {  	var signature = ReadSignature (rows [i].Col2);  	infos.Add (new StateMachineScopeDebugInformation (signature.ReadInt32 ()' signature.ReadInt32 ()));  } else if (rows [i].Col1 == AsyncMethodBodyDebugInformation.KindIdentifier) {  	var signature = ReadSignature (rows [i].Col2);  	var catch_offset = signature.ReadInt32 () - 1;  	var yields = new Collection<InstructionOffset> ();  	var resumes = new Collection<InstructionOffset> ();  	uint move_next_rid = 0;  	while (signature.CanReadMore ()) {  		yields.Add (new InstructionOffset (signature.ReadInt32 ()));  		resumes.Add (new InstructionOffset (signature.ReadInt32 ()));  		move_next_rid = signature.ReadCompressedUInt32 ();  	}  	var async_body = new AsyncMethodBodyDebugInformation (catch_offset);  	async_body.yields = yields;  	async_body.resumes = resumes;  	async_body.move_next = GetMethodDefinition (move_next_rid);  	infos.Add (async_body);  } else if (rows [i].Col1 == EmbeddedSourceDebugInformation.KindIdentifier) {  	var signature = ReadSignature (rows [i].Col2);  	var format = signature.ReadInt32 ();  	var length = signature.sig_length - 4;  	var info = null as CustomDebugInformation;  	if (format == 0) {  		info = new EmbeddedSourceDebugInformation (signature.ReadBytes ((int)length)' compress: false);  	} else if (format > 0) {  		var compressed_stream = new MemoryStream (signature.ReadBytes ((int)length));  		var decompressed_stream = new MemoryStream (format);  		using (var deflate_stream = new DeflateStream (compressed_stream' CompressionMode.Decompress' leaveOpen: true))  			deflate_stream.CopyTo (decompressed_stream);  		info = new EmbeddedSourceDebugInformation (decompressed_stream.GetBuffer ()' compress: true);  	} else if (format < 0) {  		info = new BinaryCustomDebugInformation (rows [i].Col1' ReadBlob (rows [i].Col2));  	}  	infos.Add (info);  } else if (rows [i].Col1 == SourceLinkDebugInformation.KindIdentifier) {  	infos.Add (new SourceLinkDebugInformation (Encoding.UTF8.GetString (ReadBlob (rows [i].Col2))));  } else {  	infos.Add (new BinaryCustomDebugInformation (rows [i].Col1' ReadBlob (rows [i].Col2)));  }  
Magic Number,Mono.Cecil,MetadataReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,GetCustomDebugInformation,The following statement contains a magic number: if (rows [i].Col1 == AsyncMethodBodyDebugInformation.KindIdentifier) {  	var signature = ReadSignature (rows [i].Col2);  	var catch_offset = signature.ReadInt32 () - 1;  	var yields = new Collection<InstructionOffset> ();  	var resumes = new Collection<InstructionOffset> ();  	uint move_next_rid = 0;  	while (signature.CanReadMore ()) {  		yields.Add (new InstructionOffset (signature.ReadInt32 ()));  		resumes.Add (new InstructionOffset (signature.ReadInt32 ()));  		move_next_rid = signature.ReadCompressedUInt32 ();  	}  	var async_body = new AsyncMethodBodyDebugInformation (catch_offset);  	async_body.yields = yields;  	async_body.resumes = resumes;  	async_body.move_next = GetMethodDefinition (move_next_rid);  	infos.Add (async_body);  } else if (rows [i].Col1 == EmbeddedSourceDebugInformation.KindIdentifier) {  	var signature = ReadSignature (rows [i].Col2);  	var format = signature.ReadInt32 ();  	var length = signature.sig_length - 4;  	var info = null as CustomDebugInformation;  	if (format == 0) {  		info = new EmbeddedSourceDebugInformation (signature.ReadBytes ((int)length)' compress: false);  	} else if (format > 0) {  		var compressed_stream = new MemoryStream (signature.ReadBytes ((int)length));  		var decompressed_stream = new MemoryStream (format);  		using (var deflate_stream = new DeflateStream (compressed_stream' CompressionMode.Decompress' leaveOpen: true))  			deflate_stream.CopyTo (decompressed_stream);  		info = new EmbeddedSourceDebugInformation (decompressed_stream.GetBuffer ()' compress: true);  	} else if (format < 0) {  		info = new BinaryCustomDebugInformation (rows [i].Col1' ReadBlob (rows [i].Col2));  	}  	infos.Add (info);  } else if (rows [i].Col1 == SourceLinkDebugInformation.KindIdentifier) {  	infos.Add (new SourceLinkDebugInformation (Encoding.UTF8.GetString (ReadBlob (rows [i].Col2))));  } else {  	infos.Add (new BinaryCustomDebugInformation (rows [i].Col1' ReadBlob (rows [i].Col2)));  }  
Magic Number,Mono.Cecil,MetadataReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,GetCustomDebugInformation,The following statement contains a magic number: if (rows [i].Col1 == EmbeddedSourceDebugInformation.KindIdentifier) {  	var signature = ReadSignature (rows [i].Col2);  	var format = signature.ReadInt32 ();  	var length = signature.sig_length - 4;  	var info = null as CustomDebugInformation;  	if (format == 0) {  		info = new EmbeddedSourceDebugInformation (signature.ReadBytes ((int)length)' compress: false);  	} else if (format > 0) {  		var compressed_stream = new MemoryStream (signature.ReadBytes ((int)length));  		var decompressed_stream = new MemoryStream (format);  		using (var deflate_stream = new DeflateStream (compressed_stream' CompressionMode.Decompress' leaveOpen: true))  			deflate_stream.CopyTo (decompressed_stream);  		info = new EmbeddedSourceDebugInformation (decompressed_stream.GetBuffer ()' compress: true);  	} else if (format < 0) {  		info = new BinaryCustomDebugInformation (rows [i].Col1' ReadBlob (rows [i].Col2));  	}  	infos.Add (info);  } else if (rows [i].Col1 == SourceLinkDebugInformation.KindIdentifier) {  	infos.Add (new SourceLinkDebugInformation (Encoding.UTF8.GetString (ReadBlob (rows [i].Col2))));  } else {  	infos.Add (new BinaryCustomDebugInformation (rows [i].Col1' ReadBlob (rows [i].Col2)));  }  
Magic Number,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,CreateTextMap,The following statement contains a magic number: map.AddMap (TextSegment.ImportAddressTable' module.Architecture == TargetArchitecture.I386 ? 8 : 0);  
Magic Number,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,CreateTextMap,The following statement contains a magic number: map.AddMap (TextSegment.CLIHeader' 0x48' 8);  
Magic Number,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,GetConstantSignature,The following statement contains a magic number: if (type.IsTypeOf ("System"' "Decimal")) {  	var bits = decimal.GetBits ((decimal)constant.Value);  	var low = (uint)bits [0];  	var mid = (uint)bits [1];  	var high = (uint)bits [2];  	var scale = (byte)(bits [3] >> 16);  	var negative = (bits [3] & 0x80000000) != 0;  	signature.WriteByte ((byte)(scale | (negative ? 0x80 : 0x00)));  	signature.WriteUInt32 (low);  	signature.WriteUInt32 (mid);  	signature.WriteUInt32 (high);  	return signature;  }  
Magic Number,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,GetConstantSignature,The following statement contains a magic number: if (type.IsTypeOf ("System"' "Decimal")) {  	var bits = decimal.GetBits ((decimal)constant.Value);  	var low = (uint)bits [0];  	var mid = (uint)bits [1];  	var high = (uint)bits [2];  	var scale = (byte)(bits [3] >> 16);  	var negative = (bits [3] & 0x80000000) != 0;  	signature.WriteByte ((byte)(scale | (negative ? 0x80 : 0x00)));  	signature.WriteUInt32 (low);  	signature.WriteUInt32 (mid);  	signature.WriteUInt32 (high);  	return signature;  }  
Magic Number,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,GetConstantSignature,The following statement contains a magic number: if (type.IsTypeOf ("System"' "Decimal")) {  	var bits = decimal.GetBits ((decimal)constant.Value);  	var low = (uint)bits [0];  	var mid = (uint)bits [1];  	var high = (uint)bits [2];  	var scale = (byte)(bits [3] >> 16);  	var negative = (bits [3] & 0x80000000) != 0;  	signature.WriteByte ((byte)(scale | (negative ? 0x80 : 0x00)));  	signature.WriteUInt32 (low);  	signature.WriteUInt32 (mid);  	signature.WriteUInt32 (high);  	return signature;  }  
Magic Number,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,GetConstantSignature,The following statement contains a magic number: if (type.IsTypeOf ("System"' "Decimal")) {  	var bits = decimal.GetBits ((decimal)constant.Value);  	var low = (uint)bits [0];  	var mid = (uint)bits [1];  	var high = (uint)bits [2];  	var scale = (byte)(bits [3] >> 16);  	var negative = (bits [3] & 0x80000000) != 0;  	signature.WriteByte ((byte)(scale | (negative ? 0x80 : 0x00)));  	signature.WriteUInt32 (low);  	signature.WriteUInt32 (mid);  	signature.WriteUInt32 (high);  	return signature;  }  
Magic Number,Mono.Cecil,BaseAssemblyResolver,F:\newReposMay17\jbevain_cecil\Mono.Cecil\BaseAssemblyResolver.cs,BaseAssemblyResolver,The following statement contains a magic number: directories = new Collection<string> (2) {  	"."'  	"bin"  };  
Magic Number,Mono.Cecil,BaseAssemblyResolver,F:\newReposMay17\jbevain_cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (on_mono) {  	if (version.Major == 1)  		path = Path.Combine (path' "1.0");  	else if (version.Major == 2) {  		if (version.MajorRevision == 5)  			path = Path.Combine (path' "2.1");  		else  			path = Path.Combine (path' "2.0");  	} else if (version.Major == 4)  		path = Path.Combine (path' "4.0");  	else  		throw new NotSupportedException ("Version not supported: " + version);  } else {  	switch (version.Major) {  	case 1:  		if (version.MajorRevision == 3300)  			path = Path.Combine (path' "v1.0.3705");  		else  			path = Path.Combine (path' "v1.0.5000.0");  		break;  	case 2:  		path = Path.Combine (path' "v2.0.50727");  		break;  	case 4:  		path = Path.Combine (path' "v4.0.30319");  		break;  	default:  		throw new NotSupportedException ("Version not supported: " + version);  	}  }  
Magic Number,Mono.Cecil,BaseAssemblyResolver,F:\newReposMay17\jbevain_cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (on_mono) {  	if (version.Major == 1)  		path = Path.Combine (path' "1.0");  	else if (version.Major == 2) {  		if (version.MajorRevision == 5)  			path = Path.Combine (path' "2.1");  		else  			path = Path.Combine (path' "2.0");  	} else if (version.Major == 4)  		path = Path.Combine (path' "4.0");  	else  		throw new NotSupportedException ("Version not supported: " + version);  } else {  	switch (version.Major) {  	case 1:  		if (version.MajorRevision == 3300)  			path = Path.Combine (path' "v1.0.3705");  		else  			path = Path.Combine (path' "v1.0.5000.0");  		break;  	case 2:  		path = Path.Combine (path' "v2.0.50727");  		break;  	case 4:  		path = Path.Combine (path' "v4.0.30319");  		break;  	default:  		throw new NotSupportedException ("Version not supported: " + version);  	}  }  
Magic Number,Mono.Cecil,BaseAssemblyResolver,F:\newReposMay17\jbevain_cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (on_mono) {  	if (version.Major == 1)  		path = Path.Combine (path' "1.0");  	else if (version.Major == 2) {  		if (version.MajorRevision == 5)  			path = Path.Combine (path' "2.1");  		else  			path = Path.Combine (path' "2.0");  	} else if (version.Major == 4)  		path = Path.Combine (path' "4.0");  	else  		throw new NotSupportedException ("Version not supported: " + version);  } else {  	switch (version.Major) {  	case 1:  		if (version.MajorRevision == 3300)  			path = Path.Combine (path' "v1.0.3705");  		else  			path = Path.Combine (path' "v1.0.5000.0");  		break;  	case 2:  		path = Path.Combine (path' "v2.0.50727");  		break;  	case 4:  		path = Path.Combine (path' "v4.0.30319");  		break;  	default:  		throw new NotSupportedException ("Version not supported: " + version);  	}  }  
Magic Number,Mono.Cecil,BaseAssemblyResolver,F:\newReposMay17\jbevain_cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (on_mono) {  	if (version.Major == 1)  		path = Path.Combine (path' "1.0");  	else if (version.Major == 2) {  		if (version.MajorRevision == 5)  			path = Path.Combine (path' "2.1");  		else  			path = Path.Combine (path' "2.0");  	} else if (version.Major == 4)  		path = Path.Combine (path' "4.0");  	else  		throw new NotSupportedException ("Version not supported: " + version);  } else {  	switch (version.Major) {  	case 1:  		if (version.MajorRevision == 3300)  			path = Path.Combine (path' "v1.0.3705");  		else  			path = Path.Combine (path' "v1.0.5000.0");  		break;  	case 2:  		path = Path.Combine (path' "v2.0.50727");  		break;  	case 4:  		path = Path.Combine (path' "v4.0.30319");  		break;  	default:  		throw new NotSupportedException ("Version not supported: " + version);  	}  }  
Magic Number,Mono.Cecil,BaseAssemblyResolver,F:\newReposMay17\jbevain_cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (on_mono) {  	if (version.Major == 1)  		path = Path.Combine (path' "1.0");  	else if (version.Major == 2) {  		if (version.MajorRevision == 5)  			path = Path.Combine (path' "2.1");  		else  			path = Path.Combine (path' "2.0");  	} else if (version.Major == 4)  		path = Path.Combine (path' "4.0");  	else  		throw new NotSupportedException ("Version not supported: " + version);  } else {  	switch (version.Major) {  	case 1:  		if (version.MajorRevision == 3300)  			path = Path.Combine (path' "v1.0.3705");  		else  			path = Path.Combine (path' "v1.0.5000.0");  		break;  	case 2:  		path = Path.Combine (path' "v2.0.50727");  		break;  	case 4:  		path = Path.Combine (path' "v4.0.30319");  		break;  	default:  		throw new NotSupportedException ("Version not supported: " + version);  	}  }  
Magic Number,Mono.Cecil,BaseAssemblyResolver,F:\newReposMay17\jbevain_cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (on_mono) {  	if (version.Major == 1)  		path = Path.Combine (path' "1.0");  	else if (version.Major == 2) {  		if (version.MajorRevision == 5)  			path = Path.Combine (path' "2.1");  		else  			path = Path.Combine (path' "2.0");  	} else if (version.Major == 4)  		path = Path.Combine (path' "4.0");  	else  		throw new NotSupportedException ("Version not supported: " + version);  } else {  	switch (version.Major) {  	case 1:  		if (version.MajorRevision == 3300)  			path = Path.Combine (path' "v1.0.3705");  		else  			path = Path.Combine (path' "v1.0.5000.0");  		break;  	case 2:  		path = Path.Combine (path' "v2.0.50727");  		break;  	case 4:  		path = Path.Combine (path' "v4.0.30319");  		break;  	default:  		throw new NotSupportedException ("Version not supported: " + version);  	}  }  
Magic Number,Mono.Cecil,BaseAssemblyResolver,F:\newReposMay17\jbevain_cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (version.Major == 1)  	path = Path.Combine (path' "1.0");  else if (version.Major == 2) {  	if (version.MajorRevision == 5)  		path = Path.Combine (path' "2.1");  	else  		path = Path.Combine (path' "2.0");  } else if (version.Major == 4)  	path = Path.Combine (path' "4.0");  else  	throw new NotSupportedException ("Version not supported: " + version);  
Magic Number,Mono.Cecil,BaseAssemblyResolver,F:\newReposMay17\jbevain_cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (version.Major == 1)  	path = Path.Combine (path' "1.0");  else if (version.Major == 2) {  	if (version.MajorRevision == 5)  		path = Path.Combine (path' "2.1");  	else  		path = Path.Combine (path' "2.0");  } else if (version.Major == 4)  	path = Path.Combine (path' "4.0");  else  	throw new NotSupportedException ("Version not supported: " + version);  
Magic Number,Mono.Cecil,BaseAssemblyResolver,F:\newReposMay17\jbevain_cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (version.Major == 1)  	path = Path.Combine (path' "1.0");  else if (version.Major == 2) {  	if (version.MajorRevision == 5)  		path = Path.Combine (path' "2.1");  	else  		path = Path.Combine (path' "2.0");  } else if (version.Major == 4)  	path = Path.Combine (path' "4.0");  else  	throw new NotSupportedException ("Version not supported: " + version);  
Magic Number,Mono.Cecil,BaseAssemblyResolver,F:\newReposMay17\jbevain_cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (version.Major == 2) {  	if (version.MajorRevision == 5)  		path = Path.Combine (path' "2.1");  	else  		path = Path.Combine (path' "2.0");  } else if (version.Major == 4)  	path = Path.Combine (path' "4.0");  else  	throw new NotSupportedException ("Version not supported: " + version);  
Magic Number,Mono.Cecil,BaseAssemblyResolver,F:\newReposMay17\jbevain_cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (version.Major == 2) {  	if (version.MajorRevision == 5)  		path = Path.Combine (path' "2.1");  	else  		path = Path.Combine (path' "2.0");  } else if (version.Major == 4)  	path = Path.Combine (path' "4.0");  else  	throw new NotSupportedException ("Version not supported: " + version);  
Magic Number,Mono.Cecil,BaseAssemblyResolver,F:\newReposMay17\jbevain_cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (version.Major == 2) {  	if (version.MajorRevision == 5)  		path = Path.Combine (path' "2.1");  	else  		path = Path.Combine (path' "2.0");  } else if (version.Major == 4)  	path = Path.Combine (path' "4.0");  else  	throw new NotSupportedException ("Version not supported: " + version);  
Magic Number,Mono.Cecil,BaseAssemblyResolver,F:\newReposMay17\jbevain_cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (version.MajorRevision == 5)  	path = Path.Combine (path' "2.1");  else  	path = Path.Combine (path' "2.0");  
Magic Number,Mono.Cecil,BaseAssemblyResolver,F:\newReposMay17\jbevain_cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (version.Major == 4)  	path = Path.Combine (path' "4.0");  else  	throw new NotSupportedException ("Version not supported: " + version);  
Magic Number,Mono.Cecil,BaseAssemblyResolver,F:\newReposMay17\jbevain_cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: switch (version.Major) {  case 1:  	if (version.MajorRevision == 3300)  		path = Path.Combine (path' "v1.0.3705");  	else  		path = Path.Combine (path' "v1.0.5000.0");  	break;  case 2:  	path = Path.Combine (path' "v2.0.50727");  	break;  case 4:  	path = Path.Combine (path' "v4.0.30319");  	break;  default:  	throw new NotSupportedException ("Version not supported: " + version);  }  
Magic Number,Mono.Cecil,BaseAssemblyResolver,F:\newReposMay17\jbevain_cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: switch (version.Major) {  case 1:  	if (version.MajorRevision == 3300)  		path = Path.Combine (path' "v1.0.3705");  	else  		path = Path.Combine (path' "v1.0.5000.0");  	break;  case 2:  	path = Path.Combine (path' "v2.0.50727");  	break;  case 4:  	path = Path.Combine (path' "v4.0.30319");  	break;  default:  	throw new NotSupportedException ("Version not supported: " + version);  }  
Magic Number,Mono.Cecil,BaseAssemblyResolver,F:\newReposMay17\jbevain_cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: switch (version.Major) {  case 1:  	if (version.MajorRevision == 3300)  		path = Path.Combine (path' "v1.0.3705");  	else  		path = Path.Combine (path' "v1.0.5000.0");  	break;  case 2:  	path = Path.Combine (path' "v2.0.50727");  	break;  case 4:  	path = Path.Combine (path' "v4.0.30319");  	break;  default:  	throw new NotSupportedException ("Version not supported: " + version);  }  
Magic Number,Mono.Cecil,BaseAssemblyResolver,F:\newReposMay17\jbevain_cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetCorlib,The following statement contains a magic number: if (version.MajorRevision == 3300)  	path = Path.Combine (path' "v1.0.3705");  else  	path = Path.Combine (path' "v1.0.5000.0");  
Magic Number,Mono.Cecil,BaseAssemblyResolver,F:\newReposMay17\jbevain_cecil\Mono.Cecil\BaseAssemblyResolver.cs,GetAssemblyInNetGac,The following statement contains a magic number: for (int i = 0; i < 2; i++) {  	for (int j = 0; j < gacs.Length; j++) {  		var gac = Path.Combine (gac_paths [i]' gacs [j]);  		var file = GetAssemblyFile (reference' prefixes [i]' gac);  		if (Directory.Exists (gac) && File.Exists (file))  			return GetAssembly (file' parameters);  	}  }  
Magic Number,Mono.Cecil,MetadataSystem,F:\newReposMay17\jbevain_cecil\Mono.Cecil\MetadataSystem.cs,InitializePrimitives,The following statement contains a magic number: primitive_value_types = new Dictionary<string' Row<ElementType' bool>> (18' StringComparer.Ordinal) {  	{  		"Void"'  		new Row<ElementType' bool> (ElementType.Void' false)  	}'  	{  		"Boolean"'  		new Row<ElementType' bool> (ElementType.Boolean' true)  	}'  	{  		"Char"'  		new Row<ElementType' bool> (ElementType.Char' true)  	}'  	{  		"SByte"'  		new Row<ElementType' bool> (ElementType.I1' true)  	}'  	{  		"Byte"'  		new Row<ElementType' bool> (ElementType.U1' true)  	}'  	{  		"Int16"'  		new Row<ElementType' bool> (ElementType.I2' true)  	}'  	{  		"UInt16"'  		new Row<ElementType' bool> (ElementType.U2' true)  	}'  	{  		"Int32"'  		new Row<ElementType' bool> (ElementType.I4' true)  	}'  	{  		"UInt32"'  		new Row<ElementType' bool> (ElementType.U4' true)  	}'  	{  		"Int64"'  		new Row<ElementType' bool> (ElementType.I8' true)  	}'  	{  		"UInt64"'  		new Row<ElementType' bool> (ElementType.U8' true)  	}'  	{  		"Single"'  		new Row<ElementType' bool> (ElementType.R4' true)  	}'  	{  		"Double"'  		new Row<ElementType' bool> (ElementType.R8' true)  	}'  	{  		"String"'  		new Row<ElementType' bool> (ElementType.String' false)  	}'  	{  		"TypedReference"'  		new Row<ElementType' bool> (ElementType.TypedByRef' false)  	}'  	{  		"IntPtr"'  		new Row<ElementType' bool> (ElementType.I' true)  	}'  	{  		"UIntPtr"'  		new Row<ElementType' bool> (ElementType.U' true)  	}'  	{  		"Object"'  		new Row<ElementType' bool> (ElementType.Object' false)  	}'  };  
Magic Number,Mono.Cecil,MetadataSystem,F:\newReposMay17\jbevain_cecil\Mono.Cecil\MetadataSystem.cs,BinaryRangeSearch,The following statement contains a magic number: while (min <= max) {  	int mid = min + ((max - min) / 2);  	var type = types [mid];  	var range = field ? type.fields_range : type.methods_range;  	if (rid < range.Start)  		max = mid - 1;  	else if (rid >= range.Start + range.Length)  		min = mid + 1;  	else  		return type;  }  
Magic Number,Mono.Cecil,ModuleDefinition,F:\newReposMay17\jbevain_cecil\Mono.Cecil\ModuleDefinition.cs,CreateAssemblyName,The following statement contains a magic number: if (name.EndsWith (".dll") || name.EndsWith (".exe"))  	name = name.Substring (0' name.Length - 4);  
Magic Number,Mono.Cecil,ModuleDefinition,F:\newReposMay17\jbevain_cecil\Mono.Cecil\ModuleDefinition.cs,CreateAssemblyName,The following statement contains a magic number: name = name.Substring (0' name.Length - 4);  
Magic Number,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,ReadMethodBody,The following statement contains a magic number: switch (flags & 0x3) {  case 0x2:  	// tiny  	body.code_size = flags >> 2;  	body.MaxStackSize = 8;  	ReadCode ();  	break;  case 0x3:  	// fat  	Advance (-1);  	ReadFatMethod ();  	break;  default:  	throw new InvalidOperationException ();  }  
Magic Number,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,ReadMethodBody,The following statement contains a magic number: switch (flags & 0x3) {  case 0x2:  	// tiny  	body.code_size = flags >> 2;  	body.MaxStackSize = 8;  	ReadCode ();  	break;  case 0x3:  	// fat  	Advance (-1);  	ReadFatMethod ();  	break;  default:  	throw new InvalidOperationException ();  }  
Magic Number,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,ReadMethodBody,The following statement contains a magic number: body.code_size = flags >> 2;  
Magic Number,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,ReadMethodBody,The following statement contains a magic number: body.MaxStackSize = 8;  
Magic Number,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,ReadOperand,The following statement contains a magic number: switch (instruction.opcode.OperandType) {  case OperandType.InlineSwitch:  	var length = ReadInt32 ();  	var base_offset = Offset + (4 * length);  	var branches = new int[length];  	for (int i = 0; i < length; i++)  		branches [i] = base_offset + ReadInt32 ();  	return branches;  case OperandType.ShortInlineBrTarget:  	return ReadSByte () + Offset;  case OperandType.InlineBrTarget:  	return ReadInt32 () + Offset;  case OperandType.ShortInlineI:  	if (instruction.opcode == OpCodes.Ldc_I4_S)  		return ReadSByte ();  	return ReadByte ();  case OperandType.InlineI:  	return ReadInt32 ();  case OperandType.ShortInlineR:  	return ReadSingle ();  case OperandType.InlineR:  	return ReadDouble ();  case OperandType.InlineI8:  	return ReadInt64 ();  case OperandType.ShortInlineVar:  	return GetVariable (ReadByte ());  case OperandType.InlineVar:  	return GetVariable (ReadUInt16 ());  case OperandType.ShortInlineArg:  	return GetParameter (ReadByte ());  case OperandType.InlineArg:  	return GetParameter (ReadUInt16 ());  case OperandType.InlineSig:  	return GetCallSite (ReadToken ());  case OperandType.InlineString:  	return GetString (ReadToken ());  case OperandType.InlineTok:  case OperandType.InlineType:  case OperandType.InlineMethod:  case OperandType.InlineField:  	return reader.LookupToken (ReadToken ());  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,GetInstruction,The following statement contains a magic number: while (min <= max) {  	int mid = min + ((max - min) / 2);  	var instruction = items [mid];  	var instruction_offset = instruction.offset;  	if (offset == instruction_offset)  		return instruction;  	if (offset < instruction_offset)  		max = mid - 1;  	else  		min = mid + 1;  }  
Magic Number,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,ReadSection,The following statement contains a magic number: Align (4);  
Magic Number,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,ReadSmallSection,The following statement contains a magic number: Advance (2);  
Magic Number,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,ReadExceptionHandlerSpecific,The following statement contains a magic number: switch (handler.HandlerType) {  case ExceptionHandlerType.Catch:  	handler.CatchType = (TypeReference)reader.LookupToken (ReadToken ());  	break;  case ExceptionHandlerType.Filter:  	handler.FilterStart = GetInstruction (ReadInt32 ());  	break;  default:  	Advance (4);  	break;  }  
Magic Number,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,ReadExceptionHandlerSpecific,The following statement contains a magic number: Advance (4);  
Magic Number,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawMethodBody,The following statement contains a magic number: switch (flags & 0x3) {  case 0x2:  	// tiny  	buffer.WriteByte (flags);  	local_var_token = MetadataToken.Zero;  	code_size = flags >> 2;  	PatchRawCode (buffer' code_size' writer);  	break;  case 0x3:  	// fat  	Advance (-1);  	PatchRawFatMethod (buffer' writer' out code_size' out local_var_token);  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawMethodBody,The following statement contains a magic number: code_size = flags >> 2;  
Magic Number,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: while (buffer.position < end) {  	OpCode opcode;  	var il_opcode = buffer.ReadByte ();  	if (il_opcode != 0xfe) {  		opcode = OpCodes.OneByteOpCode [il_opcode];  	} else {  		var il_opcode2 = buffer.ReadByte ();  		opcode = OpCodes.TwoBytesOpCode [il_opcode2];  	}  	switch (opcode.OperandType) {  	case OperandType.ShortInlineI:  	case OperandType.ShortInlineBrTarget:  	case OperandType.ShortInlineVar:  	case OperandType.ShortInlineArg:  		buffer.position += 1;  		break;  	case OperandType.InlineVar:  	case OperandType.InlineArg:  		buffer.position += 2;  		break;  	case OperandType.InlineBrTarget:  	case OperandType.ShortInlineR:  	case OperandType.InlineI:  		buffer.position += 4;  		break;  	case OperandType.InlineI8:  	case OperandType.InlineR:  		buffer.position += 8;  		break;  	case OperandType.InlineSwitch:  		var length = buffer.ReadInt32 ();  		buffer.position += length * 4;  		break;  	case OperandType.InlineString:  		var @string = GetString (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (new MetadataToken (TokenType.String' metadata.user_string_heap.GetStringIndex (@string)).ToUInt32 ());  		break;  	case OperandType.InlineSig:  		var call_site = GetCallSite (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (writer.GetStandAloneSignature (call_site).ToUInt32 ());  		break;  	case OperandType.InlineTok:  	case OperandType.InlineType:  	case OperandType.InlineMethod:  	case OperandType.InlineField:  		var provider = reader.LookupToken (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (metadata.LookupToken (provider).ToUInt32 ());  		break;  	}  }  
Magic Number,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: while (buffer.position < end) {  	OpCode opcode;  	var il_opcode = buffer.ReadByte ();  	if (il_opcode != 0xfe) {  		opcode = OpCodes.OneByteOpCode [il_opcode];  	} else {  		var il_opcode2 = buffer.ReadByte ();  		opcode = OpCodes.TwoBytesOpCode [il_opcode2];  	}  	switch (opcode.OperandType) {  	case OperandType.ShortInlineI:  	case OperandType.ShortInlineBrTarget:  	case OperandType.ShortInlineVar:  	case OperandType.ShortInlineArg:  		buffer.position += 1;  		break;  	case OperandType.InlineVar:  	case OperandType.InlineArg:  		buffer.position += 2;  		break;  	case OperandType.InlineBrTarget:  	case OperandType.ShortInlineR:  	case OperandType.InlineI:  		buffer.position += 4;  		break;  	case OperandType.InlineI8:  	case OperandType.InlineR:  		buffer.position += 8;  		break;  	case OperandType.InlineSwitch:  		var length = buffer.ReadInt32 ();  		buffer.position += length * 4;  		break;  	case OperandType.InlineString:  		var @string = GetString (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (new MetadataToken (TokenType.String' metadata.user_string_heap.GetStringIndex (@string)).ToUInt32 ());  		break;  	case OperandType.InlineSig:  		var call_site = GetCallSite (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (writer.GetStandAloneSignature (call_site).ToUInt32 ());  		break;  	case OperandType.InlineTok:  	case OperandType.InlineType:  	case OperandType.InlineMethod:  	case OperandType.InlineField:  		var provider = reader.LookupToken (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (metadata.LookupToken (provider).ToUInt32 ());  		break;  	}  }  
Magic Number,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: while (buffer.position < end) {  	OpCode opcode;  	var il_opcode = buffer.ReadByte ();  	if (il_opcode != 0xfe) {  		opcode = OpCodes.OneByteOpCode [il_opcode];  	} else {  		var il_opcode2 = buffer.ReadByte ();  		opcode = OpCodes.TwoBytesOpCode [il_opcode2];  	}  	switch (opcode.OperandType) {  	case OperandType.ShortInlineI:  	case OperandType.ShortInlineBrTarget:  	case OperandType.ShortInlineVar:  	case OperandType.ShortInlineArg:  		buffer.position += 1;  		break;  	case OperandType.InlineVar:  	case OperandType.InlineArg:  		buffer.position += 2;  		break;  	case OperandType.InlineBrTarget:  	case OperandType.ShortInlineR:  	case OperandType.InlineI:  		buffer.position += 4;  		break;  	case OperandType.InlineI8:  	case OperandType.InlineR:  		buffer.position += 8;  		break;  	case OperandType.InlineSwitch:  		var length = buffer.ReadInt32 ();  		buffer.position += length * 4;  		break;  	case OperandType.InlineString:  		var @string = GetString (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (new MetadataToken (TokenType.String' metadata.user_string_heap.GetStringIndex (@string)).ToUInt32 ());  		break;  	case OperandType.InlineSig:  		var call_site = GetCallSite (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (writer.GetStandAloneSignature (call_site).ToUInt32 ());  		break;  	case OperandType.InlineTok:  	case OperandType.InlineType:  	case OperandType.InlineMethod:  	case OperandType.InlineField:  		var provider = reader.LookupToken (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (metadata.LookupToken (provider).ToUInt32 ());  		break;  	}  }  
Magic Number,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: while (buffer.position < end) {  	OpCode opcode;  	var il_opcode = buffer.ReadByte ();  	if (il_opcode != 0xfe) {  		opcode = OpCodes.OneByteOpCode [il_opcode];  	} else {  		var il_opcode2 = buffer.ReadByte ();  		opcode = OpCodes.TwoBytesOpCode [il_opcode2];  	}  	switch (opcode.OperandType) {  	case OperandType.ShortInlineI:  	case OperandType.ShortInlineBrTarget:  	case OperandType.ShortInlineVar:  	case OperandType.ShortInlineArg:  		buffer.position += 1;  		break;  	case OperandType.InlineVar:  	case OperandType.InlineArg:  		buffer.position += 2;  		break;  	case OperandType.InlineBrTarget:  	case OperandType.ShortInlineR:  	case OperandType.InlineI:  		buffer.position += 4;  		break;  	case OperandType.InlineI8:  	case OperandType.InlineR:  		buffer.position += 8;  		break;  	case OperandType.InlineSwitch:  		var length = buffer.ReadInt32 ();  		buffer.position += length * 4;  		break;  	case OperandType.InlineString:  		var @string = GetString (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (new MetadataToken (TokenType.String' metadata.user_string_heap.GetStringIndex (@string)).ToUInt32 ());  		break;  	case OperandType.InlineSig:  		var call_site = GetCallSite (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (writer.GetStandAloneSignature (call_site).ToUInt32 ());  		break;  	case OperandType.InlineTok:  	case OperandType.InlineType:  	case OperandType.InlineMethod:  	case OperandType.InlineField:  		var provider = reader.LookupToken (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (metadata.LookupToken (provider).ToUInt32 ());  		break;  	}  }  
Magic Number,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: while (buffer.position < end) {  	OpCode opcode;  	var il_opcode = buffer.ReadByte ();  	if (il_opcode != 0xfe) {  		opcode = OpCodes.OneByteOpCode [il_opcode];  	} else {  		var il_opcode2 = buffer.ReadByte ();  		opcode = OpCodes.TwoBytesOpCode [il_opcode2];  	}  	switch (opcode.OperandType) {  	case OperandType.ShortInlineI:  	case OperandType.ShortInlineBrTarget:  	case OperandType.ShortInlineVar:  	case OperandType.ShortInlineArg:  		buffer.position += 1;  		break;  	case OperandType.InlineVar:  	case OperandType.InlineArg:  		buffer.position += 2;  		break;  	case OperandType.InlineBrTarget:  	case OperandType.ShortInlineR:  	case OperandType.InlineI:  		buffer.position += 4;  		break;  	case OperandType.InlineI8:  	case OperandType.InlineR:  		buffer.position += 8;  		break;  	case OperandType.InlineSwitch:  		var length = buffer.ReadInt32 ();  		buffer.position += length * 4;  		break;  	case OperandType.InlineString:  		var @string = GetString (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (new MetadataToken (TokenType.String' metadata.user_string_heap.GetStringIndex (@string)).ToUInt32 ());  		break;  	case OperandType.InlineSig:  		var call_site = GetCallSite (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (writer.GetStandAloneSignature (call_site).ToUInt32 ());  		break;  	case OperandType.InlineTok:  	case OperandType.InlineType:  	case OperandType.InlineMethod:  	case OperandType.InlineField:  		var provider = reader.LookupToken (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (metadata.LookupToken (provider).ToUInt32 ());  		break;  	}  }  
Magic Number,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: while (buffer.position < end) {  	OpCode opcode;  	var il_opcode = buffer.ReadByte ();  	if (il_opcode != 0xfe) {  		opcode = OpCodes.OneByteOpCode [il_opcode];  	} else {  		var il_opcode2 = buffer.ReadByte ();  		opcode = OpCodes.TwoBytesOpCode [il_opcode2];  	}  	switch (opcode.OperandType) {  	case OperandType.ShortInlineI:  	case OperandType.ShortInlineBrTarget:  	case OperandType.ShortInlineVar:  	case OperandType.ShortInlineArg:  		buffer.position += 1;  		break;  	case OperandType.InlineVar:  	case OperandType.InlineArg:  		buffer.position += 2;  		break;  	case OperandType.InlineBrTarget:  	case OperandType.ShortInlineR:  	case OperandType.InlineI:  		buffer.position += 4;  		break;  	case OperandType.InlineI8:  	case OperandType.InlineR:  		buffer.position += 8;  		break;  	case OperandType.InlineSwitch:  		var length = buffer.ReadInt32 ();  		buffer.position += length * 4;  		break;  	case OperandType.InlineString:  		var @string = GetString (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (new MetadataToken (TokenType.String' metadata.user_string_heap.GetStringIndex (@string)).ToUInt32 ());  		break;  	case OperandType.InlineSig:  		var call_site = GetCallSite (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (writer.GetStandAloneSignature (call_site).ToUInt32 ());  		break;  	case OperandType.InlineTok:  	case OperandType.InlineType:  	case OperandType.InlineMethod:  	case OperandType.InlineField:  		var provider = reader.LookupToken (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (metadata.LookupToken (provider).ToUInt32 ());  		break;  	}  }  
Magic Number,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: while (buffer.position < end) {  	OpCode opcode;  	var il_opcode = buffer.ReadByte ();  	if (il_opcode != 0xfe) {  		opcode = OpCodes.OneByteOpCode [il_opcode];  	} else {  		var il_opcode2 = buffer.ReadByte ();  		opcode = OpCodes.TwoBytesOpCode [il_opcode2];  	}  	switch (opcode.OperandType) {  	case OperandType.ShortInlineI:  	case OperandType.ShortInlineBrTarget:  	case OperandType.ShortInlineVar:  	case OperandType.ShortInlineArg:  		buffer.position += 1;  		break;  	case OperandType.InlineVar:  	case OperandType.InlineArg:  		buffer.position += 2;  		break;  	case OperandType.InlineBrTarget:  	case OperandType.ShortInlineR:  	case OperandType.InlineI:  		buffer.position += 4;  		break;  	case OperandType.InlineI8:  	case OperandType.InlineR:  		buffer.position += 8;  		break;  	case OperandType.InlineSwitch:  		var length = buffer.ReadInt32 ();  		buffer.position += length * 4;  		break;  	case OperandType.InlineString:  		var @string = GetString (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (new MetadataToken (TokenType.String' metadata.user_string_heap.GetStringIndex (@string)).ToUInt32 ());  		break;  	case OperandType.InlineSig:  		var call_site = GetCallSite (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (writer.GetStandAloneSignature (call_site).ToUInt32 ());  		break;  	case OperandType.InlineTok:  	case OperandType.InlineType:  	case OperandType.InlineMethod:  	case OperandType.InlineField:  		var provider = reader.LookupToken (new MetadataToken (buffer.ReadUInt32 ()));  		buffer.position -= 4;  		buffer.WriteUInt32 (metadata.LookupToken (provider).ToUInt32 ());  		break;  	}  }  
Magic Number,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: switch (opcode.OperandType) {  case OperandType.ShortInlineI:  case OperandType.ShortInlineBrTarget:  case OperandType.ShortInlineVar:  case OperandType.ShortInlineArg:  	buffer.position += 1;  	break;  case OperandType.InlineVar:  case OperandType.InlineArg:  	buffer.position += 2;  	break;  case OperandType.InlineBrTarget:  case OperandType.ShortInlineR:  case OperandType.InlineI:  	buffer.position += 4;  	break;  case OperandType.InlineI8:  case OperandType.InlineR:  	buffer.position += 8;  	break;  case OperandType.InlineSwitch:  	var length = buffer.ReadInt32 ();  	buffer.position += length * 4;  	break;  case OperandType.InlineString:  	var @string = GetString (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (new MetadataToken (TokenType.String' metadata.user_string_heap.GetStringIndex (@string)).ToUInt32 ());  	break;  case OperandType.InlineSig:  	var call_site = GetCallSite (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (writer.GetStandAloneSignature (call_site).ToUInt32 ());  	break;  case OperandType.InlineTok:  case OperandType.InlineType:  case OperandType.InlineMethod:  case OperandType.InlineField:  	var provider = reader.LookupToken (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (metadata.LookupToken (provider).ToUInt32 ());  	break;  }  
Magic Number,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: switch (opcode.OperandType) {  case OperandType.ShortInlineI:  case OperandType.ShortInlineBrTarget:  case OperandType.ShortInlineVar:  case OperandType.ShortInlineArg:  	buffer.position += 1;  	break;  case OperandType.InlineVar:  case OperandType.InlineArg:  	buffer.position += 2;  	break;  case OperandType.InlineBrTarget:  case OperandType.ShortInlineR:  case OperandType.InlineI:  	buffer.position += 4;  	break;  case OperandType.InlineI8:  case OperandType.InlineR:  	buffer.position += 8;  	break;  case OperandType.InlineSwitch:  	var length = buffer.ReadInt32 ();  	buffer.position += length * 4;  	break;  case OperandType.InlineString:  	var @string = GetString (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (new MetadataToken (TokenType.String' metadata.user_string_heap.GetStringIndex (@string)).ToUInt32 ());  	break;  case OperandType.InlineSig:  	var call_site = GetCallSite (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (writer.GetStandAloneSignature (call_site).ToUInt32 ());  	break;  case OperandType.InlineTok:  case OperandType.InlineType:  case OperandType.InlineMethod:  case OperandType.InlineField:  	var provider = reader.LookupToken (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (metadata.LookupToken (provider).ToUInt32 ());  	break;  }  
Magic Number,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: switch (opcode.OperandType) {  case OperandType.ShortInlineI:  case OperandType.ShortInlineBrTarget:  case OperandType.ShortInlineVar:  case OperandType.ShortInlineArg:  	buffer.position += 1;  	break;  case OperandType.InlineVar:  case OperandType.InlineArg:  	buffer.position += 2;  	break;  case OperandType.InlineBrTarget:  case OperandType.ShortInlineR:  case OperandType.InlineI:  	buffer.position += 4;  	break;  case OperandType.InlineI8:  case OperandType.InlineR:  	buffer.position += 8;  	break;  case OperandType.InlineSwitch:  	var length = buffer.ReadInt32 ();  	buffer.position += length * 4;  	break;  case OperandType.InlineString:  	var @string = GetString (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (new MetadataToken (TokenType.String' metadata.user_string_heap.GetStringIndex (@string)).ToUInt32 ());  	break;  case OperandType.InlineSig:  	var call_site = GetCallSite (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (writer.GetStandAloneSignature (call_site).ToUInt32 ());  	break;  case OperandType.InlineTok:  case OperandType.InlineType:  case OperandType.InlineMethod:  case OperandType.InlineField:  	var provider = reader.LookupToken (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (metadata.LookupToken (provider).ToUInt32 ());  	break;  }  
Magic Number,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: switch (opcode.OperandType) {  case OperandType.ShortInlineI:  case OperandType.ShortInlineBrTarget:  case OperandType.ShortInlineVar:  case OperandType.ShortInlineArg:  	buffer.position += 1;  	break;  case OperandType.InlineVar:  case OperandType.InlineArg:  	buffer.position += 2;  	break;  case OperandType.InlineBrTarget:  case OperandType.ShortInlineR:  case OperandType.InlineI:  	buffer.position += 4;  	break;  case OperandType.InlineI8:  case OperandType.InlineR:  	buffer.position += 8;  	break;  case OperandType.InlineSwitch:  	var length = buffer.ReadInt32 ();  	buffer.position += length * 4;  	break;  case OperandType.InlineString:  	var @string = GetString (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (new MetadataToken (TokenType.String' metadata.user_string_heap.GetStringIndex (@string)).ToUInt32 ());  	break;  case OperandType.InlineSig:  	var call_site = GetCallSite (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (writer.GetStandAloneSignature (call_site).ToUInt32 ());  	break;  case OperandType.InlineTok:  case OperandType.InlineType:  case OperandType.InlineMethod:  case OperandType.InlineField:  	var provider = reader.LookupToken (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (metadata.LookupToken (provider).ToUInt32 ());  	break;  }  
Magic Number,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: switch (opcode.OperandType) {  case OperandType.ShortInlineI:  case OperandType.ShortInlineBrTarget:  case OperandType.ShortInlineVar:  case OperandType.ShortInlineArg:  	buffer.position += 1;  	break;  case OperandType.InlineVar:  case OperandType.InlineArg:  	buffer.position += 2;  	break;  case OperandType.InlineBrTarget:  case OperandType.ShortInlineR:  case OperandType.InlineI:  	buffer.position += 4;  	break;  case OperandType.InlineI8:  case OperandType.InlineR:  	buffer.position += 8;  	break;  case OperandType.InlineSwitch:  	var length = buffer.ReadInt32 ();  	buffer.position += length * 4;  	break;  case OperandType.InlineString:  	var @string = GetString (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (new MetadataToken (TokenType.String' metadata.user_string_heap.GetStringIndex (@string)).ToUInt32 ());  	break;  case OperandType.InlineSig:  	var call_site = GetCallSite (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (writer.GetStandAloneSignature (call_site).ToUInt32 ());  	break;  case OperandType.InlineTok:  case OperandType.InlineType:  case OperandType.InlineMethod:  case OperandType.InlineField:  	var provider = reader.LookupToken (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (metadata.LookupToken (provider).ToUInt32 ());  	break;  }  
Magic Number,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: switch (opcode.OperandType) {  case OperandType.ShortInlineI:  case OperandType.ShortInlineBrTarget:  case OperandType.ShortInlineVar:  case OperandType.ShortInlineArg:  	buffer.position += 1;  	break;  case OperandType.InlineVar:  case OperandType.InlineArg:  	buffer.position += 2;  	break;  case OperandType.InlineBrTarget:  case OperandType.ShortInlineR:  case OperandType.InlineI:  	buffer.position += 4;  	break;  case OperandType.InlineI8:  case OperandType.InlineR:  	buffer.position += 8;  	break;  case OperandType.InlineSwitch:  	var length = buffer.ReadInt32 ();  	buffer.position += length * 4;  	break;  case OperandType.InlineString:  	var @string = GetString (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (new MetadataToken (TokenType.String' metadata.user_string_heap.GetStringIndex (@string)).ToUInt32 ());  	break;  case OperandType.InlineSig:  	var call_site = GetCallSite (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (writer.GetStandAloneSignature (call_site).ToUInt32 ());  	break;  case OperandType.InlineTok:  case OperandType.InlineType:  case OperandType.InlineMethod:  case OperandType.InlineField:  	var provider = reader.LookupToken (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (metadata.LookupToken (provider).ToUInt32 ());  	break;  }  
Magic Number,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: switch (opcode.OperandType) {  case OperandType.ShortInlineI:  case OperandType.ShortInlineBrTarget:  case OperandType.ShortInlineVar:  case OperandType.ShortInlineArg:  	buffer.position += 1;  	break;  case OperandType.InlineVar:  case OperandType.InlineArg:  	buffer.position += 2;  	break;  case OperandType.InlineBrTarget:  case OperandType.ShortInlineR:  case OperandType.InlineI:  	buffer.position += 4;  	break;  case OperandType.InlineI8:  case OperandType.InlineR:  	buffer.position += 8;  	break;  case OperandType.InlineSwitch:  	var length = buffer.ReadInt32 ();  	buffer.position += length * 4;  	break;  case OperandType.InlineString:  	var @string = GetString (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (new MetadataToken (TokenType.String' metadata.user_string_heap.GetStringIndex (@string)).ToUInt32 ());  	break;  case OperandType.InlineSig:  	var call_site = GetCallSite (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (writer.GetStandAloneSignature (call_site).ToUInt32 ());  	break;  case OperandType.InlineTok:  case OperandType.InlineType:  case OperandType.InlineMethod:  case OperandType.InlineField:  	var provider = reader.LookupToken (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (metadata.LookupToken (provider).ToUInt32 ());  	break;  }  
Magic Number,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: buffer.position += 2;  
Magic Number,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: buffer.position += 4;  
Magic Number,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: buffer.position += 8;  
Magic Number,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: buffer.position += length * 4;  
Magic Number,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: buffer.position -= 4;  
Magic Number,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: buffer.position -= 4;  
Magic Number,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following statement contains a magic number: buffer.position -= 4;  
Magic Number,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawSection,The following statement contains a magic number: Align (4);  
Magic Number,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawSmallSection,The following statement contains a magic number: Advance (2);  
Magic Number,Mono.Cecil.Cil,CodeWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeWriter.cs,WriteUnresolvedMethodBody,The following statement contains a magic number: if (fat_header)  	Align (4);  
Magic Number,Mono.Cecil.Cil,CodeWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeWriter.cs,WriteUnresolvedMethodBody,The following statement contains a magic number: Align (4);  
Magic Number,Mono.Cecil.Cil,CodeWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeWriter.cs,WriteResolvedMethodBody,The following statement contains a magic number: if (RequiresFatHeader ()) {  	Align (4);  	rva = BeginMethod ();  	WriteFatHeader ();  	WriteInstructions ();  	if (body.HasExceptionHandlers)  		WriteExceptionHandlers ();  } else {  	rva = BeginMethod ();  	WriteByte ((byte)(0x2 | (body.CodeSize << 2)));  	// tiny  	WriteInstructions ();  	var start_position = (int)(rva - code_base);  	var body_size = position - start_position;  	var body_bytes = new byte[body_size];  	Array.Copy (buffer' start_position' body_bytes' 0' body_size);  	if (GetOrMapTinyMethodBody (new ByteBuffer (body_bytes)' ref rva))  		position = start_position;  }  
Magic Number,Mono.Cecil.Cil,CodeWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeWriter.cs,WriteResolvedMethodBody,The following statement contains a magic number: if (RequiresFatHeader ()) {  	Align (4);  	rva = BeginMethod ();  	WriteFatHeader ();  	WriteInstructions ();  	if (body.HasExceptionHandlers)  		WriteExceptionHandlers ();  } else {  	rva = BeginMethod ();  	WriteByte ((byte)(0x2 | (body.CodeSize << 2)));  	// tiny  	WriteInstructions ();  	var start_position = (int)(rva - code_base);  	var body_size = position - start_position;  	var body_bytes = new byte[body_size];  	Array.Copy (buffer' start_position' body_bytes' 0' body_size);  	if (GetOrMapTinyMethodBody (new ByteBuffer (body_bytes)' ref rva))  		position = start_position;  }  
Magic Number,Mono.Cecil.Cil,CodeWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeWriter.cs,WriteResolvedMethodBody,The following statement contains a magic number: Align (4);  
Magic Number,Mono.Cecil.Cil,CodeWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeWriter.cs,WriteResolvedMethodBody,The following statement contains a magic number: WriteByte ((byte)(0x2 | (body.CodeSize << 2)));  
Magic Number,Mono.Cecil.Cil,CodeWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeWriter.cs,WriteOperand,The following statement contains a magic number: switch (operand_type) {  case OperandType.InlineSwitch: {  	var targets = (Instruction[])operand;  	WriteInt32 (targets.Length);  	var diff = instruction.Offset + opcode.Size + (4 * (targets.Length + 1));  	for (int i = 0; i < targets.Length; i++)  		WriteInt32 (GetTargetOffset (targets [i]) - diff);  	break;  }  case OperandType.ShortInlineBrTarget: {  	var target = (Instruction)operand;  	var offset = target != null ? GetTargetOffset (target) : body.code_size;  	WriteSByte ((sbyte)(offset - (instruction.Offset + opcode.Size + 1)));  	break;  }  case OperandType.InlineBrTarget: {  	var target = (Instruction)operand;  	var offset = target != null ? GetTargetOffset (target) : body.code_size;  	WriteInt32 (offset - (instruction.Offset + opcode.Size + 4));  	break;  }  case OperandType.ShortInlineVar:  	WriteByte ((byte)GetVariableIndex ((VariableDefinition)operand));  	break;  case OperandType.ShortInlineArg:  	WriteByte ((byte)GetParameterIndex ((ParameterDefinition)operand));  	break;  case OperandType.InlineVar:  	WriteInt16 ((short)GetVariableIndex ((VariableDefinition)operand));  	break;  case OperandType.InlineArg:  	WriteInt16 ((short)GetParameterIndex ((ParameterDefinition)operand));  	break;  case OperandType.InlineSig:  	WriteMetadataToken (GetStandAloneSignature ((CallSite)operand));  	break;  case OperandType.ShortInlineI:  	if (opcode == OpCodes.Ldc_I4_S)  		WriteSByte ((sbyte)operand);  	else  		WriteByte ((byte)operand);  	break;  case OperandType.InlineI:  	WriteInt32 ((int)operand);  	break;  case OperandType.InlineI8:  	WriteInt64 ((long)operand);  	break;  case OperandType.ShortInlineR:  	WriteSingle ((float)operand);  	break;  case OperandType.InlineR:  	WriteDouble ((double)operand);  	break;  case OperandType.InlineString:  	WriteMetadataToken (new MetadataToken (TokenType.String' GetUserStringIndex ((string)operand)));  	break;  case OperandType.InlineType:  case OperandType.InlineField:  case OperandType.InlineMethod:  case OperandType.InlineTok:  	WriteMetadataToken (metadata.LookupToken ((IMetadataTokenProvider)operand));  	break;  default:  	throw new ArgumentException ();  }  
Magic Number,Mono.Cecil.Cil,CodeWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeWriter.cs,WriteOperand,The following statement contains a magic number: switch (operand_type) {  case OperandType.InlineSwitch: {  	var targets = (Instruction[])operand;  	WriteInt32 (targets.Length);  	var diff = instruction.Offset + opcode.Size + (4 * (targets.Length + 1));  	for (int i = 0; i < targets.Length; i++)  		WriteInt32 (GetTargetOffset (targets [i]) - diff);  	break;  }  case OperandType.ShortInlineBrTarget: {  	var target = (Instruction)operand;  	var offset = target != null ? GetTargetOffset (target) : body.code_size;  	WriteSByte ((sbyte)(offset - (instruction.Offset + opcode.Size + 1)));  	break;  }  case OperandType.InlineBrTarget: {  	var target = (Instruction)operand;  	var offset = target != null ? GetTargetOffset (target) : body.code_size;  	WriteInt32 (offset - (instruction.Offset + opcode.Size + 4));  	break;  }  case OperandType.ShortInlineVar:  	WriteByte ((byte)GetVariableIndex ((VariableDefinition)operand));  	break;  case OperandType.ShortInlineArg:  	WriteByte ((byte)GetParameterIndex ((ParameterDefinition)operand));  	break;  case OperandType.InlineVar:  	WriteInt16 ((short)GetVariableIndex ((VariableDefinition)operand));  	break;  case OperandType.InlineArg:  	WriteInt16 ((short)GetParameterIndex ((ParameterDefinition)operand));  	break;  case OperandType.InlineSig:  	WriteMetadataToken (GetStandAloneSignature ((CallSite)operand));  	break;  case OperandType.ShortInlineI:  	if (opcode == OpCodes.Ldc_I4_S)  		WriteSByte ((sbyte)operand);  	else  		WriteByte ((byte)operand);  	break;  case OperandType.InlineI:  	WriteInt32 ((int)operand);  	break;  case OperandType.InlineI8:  	WriteInt64 ((long)operand);  	break;  case OperandType.ShortInlineR:  	WriteSingle ((float)operand);  	break;  case OperandType.InlineR:  	WriteDouble ((double)operand);  	break;  case OperandType.InlineString:  	WriteMetadataToken (new MetadataToken (TokenType.String' GetUserStringIndex ((string)operand)));  	break;  case OperandType.InlineType:  case OperandType.InlineField:  case OperandType.InlineMethod:  case OperandType.InlineTok:  	WriteMetadataToken (metadata.LookupToken ((IMetadataTokenProvider)operand));  	break;  default:  	throw new ArgumentException ();  }  
Magic Number,Mono.Cecil.Cil,CodeWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeWriter.cs,WriteOperand,The following statement contains a magic number: WriteInt32 (offset - (instruction.Offset + opcode.Size + 4));  
Magic Number,Mono.Cecil.Cil,CodeWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeWriter.cs,RequiresFatHeader,The following statement contains a magic number: return body.CodeSize >= 64 || body.InitLocals || body.HasVariables || body.HasExceptionHandlers || body.MaxStackSize > 8;  
Magic Number,Mono.Cecil.Cil,CodeWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeWriter.cs,RequiresFatHeader,The following statement contains a magic number: return body.CodeSize >= 64 || body.InitLocals || body.HasVariables || body.HasExceptionHandlers || body.MaxStackSize > 8;  
Magic Number,Mono.Cecil.Cil,CodeWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeWriter.cs,ComputePopDelta,The following statement contains a magic number: switch (pop_behavior) {  case StackBehaviour.Popi:  case StackBehaviour.Popref:  case StackBehaviour.Pop1:  	stack_size--;  	break;  case StackBehaviour.Pop1_pop1:  case StackBehaviour.Popi_pop1:  case StackBehaviour.Popi_popi:  case StackBehaviour.Popi_popi8:  case StackBehaviour.Popi_popr4:  case StackBehaviour.Popi_popr8:  case StackBehaviour.Popref_pop1:  case StackBehaviour.Popref_popi:  	stack_size -= 2;  	break;  case StackBehaviour.Popi_popi_popi:  case StackBehaviour.Popref_popi_popi:  case StackBehaviour.Popref_popi_popi8:  case StackBehaviour.Popref_popi_popr4:  case StackBehaviour.Popref_popi_popr8:  case StackBehaviour.Popref_popi_popref:  	stack_size -= 3;  	break;  case StackBehaviour.PopAll:  	stack_size = 0;  	break;  }  
Magic Number,Mono.Cecil.Cil,CodeWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeWriter.cs,ComputePopDelta,The following statement contains a magic number: switch (pop_behavior) {  case StackBehaviour.Popi:  case StackBehaviour.Popref:  case StackBehaviour.Pop1:  	stack_size--;  	break;  case StackBehaviour.Pop1_pop1:  case StackBehaviour.Popi_pop1:  case StackBehaviour.Popi_popi:  case StackBehaviour.Popi_popi8:  case StackBehaviour.Popi_popr4:  case StackBehaviour.Popi_popr8:  case StackBehaviour.Popref_pop1:  case StackBehaviour.Popref_popi:  	stack_size -= 2;  	break;  case StackBehaviour.Popi_popi_popi:  case StackBehaviour.Popref_popi_popi:  case StackBehaviour.Popref_popi_popi8:  case StackBehaviour.Popref_popi_popr4:  case StackBehaviour.Popref_popi_popr8:  case StackBehaviour.Popref_popi_popref:  	stack_size -= 3;  	break;  case StackBehaviour.PopAll:  	stack_size = 0;  	break;  }  
Magic Number,Mono.Cecil.Cil,CodeWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeWriter.cs,ComputePopDelta,The following statement contains a magic number: stack_size -= 2;  
Magic Number,Mono.Cecil.Cil,CodeWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeWriter.cs,ComputePopDelta,The following statement contains a magic number: stack_size -= 3;  
Magic Number,Mono.Cecil.Cil,CodeWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeWriter.cs,ComputePushDelta,The following statement contains a magic number: switch (push_behaviour) {  case StackBehaviour.Push1:  case StackBehaviour.Pushi:  case StackBehaviour.Pushi8:  case StackBehaviour.Pushr4:  case StackBehaviour.Pushr8:  case StackBehaviour.Pushref:  	stack_size++;  	break;  case StackBehaviour.Push1_push1:  	stack_size += 2;  	break;  }  
Magic Number,Mono.Cecil.Cil,CodeWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeWriter.cs,ComputePushDelta,The following statement contains a magic number: stack_size += 2;  
Magic Number,Mono.Cecil.Cil,CodeWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeWriter.cs,WriteExceptionHandlers,The following statement contains a magic number: Align (4);  
Magic Number,Mono.Cecil.Cil,CodeWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeWriter.cs,IsFatRange,The following statement contains a magic number: return end.Offset - start.Offset > 255 || start.Offset > 65535;  
Magic Number,Mono.Cecil.Cil,CodeWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeWriter.cs,IsFatRange,The following statement contains a magic number: return end.Offset - start.Offset > 255 || start.Offset > 65535;  
Magic Number,Mono.Cecil.Cil,CodeWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeWriter.cs,WriteSmallSection,The following statement contains a magic number: WriteByte ((byte)(handlers.Count * 12 + 4));  
Magic Number,Mono.Cecil.Cil,CodeWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeWriter.cs,WriteSmallSection,The following statement contains a magic number: WriteByte ((byte)(handlers.Count * 12 + 4));  
Magic Number,Mono.Cecil.Cil,CodeWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeWriter.cs,WriteSmallSection,The following statement contains a magic number: WriteBytes (2);  
Magic Number,Mono.Cecil.Cil,CodeWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeWriter.cs,WriteFatSection,The following statement contains a magic number: WriteByte ((byte)((size >> 8) & 0xff));  
Magic Number,Mono.Cecil.Cil,CodeWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeWriter.cs,WriteFatSection,The following statement contains a magic number: WriteByte ((byte)((size >> 16) & 0xff));  
Magic Number,Mono.Cecil.Cil,Instruction,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\Instruction.cs,GetSize,The following statement contains a magic number: switch (opcode.OperandType) {  case OperandType.InlineSwitch:  	return size + (1 + ((Instruction[])operand).Length) * 4;  case OperandType.InlineI8:  case OperandType.InlineR:  	return size + 8;  case OperandType.InlineBrTarget:  case OperandType.InlineField:  case OperandType.InlineI:  case OperandType.InlineMethod:  case OperandType.InlineString:  case OperandType.InlineTok:  case OperandType.InlineType:  case OperandType.ShortInlineR:  case OperandType.InlineSig:  	return size + 4;  case OperandType.InlineArg:  case OperandType.InlineVar:  	return size + 2;  case OperandType.ShortInlineBrTarget:  case OperandType.ShortInlineI:  case OperandType.ShortInlineArg:  case OperandType.ShortInlineVar:  	return size + 1;  default:  	return size;  }  
Magic Number,Mono.Cecil.Cil,Instruction,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\Instruction.cs,GetSize,The following statement contains a magic number: switch (opcode.OperandType) {  case OperandType.InlineSwitch:  	return size + (1 + ((Instruction[])operand).Length) * 4;  case OperandType.InlineI8:  case OperandType.InlineR:  	return size + 8;  case OperandType.InlineBrTarget:  case OperandType.InlineField:  case OperandType.InlineI:  case OperandType.InlineMethod:  case OperandType.InlineString:  case OperandType.InlineTok:  case OperandType.InlineType:  case OperandType.ShortInlineR:  case OperandType.InlineSig:  	return size + 4;  case OperandType.InlineArg:  case OperandType.InlineVar:  	return size + 2;  case OperandType.ShortInlineBrTarget:  case OperandType.ShortInlineI:  case OperandType.ShortInlineArg:  case OperandType.ShortInlineVar:  	return size + 1;  default:  	return size;  }  
Magic Number,Mono.Cecil.Cil,Instruction,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\Instruction.cs,GetSize,The following statement contains a magic number: switch (opcode.OperandType) {  case OperandType.InlineSwitch:  	return size + (1 + ((Instruction[])operand).Length) * 4;  case OperandType.InlineI8:  case OperandType.InlineR:  	return size + 8;  case OperandType.InlineBrTarget:  case OperandType.InlineField:  case OperandType.InlineI:  case OperandType.InlineMethod:  case OperandType.InlineString:  case OperandType.InlineTok:  case OperandType.InlineType:  case OperandType.ShortInlineR:  case OperandType.InlineSig:  	return size + 4;  case OperandType.InlineArg:  case OperandType.InlineVar:  	return size + 2;  case OperandType.ShortInlineBrTarget:  case OperandType.ShortInlineI:  case OperandType.ShortInlineArg:  case OperandType.ShortInlineVar:  	return size + 1;  default:  	return size;  }  
Magic Number,Mono.Cecil.Cil,Instruction,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\Instruction.cs,GetSize,The following statement contains a magic number: switch (opcode.OperandType) {  case OperandType.InlineSwitch:  	return size + (1 + ((Instruction[])operand).Length) * 4;  case OperandType.InlineI8:  case OperandType.InlineR:  	return size + 8;  case OperandType.InlineBrTarget:  case OperandType.InlineField:  case OperandType.InlineI:  case OperandType.InlineMethod:  case OperandType.InlineString:  case OperandType.InlineTok:  case OperandType.InlineType:  case OperandType.ShortInlineR:  case OperandType.InlineSig:  	return size + 4;  case OperandType.InlineArg:  case OperandType.InlineVar:  	return size + 2;  case OperandType.ShortInlineBrTarget:  case OperandType.ShortInlineI:  case OperandType.ShortInlineArg:  case OperandType.ShortInlineVar:  	return size + 1;  default:  	return size;  }  
Magic Number,Mono.Cecil.Cil,Instruction,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\Instruction.cs,GetSize,The following statement contains a magic number: return size + (1 + ((Instruction[])operand).Length) * 4;  
Magic Number,Mono.Cecil.Cil,Instruction,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\Instruction.cs,GetSize,The following statement contains a magic number: return size + 8;  
Magic Number,Mono.Cecil.Cil,Instruction,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\Instruction.cs,GetSize,The following statement contains a magic number: return size + 4;  
Magic Number,Mono.Cecil.Cil,Instruction,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\Instruction.cs,GetSize,The following statement contains a magic number: return size + 2;  
Magic Number,Mono.Cecil.Cil,OpCode,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\OpCode.cs,OpCode,The following statement contains a magic number: this.op2 = (byte)((x >> 8) & 0xff);  
Magic Number,Mono.Cecil.Cil,OpCode,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\OpCode.cs,OpCode,The following statement contains a magic number: this.code = (byte)((x >> 16) & 0xff);  
Magic Number,Mono.Cecil.Cil,OpCode,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\OpCode.cs,OpCode,The following statement contains a magic number: this.flow_control = (byte)((x >> 24) & 0xff);  
Magic Number,Mono.Cecil.Cil,OpCode,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\OpCode.cs,OpCode,The following statement contains a magic number: this.operand_type = (byte)((y >> 8) & 0xff);  
Magic Number,Mono.Cecil.Cil,OpCode,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\OpCode.cs,OpCode,The following statement contains a magic number: this.stack_behavior_pop = (byte)((y >> 16) & 0xff);  
Magic Number,Mono.Cecil.Cil,OpCode,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\OpCode.cs,OpCode,The following statement contains a magic number: this.stack_behavior_push = (byte)((y >> 24) & 0xff);  
Magic Number,Mono.Cecil.Cil,OpCodeNames,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\OpCode.cs,OpCodeNames,The following statement contains a magic number: names = new string[219];  
Magic Number,Mono.Cecil.Cil,PortablePdbReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\PortablePdb.cs,ProcessDebugHeader,The following statement contains a magic number: if (data.Length < 24)  	return false;  
Magic Number,Mono.Cecil.Cil,PortablePdbReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\PortablePdb.cs,ProcessDebugHeader,The following statement contains a magic number: Buffer.BlockCopy (data' 4' buffer' 0' 16);  
Magic Number,Mono.Cecil.Cil,PortablePdbReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\PortablePdb.cs,ProcessDebugHeader,The following statement contains a magic number: Buffer.BlockCopy (data' 4' buffer' 0' 16);  
Magic Number,Mono.Cecil.Cil,PortablePdbReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\PortablePdb.cs,ProcessDebugHeader,The following statement contains a magic number: Buffer.BlockCopy (image.PdbHeap.Id' 0' buffer' 0' 16);  
Magic Number,Mono.Cecil.Cil,PortablePdbReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\PortablePdb.cs,ReadInt32,The following statement contains a magic number: return (bytes [start] | (bytes [start + 1] << 8) | (bytes [start + 2] << 16) | (bytes [start + 3] << 24));  
Magic Number,Mono.Cecil.Cil,PortablePdbReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\PortablePdb.cs,ReadInt32,The following statement contains a magic number: return (bytes [start] | (bytes [start + 1] << 8) | (bytes [start + 2] << 16) | (bytes [start + 3] << 24));  
Magic Number,Mono.Cecil.Cil,PortablePdbReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\PortablePdb.cs,ReadInt32,The following statement contains a magic number: return (bytes [start] | (bytes [start + 1] << 8) | (bytes [start + 2] << 16) | (bytes [start + 3] << 24));  
Magic Number,Mono.Cecil.Cil,PortablePdbReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\PortablePdb.cs,ReadInt32,The following statement contains a magic number: return (bytes [start] | (bytes [start + 1] << 8) | (bytes [start + 2] << 16) | (bytes [start + 3] << 24));  
Magic Number,Mono.Cecil.Cil,PortablePdbReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\PortablePdb.cs,ReadInt32,The following statement contains a magic number: return (bytes [start] | (bytes [start + 1] << 8) | (bytes [start + 2] << 16) | (bytes [start + 3] << 24));  
Magic Number,Mono.Cecil.Metadata,TableHeapBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Metadata\Buffers.cs,WriteBySize,The following statement contains a magic number: if (size == 4)  	WriteUInt32 (value);  else  	WriteUInt16 ((ushort)value);  
Magic Number,Mono.Cecil.Metadata,TableHeapBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Metadata\Buffers.cs,WriteTableHeap,The following statement contains a magic number: WriteByte (10);  
Magic Number,Mono.Cecil.Metadata,TableHeapBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Metadata\Buffers.cs,GetTableHeapVersion,The following statement contains a magic number: switch (module.Runtime) {  case TargetRuntime.Net_1_0:  case TargetRuntime.Net_1_1:  	return 1;  default:  	return 2;  }  
Magic Number,Mono.Cecil.Metadata,TableHeapBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Metadata\Buffers.cs,GetTableHeapVersion,The following statement contains a magic number: return 2;  
Magic Number,Mono.Cecil.Metadata,TableHeapBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Metadata\Buffers.cs,FixupData,The following statement contains a magic number: for (int i = 0; i < table.length; i++) {  	var rva = ReadUInt32 ();  	base.position -= 4;  	WriteUInt32 (rva + data_rva);  	base.position += field_idx_size;  }  
Magic Number,Mono.Cecil.Metadata,TableHeapBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Metadata\Buffers.cs,FixupData,The following statement contains a magic number: base.position -= 4;  
Magic Number,Mono.Cecil.Metadata,UserStringHeapBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Metadata\Buffers.cs,WriteString,The following statement contains a magic number: WriteCompressedUInt32 ((uint)@string.Length * 2 + 1);  
Magic Number,Mono.Cecil.Metadata,UserStringHeap,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Metadata\UserStringHeap.cs,ReadStringAt,The following statement contains a magic number: for (int i = start' j = 0; i < start + length; i += 2)  	chars [j++] = (char)(data [i] | (data [i + 1] << 8));  
Magic Number,Mono.Cecil.Metadata,UserStringHeap,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Metadata\UserStringHeap.cs,ReadStringAt,The following statement contains a magic number: for (int i = start' j = 0; i < start + length; i += 2)  	chars [j++] = (char)(data [i] | (data [i + 1] << 8));  
Magic Number,Mono.Cecil.Metadata,UserStringHeap,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Metadata\UserStringHeap.cs,ReadStringAt,The following statement contains a magic number: i += 2
Magic Number,Mono.Cecil.Metadata,UserStringHeap,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Metadata\UserStringHeap.cs,ReadStringAt,The following statement contains a magic number: chars [j++] = (char)(data [i] | (data [i + 1] << 8));  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,ReadUInt16,The following statement contains a magic number: position += 2;  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,ReadUInt32,The following statement contains a magic number: position += 4;  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,ReadUInt64,The following statement contains a magic number: return (((ulong)high) << 32) | low;  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((first & 0x40) == 0)  	return ((uint)(first & ~0x80) << 8) | ReadByte ();  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,ReadCompressedUInt32,The following statement contains a magic number: return ((uint)(first & ~0x80) << 8) | ReadByte ();  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,ReadCompressedUInt32,The following statement contains a magic number: return ((uint)(first & ~0xc0) << 24) | (uint)ReadByte () << 16 | (uint)ReadByte () << 8 | ReadByte ();  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,ReadCompressedUInt32,The following statement contains a magic number: return ((uint)(first & ~0xc0) << 24) | (uint)ReadByte () << 16 | (uint)ReadByte () << 8 | ReadByte ();  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,ReadCompressedUInt32,The following statement contains a magic number: return ((uint)(first & ~0xc0) << 24) | (uint)ReadByte () << 16 | (uint)ReadByte () << 8 | ReadByte ();  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,ReadSingle,The following statement contains a magic number: if (!BitConverter.IsLittleEndian) {  	var bytes = ReadBytes (4);  	Array.Reverse (bytes);  	return BitConverter.ToSingle (bytes' 0);  }  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,ReadSingle,The following statement contains a magic number: position += 4;  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,ReadDouble,The following statement contains a magic number: if (!BitConverter.IsLittleEndian) {  	var bytes = ReadBytes (8);  	Array.Reverse (bytes);  	return BitConverter.ToDouble (bytes' 0);  }  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,ReadDouble,The following statement contains a magic number: position += 8;  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteUInt16,The following statement contains a magic number: if (position + 2 > buffer.Length)  	Grow (2);  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteUInt16,The following statement contains a magic number: if (position + 2 > buffer.Length)  	Grow (2);  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteUInt16,The following statement contains a magic number: Grow (2);  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteUInt16,The following statement contains a magic number: buffer [position++] = (byte)(value >> 8);  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteUInt32,The following statement contains a magic number: if (position + 4 > buffer.Length)  	Grow (4);  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteUInt32,The following statement contains a magic number: if (position + 4 > buffer.Length)  	Grow (4);  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteUInt32,The following statement contains a magic number: Grow (4);  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteUInt32,The following statement contains a magic number: buffer [position++] = (byte)(value >> 8);  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteUInt32,The following statement contains a magic number: buffer [position++] = (byte)(value >> 16);  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteUInt32,The following statement contains a magic number: buffer [position++] = (byte)(value >> 24);  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteUInt64,The following statement contains a magic number: if (position + 8 > buffer.Length)  	Grow (8);  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteUInt64,The following statement contains a magic number: if (position + 8 > buffer.Length)  	Grow (8);  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteUInt64,The following statement contains a magic number: Grow (8);  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteUInt64,The following statement contains a magic number: buffer [position++] = (byte)(value >> 8);  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteUInt64,The following statement contains a magic number: buffer [position++] = (byte)(value >> 16);  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteUInt64,The following statement contains a magic number: buffer [position++] = (byte)(value >> 24);  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteUInt64,The following statement contains a magic number: buffer [position++] = (byte)(value >> 32);  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteUInt64,The following statement contains a magic number: buffer [position++] = (byte)(value >> 40);  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteUInt64,The following statement contains a magic number: buffer [position++] = (byte)(value >> 48);  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteUInt64,The following statement contains a magic number: buffer [position++] = (byte)(value >> 56);  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteCompressedUInt32,The following statement contains a magic number: if (value < 0x80)  	WriteByte ((byte)value);  else if (value < 0x4000) {  	WriteByte ((byte)(0x80 | (value >> 8)));  	WriteByte ((byte)(value & 0xff));  } else {  	WriteByte ((byte)((value >> 24) | 0xc0));  	WriteByte ((byte)((value >> 16) & 0xff));  	WriteByte ((byte)((value >> 8) & 0xff));  	WriteByte ((byte)(value & 0xff));  }  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteCompressedUInt32,The following statement contains a magic number: if (value < 0x80)  	WriteByte ((byte)value);  else if (value < 0x4000) {  	WriteByte ((byte)(0x80 | (value >> 8)));  	WriteByte ((byte)(value & 0xff));  } else {  	WriteByte ((byte)((value >> 24) | 0xc0));  	WriteByte ((byte)((value >> 16) & 0xff));  	WriteByte ((byte)((value >> 8) & 0xff));  	WriteByte ((byte)(value & 0xff));  }  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteCompressedUInt32,The following statement contains a magic number: if (value < 0x80)  	WriteByte ((byte)value);  else if (value < 0x4000) {  	WriteByte ((byte)(0x80 | (value >> 8)));  	WriteByte ((byte)(value & 0xff));  } else {  	WriteByte ((byte)((value >> 24) | 0xc0));  	WriteByte ((byte)((value >> 16) & 0xff));  	WriteByte ((byte)((value >> 8) & 0xff));  	WriteByte ((byte)(value & 0xff));  }  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteCompressedUInt32,The following statement contains a magic number: if (value < 0x80)  	WriteByte ((byte)value);  else if (value < 0x4000) {  	WriteByte ((byte)(0x80 | (value >> 8)));  	WriteByte ((byte)(value & 0xff));  } else {  	WriteByte ((byte)((value >> 24) | 0xc0));  	WriteByte ((byte)((value >> 16) & 0xff));  	WriteByte ((byte)((value >> 8) & 0xff));  	WriteByte ((byte)(value & 0xff));  }  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteCompressedUInt32,The following statement contains a magic number: if (value < 0x4000) {  	WriteByte ((byte)(0x80 | (value >> 8)));  	WriteByte ((byte)(value & 0xff));  } else {  	WriteByte ((byte)((value >> 24) | 0xc0));  	WriteByte ((byte)((value >> 16) & 0xff));  	WriteByte ((byte)((value >> 8) & 0xff));  	WriteByte ((byte)(value & 0xff));  }  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteCompressedUInt32,The following statement contains a magic number: if (value < 0x4000) {  	WriteByte ((byte)(0x80 | (value >> 8)));  	WriteByte ((byte)(value & 0xff));  } else {  	WriteByte ((byte)((value >> 24) | 0xc0));  	WriteByte ((byte)((value >> 16) & 0xff));  	WriteByte ((byte)((value >> 8) & 0xff));  	WriteByte ((byte)(value & 0xff));  }  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteCompressedUInt32,The following statement contains a magic number: if (value < 0x4000) {  	WriteByte ((byte)(0x80 | (value >> 8)));  	WriteByte ((byte)(value & 0xff));  } else {  	WriteByte ((byte)((value >> 24) | 0xc0));  	WriteByte ((byte)((value >> 16) & 0xff));  	WriteByte ((byte)((value >> 8) & 0xff));  	WriteByte ((byte)(value & 0xff));  }  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteCompressedUInt32,The following statement contains a magic number: if (value < 0x4000) {  	WriteByte ((byte)(0x80 | (value >> 8)));  	WriteByte ((byte)(value & 0xff));  } else {  	WriteByte ((byte)((value >> 24) | 0xc0));  	WriteByte ((byte)((value >> 16) & 0xff));  	WriteByte ((byte)((value >> 8) & 0xff));  	WriteByte ((byte)(value & 0xff));  }  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteCompressedUInt32,The following statement contains a magic number: WriteByte ((byte)(0x80 | (value >> 8)));  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteCompressedUInt32,The following statement contains a magic number: WriteByte ((byte)((value >> 24) | 0xc0));  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteCompressedUInt32,The following statement contains a magic number: WriteByte ((byte)((value >> 16) & 0xff));  
Magic Number,Mono.Cecil.PE,ByteBuffer,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ByteBuffer.cs,WriteCompressedUInt32,The following statement contains a magic number: WriteByte ((byte)((value >> 8) & 0xff));  
Magic Number,Mono.Cecil.PE,Image,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\Image.cs,GetTableIndexSize,The following statement contains a magic number: return GetTableLength (table) < 65536 ? 2 : 4;  
Magic Number,Mono.Cecil.PE,Image,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\Image.cs,GetTableIndexSize,The following statement contains a magic number: return GetTableLength (table) < 65536 ? 2 : 4;  
Magic Number,Mono.Cecil.PE,Image,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\Image.cs,GetTableIndexSize,The following statement contains a magic number: return GetTableLength (table) < 65536 ? 2 : 4;  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ReadImage,The following statement contains a magic number: if (BaseStream.Length < 128)  	throw new BadImageFormatException ();  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ReadImage,The following statement contains a magic number: Advance (58);  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ReadImage,The following statement contains a magic number: Advance (10);  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ReadOptionalHeaders,The following statement contains a magic number: Advance (66);  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ReadOptionalHeaders,The following statement contains a magic number: Advance (pe64 ? 88 : 72);  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ReadOptionalHeaders,The following statement contains a magic number: Advance (pe64 ? 88 : 72);  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ReadOptionalHeaders,The following statement contains a magic number: Advance (56);  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ReadOptionalHeaders,The following statement contains a magic number: Advance (8);  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ReadAlignedString,The following statement contains a magic number: Advance (-1 + ((read + 4) & ~3) - read);  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ReadAlignedString,The following statement contains a magic number: Advance (-1 + ((read + 4) & ~3) - read);  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ReadSections,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	var section = new Section ();  	// Name  	section.Name = ReadZeroTerminatedString (8);  	// VirtualSize		4  	Advance (4);  	// VirtualAddress	4  	section.VirtualAddress = ReadUInt32 ();  	// SizeOfRawData	4  	section.SizeOfRawData = ReadUInt32 ();  	// PointerToRawData	4  	section.PointerToRawData = ReadUInt32 ();  	// PointerToRelocations		4  	// PointerToLineNumbers		4  	// NumberOfRelocations		2  	// NumberOfLineNumbers		2  	// Characteristics			4  	Advance (16);  	sections [i] = section;  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ReadSections,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	var section = new Section ();  	// Name  	section.Name = ReadZeroTerminatedString (8);  	// VirtualSize		4  	Advance (4);  	// VirtualAddress	4  	section.VirtualAddress = ReadUInt32 ();  	// SizeOfRawData	4  	section.SizeOfRawData = ReadUInt32 ();  	// PointerToRawData	4  	section.PointerToRawData = ReadUInt32 ();  	// PointerToRelocations		4  	// PointerToLineNumbers		4  	// NumberOfRelocations		2  	// NumberOfLineNumbers		2  	// Characteristics			4  	Advance (16);  	sections [i] = section;  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ReadSections,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	var section = new Section ();  	// Name  	section.Name = ReadZeroTerminatedString (8);  	// VirtualSize		4  	Advance (4);  	// VirtualAddress	4  	section.VirtualAddress = ReadUInt32 ();  	// SizeOfRawData	4  	section.SizeOfRawData = ReadUInt32 ();  	// PointerToRawData	4  	section.PointerToRawData = ReadUInt32 ();  	// PointerToRelocations		4  	// PointerToLineNumbers		4  	// NumberOfRelocations		2  	// NumberOfLineNumbers		2  	// Characteristics			4  	Advance (16);  	sections [i] = section;  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ReadSections,The following statement contains a magic number: section.Name = ReadZeroTerminatedString (8);  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ReadSections,The following statement contains a magic number: Advance (4);  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ReadSections,The following statement contains a magic number: Advance (16);  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ReadCLIHeader,The following statement contains a magic number: Advance (8);  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ReadMetadata,The following statement contains a magic number: Advance (8);  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ReadMetadata,The following statement contains a magic number: Advance (2);  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ReadTableHeap,The following statement contains a magic number: Advance (6);  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,SetIndexSize,The following statement contains a magic number: heap.IndexSize = (sizes & flag) > 0 ? 4 : 2;  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,SetIndexSize,The following statement contains a magic number: heap.IndexSize = (sizes & flag) > 0 ? 4 : 2;  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < Mixin.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (guididx_size * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  		size = 8;  		break;  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	case Table.Document:  		size = blobidx_size // Name  		+ guididx_size // HashAlgorithm  		+ blobidx_size // Hash  		+ guididx_size;  		// Language  		break;  	case Table.MethodDebugInformation:  		size = GetTableIndexSize (Table.Document) // Document  		+ blobidx_size;  		// SequencePoints  		break;  	case Table.LocalScope:  		size = GetTableIndexSize (Table.Method) // Method  		+ GetTableIndexSize (Table.ImportScope) // ImportScope  		+ GetTableIndexSize (Table.LocalVariable) // VariableList  		+ GetTableIndexSize (Table.LocalConstant) // ConstantList  		+ 4 * 2;  		// StartOffset' Length  		break;  	case Table.LocalVariable:  		size = 2 // Attributes  		+ 2 // Index  		+ stridx_size;  		// Name  		break;  	case Table.LocalConstant:  		size = stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.ImportScope:  		size = GetTableIndexSize (Table.ImportScope) // Parent  		+ blobidx_size;  		break;  	case Table.StateMachineMethod:  		size = GetTableIndexSize (Table.Method) // MoveNextMethod  		+ GetTableIndexSize (Table.Method);  		// KickOffMethod  		break;  	case Table.CustomDebugInformation:  		size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  		+ guididx_size // Kind  		+ blobidx_size;  		// Value  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < Mixin.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (guididx_size * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  		size = 8;  		break;  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	case Table.Document:  		size = blobidx_size // Name  		+ guididx_size // HashAlgorithm  		+ blobidx_size // Hash  		+ guididx_size;  		// Language  		break;  	case Table.MethodDebugInformation:  		size = GetTableIndexSize (Table.Document) // Document  		+ blobidx_size;  		// SequencePoints  		break;  	case Table.LocalScope:  		size = GetTableIndexSize (Table.Method) // Method  		+ GetTableIndexSize (Table.ImportScope) // ImportScope  		+ GetTableIndexSize (Table.LocalVariable) // VariableList  		+ GetTableIndexSize (Table.LocalConstant) // ConstantList  		+ 4 * 2;  		// StartOffset' Length  		break;  	case Table.LocalVariable:  		size = 2 // Attributes  		+ 2 // Index  		+ stridx_size;  		// Name  		break;  	case Table.LocalConstant:  		size = stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.ImportScope:  		size = GetTableIndexSize (Table.ImportScope) // Parent  		+ blobidx_size;  		break;  	case Table.StateMachineMethod:  		size = GetTableIndexSize (Table.Method) // MoveNextMethod  		+ GetTableIndexSize (Table.Method);  		// KickOffMethod  		break;  	case Table.CustomDebugInformation:  		size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  		+ guididx_size // Kind  		+ blobidx_size;  		// Value  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < Mixin.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (guididx_size * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  		size = 8;  		break;  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	case Table.Document:  		size = blobidx_size // Name  		+ guididx_size // HashAlgorithm  		+ blobidx_size // Hash  		+ guididx_size;  		// Language  		break;  	case Table.MethodDebugInformation:  		size = GetTableIndexSize (Table.Document) // Document  		+ blobidx_size;  		// SequencePoints  		break;  	case Table.LocalScope:  		size = GetTableIndexSize (Table.Method) // Method  		+ GetTableIndexSize (Table.ImportScope) // ImportScope  		+ GetTableIndexSize (Table.LocalVariable) // VariableList  		+ GetTableIndexSize (Table.LocalConstant) // ConstantList  		+ 4 * 2;  		// StartOffset' Length  		break;  	case Table.LocalVariable:  		size = 2 // Attributes  		+ 2 // Index  		+ stridx_size;  		// Name  		break;  	case Table.LocalConstant:  		size = stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.ImportScope:  		size = GetTableIndexSize (Table.ImportScope) // Parent  		+ blobidx_size;  		break;  	case Table.StateMachineMethod:  		size = GetTableIndexSize (Table.Method) // MoveNextMethod  		+ GetTableIndexSize (Table.Method);  		// KickOffMethod  		break;  	case Table.CustomDebugInformation:  		size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  		+ guididx_size // Kind  		+ blobidx_size;  		// Value  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < Mixin.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (guididx_size * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  		size = 8;  		break;  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	case Table.Document:  		size = blobidx_size // Name  		+ guididx_size // HashAlgorithm  		+ blobidx_size // Hash  		+ guididx_size;  		// Language  		break;  	case Table.MethodDebugInformation:  		size = GetTableIndexSize (Table.Document) // Document  		+ blobidx_size;  		// SequencePoints  		break;  	case Table.LocalScope:  		size = GetTableIndexSize (Table.Method) // Method  		+ GetTableIndexSize (Table.ImportScope) // ImportScope  		+ GetTableIndexSize (Table.LocalVariable) // VariableList  		+ GetTableIndexSize (Table.LocalConstant) // ConstantList  		+ 4 * 2;  		// StartOffset' Length  		break;  	case Table.LocalVariable:  		size = 2 // Attributes  		+ 2 // Index  		+ stridx_size;  		// Name  		break;  	case Table.LocalConstant:  		size = stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.ImportScope:  		size = GetTableIndexSize (Table.ImportScope) // Parent  		+ blobidx_size;  		break;  	case Table.StateMachineMethod:  		size = GetTableIndexSize (Table.Method) // MoveNextMethod  		+ GetTableIndexSize (Table.Method);  		// KickOffMethod  		break;  	case Table.CustomDebugInformation:  		size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  		+ guididx_size // Kind  		+ blobidx_size;  		// Value  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < Mixin.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (guididx_size * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  		size = 8;  		break;  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	case Table.Document:  		size = blobidx_size // Name  		+ guididx_size // HashAlgorithm  		+ blobidx_size // Hash  		+ guididx_size;  		// Language  		break;  	case Table.MethodDebugInformation:  		size = GetTableIndexSize (Table.Document) // Document  		+ blobidx_size;  		// SequencePoints  		break;  	case Table.LocalScope:  		size = GetTableIndexSize (Table.Method) // Method  		+ GetTableIndexSize (Table.ImportScope) // ImportScope  		+ GetTableIndexSize (Table.LocalVariable) // VariableList  		+ GetTableIndexSize (Table.LocalConstant) // ConstantList  		+ 4 * 2;  		// StartOffset' Length  		break;  	case Table.LocalVariable:  		size = 2 // Attributes  		+ 2 // Index  		+ stridx_size;  		// Name  		break;  	case Table.LocalConstant:  		size = stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.ImportScope:  		size = GetTableIndexSize (Table.ImportScope) // Parent  		+ blobidx_size;  		break;  	case Table.StateMachineMethod:  		size = GetTableIndexSize (Table.Method) // MoveNextMethod  		+ GetTableIndexSize (Table.Method);  		// KickOffMethod  		break;  	case Table.CustomDebugInformation:  		size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  		+ guididx_size // Kind  		+ blobidx_size;  		// Value  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < Mixin.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (guididx_size * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  		size = 8;  		break;  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	case Table.Document:  		size = blobidx_size // Name  		+ guididx_size // HashAlgorithm  		+ blobidx_size // Hash  		+ guididx_size;  		// Language  		break;  	case Table.MethodDebugInformation:  		size = GetTableIndexSize (Table.Document) // Document  		+ blobidx_size;  		// SequencePoints  		break;  	case Table.LocalScope:  		size = GetTableIndexSize (Table.Method) // Method  		+ GetTableIndexSize (Table.ImportScope) // ImportScope  		+ GetTableIndexSize (Table.LocalVariable) // VariableList  		+ GetTableIndexSize (Table.LocalConstant) // ConstantList  		+ 4 * 2;  		// StartOffset' Length  		break;  	case Table.LocalVariable:  		size = 2 // Attributes  		+ 2 // Index  		+ stridx_size;  		// Name  		break;  	case Table.LocalConstant:  		size = stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.ImportScope:  		size = GetTableIndexSize (Table.ImportScope) // Parent  		+ blobidx_size;  		break;  	case Table.StateMachineMethod:  		size = GetTableIndexSize (Table.Method) // MoveNextMethod  		+ GetTableIndexSize (Table.Method);  		// KickOffMethod  		break;  	case Table.CustomDebugInformation:  		size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  		+ guididx_size // Kind  		+ blobidx_size;  		// Value  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < Mixin.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (guididx_size * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  		size = 8;  		break;  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	case Table.Document:  		size = blobidx_size // Name  		+ guididx_size // HashAlgorithm  		+ blobidx_size // Hash  		+ guididx_size;  		// Language  		break;  	case Table.MethodDebugInformation:  		size = GetTableIndexSize (Table.Document) // Document  		+ blobidx_size;  		// SequencePoints  		break;  	case Table.LocalScope:  		size = GetTableIndexSize (Table.Method) // Method  		+ GetTableIndexSize (Table.ImportScope) // ImportScope  		+ GetTableIndexSize (Table.LocalVariable) // VariableList  		+ GetTableIndexSize (Table.LocalConstant) // ConstantList  		+ 4 * 2;  		// StartOffset' Length  		break;  	case Table.LocalVariable:  		size = 2 // Attributes  		+ 2 // Index  		+ stridx_size;  		// Name  		break;  	case Table.LocalConstant:  		size = stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.ImportScope:  		size = GetTableIndexSize (Table.ImportScope) // Parent  		+ blobidx_size;  		break;  	case Table.StateMachineMethod:  		size = GetTableIndexSize (Table.Method) // MoveNextMethod  		+ GetTableIndexSize (Table.Method);  		// KickOffMethod  		break;  	case Table.CustomDebugInformation:  		size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  		+ guididx_size // Kind  		+ blobidx_size;  		// Value  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < Mixin.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (guididx_size * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  		size = 8;  		break;  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	case Table.Document:  		size = blobidx_size // Name  		+ guididx_size // HashAlgorithm  		+ blobidx_size // Hash  		+ guididx_size;  		// Language  		break;  	case Table.MethodDebugInformation:  		size = GetTableIndexSize (Table.Document) // Document  		+ blobidx_size;  		// SequencePoints  		break;  	case Table.LocalScope:  		size = GetTableIndexSize (Table.Method) // Method  		+ GetTableIndexSize (Table.ImportScope) // ImportScope  		+ GetTableIndexSize (Table.LocalVariable) // VariableList  		+ GetTableIndexSize (Table.LocalConstant) // ConstantList  		+ 4 * 2;  		// StartOffset' Length  		break;  	case Table.LocalVariable:  		size = 2 // Attributes  		+ 2 // Index  		+ stridx_size;  		// Name  		break;  	case Table.LocalConstant:  		size = stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.ImportScope:  		size = GetTableIndexSize (Table.ImportScope) // Parent  		+ blobidx_size;  		break;  	case Table.StateMachineMethod:  		size = GetTableIndexSize (Table.Method) // MoveNextMethod  		+ GetTableIndexSize (Table.Method);  		// KickOffMethod  		break;  	case Table.CustomDebugInformation:  		size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  		+ guididx_size // Kind  		+ blobidx_size;  		// Value  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < Mixin.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (guididx_size * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  		size = 8;  		break;  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	case Table.Document:  		size = blobidx_size // Name  		+ guididx_size // HashAlgorithm  		+ blobidx_size // Hash  		+ guididx_size;  		// Language  		break;  	case Table.MethodDebugInformation:  		size = GetTableIndexSize (Table.Document) // Document  		+ blobidx_size;  		// SequencePoints  		break;  	case Table.LocalScope:  		size = GetTableIndexSize (Table.Method) // Method  		+ GetTableIndexSize (Table.ImportScope) // ImportScope  		+ GetTableIndexSize (Table.LocalVariable) // VariableList  		+ GetTableIndexSize (Table.LocalConstant) // ConstantList  		+ 4 * 2;  		// StartOffset' Length  		break;  	case Table.LocalVariable:  		size = 2 // Attributes  		+ 2 // Index  		+ stridx_size;  		// Name  		break;  	case Table.LocalConstant:  		size = stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.ImportScope:  		size = GetTableIndexSize (Table.ImportScope) // Parent  		+ blobidx_size;  		break;  	case Table.StateMachineMethod:  		size = GetTableIndexSize (Table.Method) // MoveNextMethod  		+ GetTableIndexSize (Table.Method);  		// KickOffMethod  		break;  	case Table.CustomDebugInformation:  		size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  		+ guididx_size // Kind  		+ blobidx_size;  		// Value  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < Mixin.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (guididx_size * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  		size = 8;  		break;  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	case Table.Document:  		size = blobidx_size // Name  		+ guididx_size // HashAlgorithm  		+ blobidx_size // Hash  		+ guididx_size;  		// Language  		break;  	case Table.MethodDebugInformation:  		size = GetTableIndexSize (Table.Document) // Document  		+ blobidx_size;  		// SequencePoints  		break;  	case Table.LocalScope:  		size = GetTableIndexSize (Table.Method) // Method  		+ GetTableIndexSize (Table.ImportScope) // ImportScope  		+ GetTableIndexSize (Table.LocalVariable) // VariableList  		+ GetTableIndexSize (Table.LocalConstant) // ConstantList  		+ 4 * 2;  		// StartOffset' Length  		break;  	case Table.LocalVariable:  		size = 2 // Attributes  		+ 2 // Index  		+ stridx_size;  		// Name  		break;  	case Table.LocalConstant:  		size = stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.ImportScope:  		size = GetTableIndexSize (Table.ImportScope) // Parent  		+ blobidx_size;  		break;  	case Table.StateMachineMethod:  		size = GetTableIndexSize (Table.Method) // MoveNextMethod  		+ GetTableIndexSize (Table.Method);  		// KickOffMethod  		break;  	case Table.CustomDebugInformation:  		size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  		+ guididx_size // Kind  		+ blobidx_size;  		// Value  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < Mixin.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (guididx_size * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  		size = 8;  		break;  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	case Table.Document:  		size = blobidx_size // Name  		+ guididx_size // HashAlgorithm  		+ blobidx_size // Hash  		+ guididx_size;  		// Language  		break;  	case Table.MethodDebugInformation:  		size = GetTableIndexSize (Table.Document) // Document  		+ blobidx_size;  		// SequencePoints  		break;  	case Table.LocalScope:  		size = GetTableIndexSize (Table.Method) // Method  		+ GetTableIndexSize (Table.ImportScope) // ImportScope  		+ GetTableIndexSize (Table.LocalVariable) // VariableList  		+ GetTableIndexSize (Table.LocalConstant) // ConstantList  		+ 4 * 2;  		// StartOffset' Length  		break;  	case Table.LocalVariable:  		size = 2 // Attributes  		+ 2 // Index  		+ stridx_size;  		// Name  		break;  	case Table.LocalConstant:  		size = stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.ImportScope:  		size = GetTableIndexSize (Table.ImportScope) // Parent  		+ blobidx_size;  		break;  	case Table.StateMachineMethod:  		size = GetTableIndexSize (Table.Method) // MoveNextMethod  		+ GetTableIndexSize (Table.Method);  		// KickOffMethod  		break;  	case Table.CustomDebugInformation:  		size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  		+ guididx_size // Kind  		+ blobidx_size;  		// Value  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < Mixin.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (guididx_size * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  		size = 8;  		break;  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	case Table.Document:  		size = blobidx_size // Name  		+ guididx_size // HashAlgorithm  		+ blobidx_size // Hash  		+ guididx_size;  		// Language  		break;  	case Table.MethodDebugInformation:  		size = GetTableIndexSize (Table.Document) // Document  		+ blobidx_size;  		// SequencePoints  		break;  	case Table.LocalScope:  		size = GetTableIndexSize (Table.Method) // Method  		+ GetTableIndexSize (Table.ImportScope) // ImportScope  		+ GetTableIndexSize (Table.LocalVariable) // VariableList  		+ GetTableIndexSize (Table.LocalConstant) // ConstantList  		+ 4 * 2;  		// StartOffset' Length  		break;  	case Table.LocalVariable:  		size = 2 // Attributes  		+ 2 // Index  		+ stridx_size;  		// Name  		break;  	case Table.LocalConstant:  		size = stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.ImportScope:  		size = GetTableIndexSize (Table.ImportScope) // Parent  		+ blobidx_size;  		break;  	case Table.StateMachineMethod:  		size = GetTableIndexSize (Table.Method) // MoveNextMethod  		+ GetTableIndexSize (Table.Method);  		// KickOffMethod  		break;  	case Table.CustomDebugInformation:  		size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  		+ guididx_size // Kind  		+ blobidx_size;  		// Value  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < Mixin.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (guididx_size * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  		size = 8;  		break;  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	case Table.Document:  		size = blobidx_size // Name  		+ guididx_size // HashAlgorithm  		+ blobidx_size // Hash  		+ guididx_size;  		// Language  		break;  	case Table.MethodDebugInformation:  		size = GetTableIndexSize (Table.Document) // Document  		+ blobidx_size;  		// SequencePoints  		break;  	case Table.LocalScope:  		size = GetTableIndexSize (Table.Method) // Method  		+ GetTableIndexSize (Table.ImportScope) // ImportScope  		+ GetTableIndexSize (Table.LocalVariable) // VariableList  		+ GetTableIndexSize (Table.LocalConstant) // ConstantList  		+ 4 * 2;  		// StartOffset' Length  		break;  	case Table.LocalVariable:  		size = 2 // Attributes  		+ 2 // Index  		+ stridx_size;  		// Name  		break;  	case Table.LocalConstant:  		size = stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.ImportScope:  		size = GetTableIndexSize (Table.ImportScope) // Parent  		+ blobidx_size;  		break;  	case Table.StateMachineMethod:  		size = GetTableIndexSize (Table.Method) // MoveNextMethod  		+ GetTableIndexSize (Table.Method);  		// KickOffMethod  		break;  	case Table.CustomDebugInformation:  		size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  		+ guididx_size // Kind  		+ blobidx_size;  		// Value  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < Mixin.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (guididx_size * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  		size = 8;  		break;  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	case Table.Document:  		size = blobidx_size // Name  		+ guididx_size // HashAlgorithm  		+ blobidx_size // Hash  		+ guididx_size;  		// Language  		break;  	case Table.MethodDebugInformation:  		size = GetTableIndexSize (Table.Document) // Document  		+ blobidx_size;  		// SequencePoints  		break;  	case Table.LocalScope:  		size = GetTableIndexSize (Table.Method) // Method  		+ GetTableIndexSize (Table.ImportScope) // ImportScope  		+ GetTableIndexSize (Table.LocalVariable) // VariableList  		+ GetTableIndexSize (Table.LocalConstant) // ConstantList  		+ 4 * 2;  		// StartOffset' Length  		break;  	case Table.LocalVariable:  		size = 2 // Attributes  		+ 2 // Index  		+ stridx_size;  		// Name  		break;  	case Table.LocalConstant:  		size = stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.ImportScope:  		size = GetTableIndexSize (Table.ImportScope) // Parent  		+ blobidx_size;  		break;  	case Table.StateMachineMethod:  		size = GetTableIndexSize (Table.Method) // MoveNextMethod  		+ GetTableIndexSize (Table.Method);  		// KickOffMethod  		break;  	case Table.CustomDebugInformation:  		size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  		+ guididx_size // Kind  		+ blobidx_size;  		// Value  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < Mixin.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (guididx_size * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  		size = 8;  		break;  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	case Table.Document:  		size = blobidx_size // Name  		+ guididx_size // HashAlgorithm  		+ blobidx_size // Hash  		+ guididx_size;  		// Language  		break;  	case Table.MethodDebugInformation:  		size = GetTableIndexSize (Table.Document) // Document  		+ blobidx_size;  		// SequencePoints  		break;  	case Table.LocalScope:  		size = GetTableIndexSize (Table.Method) // Method  		+ GetTableIndexSize (Table.ImportScope) // ImportScope  		+ GetTableIndexSize (Table.LocalVariable) // VariableList  		+ GetTableIndexSize (Table.LocalConstant) // ConstantList  		+ 4 * 2;  		// StartOffset' Length  		break;  	case Table.LocalVariable:  		size = 2 // Attributes  		+ 2 // Index  		+ stridx_size;  		// Name  		break;  	case Table.LocalConstant:  		size = stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.ImportScope:  		size = GetTableIndexSize (Table.ImportScope) // Parent  		+ blobidx_size;  		break;  	case Table.StateMachineMethod:  		size = GetTableIndexSize (Table.Method) // MoveNextMethod  		+ GetTableIndexSize (Table.Method);  		// KickOffMethod  		break;  	case Table.CustomDebugInformation:  		size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  		+ guididx_size // Kind  		+ blobidx_size;  		// Value  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < Mixin.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (guididx_size * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  		size = 8;  		break;  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	case Table.Document:  		size = blobidx_size // Name  		+ guididx_size // HashAlgorithm  		+ blobidx_size // Hash  		+ guididx_size;  		// Language  		break;  	case Table.MethodDebugInformation:  		size = GetTableIndexSize (Table.Document) // Document  		+ blobidx_size;  		// SequencePoints  		break;  	case Table.LocalScope:  		size = GetTableIndexSize (Table.Method) // Method  		+ GetTableIndexSize (Table.ImportScope) // ImportScope  		+ GetTableIndexSize (Table.LocalVariable) // VariableList  		+ GetTableIndexSize (Table.LocalConstant) // ConstantList  		+ 4 * 2;  		// StartOffset' Length  		break;  	case Table.LocalVariable:  		size = 2 // Attributes  		+ 2 // Index  		+ stridx_size;  		// Name  		break;  	case Table.LocalConstant:  		size = stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.ImportScope:  		size = GetTableIndexSize (Table.ImportScope) // Parent  		+ blobidx_size;  		break;  	case Table.StateMachineMethod:  		size = GetTableIndexSize (Table.Method) // MoveNextMethod  		+ GetTableIndexSize (Table.Method);  		// KickOffMethod  		break;  	case Table.CustomDebugInformation:  		size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  		+ guididx_size // Kind  		+ blobidx_size;  		// Value  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < Mixin.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (guididx_size * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  		size = 8;  		break;  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	case Table.Document:  		size = blobidx_size // Name  		+ guididx_size // HashAlgorithm  		+ blobidx_size // Hash  		+ guididx_size;  		// Language  		break;  	case Table.MethodDebugInformation:  		size = GetTableIndexSize (Table.Document) // Document  		+ blobidx_size;  		// SequencePoints  		break;  	case Table.LocalScope:  		size = GetTableIndexSize (Table.Method) // Method  		+ GetTableIndexSize (Table.ImportScope) // ImportScope  		+ GetTableIndexSize (Table.LocalVariable) // VariableList  		+ GetTableIndexSize (Table.LocalConstant) // ConstantList  		+ 4 * 2;  		// StartOffset' Length  		break;  	case Table.LocalVariable:  		size = 2 // Attributes  		+ 2 // Index  		+ stridx_size;  		// Name  		break;  	case Table.LocalConstant:  		size = stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.ImportScope:  		size = GetTableIndexSize (Table.ImportScope) // Parent  		+ blobidx_size;  		break;  	case Table.StateMachineMethod:  		size = GetTableIndexSize (Table.Method) // MoveNextMethod  		+ GetTableIndexSize (Table.Method);  		// KickOffMethod  		break;  	case Table.CustomDebugInformation:  		size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  		+ guididx_size // Kind  		+ blobidx_size;  		// Value  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < Mixin.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (guididx_size * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  		size = 8;  		break;  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	case Table.Document:  		size = blobidx_size // Name  		+ guididx_size // HashAlgorithm  		+ blobidx_size // Hash  		+ guididx_size;  		// Language  		break;  	case Table.MethodDebugInformation:  		size = GetTableIndexSize (Table.Document) // Document  		+ blobidx_size;  		// SequencePoints  		break;  	case Table.LocalScope:  		size = GetTableIndexSize (Table.Method) // Method  		+ GetTableIndexSize (Table.ImportScope) // ImportScope  		+ GetTableIndexSize (Table.LocalVariable) // VariableList  		+ GetTableIndexSize (Table.LocalConstant) // ConstantList  		+ 4 * 2;  		// StartOffset' Length  		break;  	case Table.LocalVariable:  		size = 2 // Attributes  		+ 2 // Index  		+ stridx_size;  		// Name  		break;  	case Table.LocalConstant:  		size = stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.ImportScope:  		size = GetTableIndexSize (Table.ImportScope) // Parent  		+ blobidx_size;  		break;  	case Table.StateMachineMethod:  		size = GetTableIndexSize (Table.Method) // MoveNextMethod  		+ GetTableIndexSize (Table.Method);  		// KickOffMethod  		break;  	case Table.CustomDebugInformation:  		size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  		+ guididx_size // Kind  		+ blobidx_size;  		// Value  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < Mixin.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (guididx_size * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  		size = 8;  		break;  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	case Table.Document:  		size = blobidx_size // Name  		+ guididx_size // HashAlgorithm  		+ blobidx_size // Hash  		+ guididx_size;  		// Language  		break;  	case Table.MethodDebugInformation:  		size = GetTableIndexSize (Table.Document) // Document  		+ blobidx_size;  		// SequencePoints  		break;  	case Table.LocalScope:  		size = GetTableIndexSize (Table.Method) // Method  		+ GetTableIndexSize (Table.ImportScope) // ImportScope  		+ GetTableIndexSize (Table.LocalVariable) // VariableList  		+ GetTableIndexSize (Table.LocalConstant) // ConstantList  		+ 4 * 2;  		// StartOffset' Length  		break;  	case Table.LocalVariable:  		size = 2 // Attributes  		+ 2 // Index  		+ stridx_size;  		// Name  		break;  	case Table.LocalConstant:  		size = stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.ImportScope:  		size = GetTableIndexSize (Table.ImportScope) // Parent  		+ blobidx_size;  		break;  	case Table.StateMachineMethod:  		size = GetTableIndexSize (Table.Method) // MoveNextMethod  		+ GetTableIndexSize (Table.Method);  		// KickOffMethod  		break;  	case Table.CustomDebugInformation:  		size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  		+ guididx_size // Kind  		+ blobidx_size;  		// Value  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < Mixin.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (guididx_size * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  		size = 8;  		break;  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	case Table.Document:  		size = blobidx_size // Name  		+ guididx_size // HashAlgorithm  		+ blobidx_size // Hash  		+ guididx_size;  		// Language  		break;  	case Table.MethodDebugInformation:  		size = GetTableIndexSize (Table.Document) // Document  		+ blobidx_size;  		// SequencePoints  		break;  	case Table.LocalScope:  		size = GetTableIndexSize (Table.Method) // Method  		+ GetTableIndexSize (Table.ImportScope) // ImportScope  		+ GetTableIndexSize (Table.LocalVariable) // VariableList  		+ GetTableIndexSize (Table.LocalConstant) // ConstantList  		+ 4 * 2;  		// StartOffset' Length  		break;  	case Table.LocalVariable:  		size = 2 // Attributes  		+ 2 // Index  		+ stridx_size;  		// Name  		break;  	case Table.LocalConstant:  		size = stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.ImportScope:  		size = GetTableIndexSize (Table.ImportScope) // Parent  		+ blobidx_size;  		break;  	case Table.StateMachineMethod:  		size = GetTableIndexSize (Table.Method) // MoveNextMethod  		+ GetTableIndexSize (Table.Method);  		// KickOffMethod  		break;  	case Table.CustomDebugInformation:  		size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  		+ guididx_size // Kind  		+ blobidx_size;  		// Value  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < Mixin.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (guididx_size * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  		size = 8;  		break;  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	case Table.Document:  		size = blobidx_size // Name  		+ guididx_size // HashAlgorithm  		+ blobidx_size // Hash  		+ guididx_size;  		// Language  		break;  	case Table.MethodDebugInformation:  		size = GetTableIndexSize (Table.Document) // Document  		+ blobidx_size;  		// SequencePoints  		break;  	case Table.LocalScope:  		size = GetTableIndexSize (Table.Method) // Method  		+ GetTableIndexSize (Table.ImportScope) // ImportScope  		+ GetTableIndexSize (Table.LocalVariable) // VariableList  		+ GetTableIndexSize (Table.LocalConstant) // ConstantList  		+ 4 * 2;  		// StartOffset' Length  		break;  	case Table.LocalVariable:  		size = 2 // Attributes  		+ 2 // Index  		+ stridx_size;  		// Name  		break;  	case Table.LocalConstant:  		size = stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.ImportScope:  		size = GetTableIndexSize (Table.ImportScope) // Parent  		+ blobidx_size;  		break;  	case Table.StateMachineMethod:  		size = GetTableIndexSize (Table.Method) // MoveNextMethod  		+ GetTableIndexSize (Table.Method);  		// KickOffMethod  		break;  	case Table.CustomDebugInformation:  		size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  		+ guididx_size // Kind  		+ blobidx_size;  		// Value  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < Mixin.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (guididx_size * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  		size = 8;  		break;  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	case Table.Document:  		size = blobidx_size // Name  		+ guididx_size // HashAlgorithm  		+ blobidx_size // Hash  		+ guididx_size;  		// Language  		break;  	case Table.MethodDebugInformation:  		size = GetTableIndexSize (Table.Document) // Document  		+ blobidx_size;  		// SequencePoints  		break;  	case Table.LocalScope:  		size = GetTableIndexSize (Table.Method) // Method  		+ GetTableIndexSize (Table.ImportScope) // ImportScope  		+ GetTableIndexSize (Table.LocalVariable) // VariableList  		+ GetTableIndexSize (Table.LocalConstant) // ConstantList  		+ 4 * 2;  		// StartOffset' Length  		break;  	case Table.LocalVariable:  		size = 2 // Attributes  		+ 2 // Index  		+ stridx_size;  		// Name  		break;  	case Table.LocalConstant:  		size = stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.ImportScope:  		size = GetTableIndexSize (Table.ImportScope) // Parent  		+ blobidx_size;  		break;  	case Table.StateMachineMethod:  		size = GetTableIndexSize (Table.Method) // MoveNextMethod  		+ GetTableIndexSize (Table.Method);  		// KickOffMethod  		break;  	case Table.CustomDebugInformation:  		size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  		+ guididx_size // Kind  		+ blobidx_size;  		// Value  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < Mixin.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (guididx_size * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  		size = 8;  		break;  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	case Table.Document:  		size = blobidx_size // Name  		+ guididx_size // HashAlgorithm  		+ blobidx_size // Hash  		+ guididx_size;  		// Language  		break;  	case Table.MethodDebugInformation:  		size = GetTableIndexSize (Table.Document) // Document  		+ blobidx_size;  		// SequencePoints  		break;  	case Table.LocalScope:  		size = GetTableIndexSize (Table.Method) // Method  		+ GetTableIndexSize (Table.ImportScope) // ImportScope  		+ GetTableIndexSize (Table.LocalVariable) // VariableList  		+ GetTableIndexSize (Table.LocalConstant) // ConstantList  		+ 4 * 2;  		// StartOffset' Length  		break;  	case Table.LocalVariable:  		size = 2 // Attributes  		+ 2 // Index  		+ stridx_size;  		// Name  		break;  	case Table.LocalConstant:  		size = stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.ImportScope:  		size = GetTableIndexSize (Table.ImportScope) // Parent  		+ blobidx_size;  		break;  	case Table.StateMachineMethod:  		size = GetTableIndexSize (Table.Method) // MoveNextMethod  		+ GetTableIndexSize (Table.Method);  		// KickOffMethod  		break;  	case Table.CustomDebugInformation:  		size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  		+ guididx_size // Kind  		+ blobidx_size;  		// Value  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < Mixin.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (guididx_size * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  		size = 8;  		break;  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	case Table.Document:  		size = blobidx_size // Name  		+ guididx_size // HashAlgorithm  		+ blobidx_size // Hash  		+ guididx_size;  		// Language  		break;  	case Table.MethodDebugInformation:  		size = GetTableIndexSize (Table.Document) // Document  		+ blobidx_size;  		// SequencePoints  		break;  	case Table.LocalScope:  		size = GetTableIndexSize (Table.Method) // Method  		+ GetTableIndexSize (Table.ImportScope) // ImportScope  		+ GetTableIndexSize (Table.LocalVariable) // VariableList  		+ GetTableIndexSize (Table.LocalConstant) // ConstantList  		+ 4 * 2;  		// StartOffset' Length  		break;  	case Table.LocalVariable:  		size = 2 // Attributes  		+ 2 // Index  		+ stridx_size;  		// Name  		break;  	case Table.LocalConstant:  		size = stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.ImportScope:  		size = GetTableIndexSize (Table.ImportScope) // Parent  		+ blobidx_size;  		break;  	case Table.StateMachineMethod:  		size = GetTableIndexSize (Table.Method) // MoveNextMethod  		+ GetTableIndexSize (Table.Method);  		// KickOffMethod  		break;  	case Table.CustomDebugInformation:  		size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  		+ guididx_size // Kind  		+ blobidx_size;  		// Value  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < Mixin.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (guididx_size * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  		size = 8;  		break;  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	case Table.Document:  		size = blobidx_size // Name  		+ guididx_size // HashAlgorithm  		+ blobidx_size // Hash  		+ guididx_size;  		// Language  		break;  	case Table.MethodDebugInformation:  		size = GetTableIndexSize (Table.Document) // Document  		+ blobidx_size;  		// SequencePoints  		break;  	case Table.LocalScope:  		size = GetTableIndexSize (Table.Method) // Method  		+ GetTableIndexSize (Table.ImportScope) // ImportScope  		+ GetTableIndexSize (Table.LocalVariable) // VariableList  		+ GetTableIndexSize (Table.LocalConstant) // ConstantList  		+ 4 * 2;  		// StartOffset' Length  		break;  	case Table.LocalVariable:  		size = 2 // Attributes  		+ 2 // Index  		+ stridx_size;  		// Name  		break;  	case Table.LocalConstant:  		size = stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.ImportScope:  		size = GetTableIndexSize (Table.ImportScope) // Parent  		+ blobidx_size;  		break;  	case Table.StateMachineMethod:  		size = GetTableIndexSize (Table.Method) // MoveNextMethod  		+ GetTableIndexSize (Table.Method);  		// KickOffMethod  		break;  	case Table.CustomDebugInformation:  		size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  		+ guididx_size // Kind  		+ blobidx_size;  		// Value  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < Mixin.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (guididx_size * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  		size = 8;  		break;  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	case Table.Document:  		size = blobidx_size // Name  		+ guididx_size // HashAlgorithm  		+ blobidx_size // Hash  		+ guididx_size;  		// Language  		break;  	case Table.MethodDebugInformation:  		size = GetTableIndexSize (Table.Document) // Document  		+ blobidx_size;  		// SequencePoints  		break;  	case Table.LocalScope:  		size = GetTableIndexSize (Table.Method) // Method  		+ GetTableIndexSize (Table.ImportScope) // ImportScope  		+ GetTableIndexSize (Table.LocalVariable) // VariableList  		+ GetTableIndexSize (Table.LocalConstant) // ConstantList  		+ 4 * 2;  		// StartOffset' Length  		break;  	case Table.LocalVariable:  		size = 2 // Attributes  		+ 2 // Index  		+ stridx_size;  		// Name  		break;  	case Table.LocalConstant:  		size = stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.ImportScope:  		size = GetTableIndexSize (Table.ImportScope) // Parent  		+ blobidx_size;  		break;  	case Table.StateMachineMethod:  		size = GetTableIndexSize (Table.Method) // MoveNextMethod  		+ GetTableIndexSize (Table.Method);  		// KickOffMethod  		break;  	case Table.CustomDebugInformation:  		size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  		+ guididx_size // Kind  		+ blobidx_size;  		// Value  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < Mixin.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (guididx_size * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  		size = 8;  		break;  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	case Table.Document:  		size = blobidx_size // Name  		+ guididx_size // HashAlgorithm  		+ blobidx_size // Hash  		+ guididx_size;  		// Language  		break;  	case Table.MethodDebugInformation:  		size = GetTableIndexSize (Table.Document) // Document  		+ blobidx_size;  		// SequencePoints  		break;  	case Table.LocalScope:  		size = GetTableIndexSize (Table.Method) // Method  		+ GetTableIndexSize (Table.ImportScope) // ImportScope  		+ GetTableIndexSize (Table.LocalVariable) // VariableList  		+ GetTableIndexSize (Table.LocalConstant) // ConstantList  		+ 4 * 2;  		// StartOffset' Length  		break;  	case Table.LocalVariable:  		size = 2 // Attributes  		+ 2 // Index  		+ stridx_size;  		// Name  		break;  	case Table.LocalConstant:  		size = stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.ImportScope:  		size = GetTableIndexSize (Table.ImportScope) // Parent  		+ blobidx_size;  		break;  	case Table.StateMachineMethod:  		size = GetTableIndexSize (Table.Method) // MoveNextMethod  		+ GetTableIndexSize (Table.Method);  		// KickOffMethod  		break;  	case Table.CustomDebugInformation:  		size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  		+ guididx_size // Kind  		+ blobidx_size;  		// Value  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < Mixin.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (guididx_size * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  		size = 8;  		break;  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	case Table.Document:  		size = blobidx_size // Name  		+ guididx_size // HashAlgorithm  		+ blobidx_size // Hash  		+ guididx_size;  		// Language  		break;  	case Table.MethodDebugInformation:  		size = GetTableIndexSize (Table.Document) // Document  		+ blobidx_size;  		// SequencePoints  		break;  	case Table.LocalScope:  		size = GetTableIndexSize (Table.Method) // Method  		+ GetTableIndexSize (Table.ImportScope) // ImportScope  		+ GetTableIndexSize (Table.LocalVariable) // VariableList  		+ GetTableIndexSize (Table.LocalConstant) // ConstantList  		+ 4 * 2;  		// StartOffset' Length  		break;  	case Table.LocalVariable:  		size = 2 // Attributes  		+ 2 // Index  		+ stridx_size;  		// Name  		break;  	case Table.LocalConstant:  		size = stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.ImportScope:  		size = GetTableIndexSize (Table.ImportScope) // Parent  		+ blobidx_size;  		break;  	case Table.StateMachineMethod:  		size = GetTableIndexSize (Table.Method) // MoveNextMethod  		+ GetTableIndexSize (Table.Method);  		// KickOffMethod  		break;  	case Table.CustomDebugInformation:  		size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  		+ guididx_size // Kind  		+ blobidx_size;  		// Value  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < Mixin.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (guididx_size * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  		size = 8;  		break;  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	case Table.Document:  		size = blobidx_size // Name  		+ guididx_size // HashAlgorithm  		+ blobidx_size // Hash  		+ guididx_size;  		// Language  		break;  	case Table.MethodDebugInformation:  		size = GetTableIndexSize (Table.Document) // Document  		+ blobidx_size;  		// SequencePoints  		break;  	case Table.LocalScope:  		size = GetTableIndexSize (Table.Method) // Method  		+ GetTableIndexSize (Table.ImportScope) // ImportScope  		+ GetTableIndexSize (Table.LocalVariable) // VariableList  		+ GetTableIndexSize (Table.LocalConstant) // ConstantList  		+ 4 * 2;  		// StartOffset' Length  		break;  	case Table.LocalVariable:  		size = 2 // Attributes  		+ 2 // Index  		+ stridx_size;  		// Name  		break;  	case Table.LocalConstant:  		size = stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.ImportScope:  		size = GetTableIndexSize (Table.ImportScope) // Parent  		+ blobidx_size;  		break;  	case Table.StateMachineMethod:  		size = GetTableIndexSize (Table.Method) // MoveNextMethod  		+ GetTableIndexSize (Table.Method);  		// KickOffMethod  		break;  	case Table.CustomDebugInformation:  		size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  		+ guididx_size // Kind  		+ blobidx_size;  		// Value  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < Mixin.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (guididx_size * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  		size = 8;  		break;  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	case Table.Document:  		size = blobidx_size // Name  		+ guididx_size // HashAlgorithm  		+ blobidx_size // Hash  		+ guididx_size;  		// Language  		break;  	case Table.MethodDebugInformation:  		size = GetTableIndexSize (Table.Document) // Document  		+ blobidx_size;  		// SequencePoints  		break;  	case Table.LocalScope:  		size = GetTableIndexSize (Table.Method) // Method  		+ GetTableIndexSize (Table.ImportScope) // ImportScope  		+ GetTableIndexSize (Table.LocalVariable) // VariableList  		+ GetTableIndexSize (Table.LocalConstant) // ConstantList  		+ 4 * 2;  		// StartOffset' Length  		break;  	case Table.LocalVariable:  		size = 2 // Attributes  		+ 2 // Index  		+ stridx_size;  		// Name  		break;  	case Table.LocalConstant:  		size = stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.ImportScope:  		size = GetTableIndexSize (Table.ImportScope) // Parent  		+ blobidx_size;  		break;  	case Table.StateMachineMethod:  		size = GetTableIndexSize (Table.Method) // MoveNextMethod  		+ GetTableIndexSize (Table.Method);  		// KickOffMethod  		break;  	case Table.CustomDebugInformation:  		size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  		+ guididx_size // Kind  		+ blobidx_size;  		// Value  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < Mixin.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (guididx_size * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  		size = 8;  		break;  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	case Table.Document:  		size = blobidx_size // Name  		+ guididx_size // HashAlgorithm  		+ blobidx_size // Hash  		+ guididx_size;  		// Language  		break;  	case Table.MethodDebugInformation:  		size = GetTableIndexSize (Table.Document) // Document  		+ blobidx_size;  		// SequencePoints  		break;  	case Table.LocalScope:  		size = GetTableIndexSize (Table.Method) // Method  		+ GetTableIndexSize (Table.ImportScope) // ImportScope  		+ GetTableIndexSize (Table.LocalVariable) // VariableList  		+ GetTableIndexSize (Table.LocalConstant) // ConstantList  		+ 4 * 2;  		// StartOffset' Length  		break;  	case Table.LocalVariable:  		size = 2 // Attributes  		+ 2 // Index  		+ stridx_size;  		// Name  		break;  	case Table.LocalConstant:  		size = stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.ImportScope:  		size = GetTableIndexSize (Table.ImportScope) // Parent  		+ blobidx_size;  		break;  	case Table.StateMachineMethod:  		size = GetTableIndexSize (Table.Method) // MoveNextMethod  		+ GetTableIndexSize (Table.Method);  		// KickOffMethod  		break;  	case Table.CustomDebugInformation:  		size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  		+ guididx_size // Kind  		+ blobidx_size;  		// Value  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < Mixin.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (guididx_size * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  		size = 8;  		break;  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	case Table.Document:  		size = blobidx_size // Name  		+ guididx_size // HashAlgorithm  		+ blobidx_size // Hash  		+ guididx_size;  		// Language  		break;  	case Table.MethodDebugInformation:  		size = GetTableIndexSize (Table.Document) // Document  		+ blobidx_size;  		// SequencePoints  		break;  	case Table.LocalScope:  		size = GetTableIndexSize (Table.Method) // Method  		+ GetTableIndexSize (Table.ImportScope) // ImportScope  		+ GetTableIndexSize (Table.LocalVariable) // VariableList  		+ GetTableIndexSize (Table.LocalConstant) // ConstantList  		+ 4 * 2;  		// StartOffset' Length  		break;  	case Table.LocalVariable:  		size = 2 // Attributes  		+ 2 // Index  		+ stridx_size;  		// Name  		break;  	case Table.LocalConstant:  		size = stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.ImportScope:  		size = GetTableIndexSize (Table.ImportScope) // Parent  		+ blobidx_size;  		break;  	case Table.StateMachineMethod:  		size = GetTableIndexSize (Table.Method) // MoveNextMethod  		+ GetTableIndexSize (Table.Method);  		// KickOffMethod  		break;  	case Table.CustomDebugInformation:  		size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  		+ guididx_size // Kind  		+ blobidx_size;  		// Value  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < Mixin.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (guididx_size * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  		size = 8;  		break;  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	case Table.Document:  		size = blobidx_size // Name  		+ guididx_size // HashAlgorithm  		+ blobidx_size // Hash  		+ guididx_size;  		// Language  		break;  	case Table.MethodDebugInformation:  		size = GetTableIndexSize (Table.Document) // Document  		+ blobidx_size;  		// SequencePoints  		break;  	case Table.LocalScope:  		size = GetTableIndexSize (Table.Method) // Method  		+ GetTableIndexSize (Table.ImportScope) // ImportScope  		+ GetTableIndexSize (Table.LocalVariable) // VariableList  		+ GetTableIndexSize (Table.LocalConstant) // ConstantList  		+ 4 * 2;  		// StartOffset' Length  		break;  	case Table.LocalVariable:  		size = 2 // Attributes  		+ 2 // Index  		+ stridx_size;  		// Name  		break;  	case Table.LocalConstant:  		size = stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.ImportScope:  		size = GetTableIndexSize (Table.ImportScope) // Parent  		+ blobidx_size;  		break;  	case Table.StateMachineMethod:  		size = GetTableIndexSize (Table.Method) // MoveNextMethod  		+ GetTableIndexSize (Table.Method);  		// KickOffMethod  		break;  	case Table.CustomDebugInformation:  		size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  		+ guididx_size // Kind  		+ blobidx_size;  		// Value  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < Mixin.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (guididx_size * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  		size = 8;  		break;  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	case Table.Document:  		size = blobidx_size // Name  		+ guididx_size // HashAlgorithm  		+ blobidx_size // Hash  		+ guididx_size;  		// Language  		break;  	case Table.MethodDebugInformation:  		size = GetTableIndexSize (Table.Document) // Document  		+ blobidx_size;  		// SequencePoints  		break;  	case Table.LocalScope:  		size = GetTableIndexSize (Table.Method) // Method  		+ GetTableIndexSize (Table.ImportScope) // ImportScope  		+ GetTableIndexSize (Table.LocalVariable) // VariableList  		+ GetTableIndexSize (Table.LocalConstant) // ConstantList  		+ 4 * 2;  		// StartOffset' Length  		break;  	case Table.LocalVariable:  		size = 2 // Attributes  		+ 2 // Index  		+ stridx_size;  		// Name  		break;  	case Table.LocalConstant:  		size = stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.ImportScope:  		size = GetTableIndexSize (Table.ImportScope) // Parent  		+ blobidx_size;  		break;  	case Table.StateMachineMethod:  		size = GetTableIndexSize (Table.Method) // MoveNextMethod  		+ GetTableIndexSize (Table.Method);  		// KickOffMethod  		break;  	case Table.CustomDebugInformation:  		size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  		+ guididx_size // Kind  		+ blobidx_size;  		// Value  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < Mixin.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (guididx_size * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  		size = 8;  		break;  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	case Table.Document:  		size = blobidx_size // Name  		+ guididx_size // HashAlgorithm  		+ blobidx_size // Hash  		+ guididx_size;  		// Language  		break;  	case Table.MethodDebugInformation:  		size = GetTableIndexSize (Table.Document) // Document  		+ blobidx_size;  		// SequencePoints  		break;  	case Table.LocalScope:  		size = GetTableIndexSize (Table.Method) // Method  		+ GetTableIndexSize (Table.ImportScope) // ImportScope  		+ GetTableIndexSize (Table.LocalVariable) // VariableList  		+ GetTableIndexSize (Table.LocalConstant) // ConstantList  		+ 4 * 2;  		// StartOffset' Length  		break;  	case Table.LocalVariable:  		size = 2 // Attributes  		+ 2 // Index  		+ stridx_size;  		// Name  		break;  	case Table.LocalConstant:  		size = stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.ImportScope:  		size = GetTableIndexSize (Table.ImportScope) // Parent  		+ blobidx_size;  		break;  	case Table.StateMachineMethod:  		size = GetTableIndexSize (Table.Method) // MoveNextMethod  		+ GetTableIndexSize (Table.Method);  		// KickOffMethod  		break;  	case Table.CustomDebugInformation:  		size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  		+ guididx_size // Kind  		+ blobidx_size;  		// Value  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < Mixin.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (guididx_size * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  		size = 8;  		break;  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	case Table.Document:  		size = blobidx_size // Name  		+ guididx_size // HashAlgorithm  		+ blobidx_size // Hash  		+ guididx_size;  		// Language  		break;  	case Table.MethodDebugInformation:  		size = GetTableIndexSize (Table.Document) // Document  		+ blobidx_size;  		// SequencePoints  		break;  	case Table.LocalScope:  		size = GetTableIndexSize (Table.Method) // Method  		+ GetTableIndexSize (Table.ImportScope) // ImportScope  		+ GetTableIndexSize (Table.LocalVariable) // VariableList  		+ GetTableIndexSize (Table.LocalConstant) // ConstantList  		+ 4 * 2;  		// StartOffset' Length  		break;  	case Table.LocalVariable:  		size = 2 // Attributes  		+ 2 // Index  		+ stridx_size;  		// Name  		break;  	case Table.LocalConstant:  		size = stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.ImportScope:  		size = GetTableIndexSize (Table.ImportScope) // Parent  		+ blobidx_size;  		break;  	case Table.StateMachineMethod:  		size = GetTableIndexSize (Table.Method) // MoveNextMethod  		+ GetTableIndexSize (Table.Method);  		// KickOffMethod  		break;  	case Table.CustomDebugInformation:  		size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  		+ guididx_size // Kind  		+ blobidx_size;  		// Value  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: for (int i = 0; i < Mixin.TableCount; i++) {  	var table = (Table)i;  	if (!heap.HasTable (table))  		continue;  	int size;  	switch (table) {  	case Table.Module:  		size = 2 // Generation  		+ stridx_size // Name  		+ (guididx_size * 3);  		// Mvid' EncId' EncBaseId  		break;  	case Table.TypeRef:  		size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  		+ (stridx_size * 2);  		// Name' Namespace  		break;  	case Table.TypeDef:  		size = 4 // Flags  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  		+ GetTableIndexSize (Table.Field) // FieldList  		+ GetTableIndexSize (Table.Method);  		// MethodList  		break;  	case Table.FieldPtr:  		size = GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.Field:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.MethodPtr:  		size = GetTableIndexSize (Table.Method);  		// Method  		break;  	case Table.Method:  		size = 8 // Rva 4' ImplFlags 2' Flags 2  		+ stridx_size // Name  		+ blobidx_size // Signature  		+ GetTableIndexSize (Table.Param);  		// ParamList  		break;  	case Table.ParamPtr:  		size = GetTableIndexSize (Table.Param);  		// Param  		break;  	case Table.Param:  		size = 4 // Flags 2' Sequence 2  		+ stridx_size;  		// Name  		break;  	case Table.InterfaceImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Interface  		break;  	case Table.MemberRef:  		size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  		+ stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.Constant:  		size = 2 // Type  		+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  		+ blobidx_size;  		// Value  		break;  	case Table.CustomAttribute:  		size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  		+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  		+ blobidx_size;  		// Value  		break;  	case Table.FieldMarshal:  		size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  		+ blobidx_size;  		// NativeType  		break;  	case Table.DeclSecurity:  		size = 2 // Action  		+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  		+ blobidx_size;  		// PermissionSet  		break;  	case Table.ClassLayout:  		size = 6 // PackingSize 2' ClassSize 4  		+ GetTableIndexSize (Table.TypeDef);  		// Parent  		break;  	case Table.FieldLayout:  		size = 4 // Offset  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.StandAloneSig:  		size = blobidx_size;  		// Signature  		break;  	case Table.EventMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Event);  		// EventList  		break;  	case Table.EventPtr:  		size = GetTableIndexSize (Table.Event);  		// Event  		break;  	case Table.Event:  		size = 2 // Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// EventType  		break;  	case Table.PropertyMap:  		size = GetTableIndexSize (Table.TypeDef) // Parent  		+ GetTableIndexSize (Table.Property);  		// PropertyList  		break;  	case Table.PropertyPtr:  		size = GetTableIndexSize (Table.Property);  		// Property  		break;  	case Table.Property:  		size = 2 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// Type  		break;  	case Table.MethodSemantics:  		size = 2 // Semantics  		+ GetTableIndexSize (Table.Method) // Method  		+ GetCodedIndexSize (CodedIndex.HasSemantics);  		// Association  		break;  	case Table.MethodImpl:  		size = GetTableIndexSize (Table.TypeDef) // Class  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  		+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  		// MethodDeclaration  		break;  	case Table.ModuleRef:  		size = stridx_size;  		// Name  		break;  	case Table.TypeSpec:  		size = blobidx_size;  		// Signature  		break;  	case Table.ImplMap:  		size = 2 // MappingFlags  		+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  		+ stridx_size // ImportName  		+ GetTableIndexSize (Table.ModuleRef);  		// ImportScope  		break;  	case Table.FieldRVA:  		size = 4 // RVA  		+ GetTableIndexSize (Table.Field);  		// Field  		break;  	case Table.EncLog:  		size = 8;  		break;  	case Table.EncMap:  		size = 4;  		break;  	case Table.Assembly:  		size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  		+ blobidx_size // PublicKey  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyProcessor:  		size = 4;  		// Processor  		break;  	case Table.AssemblyOS:  		size = 12;  		// Platform 4' Version 2 * 4  		break;  	case Table.AssemblyRef:  		size = 12 // Version 2 * 4 + Flags 4  		+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  		+ (stridx_size * 2);  		// Name' Culture  		break;  	case Table.AssemblyRefProcessor:  		size = 4 // Processor  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.AssemblyRefOS:  		size = 12 // Platform 4' Version 2 * 4  		+ GetTableIndexSize (Table.AssemblyRef);  		// AssemblyRef  		break;  	case Table.File:  		size = 4 // Flags  		+ stridx_size // Name  		+ blobidx_size;  		// HashValue  		break;  	case Table.ExportedType:  		size = 8 // Flags 4' TypeDefId 4  		+ (stridx_size * 2) // Name' Namespace  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.ManifestResource:  		size = 8 // Offset' Flags  		+ stridx_size // Name  		+ GetCodedIndexSize (CodedIndex.Implementation);  		// Implementation  		break;  	case Table.NestedClass:  		size = GetTableIndexSize (Table.TypeDef) // NestedClass  		+ GetTableIndexSize (Table.TypeDef);  		// EnclosingClass  		break;  	case Table.GenericParam:  		size = 4 // Number' Flags  		+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  		+ stridx_size;  		// Name  		break;  	case Table.MethodSpec:  		size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  		+ blobidx_size;  		// Instantiation  		break;  	case Table.GenericParamConstraint:  		size = GetTableIndexSize (Table.GenericParam) // Owner  		+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  		// Constraint  		break;  	case Table.Document:  		size = blobidx_size // Name  		+ guididx_size // HashAlgorithm  		+ blobidx_size // Hash  		+ guididx_size;  		// Language  		break;  	case Table.MethodDebugInformation:  		size = GetTableIndexSize (Table.Document) // Document  		+ blobidx_size;  		// SequencePoints  		break;  	case Table.LocalScope:  		size = GetTableIndexSize (Table.Method) // Method  		+ GetTableIndexSize (Table.ImportScope) // ImportScope  		+ GetTableIndexSize (Table.LocalVariable) // VariableList  		+ GetTableIndexSize (Table.LocalConstant) // ConstantList  		+ 4 * 2;  		// StartOffset' Length  		break;  	case Table.LocalVariable:  		size = 2 // Attributes  		+ 2 // Index  		+ stridx_size;  		// Name  		break;  	case Table.LocalConstant:  		size = stridx_size // Name  		+ blobidx_size;  		// Signature  		break;  	case Table.ImportScope:  		size = GetTableIndexSize (Table.ImportScope) // Parent  		+ blobidx_size;  		break;  	case Table.StateMachineMethod:  		size = GetTableIndexSize (Table.Method) // MoveNextMethod  		+ GetTableIndexSize (Table.Method);  		// KickOffMethod  		break;  	case Table.CustomDebugInformation:  		size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  		+ guididx_size // Kind  		+ blobidx_size;  		// Value  		break;  	default:  		throw new NotSupportedException ();  	}  	tables [i].RowSize = (uint)size;  	tables [i].Offset = offset;  	offset += (uint)size * tables [i].Length;  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (guididx_size * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  	size = 8;  	break;  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  case Table.Document:  	size = blobidx_size // Name  	+ guididx_size // HashAlgorithm  	+ blobidx_size // Hash  	+ guididx_size;  	// Language  	break;  case Table.MethodDebugInformation:  	size = GetTableIndexSize (Table.Document) // Document  	+ blobidx_size;  	// SequencePoints  	break;  case Table.LocalScope:  	size = GetTableIndexSize (Table.Method) // Method  	+ GetTableIndexSize (Table.ImportScope) // ImportScope  	+ GetTableIndexSize (Table.LocalVariable) // VariableList  	+ GetTableIndexSize (Table.LocalConstant) // ConstantList  	+ 4 * 2;  	// StartOffset' Length  	break;  case Table.LocalVariable:  	size = 2 // Attributes  	+ 2 // Index  	+ stridx_size;  	// Name  	break;  case Table.LocalConstant:  	size = stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.ImportScope:  	size = GetTableIndexSize (Table.ImportScope) // Parent  	+ blobidx_size;  	break;  case Table.StateMachineMethod:  	size = GetTableIndexSize (Table.Method) // MoveNextMethod  	+ GetTableIndexSize (Table.Method);  	// KickOffMethod  	break;  case Table.CustomDebugInformation:  	size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  	+ guididx_size // Kind  	+ blobidx_size;  	// Value  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (guididx_size * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  	size = 8;  	break;  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  case Table.Document:  	size = blobidx_size // Name  	+ guididx_size // HashAlgorithm  	+ blobidx_size // Hash  	+ guididx_size;  	// Language  	break;  case Table.MethodDebugInformation:  	size = GetTableIndexSize (Table.Document) // Document  	+ blobidx_size;  	// SequencePoints  	break;  case Table.LocalScope:  	size = GetTableIndexSize (Table.Method) // Method  	+ GetTableIndexSize (Table.ImportScope) // ImportScope  	+ GetTableIndexSize (Table.LocalVariable) // VariableList  	+ GetTableIndexSize (Table.LocalConstant) // ConstantList  	+ 4 * 2;  	// StartOffset' Length  	break;  case Table.LocalVariable:  	size = 2 // Attributes  	+ 2 // Index  	+ stridx_size;  	// Name  	break;  case Table.LocalConstant:  	size = stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.ImportScope:  	size = GetTableIndexSize (Table.ImportScope) // Parent  	+ blobidx_size;  	break;  case Table.StateMachineMethod:  	size = GetTableIndexSize (Table.Method) // MoveNextMethod  	+ GetTableIndexSize (Table.Method);  	// KickOffMethod  	break;  case Table.CustomDebugInformation:  	size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  	+ guididx_size // Kind  	+ blobidx_size;  	// Value  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (guididx_size * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  	size = 8;  	break;  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  case Table.Document:  	size = blobidx_size // Name  	+ guididx_size // HashAlgorithm  	+ blobidx_size // Hash  	+ guididx_size;  	// Language  	break;  case Table.MethodDebugInformation:  	size = GetTableIndexSize (Table.Document) // Document  	+ blobidx_size;  	// SequencePoints  	break;  case Table.LocalScope:  	size = GetTableIndexSize (Table.Method) // Method  	+ GetTableIndexSize (Table.ImportScope) // ImportScope  	+ GetTableIndexSize (Table.LocalVariable) // VariableList  	+ GetTableIndexSize (Table.LocalConstant) // ConstantList  	+ 4 * 2;  	// StartOffset' Length  	break;  case Table.LocalVariable:  	size = 2 // Attributes  	+ 2 // Index  	+ stridx_size;  	// Name  	break;  case Table.LocalConstant:  	size = stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.ImportScope:  	size = GetTableIndexSize (Table.ImportScope) // Parent  	+ blobidx_size;  	break;  case Table.StateMachineMethod:  	size = GetTableIndexSize (Table.Method) // MoveNextMethod  	+ GetTableIndexSize (Table.Method);  	// KickOffMethod  	break;  case Table.CustomDebugInformation:  	size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  	+ guididx_size // Kind  	+ blobidx_size;  	// Value  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (guididx_size * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  	size = 8;  	break;  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  case Table.Document:  	size = blobidx_size // Name  	+ guididx_size // HashAlgorithm  	+ blobidx_size // Hash  	+ guididx_size;  	// Language  	break;  case Table.MethodDebugInformation:  	size = GetTableIndexSize (Table.Document) // Document  	+ blobidx_size;  	// SequencePoints  	break;  case Table.LocalScope:  	size = GetTableIndexSize (Table.Method) // Method  	+ GetTableIndexSize (Table.ImportScope) // ImportScope  	+ GetTableIndexSize (Table.LocalVariable) // VariableList  	+ GetTableIndexSize (Table.LocalConstant) // ConstantList  	+ 4 * 2;  	// StartOffset' Length  	break;  case Table.LocalVariable:  	size = 2 // Attributes  	+ 2 // Index  	+ stridx_size;  	// Name  	break;  case Table.LocalConstant:  	size = stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.ImportScope:  	size = GetTableIndexSize (Table.ImportScope) // Parent  	+ blobidx_size;  	break;  case Table.StateMachineMethod:  	size = GetTableIndexSize (Table.Method) // MoveNextMethod  	+ GetTableIndexSize (Table.Method);  	// KickOffMethod  	break;  case Table.CustomDebugInformation:  	size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  	+ guididx_size // Kind  	+ blobidx_size;  	// Value  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (guididx_size * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  	size = 8;  	break;  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  case Table.Document:  	size = blobidx_size // Name  	+ guididx_size // HashAlgorithm  	+ blobidx_size // Hash  	+ guididx_size;  	// Language  	break;  case Table.MethodDebugInformation:  	size = GetTableIndexSize (Table.Document) // Document  	+ blobidx_size;  	// SequencePoints  	break;  case Table.LocalScope:  	size = GetTableIndexSize (Table.Method) // Method  	+ GetTableIndexSize (Table.ImportScope) // ImportScope  	+ GetTableIndexSize (Table.LocalVariable) // VariableList  	+ GetTableIndexSize (Table.LocalConstant) // ConstantList  	+ 4 * 2;  	// StartOffset' Length  	break;  case Table.LocalVariable:  	size = 2 // Attributes  	+ 2 // Index  	+ stridx_size;  	// Name  	break;  case Table.LocalConstant:  	size = stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.ImportScope:  	size = GetTableIndexSize (Table.ImportScope) // Parent  	+ blobidx_size;  	break;  case Table.StateMachineMethod:  	size = GetTableIndexSize (Table.Method) // MoveNextMethod  	+ GetTableIndexSize (Table.Method);  	// KickOffMethod  	break;  case Table.CustomDebugInformation:  	size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  	+ guididx_size // Kind  	+ blobidx_size;  	// Value  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (guididx_size * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  	size = 8;  	break;  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  case Table.Document:  	size = blobidx_size // Name  	+ guididx_size // HashAlgorithm  	+ blobidx_size // Hash  	+ guididx_size;  	// Language  	break;  case Table.MethodDebugInformation:  	size = GetTableIndexSize (Table.Document) // Document  	+ blobidx_size;  	// SequencePoints  	break;  case Table.LocalScope:  	size = GetTableIndexSize (Table.Method) // Method  	+ GetTableIndexSize (Table.ImportScope) // ImportScope  	+ GetTableIndexSize (Table.LocalVariable) // VariableList  	+ GetTableIndexSize (Table.LocalConstant) // ConstantList  	+ 4 * 2;  	// StartOffset' Length  	break;  case Table.LocalVariable:  	size = 2 // Attributes  	+ 2 // Index  	+ stridx_size;  	// Name  	break;  case Table.LocalConstant:  	size = stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.ImportScope:  	size = GetTableIndexSize (Table.ImportScope) // Parent  	+ blobidx_size;  	break;  case Table.StateMachineMethod:  	size = GetTableIndexSize (Table.Method) // MoveNextMethod  	+ GetTableIndexSize (Table.Method);  	// KickOffMethod  	break;  case Table.CustomDebugInformation:  	size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  	+ guididx_size // Kind  	+ blobidx_size;  	// Value  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (guididx_size * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  	size = 8;  	break;  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  case Table.Document:  	size = blobidx_size // Name  	+ guididx_size // HashAlgorithm  	+ blobidx_size // Hash  	+ guididx_size;  	// Language  	break;  case Table.MethodDebugInformation:  	size = GetTableIndexSize (Table.Document) // Document  	+ blobidx_size;  	// SequencePoints  	break;  case Table.LocalScope:  	size = GetTableIndexSize (Table.Method) // Method  	+ GetTableIndexSize (Table.ImportScope) // ImportScope  	+ GetTableIndexSize (Table.LocalVariable) // VariableList  	+ GetTableIndexSize (Table.LocalConstant) // ConstantList  	+ 4 * 2;  	// StartOffset' Length  	break;  case Table.LocalVariable:  	size = 2 // Attributes  	+ 2 // Index  	+ stridx_size;  	// Name  	break;  case Table.LocalConstant:  	size = stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.ImportScope:  	size = GetTableIndexSize (Table.ImportScope) // Parent  	+ blobidx_size;  	break;  case Table.StateMachineMethod:  	size = GetTableIndexSize (Table.Method) // MoveNextMethod  	+ GetTableIndexSize (Table.Method);  	// KickOffMethod  	break;  case Table.CustomDebugInformation:  	size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  	+ guididx_size // Kind  	+ blobidx_size;  	// Value  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (guididx_size * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  	size = 8;  	break;  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  case Table.Document:  	size = blobidx_size // Name  	+ guididx_size // HashAlgorithm  	+ blobidx_size // Hash  	+ guididx_size;  	// Language  	break;  case Table.MethodDebugInformation:  	size = GetTableIndexSize (Table.Document) // Document  	+ blobidx_size;  	// SequencePoints  	break;  case Table.LocalScope:  	size = GetTableIndexSize (Table.Method) // Method  	+ GetTableIndexSize (Table.ImportScope) // ImportScope  	+ GetTableIndexSize (Table.LocalVariable) // VariableList  	+ GetTableIndexSize (Table.LocalConstant) // ConstantList  	+ 4 * 2;  	// StartOffset' Length  	break;  case Table.LocalVariable:  	size = 2 // Attributes  	+ 2 // Index  	+ stridx_size;  	// Name  	break;  case Table.LocalConstant:  	size = stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.ImportScope:  	size = GetTableIndexSize (Table.ImportScope) // Parent  	+ blobidx_size;  	break;  case Table.StateMachineMethod:  	size = GetTableIndexSize (Table.Method) // MoveNextMethod  	+ GetTableIndexSize (Table.Method);  	// KickOffMethod  	break;  case Table.CustomDebugInformation:  	size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  	+ guididx_size // Kind  	+ blobidx_size;  	// Value  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (guididx_size * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  	size = 8;  	break;  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  case Table.Document:  	size = blobidx_size // Name  	+ guididx_size // HashAlgorithm  	+ blobidx_size // Hash  	+ guididx_size;  	// Language  	break;  case Table.MethodDebugInformation:  	size = GetTableIndexSize (Table.Document) // Document  	+ blobidx_size;  	// SequencePoints  	break;  case Table.LocalScope:  	size = GetTableIndexSize (Table.Method) // Method  	+ GetTableIndexSize (Table.ImportScope) // ImportScope  	+ GetTableIndexSize (Table.LocalVariable) // VariableList  	+ GetTableIndexSize (Table.LocalConstant) // ConstantList  	+ 4 * 2;  	// StartOffset' Length  	break;  case Table.LocalVariable:  	size = 2 // Attributes  	+ 2 // Index  	+ stridx_size;  	// Name  	break;  case Table.LocalConstant:  	size = stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.ImportScope:  	size = GetTableIndexSize (Table.ImportScope) // Parent  	+ blobidx_size;  	break;  case Table.StateMachineMethod:  	size = GetTableIndexSize (Table.Method) // MoveNextMethod  	+ GetTableIndexSize (Table.Method);  	// KickOffMethod  	break;  case Table.CustomDebugInformation:  	size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  	+ guididx_size // Kind  	+ blobidx_size;  	// Value  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (guididx_size * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  	size = 8;  	break;  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  case Table.Document:  	size = blobidx_size // Name  	+ guididx_size // HashAlgorithm  	+ blobidx_size // Hash  	+ guididx_size;  	// Language  	break;  case Table.MethodDebugInformation:  	size = GetTableIndexSize (Table.Document) // Document  	+ blobidx_size;  	// SequencePoints  	break;  case Table.LocalScope:  	size = GetTableIndexSize (Table.Method) // Method  	+ GetTableIndexSize (Table.ImportScope) // ImportScope  	+ GetTableIndexSize (Table.LocalVariable) // VariableList  	+ GetTableIndexSize (Table.LocalConstant) // ConstantList  	+ 4 * 2;  	// StartOffset' Length  	break;  case Table.LocalVariable:  	size = 2 // Attributes  	+ 2 // Index  	+ stridx_size;  	// Name  	break;  case Table.LocalConstant:  	size = stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.ImportScope:  	size = GetTableIndexSize (Table.ImportScope) // Parent  	+ blobidx_size;  	break;  case Table.StateMachineMethod:  	size = GetTableIndexSize (Table.Method) // MoveNextMethod  	+ GetTableIndexSize (Table.Method);  	// KickOffMethod  	break;  case Table.CustomDebugInformation:  	size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  	+ guididx_size // Kind  	+ blobidx_size;  	// Value  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (guididx_size * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  	size = 8;  	break;  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  case Table.Document:  	size = blobidx_size // Name  	+ guididx_size // HashAlgorithm  	+ blobidx_size // Hash  	+ guididx_size;  	// Language  	break;  case Table.MethodDebugInformation:  	size = GetTableIndexSize (Table.Document) // Document  	+ blobidx_size;  	// SequencePoints  	break;  case Table.LocalScope:  	size = GetTableIndexSize (Table.Method) // Method  	+ GetTableIndexSize (Table.ImportScope) // ImportScope  	+ GetTableIndexSize (Table.LocalVariable) // VariableList  	+ GetTableIndexSize (Table.LocalConstant) // ConstantList  	+ 4 * 2;  	// StartOffset' Length  	break;  case Table.LocalVariable:  	size = 2 // Attributes  	+ 2 // Index  	+ stridx_size;  	// Name  	break;  case Table.LocalConstant:  	size = stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.ImportScope:  	size = GetTableIndexSize (Table.ImportScope) // Parent  	+ blobidx_size;  	break;  case Table.StateMachineMethod:  	size = GetTableIndexSize (Table.Method) // MoveNextMethod  	+ GetTableIndexSize (Table.Method);  	// KickOffMethod  	break;  case Table.CustomDebugInformation:  	size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  	+ guididx_size // Kind  	+ blobidx_size;  	// Value  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (guididx_size * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  	size = 8;  	break;  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  case Table.Document:  	size = blobidx_size // Name  	+ guididx_size // HashAlgorithm  	+ blobidx_size // Hash  	+ guididx_size;  	// Language  	break;  case Table.MethodDebugInformation:  	size = GetTableIndexSize (Table.Document) // Document  	+ blobidx_size;  	// SequencePoints  	break;  case Table.LocalScope:  	size = GetTableIndexSize (Table.Method) // Method  	+ GetTableIndexSize (Table.ImportScope) // ImportScope  	+ GetTableIndexSize (Table.LocalVariable) // VariableList  	+ GetTableIndexSize (Table.LocalConstant) // ConstantList  	+ 4 * 2;  	// StartOffset' Length  	break;  case Table.LocalVariable:  	size = 2 // Attributes  	+ 2 // Index  	+ stridx_size;  	// Name  	break;  case Table.LocalConstant:  	size = stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.ImportScope:  	size = GetTableIndexSize (Table.ImportScope) // Parent  	+ blobidx_size;  	break;  case Table.StateMachineMethod:  	size = GetTableIndexSize (Table.Method) // MoveNextMethod  	+ GetTableIndexSize (Table.Method);  	// KickOffMethod  	break;  case Table.CustomDebugInformation:  	size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  	+ guididx_size // Kind  	+ blobidx_size;  	// Value  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (guididx_size * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  	size = 8;  	break;  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  case Table.Document:  	size = blobidx_size // Name  	+ guididx_size // HashAlgorithm  	+ blobidx_size // Hash  	+ guididx_size;  	// Language  	break;  case Table.MethodDebugInformation:  	size = GetTableIndexSize (Table.Document) // Document  	+ blobidx_size;  	// SequencePoints  	break;  case Table.LocalScope:  	size = GetTableIndexSize (Table.Method) // Method  	+ GetTableIndexSize (Table.ImportScope) // ImportScope  	+ GetTableIndexSize (Table.LocalVariable) // VariableList  	+ GetTableIndexSize (Table.LocalConstant) // ConstantList  	+ 4 * 2;  	// StartOffset' Length  	break;  case Table.LocalVariable:  	size = 2 // Attributes  	+ 2 // Index  	+ stridx_size;  	// Name  	break;  case Table.LocalConstant:  	size = stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.ImportScope:  	size = GetTableIndexSize (Table.ImportScope) // Parent  	+ blobidx_size;  	break;  case Table.StateMachineMethod:  	size = GetTableIndexSize (Table.Method) // MoveNextMethod  	+ GetTableIndexSize (Table.Method);  	// KickOffMethod  	break;  case Table.CustomDebugInformation:  	size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  	+ guididx_size // Kind  	+ blobidx_size;  	// Value  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (guididx_size * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  	size = 8;  	break;  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  case Table.Document:  	size = blobidx_size // Name  	+ guididx_size // HashAlgorithm  	+ blobidx_size // Hash  	+ guididx_size;  	// Language  	break;  case Table.MethodDebugInformation:  	size = GetTableIndexSize (Table.Document) // Document  	+ blobidx_size;  	// SequencePoints  	break;  case Table.LocalScope:  	size = GetTableIndexSize (Table.Method) // Method  	+ GetTableIndexSize (Table.ImportScope) // ImportScope  	+ GetTableIndexSize (Table.LocalVariable) // VariableList  	+ GetTableIndexSize (Table.LocalConstant) // ConstantList  	+ 4 * 2;  	// StartOffset' Length  	break;  case Table.LocalVariable:  	size = 2 // Attributes  	+ 2 // Index  	+ stridx_size;  	// Name  	break;  case Table.LocalConstant:  	size = stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.ImportScope:  	size = GetTableIndexSize (Table.ImportScope) // Parent  	+ blobidx_size;  	break;  case Table.StateMachineMethod:  	size = GetTableIndexSize (Table.Method) // MoveNextMethod  	+ GetTableIndexSize (Table.Method);  	// KickOffMethod  	break;  case Table.CustomDebugInformation:  	size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  	+ guididx_size // Kind  	+ blobidx_size;  	// Value  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (guididx_size * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  	size = 8;  	break;  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  case Table.Document:  	size = blobidx_size // Name  	+ guididx_size // HashAlgorithm  	+ blobidx_size // Hash  	+ guididx_size;  	// Language  	break;  case Table.MethodDebugInformation:  	size = GetTableIndexSize (Table.Document) // Document  	+ blobidx_size;  	// SequencePoints  	break;  case Table.LocalScope:  	size = GetTableIndexSize (Table.Method) // Method  	+ GetTableIndexSize (Table.ImportScope) // ImportScope  	+ GetTableIndexSize (Table.LocalVariable) // VariableList  	+ GetTableIndexSize (Table.LocalConstant) // ConstantList  	+ 4 * 2;  	// StartOffset' Length  	break;  case Table.LocalVariable:  	size = 2 // Attributes  	+ 2 // Index  	+ stridx_size;  	// Name  	break;  case Table.LocalConstant:  	size = stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.ImportScope:  	size = GetTableIndexSize (Table.ImportScope) // Parent  	+ blobidx_size;  	break;  case Table.StateMachineMethod:  	size = GetTableIndexSize (Table.Method) // MoveNextMethod  	+ GetTableIndexSize (Table.Method);  	// KickOffMethod  	break;  case Table.CustomDebugInformation:  	size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  	+ guididx_size // Kind  	+ blobidx_size;  	// Value  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (guididx_size * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  	size = 8;  	break;  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  case Table.Document:  	size = blobidx_size // Name  	+ guididx_size // HashAlgorithm  	+ blobidx_size // Hash  	+ guididx_size;  	// Language  	break;  case Table.MethodDebugInformation:  	size = GetTableIndexSize (Table.Document) // Document  	+ blobidx_size;  	// SequencePoints  	break;  case Table.LocalScope:  	size = GetTableIndexSize (Table.Method) // Method  	+ GetTableIndexSize (Table.ImportScope) // ImportScope  	+ GetTableIndexSize (Table.LocalVariable) // VariableList  	+ GetTableIndexSize (Table.LocalConstant) // ConstantList  	+ 4 * 2;  	// StartOffset' Length  	break;  case Table.LocalVariable:  	size = 2 // Attributes  	+ 2 // Index  	+ stridx_size;  	// Name  	break;  case Table.LocalConstant:  	size = stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.ImportScope:  	size = GetTableIndexSize (Table.ImportScope) // Parent  	+ blobidx_size;  	break;  case Table.StateMachineMethod:  	size = GetTableIndexSize (Table.Method) // MoveNextMethod  	+ GetTableIndexSize (Table.Method);  	// KickOffMethod  	break;  case Table.CustomDebugInformation:  	size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  	+ guididx_size // Kind  	+ blobidx_size;  	// Value  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (guididx_size * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  	size = 8;  	break;  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  case Table.Document:  	size = blobidx_size // Name  	+ guididx_size // HashAlgorithm  	+ blobidx_size // Hash  	+ guididx_size;  	// Language  	break;  case Table.MethodDebugInformation:  	size = GetTableIndexSize (Table.Document) // Document  	+ blobidx_size;  	// SequencePoints  	break;  case Table.LocalScope:  	size = GetTableIndexSize (Table.Method) // Method  	+ GetTableIndexSize (Table.ImportScope) // ImportScope  	+ GetTableIndexSize (Table.LocalVariable) // VariableList  	+ GetTableIndexSize (Table.LocalConstant) // ConstantList  	+ 4 * 2;  	// StartOffset' Length  	break;  case Table.LocalVariable:  	size = 2 // Attributes  	+ 2 // Index  	+ stridx_size;  	// Name  	break;  case Table.LocalConstant:  	size = stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.ImportScope:  	size = GetTableIndexSize (Table.ImportScope) // Parent  	+ blobidx_size;  	break;  case Table.StateMachineMethod:  	size = GetTableIndexSize (Table.Method) // MoveNextMethod  	+ GetTableIndexSize (Table.Method);  	// KickOffMethod  	break;  case Table.CustomDebugInformation:  	size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  	+ guididx_size // Kind  	+ blobidx_size;  	// Value  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (guididx_size * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  	size = 8;  	break;  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  case Table.Document:  	size = blobidx_size // Name  	+ guididx_size // HashAlgorithm  	+ blobidx_size // Hash  	+ guididx_size;  	// Language  	break;  case Table.MethodDebugInformation:  	size = GetTableIndexSize (Table.Document) // Document  	+ blobidx_size;  	// SequencePoints  	break;  case Table.LocalScope:  	size = GetTableIndexSize (Table.Method) // Method  	+ GetTableIndexSize (Table.ImportScope) // ImportScope  	+ GetTableIndexSize (Table.LocalVariable) // VariableList  	+ GetTableIndexSize (Table.LocalConstant) // ConstantList  	+ 4 * 2;  	// StartOffset' Length  	break;  case Table.LocalVariable:  	size = 2 // Attributes  	+ 2 // Index  	+ stridx_size;  	// Name  	break;  case Table.LocalConstant:  	size = stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.ImportScope:  	size = GetTableIndexSize (Table.ImportScope) // Parent  	+ blobidx_size;  	break;  case Table.StateMachineMethod:  	size = GetTableIndexSize (Table.Method) // MoveNextMethod  	+ GetTableIndexSize (Table.Method);  	// KickOffMethod  	break;  case Table.CustomDebugInformation:  	size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  	+ guididx_size // Kind  	+ blobidx_size;  	// Value  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (guididx_size * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  	size = 8;  	break;  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  case Table.Document:  	size = blobidx_size // Name  	+ guididx_size // HashAlgorithm  	+ blobidx_size // Hash  	+ guididx_size;  	// Language  	break;  case Table.MethodDebugInformation:  	size = GetTableIndexSize (Table.Document) // Document  	+ blobidx_size;  	// SequencePoints  	break;  case Table.LocalScope:  	size = GetTableIndexSize (Table.Method) // Method  	+ GetTableIndexSize (Table.ImportScope) // ImportScope  	+ GetTableIndexSize (Table.LocalVariable) // VariableList  	+ GetTableIndexSize (Table.LocalConstant) // ConstantList  	+ 4 * 2;  	// StartOffset' Length  	break;  case Table.LocalVariable:  	size = 2 // Attributes  	+ 2 // Index  	+ stridx_size;  	// Name  	break;  case Table.LocalConstant:  	size = stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.ImportScope:  	size = GetTableIndexSize (Table.ImportScope) // Parent  	+ blobidx_size;  	break;  case Table.StateMachineMethod:  	size = GetTableIndexSize (Table.Method) // MoveNextMethod  	+ GetTableIndexSize (Table.Method);  	// KickOffMethod  	break;  case Table.CustomDebugInformation:  	size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  	+ guididx_size // Kind  	+ blobidx_size;  	// Value  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (guididx_size * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  	size = 8;  	break;  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  case Table.Document:  	size = blobidx_size // Name  	+ guididx_size // HashAlgorithm  	+ blobidx_size // Hash  	+ guididx_size;  	// Language  	break;  case Table.MethodDebugInformation:  	size = GetTableIndexSize (Table.Document) // Document  	+ blobidx_size;  	// SequencePoints  	break;  case Table.LocalScope:  	size = GetTableIndexSize (Table.Method) // Method  	+ GetTableIndexSize (Table.ImportScope) // ImportScope  	+ GetTableIndexSize (Table.LocalVariable) // VariableList  	+ GetTableIndexSize (Table.LocalConstant) // ConstantList  	+ 4 * 2;  	// StartOffset' Length  	break;  case Table.LocalVariable:  	size = 2 // Attributes  	+ 2 // Index  	+ stridx_size;  	// Name  	break;  case Table.LocalConstant:  	size = stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.ImportScope:  	size = GetTableIndexSize (Table.ImportScope) // Parent  	+ blobidx_size;  	break;  case Table.StateMachineMethod:  	size = GetTableIndexSize (Table.Method) // MoveNextMethod  	+ GetTableIndexSize (Table.Method);  	// KickOffMethod  	break;  case Table.CustomDebugInformation:  	size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  	+ guididx_size // Kind  	+ blobidx_size;  	// Value  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (guididx_size * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  	size = 8;  	break;  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  case Table.Document:  	size = blobidx_size // Name  	+ guididx_size // HashAlgorithm  	+ blobidx_size // Hash  	+ guididx_size;  	// Language  	break;  case Table.MethodDebugInformation:  	size = GetTableIndexSize (Table.Document) // Document  	+ blobidx_size;  	// SequencePoints  	break;  case Table.LocalScope:  	size = GetTableIndexSize (Table.Method) // Method  	+ GetTableIndexSize (Table.ImportScope) // ImportScope  	+ GetTableIndexSize (Table.LocalVariable) // VariableList  	+ GetTableIndexSize (Table.LocalConstant) // ConstantList  	+ 4 * 2;  	// StartOffset' Length  	break;  case Table.LocalVariable:  	size = 2 // Attributes  	+ 2 // Index  	+ stridx_size;  	// Name  	break;  case Table.LocalConstant:  	size = stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.ImportScope:  	size = GetTableIndexSize (Table.ImportScope) // Parent  	+ blobidx_size;  	break;  case Table.StateMachineMethod:  	size = GetTableIndexSize (Table.Method) // MoveNextMethod  	+ GetTableIndexSize (Table.Method);  	// KickOffMethod  	break;  case Table.CustomDebugInformation:  	size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  	+ guididx_size // Kind  	+ blobidx_size;  	// Value  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (guididx_size * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  	size = 8;  	break;  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  case Table.Document:  	size = blobidx_size // Name  	+ guididx_size // HashAlgorithm  	+ blobidx_size // Hash  	+ guididx_size;  	// Language  	break;  case Table.MethodDebugInformation:  	size = GetTableIndexSize (Table.Document) // Document  	+ blobidx_size;  	// SequencePoints  	break;  case Table.LocalScope:  	size = GetTableIndexSize (Table.Method) // Method  	+ GetTableIndexSize (Table.ImportScope) // ImportScope  	+ GetTableIndexSize (Table.LocalVariable) // VariableList  	+ GetTableIndexSize (Table.LocalConstant) // ConstantList  	+ 4 * 2;  	// StartOffset' Length  	break;  case Table.LocalVariable:  	size = 2 // Attributes  	+ 2 // Index  	+ stridx_size;  	// Name  	break;  case Table.LocalConstant:  	size = stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.ImportScope:  	size = GetTableIndexSize (Table.ImportScope) // Parent  	+ blobidx_size;  	break;  case Table.StateMachineMethod:  	size = GetTableIndexSize (Table.Method) // MoveNextMethod  	+ GetTableIndexSize (Table.Method);  	// KickOffMethod  	break;  case Table.CustomDebugInformation:  	size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  	+ guididx_size // Kind  	+ blobidx_size;  	// Value  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (guididx_size * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  	size = 8;  	break;  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  case Table.Document:  	size = blobidx_size // Name  	+ guididx_size // HashAlgorithm  	+ blobidx_size // Hash  	+ guididx_size;  	// Language  	break;  case Table.MethodDebugInformation:  	size = GetTableIndexSize (Table.Document) // Document  	+ blobidx_size;  	// SequencePoints  	break;  case Table.LocalScope:  	size = GetTableIndexSize (Table.Method) // Method  	+ GetTableIndexSize (Table.ImportScope) // ImportScope  	+ GetTableIndexSize (Table.LocalVariable) // VariableList  	+ GetTableIndexSize (Table.LocalConstant) // ConstantList  	+ 4 * 2;  	// StartOffset' Length  	break;  case Table.LocalVariable:  	size = 2 // Attributes  	+ 2 // Index  	+ stridx_size;  	// Name  	break;  case Table.LocalConstant:  	size = stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.ImportScope:  	size = GetTableIndexSize (Table.ImportScope) // Parent  	+ blobidx_size;  	break;  case Table.StateMachineMethod:  	size = GetTableIndexSize (Table.Method) // MoveNextMethod  	+ GetTableIndexSize (Table.Method);  	// KickOffMethod  	break;  case Table.CustomDebugInformation:  	size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  	+ guididx_size // Kind  	+ blobidx_size;  	// Value  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (guididx_size * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  	size = 8;  	break;  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  case Table.Document:  	size = blobidx_size // Name  	+ guididx_size // HashAlgorithm  	+ blobidx_size // Hash  	+ guididx_size;  	// Language  	break;  case Table.MethodDebugInformation:  	size = GetTableIndexSize (Table.Document) // Document  	+ blobidx_size;  	// SequencePoints  	break;  case Table.LocalScope:  	size = GetTableIndexSize (Table.Method) // Method  	+ GetTableIndexSize (Table.ImportScope) // ImportScope  	+ GetTableIndexSize (Table.LocalVariable) // VariableList  	+ GetTableIndexSize (Table.LocalConstant) // ConstantList  	+ 4 * 2;  	// StartOffset' Length  	break;  case Table.LocalVariable:  	size = 2 // Attributes  	+ 2 // Index  	+ stridx_size;  	// Name  	break;  case Table.LocalConstant:  	size = stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.ImportScope:  	size = GetTableIndexSize (Table.ImportScope) // Parent  	+ blobidx_size;  	break;  case Table.StateMachineMethod:  	size = GetTableIndexSize (Table.Method) // MoveNextMethod  	+ GetTableIndexSize (Table.Method);  	// KickOffMethod  	break;  case Table.CustomDebugInformation:  	size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  	+ guididx_size // Kind  	+ blobidx_size;  	// Value  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (guididx_size * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  	size = 8;  	break;  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  case Table.Document:  	size = blobidx_size // Name  	+ guididx_size // HashAlgorithm  	+ blobidx_size // Hash  	+ guididx_size;  	// Language  	break;  case Table.MethodDebugInformation:  	size = GetTableIndexSize (Table.Document) // Document  	+ blobidx_size;  	// SequencePoints  	break;  case Table.LocalScope:  	size = GetTableIndexSize (Table.Method) // Method  	+ GetTableIndexSize (Table.ImportScope) // ImportScope  	+ GetTableIndexSize (Table.LocalVariable) // VariableList  	+ GetTableIndexSize (Table.LocalConstant) // ConstantList  	+ 4 * 2;  	// StartOffset' Length  	break;  case Table.LocalVariable:  	size = 2 // Attributes  	+ 2 // Index  	+ stridx_size;  	// Name  	break;  case Table.LocalConstant:  	size = stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.ImportScope:  	size = GetTableIndexSize (Table.ImportScope) // Parent  	+ blobidx_size;  	break;  case Table.StateMachineMethod:  	size = GetTableIndexSize (Table.Method) // MoveNextMethod  	+ GetTableIndexSize (Table.Method);  	// KickOffMethod  	break;  case Table.CustomDebugInformation:  	size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  	+ guididx_size // Kind  	+ blobidx_size;  	// Value  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (guididx_size * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  	size = 8;  	break;  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  case Table.Document:  	size = blobidx_size // Name  	+ guididx_size // HashAlgorithm  	+ blobidx_size // Hash  	+ guididx_size;  	// Language  	break;  case Table.MethodDebugInformation:  	size = GetTableIndexSize (Table.Document) // Document  	+ blobidx_size;  	// SequencePoints  	break;  case Table.LocalScope:  	size = GetTableIndexSize (Table.Method) // Method  	+ GetTableIndexSize (Table.ImportScope) // ImportScope  	+ GetTableIndexSize (Table.LocalVariable) // VariableList  	+ GetTableIndexSize (Table.LocalConstant) // ConstantList  	+ 4 * 2;  	// StartOffset' Length  	break;  case Table.LocalVariable:  	size = 2 // Attributes  	+ 2 // Index  	+ stridx_size;  	// Name  	break;  case Table.LocalConstant:  	size = stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.ImportScope:  	size = GetTableIndexSize (Table.ImportScope) // Parent  	+ blobidx_size;  	break;  case Table.StateMachineMethod:  	size = GetTableIndexSize (Table.Method) // MoveNextMethod  	+ GetTableIndexSize (Table.Method);  	// KickOffMethod  	break;  case Table.CustomDebugInformation:  	size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  	+ guididx_size // Kind  	+ blobidx_size;  	// Value  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (guididx_size * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  	size = 8;  	break;  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  case Table.Document:  	size = blobidx_size // Name  	+ guididx_size // HashAlgorithm  	+ blobidx_size // Hash  	+ guididx_size;  	// Language  	break;  case Table.MethodDebugInformation:  	size = GetTableIndexSize (Table.Document) // Document  	+ blobidx_size;  	// SequencePoints  	break;  case Table.LocalScope:  	size = GetTableIndexSize (Table.Method) // Method  	+ GetTableIndexSize (Table.ImportScope) // ImportScope  	+ GetTableIndexSize (Table.LocalVariable) // VariableList  	+ GetTableIndexSize (Table.LocalConstant) // ConstantList  	+ 4 * 2;  	// StartOffset' Length  	break;  case Table.LocalVariable:  	size = 2 // Attributes  	+ 2 // Index  	+ stridx_size;  	// Name  	break;  case Table.LocalConstant:  	size = stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.ImportScope:  	size = GetTableIndexSize (Table.ImportScope) // Parent  	+ blobidx_size;  	break;  case Table.StateMachineMethod:  	size = GetTableIndexSize (Table.Method) // MoveNextMethod  	+ GetTableIndexSize (Table.Method);  	// KickOffMethod  	break;  case Table.CustomDebugInformation:  	size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  	+ guididx_size // Kind  	+ blobidx_size;  	// Value  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (guididx_size * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  	size = 8;  	break;  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  case Table.Document:  	size = blobidx_size // Name  	+ guididx_size // HashAlgorithm  	+ blobidx_size // Hash  	+ guididx_size;  	// Language  	break;  case Table.MethodDebugInformation:  	size = GetTableIndexSize (Table.Document) // Document  	+ blobidx_size;  	// SequencePoints  	break;  case Table.LocalScope:  	size = GetTableIndexSize (Table.Method) // Method  	+ GetTableIndexSize (Table.ImportScope) // ImportScope  	+ GetTableIndexSize (Table.LocalVariable) // VariableList  	+ GetTableIndexSize (Table.LocalConstant) // ConstantList  	+ 4 * 2;  	// StartOffset' Length  	break;  case Table.LocalVariable:  	size = 2 // Attributes  	+ 2 // Index  	+ stridx_size;  	// Name  	break;  case Table.LocalConstant:  	size = stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.ImportScope:  	size = GetTableIndexSize (Table.ImportScope) // Parent  	+ blobidx_size;  	break;  case Table.StateMachineMethod:  	size = GetTableIndexSize (Table.Method) // MoveNextMethod  	+ GetTableIndexSize (Table.Method);  	// KickOffMethod  	break;  case Table.CustomDebugInformation:  	size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  	+ guididx_size // Kind  	+ blobidx_size;  	// Value  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (guididx_size * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  	size = 8;  	break;  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  case Table.Document:  	size = blobidx_size // Name  	+ guididx_size // HashAlgorithm  	+ blobidx_size // Hash  	+ guididx_size;  	// Language  	break;  case Table.MethodDebugInformation:  	size = GetTableIndexSize (Table.Document) // Document  	+ blobidx_size;  	// SequencePoints  	break;  case Table.LocalScope:  	size = GetTableIndexSize (Table.Method) // Method  	+ GetTableIndexSize (Table.ImportScope) // ImportScope  	+ GetTableIndexSize (Table.LocalVariable) // VariableList  	+ GetTableIndexSize (Table.LocalConstant) // ConstantList  	+ 4 * 2;  	// StartOffset' Length  	break;  case Table.LocalVariable:  	size = 2 // Attributes  	+ 2 // Index  	+ stridx_size;  	// Name  	break;  case Table.LocalConstant:  	size = stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.ImportScope:  	size = GetTableIndexSize (Table.ImportScope) // Parent  	+ blobidx_size;  	break;  case Table.StateMachineMethod:  	size = GetTableIndexSize (Table.Method) // MoveNextMethod  	+ GetTableIndexSize (Table.Method);  	// KickOffMethod  	break;  case Table.CustomDebugInformation:  	size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  	+ guididx_size // Kind  	+ blobidx_size;  	// Value  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (guididx_size * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  	size = 8;  	break;  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  case Table.Document:  	size = blobidx_size // Name  	+ guididx_size // HashAlgorithm  	+ blobidx_size // Hash  	+ guididx_size;  	// Language  	break;  case Table.MethodDebugInformation:  	size = GetTableIndexSize (Table.Document) // Document  	+ blobidx_size;  	// SequencePoints  	break;  case Table.LocalScope:  	size = GetTableIndexSize (Table.Method) // Method  	+ GetTableIndexSize (Table.ImportScope) // ImportScope  	+ GetTableIndexSize (Table.LocalVariable) // VariableList  	+ GetTableIndexSize (Table.LocalConstant) // ConstantList  	+ 4 * 2;  	// StartOffset' Length  	break;  case Table.LocalVariable:  	size = 2 // Attributes  	+ 2 // Index  	+ stridx_size;  	// Name  	break;  case Table.LocalConstant:  	size = stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.ImportScope:  	size = GetTableIndexSize (Table.ImportScope) // Parent  	+ blobidx_size;  	break;  case Table.StateMachineMethod:  	size = GetTableIndexSize (Table.Method) // MoveNextMethod  	+ GetTableIndexSize (Table.Method);  	// KickOffMethod  	break;  case Table.CustomDebugInformation:  	size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  	+ guididx_size // Kind  	+ blobidx_size;  	// Value  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (guididx_size * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  	size = 8;  	break;  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  case Table.Document:  	size = blobidx_size // Name  	+ guididx_size // HashAlgorithm  	+ blobidx_size // Hash  	+ guididx_size;  	// Language  	break;  case Table.MethodDebugInformation:  	size = GetTableIndexSize (Table.Document) // Document  	+ blobidx_size;  	// SequencePoints  	break;  case Table.LocalScope:  	size = GetTableIndexSize (Table.Method) // Method  	+ GetTableIndexSize (Table.ImportScope) // ImportScope  	+ GetTableIndexSize (Table.LocalVariable) // VariableList  	+ GetTableIndexSize (Table.LocalConstant) // ConstantList  	+ 4 * 2;  	// StartOffset' Length  	break;  case Table.LocalVariable:  	size = 2 // Attributes  	+ 2 // Index  	+ stridx_size;  	// Name  	break;  case Table.LocalConstant:  	size = stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.ImportScope:  	size = GetTableIndexSize (Table.ImportScope) // Parent  	+ blobidx_size;  	break;  case Table.StateMachineMethod:  	size = GetTableIndexSize (Table.Method) // MoveNextMethod  	+ GetTableIndexSize (Table.Method);  	// KickOffMethod  	break;  case Table.CustomDebugInformation:  	size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  	+ guididx_size // Kind  	+ blobidx_size;  	// Value  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (guididx_size * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  	size = 8;  	break;  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  case Table.Document:  	size = blobidx_size // Name  	+ guididx_size // HashAlgorithm  	+ blobidx_size // Hash  	+ guididx_size;  	// Language  	break;  case Table.MethodDebugInformation:  	size = GetTableIndexSize (Table.Document) // Document  	+ blobidx_size;  	// SequencePoints  	break;  case Table.LocalScope:  	size = GetTableIndexSize (Table.Method) // Method  	+ GetTableIndexSize (Table.ImportScope) // ImportScope  	+ GetTableIndexSize (Table.LocalVariable) // VariableList  	+ GetTableIndexSize (Table.LocalConstant) // ConstantList  	+ 4 * 2;  	// StartOffset' Length  	break;  case Table.LocalVariable:  	size = 2 // Attributes  	+ 2 // Index  	+ stridx_size;  	// Name  	break;  case Table.LocalConstant:  	size = stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.ImportScope:  	size = GetTableIndexSize (Table.ImportScope) // Parent  	+ blobidx_size;  	break;  case Table.StateMachineMethod:  	size = GetTableIndexSize (Table.Method) // MoveNextMethod  	+ GetTableIndexSize (Table.Method);  	// KickOffMethod  	break;  case Table.CustomDebugInformation:  	size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  	+ guididx_size // Kind  	+ blobidx_size;  	// Value  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (guididx_size * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  	size = 8;  	break;  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  case Table.Document:  	size = blobidx_size // Name  	+ guididx_size // HashAlgorithm  	+ blobidx_size // Hash  	+ guididx_size;  	// Language  	break;  case Table.MethodDebugInformation:  	size = GetTableIndexSize (Table.Document) // Document  	+ blobidx_size;  	// SequencePoints  	break;  case Table.LocalScope:  	size = GetTableIndexSize (Table.Method) // Method  	+ GetTableIndexSize (Table.ImportScope) // ImportScope  	+ GetTableIndexSize (Table.LocalVariable) // VariableList  	+ GetTableIndexSize (Table.LocalConstant) // ConstantList  	+ 4 * 2;  	// StartOffset' Length  	break;  case Table.LocalVariable:  	size = 2 // Attributes  	+ 2 // Index  	+ stridx_size;  	// Name  	break;  case Table.LocalConstant:  	size = stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.ImportScope:  	size = GetTableIndexSize (Table.ImportScope) // Parent  	+ blobidx_size;  	break;  case Table.StateMachineMethod:  	size = GetTableIndexSize (Table.Method) // MoveNextMethod  	+ GetTableIndexSize (Table.Method);  	// KickOffMethod  	break;  case Table.CustomDebugInformation:  	size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  	+ guididx_size // Kind  	+ blobidx_size;  	// Value  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (guididx_size * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  	size = 8;  	break;  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  case Table.Document:  	size = blobidx_size // Name  	+ guididx_size // HashAlgorithm  	+ blobidx_size // Hash  	+ guididx_size;  	// Language  	break;  case Table.MethodDebugInformation:  	size = GetTableIndexSize (Table.Document) // Document  	+ blobidx_size;  	// SequencePoints  	break;  case Table.LocalScope:  	size = GetTableIndexSize (Table.Method) // Method  	+ GetTableIndexSize (Table.ImportScope) // ImportScope  	+ GetTableIndexSize (Table.LocalVariable) // VariableList  	+ GetTableIndexSize (Table.LocalConstant) // ConstantList  	+ 4 * 2;  	// StartOffset' Length  	break;  case Table.LocalVariable:  	size = 2 // Attributes  	+ 2 // Index  	+ stridx_size;  	// Name  	break;  case Table.LocalConstant:  	size = stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.ImportScope:  	size = GetTableIndexSize (Table.ImportScope) // Parent  	+ blobidx_size;  	break;  case Table.StateMachineMethod:  	size = GetTableIndexSize (Table.Method) // MoveNextMethod  	+ GetTableIndexSize (Table.Method);  	// KickOffMethod  	break;  case Table.CustomDebugInformation:  	size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  	+ guididx_size // Kind  	+ blobidx_size;  	// Value  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (guididx_size * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  	size = 8;  	break;  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  case Table.Document:  	size = blobidx_size // Name  	+ guididx_size // HashAlgorithm  	+ blobidx_size // Hash  	+ guididx_size;  	// Language  	break;  case Table.MethodDebugInformation:  	size = GetTableIndexSize (Table.Document) // Document  	+ blobidx_size;  	// SequencePoints  	break;  case Table.LocalScope:  	size = GetTableIndexSize (Table.Method) // Method  	+ GetTableIndexSize (Table.ImportScope) // ImportScope  	+ GetTableIndexSize (Table.LocalVariable) // VariableList  	+ GetTableIndexSize (Table.LocalConstant) // ConstantList  	+ 4 * 2;  	// StartOffset' Length  	break;  case Table.LocalVariable:  	size = 2 // Attributes  	+ 2 // Index  	+ stridx_size;  	// Name  	break;  case Table.LocalConstant:  	size = stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.ImportScope:  	size = GetTableIndexSize (Table.ImportScope) // Parent  	+ blobidx_size;  	break;  case Table.StateMachineMethod:  	size = GetTableIndexSize (Table.Method) // MoveNextMethod  	+ GetTableIndexSize (Table.Method);  	// KickOffMethod  	break;  case Table.CustomDebugInformation:  	size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  	+ guididx_size // Kind  	+ blobidx_size;  	// Value  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (guididx_size * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  	size = 8;  	break;  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  case Table.Document:  	size = blobidx_size // Name  	+ guididx_size // HashAlgorithm  	+ blobidx_size // Hash  	+ guididx_size;  	// Language  	break;  case Table.MethodDebugInformation:  	size = GetTableIndexSize (Table.Document) // Document  	+ blobidx_size;  	// SequencePoints  	break;  case Table.LocalScope:  	size = GetTableIndexSize (Table.Method) // Method  	+ GetTableIndexSize (Table.ImportScope) // ImportScope  	+ GetTableIndexSize (Table.LocalVariable) // VariableList  	+ GetTableIndexSize (Table.LocalConstant) // ConstantList  	+ 4 * 2;  	// StartOffset' Length  	break;  case Table.LocalVariable:  	size = 2 // Attributes  	+ 2 // Index  	+ stridx_size;  	// Name  	break;  case Table.LocalConstant:  	size = stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.ImportScope:  	size = GetTableIndexSize (Table.ImportScope) // Parent  	+ blobidx_size;  	break;  case Table.StateMachineMethod:  	size = GetTableIndexSize (Table.Method) // MoveNextMethod  	+ GetTableIndexSize (Table.Method);  	// KickOffMethod  	break;  case Table.CustomDebugInformation:  	size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  	+ guididx_size // Kind  	+ blobidx_size;  	// Value  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: switch (table) {  case Table.Module:  	size = 2 // Generation  	+ stridx_size // Name  	+ (guididx_size * 3);  	// Mvid' EncId' EncBaseId  	break;  case Table.TypeRef:  	size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  	+ (stridx_size * 2);  	// Name' Namespace  	break;  case Table.TypeDef:  	size = 4 // Flags  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  	+ GetTableIndexSize (Table.Field) // FieldList  	+ GetTableIndexSize (Table.Method);  	// MethodList  	break;  case Table.FieldPtr:  	size = GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.Field:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.MethodPtr:  	size = GetTableIndexSize (Table.Method);  	// Method  	break;  case Table.Method:  	size = 8 // Rva 4' ImplFlags 2' Flags 2  	+ stridx_size // Name  	+ blobidx_size // Signature  	+ GetTableIndexSize (Table.Param);  	// ParamList  	break;  case Table.ParamPtr:  	size = GetTableIndexSize (Table.Param);  	// Param  	break;  case Table.Param:  	size = 4 // Flags 2' Sequence 2  	+ stridx_size;  	// Name  	break;  case Table.InterfaceImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Interface  	break;  case Table.MemberRef:  	size = GetCodedIndexSize (CodedIndex.MemberRefParent) // Class  	+ stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.Constant:  	size = 2 // Type  	+ GetCodedIndexSize (CodedIndex.HasConstant) // Parent  	+ blobidx_size;  	// Value  	break;  case Table.CustomAttribute:  	size = GetCodedIndexSize (CodedIndex.HasCustomAttribute) // Parent  	+ GetCodedIndexSize (CodedIndex.CustomAttributeType) // Type  	+ blobidx_size;  	// Value  	break;  case Table.FieldMarshal:  	size = GetCodedIndexSize (CodedIndex.HasFieldMarshal) // Parent  	+ blobidx_size;  	// NativeType  	break;  case Table.DeclSecurity:  	size = 2 // Action  	+ GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  	+ blobidx_size;  	// PermissionSet  	break;  case Table.ClassLayout:  	size = 6 // PackingSize 2' ClassSize 4  	+ GetTableIndexSize (Table.TypeDef);  	// Parent  	break;  case Table.FieldLayout:  	size = 4 // Offset  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.StandAloneSig:  	size = blobidx_size;  	// Signature  	break;  case Table.EventMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Event);  	// EventList  	break;  case Table.EventPtr:  	size = GetTableIndexSize (Table.Event);  	// Event  	break;  case Table.Event:  	size = 2 // Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// EventType  	break;  case Table.PropertyMap:  	size = GetTableIndexSize (Table.TypeDef) // Parent  	+ GetTableIndexSize (Table.Property);  	// PropertyList  	break;  case Table.PropertyPtr:  	size = GetTableIndexSize (Table.Property);  	// Property  	break;  case Table.Property:  	size = 2 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// Type  	break;  case Table.MethodSemantics:  	size = 2 // Semantics  	+ GetTableIndexSize (Table.Method) // Method  	+ GetCodedIndexSize (CodedIndex.HasSemantics);  	// Association  	break;  case Table.MethodImpl:  	size = GetTableIndexSize (Table.TypeDef) // Class  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody  	+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);  	// MethodDeclaration  	break;  case Table.ModuleRef:  	size = stridx_size;  	// Name  	break;  case Table.TypeSpec:  	size = blobidx_size;  	// Signature  	break;  case Table.ImplMap:  	size = 2 // MappingFlags  	+ GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  	+ stridx_size // ImportName  	+ GetTableIndexSize (Table.ModuleRef);  	// ImportScope  	break;  case Table.FieldRVA:  	size = 4 // RVA  	+ GetTableIndexSize (Table.Field);  	// Field  	break;  case Table.EncLog:  	size = 8;  	break;  case Table.EncMap:  	size = 4;  	break;  case Table.Assembly:  	size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  	+ blobidx_size // PublicKey  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyProcessor:  	size = 4;  	// Processor  	break;  case Table.AssemblyOS:  	size = 12;  	// Platform 4' Version 2 * 4  	break;  case Table.AssemblyRef:  	size = 12 // Version 2 * 4 + Flags 4  	+ (blobidx_size * 2) // PublicKeyOrToken' HashValue  	+ (stridx_size * 2);  	// Name' Culture  	break;  case Table.AssemblyRefProcessor:  	size = 4 // Processor  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.AssemblyRefOS:  	size = 12 // Platform 4' Version 2 * 4  	+ GetTableIndexSize (Table.AssemblyRef);  	// AssemblyRef  	break;  case Table.File:  	size = 4 // Flags  	+ stridx_size // Name  	+ blobidx_size;  	// HashValue  	break;  case Table.ExportedType:  	size = 8 // Flags 4' TypeDefId 4  	+ (stridx_size * 2) // Name' Namespace  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.ManifestResource:  	size = 8 // Offset' Flags  	+ stridx_size // Name  	+ GetCodedIndexSize (CodedIndex.Implementation);  	// Implementation  	break;  case Table.NestedClass:  	size = GetTableIndexSize (Table.TypeDef) // NestedClass  	+ GetTableIndexSize (Table.TypeDef);  	// EnclosingClass  	break;  case Table.GenericParam:  	size = 4 // Number' Flags  	+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  	+ stridx_size;  	// Name  	break;  case Table.MethodSpec:  	size = GetCodedIndexSize (CodedIndex.MethodDefOrRef) // Method  	+ blobidx_size;  	// Instantiation  	break;  case Table.GenericParamConstraint:  	size = GetTableIndexSize (Table.GenericParam) // Owner  	+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  	// Constraint  	break;  case Table.Document:  	size = blobidx_size // Name  	+ guididx_size // HashAlgorithm  	+ blobidx_size // Hash  	+ guididx_size;  	// Language  	break;  case Table.MethodDebugInformation:  	size = GetTableIndexSize (Table.Document) // Document  	+ blobidx_size;  	// SequencePoints  	break;  case Table.LocalScope:  	size = GetTableIndexSize (Table.Method) // Method  	+ GetTableIndexSize (Table.ImportScope) // ImportScope  	+ GetTableIndexSize (Table.LocalVariable) // VariableList  	+ GetTableIndexSize (Table.LocalConstant) // ConstantList  	+ 4 * 2;  	// StartOffset' Length  	break;  case Table.LocalVariable:  	size = 2 // Attributes  	+ 2 // Index  	+ stridx_size;  	// Name  	break;  case Table.LocalConstant:  	size = stridx_size // Name  	+ blobidx_size;  	// Signature  	break;  case Table.ImportScope:  	size = GetTableIndexSize (Table.ImportScope) // Parent  	+ blobidx_size;  	break;  case Table.StateMachineMethod:  	size = GetTableIndexSize (Table.Method) // MoveNextMethod  	+ GetTableIndexSize (Table.Method);  	// KickOffMethod  	break;  case Table.CustomDebugInformation:  	size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent  	+ guididx_size // Kind  	+ blobidx_size;  	// Value  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 2 // Generation  + stridx_size // Name  + (guididx_size * 3);  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 2 // Generation  + stridx_size // Name  + (guididx_size * 3);  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = GetCodedIndexSize (CodedIndex.ResolutionScope) // ResolutionScope  + (stridx_size * 2);  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 4 // Flags  + (stridx_size * 2) // Name' Namespace  + GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  + GetTableIndexSize (Table.Field) // FieldList  + GetTableIndexSize (Table.Method);  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 4 // Flags  + (stridx_size * 2) // Name' Namespace  + GetCodedIndexSize (CodedIndex.TypeDefOrRef) // BaseType  + GetTableIndexSize (Table.Field) // FieldList  + GetTableIndexSize (Table.Method);  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 2 // Flags  + stridx_size // Name  + blobidx_size;  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 8 // Rva 4' ImplFlags 2' Flags 2  + stridx_size // Name  + blobidx_size // Signature  + GetTableIndexSize (Table.Param);  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 4 // Flags 2' Sequence 2  + stridx_size;  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 2 // Type  + GetCodedIndexSize (CodedIndex.HasConstant) // Parent  + blobidx_size;  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 2 // Action  + GetCodedIndexSize (CodedIndex.HasDeclSecurity) // Parent  + blobidx_size;  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 6 // PackingSize 2' ClassSize 4  + GetTableIndexSize (Table.TypeDef);  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 4 // Offset  + GetTableIndexSize (Table.Field);  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 2 // Flags  + stridx_size // Name  + GetCodedIndexSize (CodedIndex.TypeDefOrRef);  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 2 // Flags  + stridx_size // Name  + blobidx_size;  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 2 // Semantics  + GetTableIndexSize (Table.Method) // Method  + GetCodedIndexSize (CodedIndex.HasSemantics);  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 2 // MappingFlags  + GetCodedIndexSize (CodedIndex.MemberForwarded) // MemberForwarded  + stridx_size // ImportName  + GetTableIndexSize (Table.ModuleRef);  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 4 // RVA  + GetTableIndexSize (Table.Field);  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 8;  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 4;  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  + blobidx_size // PublicKey  + (stridx_size * 2);  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 16 // HashAlgId 4' Version 4 * 2' Flags 4  + blobidx_size // PublicKey  + (stridx_size * 2);  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 4;  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 12;  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 12 // Version 2 * 4 + Flags 4  + (blobidx_size * 2) // PublicKeyOrToken' HashValue  + (stridx_size * 2);  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 12 // Version 2 * 4 + Flags 4  + (blobidx_size * 2) // PublicKeyOrToken' HashValue  + (stridx_size * 2);  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 12 // Version 2 * 4 + Flags 4  + (blobidx_size * 2) // PublicKeyOrToken' HashValue  + (stridx_size * 2);  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 4 // Processor  + GetTableIndexSize (Table.AssemblyRef);  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 12 // Platform 4' Version 2 * 4  + GetTableIndexSize (Table.AssemblyRef);  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 4 // Flags  + stridx_size // Name  + blobidx_size;  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 8 // Flags 4' TypeDefId 4  + (stridx_size * 2) // Name' Namespace  + GetCodedIndexSize (CodedIndex.Implementation);  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 8 // Flags 4' TypeDefId 4  + (stridx_size * 2) // Name' Namespace  + GetCodedIndexSize (CodedIndex.Implementation);  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 8 // Offset' Flags  + stridx_size // Name  + GetCodedIndexSize (CodedIndex.Implementation);  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 4 // Number' Flags  + GetCodedIndexSize (CodedIndex.TypeOrMethodDef) // Owner  + stridx_size;  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = GetTableIndexSize (Table.Method) // Method  + GetTableIndexSize (Table.ImportScope) // ImportScope  + GetTableIndexSize (Table.LocalVariable) // VariableList  + GetTableIndexSize (Table.LocalConstant) // ConstantList  + 4 * 2;  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = GetTableIndexSize (Table.Method) // Method  + GetTableIndexSize (Table.ImportScope) // ImportScope  + GetTableIndexSize (Table.LocalVariable) // VariableList  + GetTableIndexSize (Table.LocalConstant) // ConstantList  + 4 * 2;  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 2 // Attributes  + 2 // Index  + stridx_size;  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ComputeTableInformations,The following statement contains a magic number: size = 2 // Attributes  + 2 // Index  + stridx_size;  
Magic Number,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ReadPdbHeap,The following statement contains a magic number: heap.Id = buffer.ReadBytes (20);  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,ImageWriter,The following statement contains a magic number: this.sections = (ushort)(has_reloc ? 2 : 1);  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,WriteOptionalHeaders,The following statement contains a magic number: WriteByte (8);  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,WriteOptionalHeaders,The following statement contains a magic number: WriteUInt16 (4);  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,WriteOptionalHeaders,The following statement contains a magic number: WriteUInt16 (4);  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,WriteOptionalHeaders,The following statement contains a magic number: WriteUInt32 (16);  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,WriteText,The following statement contains a magic number: WriteUInt16 (2);  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,WriteText,The following statement contains a magic number: WriteUInt16 ((ushort)((module.Runtime <= TargetRuntime.Net_1_1) ? 0 : 5));  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,GetZeroTerminatedStringLength,The following statement contains a magic number: return (@string.Length + 1 + 3) & ~3;  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,GetZeroTerminatedStringLength,The following statement contains a magic number: return (@string.Length + 1 + 3) & ~3;  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,WriteImportDirectory,The following statement contains a magic number: WriteUInt32 (text_map.GetRVA (TextSegment.ImportDirectory) + 40);  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,WriteImportDirectory,The following statement contains a magic number: WriteUInt32 (text_map.GetRVA (TextSegment.ImportHintNameTable) + 14);  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,WriteImportDirectory,The following statement contains a magic number: Advance (20);  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,WriteReloc,The following statement contains a magic number: reloc_rva += module.Architecture == TargetArchitecture.IA64 ? 0x20u : 2;  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,BuildTextMap,The following statement contains a magic number: map.AddMap (TextSegment.Code' metadata.code.length' !pe64 ? 4 : 16);  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,BuildTextMap,The following statement contains a magic number: map.AddMap (TextSegment.Code' metadata.code.length' !pe64 ? 4 : 16);  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,BuildTextMap,The following statement contains a magic number: map.AddMap (TextSegment.Resources' metadata.resources.length' 8);  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,BuildTextMap,The following statement contains a magic number: map.AddMap (TextSegment.Data' metadata.data.length' 4);  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,BuildTextMap,The following statement contains a magic number: map.AddMap (TextSegment.StrongNameSignature' GetStrongNameLength ()' 4);  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,BuildTextMap,The following statement contains a magic number: map.AddMap (TextSegment.DebugDirectory' debug_dir_len' 4);  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,BuildTextMap,The following statement contains a magic number: startup_stub_rva = module.Architecture == TargetArchitecture.IA64 ? (startup_stub_rva + 15u) & ~15u : 2 + ((startup_stub_rva + 3u) & ~3u);  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,BuildMetadataTextMap,The following statement contains a magic number: map.AddMap (TextSegment.TableHeap' metadata.table_heap.length' 4);  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,BuildMetadataTextMap,The following statement contains a magic number: map.AddMap (TextSegment.StringHeap' metadata.string_heap.length' 4);  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,BuildMetadataTextMap,The following statement contains a magic number: map.AddMap (TextSegment.UserStringHeap' metadata.user_string_heap.IsEmpty ? 0 : metadata.user_string_heap.length' 4);  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,BuildMetadataTextMap,The following statement contains a magic number: map.AddMap (TextSegment.GuidHeap' metadata.guid_heap.length' 4);  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,BuildMetadataTextMap,The following statement contains a magic number: map.AddMap (TextSegment.BlobHeap' metadata.blob_heap.IsEmpty ? 0 : metadata.blob_heap.length' 4);  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,BuildMetadataTextMap,The following statement contains a magic number: map.AddMap (TextSegment.PdbHeap' metadata.pdb_heap == null ? 0 : metadata.pdb_heap.length' 4);  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,GetStartupStubLength,The following statement contains a magic number: switch (module.Architecture) {  case TargetArchitecture.I386:  	return 6;  default:  	throw new NotSupportedException ();  }  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,GetStartupStubLength,The following statement contains a magic number: return 6;  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,GetMetadataHeaderLength,The following statement contains a magic number: return // MetadataHeader  20 + GetZeroTerminatedStringLength (runtimeVersion) // #~ header  + 12 // #Strings header  + 20 // #US header  + (metadata.user_string_heap.IsEmpty ? 0 : 12) // #GUID header  + 16 // #Blob header  + (metadata.blob_heap.IsEmpty ? 0 : 16) //  + (metadata.pdb_heap == null ? 0 : 16);  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,GetMetadataHeaderLength,The following statement contains a magic number: return // MetadataHeader  20 + GetZeroTerminatedStringLength (runtimeVersion) // #~ header  + 12 // #Strings header  + 20 // #US header  + (metadata.user_string_heap.IsEmpty ? 0 : 12) // #GUID header  + 16 // #Blob header  + (metadata.blob_heap.IsEmpty ? 0 : 16) //  + (metadata.pdb_heap == null ? 0 : 16);  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,GetMetadataHeaderLength,The following statement contains a magic number: return // MetadataHeader  20 + GetZeroTerminatedStringLength (runtimeVersion) // #~ header  + 12 // #Strings header  + 20 // #US header  + (metadata.user_string_heap.IsEmpty ? 0 : 12) // #GUID header  + 16 // #Blob header  + (metadata.blob_heap.IsEmpty ? 0 : 16) //  + (metadata.pdb_heap == null ? 0 : 16);  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,GetMetadataHeaderLength,The following statement contains a magic number: return // MetadataHeader  20 + GetZeroTerminatedStringLength (runtimeVersion) // #~ header  + 12 // #Strings header  + 20 // #US header  + (metadata.user_string_heap.IsEmpty ? 0 : 12) // #GUID header  + 16 // #Blob header  + (metadata.blob_heap.IsEmpty ? 0 : 16) //  + (metadata.pdb_heap == null ? 0 : 16);  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,GetMetadataHeaderLength,The following statement contains a magic number: return // MetadataHeader  20 + GetZeroTerminatedStringLength (runtimeVersion) // #~ header  + 12 // #Strings header  + 20 // #US header  + (metadata.user_string_heap.IsEmpty ? 0 : 12) // #GUID header  + 16 // #Blob header  + (metadata.blob_heap.IsEmpty ? 0 : 16) //  + (metadata.pdb_heap == null ? 0 : 16);  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,GetMetadataHeaderLength,The following statement contains a magic number: return // MetadataHeader  20 + GetZeroTerminatedStringLength (runtimeVersion) // #~ header  + 12 // #Strings header  + 20 // #US header  + (metadata.user_string_heap.IsEmpty ? 0 : 12) // #GUID header  + 16 // #Blob header  + (metadata.blob_heap.IsEmpty ? 0 : 16) //  + (metadata.pdb_heap == null ? 0 : 16);  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,GetMetadataHeaderLength,The following statement contains a magic number: return // MetadataHeader  20 + GetZeroTerminatedStringLength (runtimeVersion) // #~ header  + 12 // #Strings header  + 20 // #US header  + (metadata.user_string_heap.IsEmpty ? 0 : 12) // #GUID header  + 16 // #Blob header  + (metadata.blob_heap.IsEmpty ? 0 : 16) //  + (metadata.pdb_heap == null ? 0 : 16);  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,GetStrongNameLength,The following statement contains a magic number: if (size > 32)  	return size - 32;  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,GetStrongNameLength,The following statement contains a magic number: if (size > 32)  	return size - 32;  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,GetStrongNameLength,The following statement contains a magic number: return size - 32;  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,GetStrongNameLength,The following statement contains a magic number: return 128;  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,PatchResourceDirectoryTable,The following statement contains a magic number: resources.Advance (12);  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,PatchResourceDirectoryEntry,The following statement contains a magic number: resources.Advance (4);  
Magic Number,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,PatchResourceDataEntry,The following statement contains a magic number: resources.position -= 4;  
Magic Number,Mono.Collections.Generic,Collection,F:\newReposMay17\jbevain_cecil\Mono.Collections.Generic\Collection.cs,Grow,The following statement contains a magic number: new_size = System.Math.Max (System.Math.Max (items.Length * 2' default_capacity)' new_size);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,ToInt32LE,The following statement contains a magic number: return (bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,ToInt32LE,The following statement contains a magic number: return (bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,ToInt32LE,The following statement contains a magic number: return (bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,ToInt32LE,The following statement contains a magic number: return (bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,ToInt32LE,The following statement contains a magic number: return (bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,ToUInt32LE,The following statement contains a magic number: return (uint)((bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset]);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,ToUInt32LE,The following statement contains a magic number: return (uint)((bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset]);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,ToUInt32LE,The following statement contains a magic number: return (uint)((bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset]);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,ToUInt32LE,The following statement contains a magic number: return (uint)((bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset]);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,ToUInt32LE,The following statement contains a magic number: return (uint)((bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset]);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  		// DWORD magic = RSA2  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	byte[] exp = new byte[4];  	Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  	Array.Reverse (exp);  	rsap.Exponent = Trim (exp);  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	pos += byteLen;  	// BYTE prime1[rsapubkey.bitlen/16];  	int byteHalfLen = (byteLen >> 1);  	rsap.P = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.P' 0' byteHalfLen);  	Array.Reverse (rsap.P);  	pos += byteHalfLen;  	// BYTE prime2[rsapubkey.bitlen/16];  	rsap.Q = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.Q' 0' byteHalfLen);  	Array.Reverse (rsap.Q);  	pos += byteHalfLen;  	// BYTE exponent1[rsapubkey.bitlen/16];  	rsap.DP = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DP' 0' byteHalfLen);  	Array.Reverse (rsap.DP);  	pos += byteHalfLen;  	// BYTE exponent2[rsapubkey.bitlen/16];  	rsap.DQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DQ' 0' byteHalfLen);  	Array.Reverse (rsap.DQ);  	pos += byteHalfLen;  	// BYTE coefficient[rsapubkey.bitlen/16];  	rsap.InverseQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.InverseQ' 0' byteHalfLen);  	Array.Reverse (rsap.InverseQ);  	pos += byteHalfLen;  	// ok' this is hackish but CryptoAPI support it so...  	// note: only works because CRT is used by default  	// http://bugzilla.ximian.com/show_bug.cgi?id=57941  	rsap.D = new byte[byteLen];  	// must be allocated  	if (pos + byteLen + offset <= blob.Length) {  		// BYTE privateExponent[rsapubkey.bitlen/8];  		Buffer.BlockCopy (blob' pos' rsap.D' 0' byteLen);  		Array.Reverse (rsap.D);  	}  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  		// DWORD magic = RSA2  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	byte[] exp = new byte[4];  	Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  	Array.Reverse (exp);  	rsap.Exponent = Trim (exp);  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	pos += byteLen;  	// BYTE prime1[rsapubkey.bitlen/16];  	int byteHalfLen = (byteLen >> 1);  	rsap.P = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.P' 0' byteHalfLen);  	Array.Reverse (rsap.P);  	pos += byteHalfLen;  	// BYTE prime2[rsapubkey.bitlen/16];  	rsap.Q = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.Q' 0' byteHalfLen);  	Array.Reverse (rsap.Q);  	pos += byteHalfLen;  	// BYTE exponent1[rsapubkey.bitlen/16];  	rsap.DP = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DP' 0' byteHalfLen);  	Array.Reverse (rsap.DP);  	pos += byteHalfLen;  	// BYTE exponent2[rsapubkey.bitlen/16];  	rsap.DQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DQ' 0' byteHalfLen);  	Array.Reverse (rsap.DQ);  	pos += byteHalfLen;  	// BYTE coefficient[rsapubkey.bitlen/16];  	rsap.InverseQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.InverseQ' 0' byteHalfLen);  	Array.Reverse (rsap.InverseQ);  	pos += byteHalfLen;  	// ok' this is hackish but CryptoAPI support it so...  	// note: only works because CRT is used by default  	// http://bugzilla.ximian.com/show_bug.cgi?id=57941  	rsap.D = new byte[byteLen];  	// must be allocated  	if (pos + byteLen + offset <= blob.Length) {  		// BYTE privateExponent[rsapubkey.bitlen/8];  		Buffer.BlockCopy (blob' pos' rsap.D' 0' byteLen);  		Array.Reverse (rsap.D);  	}  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  		// DWORD magic = RSA2  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	byte[] exp = new byte[4];  	Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  	Array.Reverse (exp);  	rsap.Exponent = Trim (exp);  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	pos += byteLen;  	// BYTE prime1[rsapubkey.bitlen/16];  	int byteHalfLen = (byteLen >> 1);  	rsap.P = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.P' 0' byteHalfLen);  	Array.Reverse (rsap.P);  	pos += byteHalfLen;  	// BYTE prime2[rsapubkey.bitlen/16];  	rsap.Q = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.Q' 0' byteHalfLen);  	Array.Reverse (rsap.Q);  	pos += byteHalfLen;  	// BYTE exponent1[rsapubkey.bitlen/16];  	rsap.DP = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DP' 0' byteHalfLen);  	Array.Reverse (rsap.DP);  	pos += byteHalfLen;  	// BYTE exponent2[rsapubkey.bitlen/16];  	rsap.DQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DQ' 0' byteHalfLen);  	Array.Reverse (rsap.DQ);  	pos += byteHalfLen;  	// BYTE coefficient[rsapubkey.bitlen/16];  	rsap.InverseQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.InverseQ' 0' byteHalfLen);  	Array.Reverse (rsap.InverseQ);  	pos += byteHalfLen;  	// ok' this is hackish but CryptoAPI support it so...  	// note: only works because CRT is used by default  	// http://bugzilla.ximian.com/show_bug.cgi?id=57941  	rsap.D = new byte[byteLen];  	// must be allocated  	if (pos + byteLen + offset <= blob.Length) {  		// BYTE privateExponent[rsapubkey.bitlen/8];  		Buffer.BlockCopy (blob' pos' rsap.D' 0' byteLen);  		Array.Reverse (rsap.D);  	}  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  		// DWORD magic = RSA2  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	byte[] exp = new byte[4];  	Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  	Array.Reverse (exp);  	rsap.Exponent = Trim (exp);  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	pos += byteLen;  	// BYTE prime1[rsapubkey.bitlen/16];  	int byteHalfLen = (byteLen >> 1);  	rsap.P = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.P' 0' byteHalfLen);  	Array.Reverse (rsap.P);  	pos += byteHalfLen;  	// BYTE prime2[rsapubkey.bitlen/16];  	rsap.Q = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.Q' 0' byteHalfLen);  	Array.Reverse (rsap.Q);  	pos += byteHalfLen;  	// BYTE exponent1[rsapubkey.bitlen/16];  	rsap.DP = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DP' 0' byteHalfLen);  	Array.Reverse (rsap.DP);  	pos += byteHalfLen;  	// BYTE exponent2[rsapubkey.bitlen/16];  	rsap.DQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DQ' 0' byteHalfLen);  	Array.Reverse (rsap.DQ);  	pos += byteHalfLen;  	// BYTE coefficient[rsapubkey.bitlen/16];  	rsap.InverseQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.InverseQ' 0' byteHalfLen);  	Array.Reverse (rsap.InverseQ);  	pos += byteHalfLen;  	// ok' this is hackish but CryptoAPI support it so...  	// note: only works because CRT is used by default  	// http://bugzilla.ximian.com/show_bug.cgi?id=57941  	rsap.D = new byte[byteLen];  	// must be allocated  	if (pos + byteLen + offset <= blob.Length) {  		// BYTE privateExponent[rsapubkey.bitlen/8];  		Buffer.BlockCopy (blob' pos' rsap.D' 0' byteLen);  		Array.Reverse (rsap.D);  	}  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  		// DWORD magic = RSA2  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	byte[] exp = new byte[4];  	Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  	Array.Reverse (exp);  	rsap.Exponent = Trim (exp);  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	pos += byteLen;  	// BYTE prime1[rsapubkey.bitlen/16];  	int byteHalfLen = (byteLen >> 1);  	rsap.P = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.P' 0' byteHalfLen);  	Array.Reverse (rsap.P);  	pos += byteHalfLen;  	// BYTE prime2[rsapubkey.bitlen/16];  	rsap.Q = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.Q' 0' byteHalfLen);  	Array.Reverse (rsap.Q);  	pos += byteHalfLen;  	// BYTE exponent1[rsapubkey.bitlen/16];  	rsap.DP = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DP' 0' byteHalfLen);  	Array.Reverse (rsap.DP);  	pos += byteHalfLen;  	// BYTE exponent2[rsapubkey.bitlen/16];  	rsap.DQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DQ' 0' byteHalfLen);  	Array.Reverse (rsap.DQ);  	pos += byteHalfLen;  	// BYTE coefficient[rsapubkey.bitlen/16];  	rsap.InverseQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.InverseQ' 0' byteHalfLen);  	Array.Reverse (rsap.InverseQ);  	pos += byteHalfLen;  	// ok' this is hackish but CryptoAPI support it so...  	// note: only works because CRT is used by default  	// http://bugzilla.ximian.com/show_bug.cgi?id=57941  	rsap.D = new byte[byteLen];  	// must be allocated  	if (pos + byteLen + offset <= blob.Length) {  		// BYTE privateExponent[rsapubkey.bitlen/8];  		Buffer.BlockCopy (blob' pos' rsap.D' 0' byteLen);  		Array.Reverse (rsap.D);  	}  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  		// DWORD magic = RSA2  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	byte[] exp = new byte[4];  	Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  	Array.Reverse (exp);  	rsap.Exponent = Trim (exp);  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	pos += byteLen;  	// BYTE prime1[rsapubkey.bitlen/16];  	int byteHalfLen = (byteLen >> 1);  	rsap.P = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.P' 0' byteHalfLen);  	Array.Reverse (rsap.P);  	pos += byteHalfLen;  	// BYTE prime2[rsapubkey.bitlen/16];  	rsap.Q = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.Q' 0' byteHalfLen);  	Array.Reverse (rsap.Q);  	pos += byteHalfLen;  	// BYTE exponent1[rsapubkey.bitlen/16];  	rsap.DP = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DP' 0' byteHalfLen);  	Array.Reverse (rsap.DP);  	pos += byteHalfLen;  	// BYTE exponent2[rsapubkey.bitlen/16];  	rsap.DQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DQ' 0' byteHalfLen);  	Array.Reverse (rsap.DQ);  	pos += byteHalfLen;  	// BYTE coefficient[rsapubkey.bitlen/16];  	rsap.InverseQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.InverseQ' 0' byteHalfLen);  	Array.Reverse (rsap.InverseQ);  	pos += byteHalfLen;  	// ok' this is hackish but CryptoAPI support it so...  	// note: only works because CRT is used by default  	// http://bugzilla.ximian.com/show_bug.cgi?id=57941  	rsap.D = new byte[byteLen];  	// must be allocated  	if (pos + byteLen + offset <= blob.Length) {  		// BYTE privateExponent[rsapubkey.bitlen/8];  		Buffer.BlockCopy (blob' pos' rsap.D' 0' byteLen);  		Array.Reverse (rsap.D);  	}  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  		// DWORD magic = RSA2  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	byte[] exp = new byte[4];  	Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  	Array.Reverse (exp);  	rsap.Exponent = Trim (exp);  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	pos += byteLen;  	// BYTE prime1[rsapubkey.bitlen/16];  	int byteHalfLen = (byteLen >> 1);  	rsap.P = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.P' 0' byteHalfLen);  	Array.Reverse (rsap.P);  	pos += byteHalfLen;  	// BYTE prime2[rsapubkey.bitlen/16];  	rsap.Q = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.Q' 0' byteHalfLen);  	Array.Reverse (rsap.Q);  	pos += byteHalfLen;  	// BYTE exponent1[rsapubkey.bitlen/16];  	rsap.DP = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DP' 0' byteHalfLen);  	Array.Reverse (rsap.DP);  	pos += byteHalfLen;  	// BYTE exponent2[rsapubkey.bitlen/16];  	rsap.DQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DQ' 0' byteHalfLen);  	Array.Reverse (rsap.DQ);  	pos += byteHalfLen;  	// BYTE coefficient[rsapubkey.bitlen/16];  	rsap.InverseQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.InverseQ' 0' byteHalfLen);  	Array.Reverse (rsap.InverseQ);  	pos += byteHalfLen;  	// ok' this is hackish but CryptoAPI support it so...  	// note: only works because CRT is used by default  	// http://bugzilla.ximian.com/show_bug.cgi?id=57941  	rsap.D = new byte[byteLen];  	// must be allocated  	if (pos + byteLen + offset <= blob.Length) {  		// BYTE privateExponent[rsapubkey.bitlen/8];  		Buffer.BlockCopy (blob' pos' rsap.D' 0' byteLen);  		Array.Reverse (rsap.D);  	}  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  		// DWORD magic = RSA2  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	byte[] exp = new byte[4];  	Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  	Array.Reverse (exp);  	rsap.Exponent = Trim (exp);  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	pos += byteLen;  	// BYTE prime1[rsapubkey.bitlen/16];  	int byteHalfLen = (byteLen >> 1);  	rsap.P = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.P' 0' byteHalfLen);  	Array.Reverse (rsap.P);  	pos += byteHalfLen;  	// BYTE prime2[rsapubkey.bitlen/16];  	rsap.Q = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.Q' 0' byteHalfLen);  	Array.Reverse (rsap.Q);  	pos += byteHalfLen;  	// BYTE exponent1[rsapubkey.bitlen/16];  	rsap.DP = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DP' 0' byteHalfLen);  	Array.Reverse (rsap.DP);  	pos += byteHalfLen;  	// BYTE exponent2[rsapubkey.bitlen/16];  	rsap.DQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DQ' 0' byteHalfLen);  	Array.Reverse (rsap.DQ);  	pos += byteHalfLen;  	// BYTE coefficient[rsapubkey.bitlen/16];  	rsap.InverseQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.InverseQ' 0' byteHalfLen);  	Array.Reverse (rsap.InverseQ);  	pos += byteHalfLen;  	// ok' this is hackish but CryptoAPI support it so...  	// note: only works because CRT is used by default  	// http://bugzilla.ximian.com/show_bug.cgi?id=57941  	rsap.D = new byte[byteLen];  	// must be allocated  	if (pos + byteLen + offset <= blob.Length) {  		// BYTE privateExponent[rsapubkey.bitlen/8];  		Buffer.BlockCopy (blob' pos' rsap.D' 0' byteLen);  		Array.Reverse (rsap.D);  	}  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  		// DWORD magic = RSA2  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	byte[] exp = new byte[4];  	Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  	Array.Reverse (exp);  	rsap.Exponent = Trim (exp);  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	pos += byteLen;  	// BYTE prime1[rsapubkey.bitlen/16];  	int byteHalfLen = (byteLen >> 1);  	rsap.P = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.P' 0' byteHalfLen);  	Array.Reverse (rsap.P);  	pos += byteHalfLen;  	// BYTE prime2[rsapubkey.bitlen/16];  	rsap.Q = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.Q' 0' byteHalfLen);  	Array.Reverse (rsap.Q);  	pos += byteHalfLen;  	// BYTE exponent1[rsapubkey.bitlen/16];  	rsap.DP = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DP' 0' byteHalfLen);  	Array.Reverse (rsap.DP);  	pos += byteHalfLen;  	// BYTE exponent2[rsapubkey.bitlen/16];  	rsap.DQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.DQ' 0' byteHalfLen);  	Array.Reverse (rsap.DQ);  	pos += byteHalfLen;  	// BYTE coefficient[rsapubkey.bitlen/16];  	rsap.InverseQ = new byte[byteHalfLen];  	Buffer.BlockCopy (blob' pos' rsap.InverseQ' 0' byteHalfLen);  	Array.Reverse (rsap.InverseQ);  	pos += byteHalfLen;  	// ok' this is hackish but CryptoAPI support it so...  	// note: only works because CRT is used by default  	// http://bugzilla.ximian.com/show_bug.cgi?id=57941  	rsap.D = new byte[byteLen];  	// must be allocated  	if (pos + byteLen + offset <= blob.Length) {  		// BYTE privateExponent[rsapubkey.bitlen/8];  		Buffer.BlockCopy (blob' pos' rsap.D' 0' byteLen);  		Array.Reverse (rsap.D);  	}  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  	// DWORD magic = RSA2  	throw new CryptographicException ("Invalid blob header");  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  	// DWORD magic = RSA2  	throw new CryptographicException ("Invalid blob header");  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: if ((blob [offset] != 0x07) || // PRIVATEKEYBLOB (0x07)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x32415352))  	// DWORD magic = RSA2  	throw new CryptographicException ("Invalid blob header");  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPrivateKeyBlob,The following statement contains a magic number: Buffer.BlockCopy (blob' offset + 16' exp' 0' 4);  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: try {  	if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  	(blob [offset + 1] != 0x02) || // Version (0x02)  	(blob [offset + 2] != 0x00) || // Reserved (word)  	(blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  		// DWORD magic = RSA1  		throw new CryptographicException ("Invalid blob header");  	// ALGID (CALG_RSA_SIGN' CALG_RSA_KEYX' ...)  	// int algId = ToInt32LE (blob' offset+4);  	// DWORD bitlen  	int bitLen = ToInt32LE (blob' offset + 12);  	// DWORD public exponent  	RSAParameters rsap = new RSAParameters ();  	rsap.Exponent = new byte[3];  	rsap.Exponent [0] = blob [offset + 18];  	rsap.Exponent [1] = blob [offset + 17];  	rsap.Exponent [2] = blob [offset + 16];  	int pos = offset + 20;  	// BYTE modulus[rsapubkey.bitlen/8];  	int byteLen = (bitLen >> 3);  	rsap.Modulus = new byte[byteLen];  	Buffer.BlockCopy (blob' pos' rsap.Modulus' 0' byteLen);  	Array.Reverse (rsap.Modulus);  	RSA rsa = null;  	try {  		rsa = RSA.Create ();  		rsa.ImportParameters (rsap);  	} catch (CryptographicException) {  		// this may cause problem when this code is run under  		// the SYSTEM identity on Windows (e.g. ASP.NET). See  		// http://bugzilla.ximian.com/show_bug.cgi?id=77559  		CspParameters csp = new CspParameters ();  		csp.Flags = CspProviderFlags.UseMachineKeyStore;  		rsa = new RSACryptoServiceProvider (csp);  		rsa.ImportParameters (rsap);  	}  	return rsa;  } catch (Exception e) {  	throw new CryptographicException ("Invalid blob."' e);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  	// DWORD magic = RSA1  	throw new CryptographicException ("Invalid blob header");  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  	// DWORD magic = RSA1  	throw new CryptographicException ("Invalid blob header");  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: if ((blob [offset] != 0x06) || // PUBLICKEYBLOB (0x06)  (blob [offset + 1] != 0x02) || // Version (0x02)  (blob [offset + 2] != 0x00) || // Reserved (word)  (blob [offset + 3] != 0x00) || (ToUInt32LE (blob' offset + 8) != 0x31415352))  	// DWORD magic = RSA1  	throw new CryptographicException ("Invalid blob header");  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: rsap.Exponent = new byte[3];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: rsap.Exponent [0] = blob [offset + 18];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: rsap.Exponent [1] = blob [offset + 17];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: rsap.Exponent [2] = blob [offset + 16];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiPublicKeyBlob,The following statement contains a magic number: rsap.Exponent [2] = blob [offset + 16];  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiKeyBlob,The following statement contains a magic number: switch (blob [offset]) {  case 0x00:  	// this could be a public key inside an header  	// like "sn -e" would produce  	if (blob [offset + 12] == 0x06) {  		return FromCapiPublicKeyBlob (blob' offset + 12);  	}  	break;  case 0x06:  	return FromCapiPublicKeyBlob (blob' offset);  case 0x07:  	return FromCapiPrivateKeyBlob (blob' offset);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiKeyBlob,The following statement contains a magic number: switch (blob [offset]) {  case 0x00:  	// this could be a public key inside an header  	// like "sn -e" would produce  	if (blob [offset + 12] == 0x06) {  		return FromCapiPublicKeyBlob (blob' offset + 12);  	}  	break;  case 0x06:  	return FromCapiPublicKeyBlob (blob' offset);  case 0x07:  	return FromCapiPrivateKeyBlob (blob' offset);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiKeyBlob,The following statement contains a magic number: if (blob [offset + 12] == 0x06) {  	return FromCapiPublicKeyBlob (blob' offset + 12);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiKeyBlob,The following statement contains a magic number: if (blob [offset + 12] == 0x06) {  	return FromCapiPublicKeyBlob (blob' offset + 12);  }  
Magic Number,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiKeyBlob,The following statement contains a magic number: return FromCapiPublicKeyBlob (blob' offset + 12);  
Duplicate Code,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetMetadataToken,The method contains a code clone-set at the following line numbers (starting from the method definition): ((36' 103)' (249' 316))
Duplicate Code,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,CompressMetadataToken,The method contains a code clone-set at the following line numbers (starting from the method definition): ((31' 76)' (195' 240))
Duplicate Code,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,GetSize,The method contains a code clone-set at the following line numbers (starting from the method definition): ((22' 45)' (126' 149))
Duplicate Code,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,WriteDOSHeader,The method contains a code clone-set at the following line numbers (starting from the method definition): ((29' 48)' (30' 49)' (31' 50)' (32' 51)' (33' 52)' (34' 53)' (35' 54)' (36' 55)' (37' 56)' (38' 57)' (39' 58)' (40' 59)' (41' 60)' (42' 61)' (43' 62)' (44' 63))
Duplicate Code,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,WriteDOSHeader,The method contains a code clone-set at the following line numbers (starting from the method definition): ((29' 62)' (30' 63))
Duplicate Code,Mono.Cecil.PE,ImageWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageWriter.cs,WriteDOSHeader,The method contains a code clone-set at the following line numbers (starting from the method definition): ((29' 48)' (31' 50)' (32' 51)' (33' 52)' (34' 53)' (35' 54)' (36' 55)' (37' 56)' (38' 57)' (39' 58)' (40' 59)' (41' 60)' (42' 61)' (43' 62)' (44' 63))
Missing Default,Mono.Cecil,Mixin,F:\newReposMay17\jbevain_cecil\Mono\Empty.cs,IsTypeSpecification,The following switch statement is missing a default case: switch (type.etype) {  case ElementType.Array:  case ElementType.ByRef:  case ElementType.CModOpt:  case ElementType.CModReqD:  case ElementType.FnPtr:  case ElementType.GenericInst:  case ElementType.MVar:  case ElementType.Pinned:  case ElementType.Ptr:  case ElementType.SzArray:  case ElementType.Sentinel:  case ElementType.Var:  	return true;  }  
Missing Default,Mono.Cecil,AssemblyNameReference,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyNameReference.cs,Parse,The following switch statement is missing a default case: switch (parts [0].ToLowerInvariant ()) {  case "version":  	name.Version = new Version (parts [1]);  	break;  case "culture":  	name.Culture = parts [1] == "neutral" ? "" : parts [1];  	break;  case "publickeytoken":  	var pk_token = parts [1];  	if (pk_token == "null")  		break;  	name.PublicKeyToken = new byte[pk_token.Length / 2];  	for (int j = 0; j < name.PublicKeyToken.Length; j++)  		name.PublicKeyToken [j] = Byte.Parse (pk_token.Substring (j * 2' 2)' NumberStyles.HexNumber);  	break;  }  
Missing Default,Mono.Cecil,MetadataReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,ReadExportedTypes,The following switch statement is missing a default case: switch (implementation.TokenType) {  case TokenType.AssemblyRef:  case TokenType.File:  	scope = GetExportedTypeScope (implementation);  	break;  case TokenType.ExportedType:  	// FIXME: if the table is not properly sorted  	declaring_type = exported_types [(int)implementation.RID - 1];  	break;  }  
Missing Default,Mono.Cecil,MetadataReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyReader.cs,ReadImportTarget,The following switch statement is missing a default case: switch (kind) {  case ImportTargetKind.ImportNamespace:  	@namespace = ReadUTF8StringBlob (signature.ReadCompressedUInt32 ());  	break;  case ImportTargetKind.ImportNamespaceInAssembly:  	reference = metadata.GetAssemblyNameReference (signature.ReadCompressedUInt32 ());  	@namespace = ReadUTF8StringBlob (signature.ReadCompressedUInt32 ());  	break;  case ImportTargetKind.ImportType:  	type = signature.ReadTypeToken ();  	break;  case ImportTargetKind.ImportXmlNamespaceWithAlias:  	alias = ReadUTF8StringBlob (signature.ReadCompressedUInt32 ());  	@namespace = ReadUTF8StringBlob (signature.ReadCompressedUInt32 ());  	break;  case ImportTargetKind.ImportAlias:  	alias = ReadUTF8StringBlob (signature.ReadCompressedUInt32 ());  	break;  case ImportTargetKind.DefineAssemblyAlias:  	alias = ReadUTF8StringBlob (signature.ReadCompressedUInt32 ());  	reference = metadata.GetAssemblyNameReference (signature.ReadCompressedUInt32 ());  	break;  case ImportTargetKind.DefineNamespaceAlias:  	alias = ReadUTF8StringBlob (signature.ReadCompressedUInt32 ());  	@namespace = ReadUTF8StringBlob (signature.ReadCompressedUInt32 ());  	break;  case ImportTargetKind.DefineNamespaceInAssemblyAlias:  	alias = ReadUTF8StringBlob (signature.ReadCompressedUInt32 ());  	reference = metadata.GetAssemblyNameReference (signature.ReadCompressedUInt32 ());  	@namespace = ReadUTF8StringBlob (signature.ReadCompressedUInt32 ());  	break;  case ImportTargetKind.DefineTypeAlias:  	alias = ReadUTF8StringBlob (signature.ReadCompressedUInt32 ());  	type = signature.ReadTypeToken ();  	break;  }  
Missing Default,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,GetExportedTypeScope,The following switch statement is missing a default case: switch (scope.MetadataToken.TokenType) {  case TokenType.AssemblyRef:  	return scope.MetadataToken;  case TokenType.ModuleRef:  	var file_table = GetTable<FileTable> (Table.File);  	for (int i = 0; i < file_table.length; i++)  		if (file_table.rows [i].Col2 == GetStringIndex (scope.Name))  			return new MetadataToken (TokenType.File' i + 1);  	break;  }  
Missing Default,Mono.Cecil,MetadataBuilder,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,AddImportTarget,The following switch statement is missing a default case: switch (target.kind) {  case ImportTargetKind.ImportNamespace:  	signature.WriteCompressedUInt32 (GetUTF8StringBlobIndex (target.@namespace));  	break;  case ImportTargetKind.ImportNamespaceInAssembly:  	signature.WriteCompressedUInt32 (target.reference.MetadataToken.RID);  	signature.WriteCompressedUInt32 (GetUTF8StringBlobIndex (target.@namespace));  	break;  case ImportTargetKind.ImportType:  	signature.WriteTypeToken (target.type);  	break;  case ImportTargetKind.ImportXmlNamespaceWithAlias:  	signature.WriteCompressedUInt32 (GetUTF8StringBlobIndex (target.alias));  	signature.WriteCompressedUInt32 (GetUTF8StringBlobIndex (target.@namespace));  	break;  case ImportTargetKind.ImportAlias:  	signature.WriteCompressedUInt32 (GetUTF8StringBlobIndex (target.alias));  	break;  case ImportTargetKind.DefineAssemblyAlias:  	signature.WriteCompressedUInt32 (GetUTF8StringBlobIndex (target.alias));  	signature.WriteCompressedUInt32 (target.reference.MetadataToken.RID);  	break;  case ImportTargetKind.DefineNamespaceAlias:  	signature.WriteCompressedUInt32 (GetUTF8StringBlobIndex (target.alias));  	signature.WriteCompressedUInt32 (GetUTF8StringBlobIndex (target.@namespace));  	break;  case ImportTargetKind.DefineNamespaceInAssemblyAlias:  	signature.WriteCompressedUInt32 (GetUTF8StringBlobIndex (target.alias));  	signature.WriteCompressedUInt32 (target.reference.MetadataToken.RID);  	signature.WriteCompressedUInt32 (GetUTF8StringBlobIndex (target.@namespace));  	break;  case ImportTargetKind.DefineTypeAlias:  	signature.WriteCompressedUInt32 (GetUTF8StringBlobIndex (target.alias));  	signature.WriteTypeToken (target.type);  	break;  }  
Missing Default,Mono.Cecil,SignatureWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil\AssemblyWriter.cs,WriteMarshalInfo,The following switch statement is missing a default case: switch (marshal_info.native) {  case NativeType.Array: {  	var array = (ArrayMarshalInfo)marshal_info;  	if (array.element_type != NativeType.None)  		WriteNativeType (array.element_type);  	if (array.size_parameter_index > -1)  		WriteCompressedUInt32 ((uint)array.size_parameter_index);  	if (array.size > -1)  		WriteCompressedUInt32 ((uint)array.size);  	if (array.size_parameter_multiplier > -1)  		WriteCompressedUInt32 ((uint)array.size_parameter_multiplier);  	return;  }  case NativeType.SafeArray: {  	var array = (SafeArrayMarshalInfo)marshal_info;  	if (array.element_type != VariantType.None)  		WriteVariantType (array.element_type);  	return;  }  case NativeType.FixedArray: {  	var array = (FixedArrayMarshalInfo)marshal_info;  	if (array.size > -1)  		WriteCompressedUInt32 ((uint)array.size);  	if (array.element_type != NativeType.None)  		WriteNativeType (array.element_type);  	return;  }  case NativeType.FixedSysString:  	var sys_string = (FixedSysStringMarshalInfo)marshal_info;  	if (sys_string.size > -1)  		WriteCompressedUInt32 ((uint)sys_string.size);  	return;  case NativeType.CustomMarshaler:  	var marshaler = (CustomMarshalInfo)marshal_info;  	WriteUTF8String (marshaler.guid != Guid.Empty ? marshaler.guid.ToString () : string.Empty);  	WriteUTF8String (marshaler.unmanaged_type);  	WriteTypeReference (marshaler.managed_type);  	WriteUTF8String (marshaler.cookie);  	return;  }  
Missing Default,Mono.Cecil,GenericParameter,F:\newReposMay17\jbevain_cecil\Mono.Cecil\GenericParameter.cs,ConvertGenericParameterType,The following switch statement is missing a default case: switch (type) {  case GenericParameterType.Type:  	return ElementType.Var;  case GenericParameterType.Method:  	return ElementType.MVar;  }  
Missing Default,Mono.Cecil,MetadataImporter,F:\newReposMay17\jbevain_cecil\Mono.Cecil\Import.cs,ImportScope,The following switch statement is missing a default case: switch (scope.MetadataScopeType) {  case MetadataScopeType.AssemblyNameReference:  	return ImportAssemblyName ((AssemblyNameReference)scope);  case MetadataScopeType.ModuleDefinition:  	if (scope == module)  		return scope;  	return ImportAssemblyName (((ModuleDefinition)scope).Assembly.Name);  case MetadataScopeType.ModuleReference:  	throw new NotImplementedException ();  }  
Missing Default,Mono.Cecil,MetadataImporter,F:\newReposMay17\jbevain_cecil\Mono.Cecil\Import.cs,ImportTypeSpecification,The following switch statement is missing a default case: switch (type.etype) {  case ElementType.SzArray:  	var vector = (ArrayType)type;  	return new ArrayType (ImportType (vector.ElementType' context));  case ElementType.Ptr:  	var pointer = (PointerType)type;  	return new PointerType (ImportType (pointer.ElementType' context));  case ElementType.ByRef:  	var byref = (ByReferenceType)type;  	return new ByReferenceType (ImportType (byref.ElementType' context));  case ElementType.Pinned:  	var pinned = (PinnedType)type;  	return new PinnedType (ImportType (pinned.ElementType' context));  case ElementType.Sentinel:  	var sentinel = (SentinelType)type;  	return new SentinelType (ImportType (sentinel.ElementType' context));  case ElementType.FnPtr:  	var fnptr = (FunctionPointerType)type;  	var imported_fnptr = new FunctionPointerType () {  		HasThis = fnptr.HasThis'  		ExplicitThis = fnptr.ExplicitThis'  		CallingConvention = fnptr.CallingConvention'  		ReturnType = ImportType (fnptr.ReturnType' context)'  	};  	if (!fnptr.HasParameters)  		return imported_fnptr;  	for (int i = 0; i < fnptr.Parameters.Count; i++)  		imported_fnptr.Parameters.Add (new ParameterDefinition (ImportType (fnptr.Parameters [i].ParameterType' context)));  	return imported_fnptr;  case ElementType.CModOpt:  	var modopt = (OptionalModifierType)type;  	return new OptionalModifierType (ImportType (modopt.ModifierType' context)' ImportType (modopt.ElementType' context));  case ElementType.CModReqD:  	var modreq = (RequiredModifierType)type;  	return new RequiredModifierType (ImportType (modreq.ModifierType' context)' ImportType (modreq.ElementType' context));  case ElementType.Array:  	var array = (ArrayType)type;  	var imported_array = new ArrayType (ImportType (array.ElementType' context));  	if (array.IsVector)  		return imported_array;  	var dimensions = array.Dimensions;  	var imported_dimensions = imported_array.Dimensions;  	imported_dimensions.Clear ();  	for (int i = 0; i < dimensions.Count; i++) {  		var dimension = dimensions [i];  		imported_dimensions.Add (new ArrayDimension (dimension.LowerBound' dimension.UpperBound));  	}  	return imported_array;  case ElementType.GenericInst:  	var instance = (GenericInstanceType)type;  	var element_type = ImportType (instance.ElementType' context);  	var imported_instance = new GenericInstanceType (element_type);  	var arguments = instance.GenericArguments;  	var imported_arguments = imported_instance.GenericArguments;  	for (int i = 0; i < arguments.Count; i++)  		imported_arguments.Add (ImportType (arguments [i]' context));  	return imported_instance;  case ElementType.Var:  	var var_parameter = (GenericParameter)type;  	if (var_parameter.DeclaringType == null)  		throw new InvalidOperationException ();  	return context.TypeParameter (var_parameter.DeclaringType.FullName' var_parameter.Position);  case ElementType.MVar:  	var mvar_parameter = (GenericParameter)type;  	if (mvar_parameter.DeclaringMethod == null)  		throw new InvalidOperationException ();  	return context.MethodParameter (context.NormalizeMethodName (mvar_parameter.DeclaringMethod)' mvar_parameter.Position);  }  
Missing Default,Mono.Cecil,MetadataResolver,F:\newReposMay17\jbevain_cecil\Mono.Cecil\MetadataResolver.cs,Resolve,The following switch statement is missing a default case: switch (scope.MetadataScopeType) {  case MetadataScopeType.AssemblyNameReference:  	var assembly = assembly_resolver.Resolve ((AssemblyNameReference)scope);  	if (assembly == null)  		return null;  	return GetType (assembly.MainModule' type);  case MetadataScopeType.ModuleDefinition:  	return GetType ((ModuleDefinition)scope' type);  case MetadataScopeType.ModuleReference:  	var modules = type.Module.Assembly.Modules;  	var module_ref = (ModuleReference)scope;  	for (int i = 0; i < modules.Count; i++) {  		var netmodule = modules [i];  		if (netmodule.Name == module_ref.Name)  			return GetType (netmodule' type);  	}  	break;  }  
Missing Default,Mono.Cecil,TypeParser,F:\newReposMay17\jbevain_cecil\Mono.Cecil\TypeParser.cs,GetScopeFullName,The following switch statement is missing a default case: switch (scope.MetadataScopeType) {  case MetadataScopeType.AssemblyNameReference:  	return ((AssemblyNameReference)scope).FullName;  case MetadataScopeType.ModuleDefinition:  	return ((ModuleDefinition)scope).Assembly.Name.FullName;  }  
Missing Default,Mono.Cecil,WindowsRuntimeProjections,F:\newReposMay17\jbevain_cecil\Mono.Cecil\WindowsRuntimeProjections.cs,NeedsWindowsRuntimePrefix,The following switch statement is missing a default case: switch (base_type.Name) {  case "Attribute":  case "MulticastDelegate":  case "ValueType":  	return false;  }  
Missing Default,Mono.Cecil,WindowsRuntimeProjections,F:\newReposMay17\jbevain_cecil\Mono.Cecil\WindowsRuntimeProjections.cs,ApplyProjection,The following switch statement is missing a default case: switch (treatment & TypeDefinitionTreatment.KindMask) {  case TypeDefinitionTreatment.NormalType:  	type.Attributes |= TypeAttributes.WindowsRuntime | TypeAttributes.Import;  	break;  case TypeDefinitionTreatment.NormalAttribute:  	type.Attributes |= TypeAttributes.WindowsRuntime | TypeAttributes.Sealed;  	break;  case TypeDefinitionTreatment.UnmangleWindowsRuntimeName:  	type.Attributes = type.Attributes & ~TypeAttributes.SpecialName | TypeAttributes.Public;  	type.Name = type.Name.Substring ("<CLR>".Length);  	break;  case TypeDefinitionTreatment.PrefixWindowsRuntimeName:  	type.Attributes = type.Attributes & ~TypeAttributes.Public | TypeAttributes.Import;  	type.Name = "<WinRT>" + type.Name;  	break;  case TypeDefinitionTreatment.RedirectToClrType:  	type.Attributes = type.Attributes & ~TypeAttributes.Public | TypeAttributes.Import;  	break;  case TypeDefinitionTreatment.RedirectToClrAttribute:  	type.Attributes = type.Attributes & ~TypeAttributes.Public;  	break;  }  
Missing Default,Mono.Cecil,WindowsRuntimeProjections,F:\newReposMay17\jbevain_cecil\Mono.Cecil\WindowsRuntimeProjections.cs,ApplyProjection,The following switch statement is missing a default case: switch (projection.Treatment) {  case TypeReferenceTreatment.SystemDelegate:  case TypeReferenceTreatment.SystemAttribute:  	type.Scope = type.Module.Projections.GetAssemblyReference ("System.Runtime");  	break;  case TypeReferenceTreatment.UseProjectionInfo:  	var info = Projections [type.Name];  	type.Name = info.ClrName;  	type.Namespace = info.ClrNamespace;  	type.Scope = type.Module.Projections.GetAssemblyReference (info.ClrAssembly);  	break;  }  
Missing Default,Mono.Cecil,WindowsRuntimeProjections,F:\newReposMay17\jbevain_cecil\Mono.Cecil\WindowsRuntimeProjections.cs,Project,The following switch statement is missing a default case: switch (GetSpecialTypeReferenceTreatment (base_type)) {  case TypeReferenceTreatment.SystemDelegate:  	treatment = MethodDefinitionTreatment.Runtime | MethodDefinitionTreatment.Public;  	other = false;  	break;  case TypeReferenceTreatment.SystemAttribute:  	treatment = MethodDefinitionTreatment.Runtime | MethodDefinitionTreatment.InternalCall;  	other = false;  	break;  }  
Missing Default,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,ResolveBranches,The following switch statement is missing a default case: switch (instruction.opcode.OperandType) {  case OperandType.ShortInlineBrTarget:  case OperandType.InlineBrTarget:  	instruction.operand = GetInstruction ((int)instruction.operand);  	break;  case OperandType.InlineSwitch:  	var offsets = (int[])instruction.operand;  	var branches = new Instruction[offsets.Length];  	for (int j = 0; j < offsets.Length; j++)  		branches [j] = GetInstruction (offsets [j]);  	instruction.operand = branches;  	break;  }  
Missing Default,Mono.Cecil.Cil,CodeReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeReader.cs,PatchRawCode,The following switch statement is missing a default case: switch (opcode.OperandType) {  case OperandType.ShortInlineI:  case OperandType.ShortInlineBrTarget:  case OperandType.ShortInlineVar:  case OperandType.ShortInlineArg:  	buffer.position += 1;  	break;  case OperandType.InlineVar:  case OperandType.InlineArg:  	buffer.position += 2;  	break;  case OperandType.InlineBrTarget:  case OperandType.ShortInlineR:  case OperandType.InlineI:  	buffer.position += 4;  	break;  case OperandType.InlineI8:  case OperandType.InlineR:  	buffer.position += 8;  	break;  case OperandType.InlineSwitch:  	var length = buffer.ReadInt32 ();  	buffer.position += length * 4;  	break;  case OperandType.InlineString:  	var @string = GetString (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (new MetadataToken (TokenType.String' metadata.user_string_heap.GetStringIndex (@string)).ToUInt32 ());  	break;  case OperandType.InlineSig:  	var call_site = GetCallSite (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (writer.GetStandAloneSignature (call_site).ToUInt32 ());  	break;  case OperandType.InlineTok:  case OperandType.InlineType:  case OperandType.InlineMethod:  case OperandType.InlineField:  	var provider = reader.LookupToken (new MetadataToken (buffer.ReadUInt32 ()));  	buffer.position -= 4;  	buffer.WriteUInt32 (metadata.LookupToken (provider).ToUInt32 ());  	break;  }  
Missing Default,Mono.Cecil.Cil,CodeWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeWriter.cs,ComputeExceptionHandlerStackSize,The following switch statement is missing a default case: switch (exception_handler.HandlerType) {  case ExceptionHandlerType.Catch:  	AddExceptionStackSize (exception_handler.HandlerStart' ref stack_sizes);  	break;  case ExceptionHandlerType.Filter:  	AddExceptionStackSize (exception_handler.FilterStart' ref stack_sizes);  	AddExceptionStackSize (exception_handler.HandlerStart' ref stack_sizes);  	break;  }  
Missing Default,Mono.Cecil.Cil,CodeWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeWriter.cs,CopyBranchStackSize,The following switch statement is missing a default case: switch (instruction.opcode.OperandType) {  case OperandType.ShortInlineBrTarget:  case OperandType.InlineBrTarget:  	CopyBranchStackSize (ref stack_sizes' (Instruction)instruction.operand' stack_size);  	break;  case OperandType.InlineSwitch:  	var targets = (Instruction[])instruction.operand;  	for (int i = 0; i < targets.Length; i++)  		CopyBranchStackSize (ref stack_sizes' targets [i]' stack_size);  	break;  }  
Missing Default,Mono.Cecil.Cil,CodeWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeWriter.cs,ComputeStackSize,The following switch statement is missing a default case: switch (instruction.opcode.FlowControl) {  case FlowControl.Branch:  case FlowControl.Break:  case FlowControl.Throw:  case FlowControl.Return:  	stack_size = 0;  	break;  }  
Missing Default,Mono.Cecil.Cil,CodeWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeWriter.cs,ComputePopDelta,The following switch statement is missing a default case: switch (pop_behavior) {  case StackBehaviour.Popi:  case StackBehaviour.Popref:  case StackBehaviour.Pop1:  	stack_size--;  	break;  case StackBehaviour.Pop1_pop1:  case StackBehaviour.Popi_pop1:  case StackBehaviour.Popi_popi:  case StackBehaviour.Popi_popi8:  case StackBehaviour.Popi_popr4:  case StackBehaviour.Popi_popr8:  case StackBehaviour.Popref_pop1:  case StackBehaviour.Popref_popi:  	stack_size -= 2;  	break;  case StackBehaviour.Popi_popi_popi:  case StackBehaviour.Popref_popi_popi:  case StackBehaviour.Popref_popi_popi8:  case StackBehaviour.Popref_popi_popr4:  case StackBehaviour.Popref_popi_popr8:  case StackBehaviour.Popref_popi_popref:  	stack_size -= 3;  	break;  case StackBehaviour.PopAll:  	stack_size = 0;  	break;  }  
Missing Default,Mono.Cecil.Cil,CodeWriter,F:\newReposMay17\jbevain_cecil\Mono.Cecil.Cil\CodeWriter.cs,ComputePushDelta,The following switch statement is missing a default case: switch (push_behaviour) {  case StackBehaviour.Push1:  case StackBehaviour.Pushi:  case StackBehaviour.Pushi8:  case StackBehaviour.Pushr4:  case StackBehaviour.Pushr8:  case StackBehaviour.Pushref:  	stack_size++;  	break;  case StackBehaviour.Push1_push1:  	stack_size += 2;  	break;  }  
Missing Default,Mono.Cecil.PE,ImageReader,F:\newReposMay17\jbevain_cecil\Mono.Cecil.PE\ImageReader.cs,ReadMetadataStream,The following switch statement is missing a default case: switch (name) {  case "#~":  case "#-":  	image.TableHeap = new TableHeap (data);  	table_heap_offset = offset;  	break;  case "#Strings":  	image.StringHeap = new StringHeap (data);  	break;  case "#Blob":  	image.BlobHeap = new BlobHeap (data);  	break;  case "#GUID":  	image.GuidHeap = new GuidHeap (data);  	break;  case "#US":  	image.UserStringHeap = new UserStringHeap (data);  	break;  case "#Pdb":  	image.PdbHeap = new PdbHeap (data);  	break;  }  
Missing Default,Mono.Security.Cryptography,CryptoConvert,F:\newReposMay17\jbevain_cecil\Mono.Security.Cryptography\CryptoConvert.cs,FromCapiKeyBlob,The following switch statement is missing a default case: switch (blob [offset]) {  case 0x00:  	// this could be a public key inside an header  	// like "sn -e" would produce  	if (blob [offset + 12] == 0x06) {  		return FromCapiPublicKeyBlob (blob' offset + 12);  	}  	break;  case 0x06:  	return FromCapiPublicKeyBlob (blob' offset);  case 0x07:  	return FromCapiPrivateKeyBlob (blob' offset);  }  
