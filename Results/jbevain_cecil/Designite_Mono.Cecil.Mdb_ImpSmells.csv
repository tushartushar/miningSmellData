Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Mono.CompilerServices.SymbolWriter,MonoSymbolFile,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs,Write,Cyclomatic complexity of the method is 15
Complex Method,Mono.CompilerServices.SymbolWriter,LineNumberTable,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,Write,Cyclomatic complexity of the method is 14
Complex Method,Mono.CompilerServices.SymbolWriter,LineNumberTable,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,DoRead,Cyclomatic complexity of the method is 35
Complex Method,Mono.CompilerServices.SymbolWriter,MethodEntry,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,WriteData,Cyclomatic complexity of the method is 11
Long Parameter List,Mono.Cecil.Mdb,MdbWriter,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.Cecil.Mdb\MdbWriter.cs,Populate,The method has 7 parameters.
Long Parameter List,Mono.CompilerServices.SymbolWriter,MonoSymbolFile,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs,DefineMethod,The method has 9 parameters.
Long Parameter List,Mono.CompilerServices.SymbolWriter,LineNumberEntry,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,LineNumberEntry,The method has 5 parameters.
Long Parameter List,Mono.CompilerServices.SymbolWriter,LineNumberEntry,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,LineNumberEntry,The method has 7 parameters.
Long Parameter List,Mono.CompilerServices.SymbolWriter,MethodEntry,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,MethodEntry,The method has 10 parameters.
Long Parameter List,Mono.CompilerServices.SymbolWriter,MonoSymbolWriter,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs,MarkSequencePoint,The method has 5 parameters.
Long Parameter List,Mono.CompilerServices.SymbolWriter,SourceMethodBuilder,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\SourceMethodBuilder.cs,MarkSequencePoint,The method has 5 parameters.
Long Parameter List,Mono.CompilerServices.SymbolWriter,SourceMethodBuilder,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\SourceMethodBuilder.cs,MarkSequencePoint,The method has 7 parameters.
Long Parameter List,Mono.CompilerServices.SymbolWriter,SymbolWriterImpl,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\SymbolWriterImpl.cs,DefineField,The method has 8 parameters.
Long Parameter List,Mono.CompilerServices.SymbolWriter,SymbolWriterImpl,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\SymbolWriterImpl.cs,DefineGlobalVariable,The method has 7 parameters.
Long Parameter List,Mono.CompilerServices.SymbolWriter,SymbolWriterImpl,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\SymbolWriterImpl.cs,DefineLocalVariable,The method has 9 parameters.
Long Parameter List,Mono.CompilerServices.SymbolWriter,SymbolWriterImpl,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\SymbolWriterImpl.cs,DefineParameter,The method has 7 parameters.
Long Parameter List,Mono.CompilerServices.SymbolWriter,SymbolWriterImpl,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\SymbolWriterImpl.cs,DefineSequencePoints,The method has 6 parameters.
Long Parameter List,Mono.CompilerServices.SymbolWriter,SymbolWriterImpl,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\SymbolWriterImpl.cs,SetMethodSourceRange,The method has 6 parameters.
Long Statement,Mono.Cecil.Mdb,MdbWriter,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.Cecil.Mdb\MdbWriter.cs,GetSourceFile,The length of the statement  "	var entry = writer.DefineDocument (url' null' document.Hash != null && document.Hash.Length == 16 ? document.Hash : null); " is 122.
Long Statement,Mono.Cecil.Mdb,MdbWriter,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.Cecil.Mdb\MdbWriter.cs,Write,The length of the statement  "		builder.MarkSequencePoint (offsets [i]' file.CompilationUnit.SourceFile' start_rows [i]' start_cols [i]' end_rows [i]' end_cols [i]' false); " is 140.
Long Statement,Mono.CompilerServices.SymbolWriter,MonoSymbolFile,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs,DefineMethod,The length of the statement  "	MethodEntry method = new MethodEntry (this' comp_unit' token' scope_vars' locals' lines' code_blocks' real_name' flags' namespace_id); " is 134.
Long Statement,Mono.CompilerServices.SymbolWriter,OffsetTable,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,ToString,The length of the statement  "	return String.Format ("OffsetTable [{0} - {1}:{2} - {3}:{4}:{5} - {6}:{7}:{8} - {9}]"' TotalFileSize' DataSectionOffset' DataSectionSize' SourceCount' SourceTableOffset' SourceTableSize' MethodCount' MethodTableOffset' MethodTableSize' TypeCount); " is 247.
Long Statement,Mono.CompilerServices.SymbolWriter,MethodEntry,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,GetLineNumberTable,The length of the statement  "		lnt = LineNumberTable.Read (SymbolFile' reader' (flags & Flags.ColumnsInfoIncluded) != 0' (flags & Flags.EndInfoIncluded) != 0); " is 128.
Long Statement,Mono.CompilerServices.SymbolWriter,SourceMethodBuilder,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\SourceMethodBuilder.cs,DefineMethod,The length of the statement  "	MethodEntry entry = new MethodEntry (file' _comp_unit.Entry' token' ScopeVariables' Locals' method_lines.ToArray ()' Blocks' null' MethodEntry.Flags.ColumnsInfoIncluded' ns_id); " is 177.
Complex Conditional,Mono.CompilerServices.SymbolWriter,SymbolWriterImpl,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\SymbolWriterImpl.cs,DefineSequencePoints,The conditional expression  "n > 0 && offsets [n] == offsets [n - 1] && lines [n] == lines [n - 1] && columns [n] == columns [n - 1]"  is complex.
Empty Catch Block,Mono.CompilerServices.SymbolWriter,MonoSymbolWriter,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs,WriteSymbolFile,The method has an empty catch block.
Magic Number,Mono.CompilerServices.SymbolWriter,MonoSymbolFile,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs,MonoSymbolFile,The following statement contains a magic number: try {  	long magic = reader.ReadInt64 ();  	int major_version = reader.ReadInt32 ();  	int minor_version = reader.ReadInt32 ();  	if (magic != OffsetTable.Magic)  		throw new MonoSymbolFileException ("Symbol file is not a valid");  	if (major_version != OffsetTable.MajorVersion)  		throw new MonoSymbolFileException ("Symbol file has version {0} but expected {1}"' major_version' OffsetTable.MajorVersion);  	if (minor_version != OffsetTable.MinorVersion)  		throw new MonoSymbolFileException ("Symbol file has version {0}.{1} but expected {2}.{3}"' major_version' minor_version' OffsetTable.MajorVersion' OffsetTable.MinorVersion);  	MajorVersion = major_version;  	MinorVersion = minor_version;  	guid = new Guid (reader.ReadBytes (16));  	ot = new OffsetTable (reader' major_version' minor_version);  } catch (Exception e) {  	throw new MonoSymbolFileException ("Cannot read symbol file"' e);  }  
Magic Number,Mono.CompilerServices.SymbolWriter,MonoSymbolFile,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs,MonoSymbolFile,The following statement contains a magic number: guid = new Guid (reader.ReadBytes (16));  
Magic Number,Mono.CompilerServices.SymbolWriter,OffsetTable,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,OffsetTable,The following statement contains a magic number: if ((platform != 4) && (platform != 128))  	FileFlags |= Flags.WindowsFileNames;  
Magic Number,Mono.CompilerServices.SymbolWriter,OffsetTable,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,OffsetTable,The following statement contains a magic number: if ((platform != 4) && (platform != 128))  	FileFlags |= Flags.WindowsFileNames;  
Magic Number,Mono.CompilerServices.SymbolWriter,SourceFileEntry,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,WriteData,The following statement contains a magic number: if (guid == null)  	guid = new byte[16];  
Magic Number,Mono.CompilerServices.SymbolWriter,SourceFileEntry,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,WriteData,The following statement contains a magic number: guid = new byte[16];  
Magic Number,Mono.CompilerServices.SymbolWriter,SourceFileEntry,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,ComputeHash,The following statement contains a magic number: if (!File.Exists (file_name))  	return new byte[16];  
Magic Number,Mono.CompilerServices.SymbolWriter,SourceFileEntry,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,ComputeHash,The following statement contains a magic number: return new byte[16];  
Magic Number,Mono.CompilerServices.SymbolWriter,SourceFileEntry,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,ComputeHash,The following statement contains a magic number: try {  	using (FileStream fs = new FileStream (file_name' FileMode.Open' FileAccess.Read)) {  		MD5 md5 = MD5.Create ();  		return md5.ComputeHash (fs);  	}  } catch {  	return new byte[16];  }  
Magic Number,Mono.CompilerServices.SymbolWriter,SourceFileEntry,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,ComputeHash,The following statement contains a magic number: return new byte[16];  
Magic Number,Mono.CompilerServices.SymbolWriter,SourceFileEntry,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,SourceFileEntry,The following statement contains a magic number: guid = reader.ReadBytes (16);  
Magic Number,Mono.CompilerServices.SymbolWriter,SourceFileEntry,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,SourceFileEntry,The following statement contains a magic number: hash = reader.ReadBytes (16);  
Magic Number,Mono.CompilerServices.SymbolWriter,SourceFileEntry,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,CheckChecksum,The following statement contains a magic number: try {  	using (FileStream fs = new FileStream (file_name' FileMode.Open)) {  		MD5 md5 = MD5.Create ();  		byte[] data = md5.ComputeHash (fs);  		for (int i = 0; i < 16; i++)  			if (data [i] != hash [i])  				return false;  		return true;  	}  } catch {  	return false;  }  
Magic Number,Mono.CompilerServices.SymbolWriter,SourceFileEntry,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,CheckChecksum,The following statement contains a magic number: using (FileStream fs = new FileStream (file_name' FileMode.Open)) {  	MD5 md5 = MD5.Create ();  	byte[] data = md5.ComputeHash (fs);  	for (int i = 0; i < 16; i++)  		if (data [i] != hash [i])  			return false;  	return true;  }  
Magic Number,Mono.CompilerServices.SymbolWriter,SourceFileEntry,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,CheckChecksum,The following statement contains a magic number: for (int i = 0; i < 16; i++)  	if (data [i] != hash [i])  		return false;  
Magic Number,Mono.CompilerServices.SymbolWriter,LineNumberTable,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,LineNumberTable,The following statement contains a magic number: this.MaxAddressIncrement = (255 - OpcodeBase) / LineRange;  
Magic Number,Mono.CompilerServices.SymbolWriter,LineNumberTable,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,Write,The following statement contains a magic number: for (int i = 0; i < LineNumbers.Length; i++) {  	int line_inc = LineNumbers [i].Row - last_line;  	int offset_inc = LineNumbers [i].Offset - last_offset;  	if (LineNumbers [i].File != last_file) {  		bw.Write (DW_LNS_set_file);  		bw.WriteLeb128 (LineNumbers [i].File);  		last_file = LineNumbers [i].File;  	}  	if (LineNumbers [i].IsHidden != last_is_hidden) {  		bw.Write ((byte)0);  		bw.Write ((byte)1);  		bw.Write (DW_LNE_MONO_negate_is_hidden);  		last_is_hidden = LineNumbers [i].IsHidden;  	}  	if (offset_inc >= MaxAddressIncrement) {  		if (offset_inc < 2 * MaxAddressIncrement) {  			bw.Write (DW_LNS_const_add_pc);  			offset_inc -= MaxAddressIncrement;  		} else {  			bw.Write (DW_LNS_advance_pc);  			bw.WriteLeb128 (offset_inc);  			offset_inc = 0;  		}  	}  	if ((line_inc < LineBase) || (line_inc >= LineBase + LineRange)) {  		bw.Write (DW_LNS_advance_line);  		bw.WriteLeb128 (line_inc);  		if (offset_inc != 0) {  			bw.Write (DW_LNS_advance_pc);  			bw.WriteLeb128 (offset_inc);  		}  		bw.Write (DW_LNS_copy);  	} else {  		byte opcode;  		opcode = (byte)(line_inc - LineBase + (LineRange * offset_inc) + OpcodeBase);  		bw.Write (opcode);  	}  	last_line = LineNumbers [i].Row;  	last_offset = LineNumbers [i].Offset;  }  
Magic Number,Mono.CompilerServices.SymbolWriter,LineNumberTable,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,Write,The following statement contains a magic number: if (offset_inc >= MaxAddressIncrement) {  	if (offset_inc < 2 * MaxAddressIncrement) {  		bw.Write (DW_LNS_const_add_pc);  		offset_inc -= MaxAddressIncrement;  	} else {  		bw.Write (DW_LNS_advance_pc);  		bw.WriteLeb128 (offset_inc);  		offset_inc = 0;  	}  }  
Magic Number,Mono.CompilerServices.SymbolWriter,LineNumberTable,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,Write,The following statement contains a magic number: if (offset_inc < 2 * MaxAddressIncrement) {  	bw.Write (DW_LNS_const_add_pc);  	offset_inc -= MaxAddressIncrement;  } else {  	bw.Write (DW_LNS_advance_pc);  	bw.WriteLeb128 (offset_inc);  	offset_inc = 0;  }  
Magic Number,Mono.CompilerServices.SymbolWriter,MethodEntry,F:\newReposMay17\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,MethodEntry,The following statement contains a magic number: if (num_locals <= 32) {  	// Most of the time' the O(n^2) factor is actually  	// less than the cost of allocating the hash table'  	// 32 is a rough number obtained through some testing.  	for (int i = 0; i < num_locals; i++) {  		string nm = locals [i].Name;  		for (int j = i + 1; j < num_locals; j++) {  			if (locals [j].Name == nm) {  				flags |= Flags.LocalNamesAmbiguous;  				goto locals_check_done;  			}  		}  	}  	locals_check_done:  	;  } else {  	var local_names = new Dictionary<string' LocalVariableEntry> ();  	foreach (LocalVariableEntry local in locals) {  		if (local_names.ContainsKey (local.Name)) {  			flags |= Flags.LocalNamesAmbiguous;  			break;  		}  		local_names.Add (local.Name' local);  	}  }  
