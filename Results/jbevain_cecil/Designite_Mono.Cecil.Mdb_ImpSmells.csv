Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Mono.CompilerServices.SymbolWriter,MonoSymbolFile,C:\repos\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs,Write,Cyclomatic complexity of the method is 10
Complex Method,Mono.CompilerServices.SymbolWriter,LineNumberTable,C:\repos\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,Write,Cyclomatic complexity of the method is 14
Complex Method,Mono.CompilerServices.SymbolWriter,LineNumberTable,C:\repos\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,DoRead,Cyclomatic complexity of the method is 11
Complex Method,Mono.CompilerServices.SymbolWriter,MethodEntry,C:\repos\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,WriteData,Cyclomatic complexity of the method is 8
Complex Method,Mono.CompilerServices.SymbolWriter,SourceMethodBuilder,C:\repos\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\SourceMethodBuilder.cs,DefineMethod,Cyclomatic complexity of the method is 8
Long Parameter List,Mono.Cecil.Mdb,MdbWriter,C:\repos\jbevain_cecil\symbols\mdb\Mono.Cecil.Mdb\MdbWriter.cs,Populate,The method has 7 parameters. Parameters: sequencePoints' offsets' startRows' endRows' startCols' endCols' file
Long Parameter List,Mono.CompilerServices.SymbolWriter,MonoSymbolFile,C:\repos\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs,DefineMethod,The method has 9 parameters. Parameters: comp_unit' token' scope_vars' locals' lines' code_blocks' real_name' flags' namespace_id
Long Parameter List,Mono.CompilerServices.SymbolWriter,LineNumberEntry,C:\repos\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,LineNumberEntry,The method has 5 parameters. Parameters: file' row' column' offset' is_hidden
Long Parameter List,Mono.CompilerServices.SymbolWriter,LineNumberEntry,C:\repos\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,LineNumberEntry,The method has 7 parameters. Parameters: file' row' column' end_row' end_column' offset' is_hidden
Long Parameter List,Mono.CompilerServices.SymbolWriter,SourceFileEntry,C:\repos\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,SourceFileEntry,The method has 5 parameters. Parameters: file' fileName' sourceFile' guid' checksum
Long Parameter List,Mono.CompilerServices.SymbolWriter,MethodEntry,C:\repos\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,MethodEntry,The method has 10 parameters. Parameters: file' comp_unit' token' scope_vars' locals' lines' code_blocks' real_name' flags' namespace_id
Long Parameter List,Mono.CompilerServices.SymbolWriter,MonoSymbolWriter,C:\repos\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs,MarkSequencePoint,The method has 5 parameters. Parameters: offset' file' line' column' is_hidden
Long Parameter List,Mono.CompilerServices.SymbolWriter,SourceMethodBuilder,C:\repos\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\SourceMethodBuilder.cs,MarkSequencePoint,The method has 5 parameters. Parameters: offset' file' line' column' is_hidden
Long Parameter List,Mono.CompilerServices.SymbolWriter,SourceMethodBuilder,C:\repos\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\SourceMethodBuilder.cs,MarkSequencePoint,The method has 7 parameters. Parameters: offset' file' line' column' end_line' end_column' is_hidden
Long Parameter List,Mono.CompilerServices.SymbolWriter,SymbolWriterImpl,C:\repos\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\SymbolWriterImpl.cs,DefineField,The method has 8 parameters. Parameters: parent' name' attributes' signature' addrKind' addr1' addr2' addr3
Long Parameter List,Mono.CompilerServices.SymbolWriter,SymbolWriterImpl,C:\repos\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\SymbolWriterImpl.cs,DefineGlobalVariable,The method has 7 parameters. Parameters: name' attributes' signature' addrKind' addr1' addr2' addr3
Long Parameter List,Mono.CompilerServices.SymbolWriter,SymbolWriterImpl,C:\repos\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\SymbolWriterImpl.cs,DefineLocalVariable,The method has 9 parameters. Parameters: name' attributes' signature' addrKind' addr1' addr2' addr3' startOffset' endOffset
Long Parameter List,Mono.CompilerServices.SymbolWriter,SymbolWriterImpl,C:\repos\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\SymbolWriterImpl.cs,DefineParameter,The method has 7 parameters. Parameters: name' attributes' sequence' addrKind' addr1' addr2' addr3
Long Parameter List,Mono.CompilerServices.SymbolWriter,SymbolWriterImpl,C:\repos\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\SymbolWriterImpl.cs,DefineSequencePoints,The method has 6 parameters. Parameters: document' offsets' lines' columns' endLines' endColumns
Long Parameter List,Mono.CompilerServices.SymbolWriter,SymbolWriterImpl,C:\repos\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\SymbolWriterImpl.cs,SetMethodSourceRange,The method has 6 parameters. Parameters: startDoc' startLine' startColumn' endDoc' endLine' endColumn
Long Statement,Mono.Cecil.Mdb,MdbWriter,C:\repos\jbevain_cecil\symbols\mdb\Mono.Cecil.Mdb\MdbWriter.cs,GetSourceFile,The length of the statement  "			var entry = writer.DefineDocument (url' null' document.Hash != null && document.Hash.Length == 16 ? document.Hash : null); " is 122.
Long Statement,Mono.CompilerServices.SymbolWriter,MethodEntry,C:\repos\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,GetLineNumberTable,The length of the statement  "				lnt = LineNumberTable.Read (SymbolFile' reader' (flags & Flags.ColumnsInfoIncluded) != 0' (flags & Flags.EndInfoIncluded) != 0); " is 128.
Complex Conditional,Mono.CompilerServices.SymbolWriter,SymbolWriterImpl,C:\repos\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\SymbolWriterImpl.cs,DefineSequencePoints,The conditional expression  "n > 0 && offsets[n] == offsets[n-1] && lines[n] == lines[n-1] && columns[n] == columns[n-1]"  is complex.
Empty Catch Block,Mono.CompilerServices.SymbolWriter,MonoSymbolWriter,C:\repos\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs,WriteSymbolFile,The method has an empty catch block.
Magic Number,Mono.Cecil.Mdb,MdbWriter,C:\repos\jbevain_cecil\symbols\mdb\Mono.Cecil.Mdb\MdbWriter.cs,GetSourceFile,The following statement contains a magic number: var entry = writer.DefineDocument (url' null' document.Hash != null && document.Hash.Length == 16 ? document.Hash : null);
Magic Number,Mono.CompilerServices.SymbolWriter,MonoSymbolFile,C:\repos\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs,MonoSymbolFile,The following statement contains a magic number: try {  				long magic = reader.ReadInt64 ();  				int major_version = reader.ReadInt32 ();  				int minor_version = reader.ReadInt32 ();    				if (magic != OffsetTable.Magic)  					throw new MonoSymbolFileException ("Symbol file is not a valid");  				if (major_version != OffsetTable.MajorVersion)  					throw new MonoSymbolFileException (  						"Symbol file has version {0} but expected {1}"' major_version' OffsetTable.MajorVersion);  				if (minor_version != OffsetTable.MinorVersion)  					throw new MonoSymbolFileException ("Symbol file has version {0}.{1} but expected {2}.{3}"'  						major_version' minor_version'  						OffsetTable.MajorVersion' OffsetTable.MinorVersion);    				MajorVersion = major_version;  				MinorVersion = minor_version;  				guid = new Guid (reader.ReadBytes (16));    				ot = new OffsetTable (reader' major_version' minor_version);  			} catch (Exception e) {  				throw new MonoSymbolFileException ("Cannot read symbol file"' e);  			}
Magic Number,Mono.CompilerServices.SymbolWriter,OffsetTable,C:\repos\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,OffsetTable,The following statement contains a magic number: if ((platform != 4) && (platform != 128))  				FileFlags |= Flags.WindowsFileNames;
Magic Number,Mono.CompilerServices.SymbolWriter,OffsetTable,C:\repos\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,OffsetTable,The following statement contains a magic number: if ((platform != 4) && (platform != 128))  				FileFlags |= Flags.WindowsFileNames;
Magic Number,Mono.CompilerServices.SymbolWriter,SourceFileEntry,C:\repos\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,WriteData,The following statement contains a magic number: if (guid == null)  				guid = new byte[16];
Magic Number,Mono.CompilerServices.SymbolWriter,SourceFileEntry,C:\repos\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,WriteData,The following statement contains a magic number: if (hash == null) {  				try {  				    using (FileStream fs = new FileStream (sourceFile' FileMode.Open' FileAccess.Read)) {  				        MD5 md5 = MD5.Create ();  				        hash = md5.ComputeHash (fs);  				    }  				} catch {  					hash = new byte [16];  				}  			}
Magic Number,Mono.CompilerServices.SymbolWriter,SourceFileEntry,C:\repos\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,SourceFileEntry,The following statement contains a magic number: guid = reader.ReadBytes (16);
Magic Number,Mono.CompilerServices.SymbolWriter,SourceFileEntry,C:\repos\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,SourceFileEntry,The following statement contains a magic number: hash = reader.ReadBytes (16);
Magic Number,Mono.CompilerServices.SymbolWriter,SourceFileEntry,C:\repos\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,CheckChecksum,The following statement contains a magic number: try {  				using (FileStream fs = new FileStream (sourceFile' FileMode.Open)) {  					MD5 md5 = MD5.Create ();  					byte[] data = md5.ComputeHash (fs);  					for (int i = 0; i < 16; i++)  						if (data [i] != hash [i])  							return false;  					return true;  				}  			} catch {  				return false;  			}
Magic Number,Mono.CompilerServices.SymbolWriter,LineNumberTable,C:\repos\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,LineNumberTable,The following statement contains a magic number: this.MaxAddressIncrement = (255 - OpcodeBase) / LineRange;
Magic Number,Mono.CompilerServices.SymbolWriter,LineNumberTable,C:\repos\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,Write,The following statement contains a magic number: for (int i = 0; i < LineNumbers.Length; i++) {  				int line_inc = LineNumbers [i].Row - last_line;  				int offset_inc = LineNumbers [i].Offset - last_offset;    				if (LineNumbers [i].File != last_file) {  					bw.Write (DW_LNS_set_file);  					bw.WriteLeb128 (LineNumbers [i].File);  					last_file = LineNumbers [i].File;  				}    				if (LineNumbers [i].IsHidden != last_is_hidden) {  					bw.Write ((byte) 0);  					bw.Write ((byte) 1);  					bw.Write (DW_LNE_MONO_negate_is_hidden);  					last_is_hidden = LineNumbers [i].IsHidden;  				}    				if (offset_inc >= MaxAddressIncrement) {  					if (offset_inc < 2 * MaxAddressIncrement) {  						bw.Write (DW_LNS_const_add_pc);  						offset_inc -= MaxAddressIncrement;  					} else {  						bw.Write (DW_LNS_advance_pc);  						bw.WriteLeb128 (offset_inc);  						offset_inc = 0;  					}  				}    				if ((line_inc < LineBase) || (line_inc >= LineBase + LineRange)) {  					bw.Write (DW_LNS_advance_line);  					bw.WriteLeb128 (line_inc);  					if (offset_inc != 0) {  						bw.Write (DW_LNS_advance_pc);  						bw.WriteLeb128 (offset_inc);  					}  					bw.Write (DW_LNS_copy);  				} else {  					byte opcode;  					opcode = (byte) (line_inc - LineBase + (LineRange * offset_inc) +  							 OpcodeBase);  					bw.Write (opcode);  				}    				last_line = LineNumbers [i].Row;  				last_offset = LineNumbers [i].Offset;  			}
Magic Number,Mono.CompilerServices.SymbolWriter,MethodEntry,C:\repos\jbevain_cecil\symbols\mdb\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs,MethodEntry,The following statement contains a magic number: if (num_locals <= 32) {  				// Most of the time' the O(n^2) factor is actually  				// less than the cost of allocating the hash table'  				// 32 is a rough number obtained through some testing.    				for (int i = 0; i < num_locals; i ++) {  					string nm = locals [i].Name;    					for (int j = i + 1; j < num_locals; j ++) {  						if (locals [j].Name == nm) {  							flags |= Flags.LocalNamesAmbiguous;  							goto locals_check_done;  						}  					}  				}  			locals_check_done :  				;  			} else {  				var local_names = new Dictionary<string' LocalVariableEntry> ();  				foreach (LocalVariableEntry local in locals) {  					if (local_names.ContainsKey (local.Name)) {  						flags |= Flags.LocalNamesAmbiguous;  						break;  					}  					local_names.Add (local.Name' local);  				}  			}
