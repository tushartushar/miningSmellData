Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.Cci.Pdb,PdbFunction,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFunction.cs,PdbFunction,The method has 109 lines of code.
Complex Method,Microsoft.Cci.Pdb,PdbConstant,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbConstant.cs,PdbConstant,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Cci.Pdb,PdbFile,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadManagedLines,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Cci.Pdb,PdbFile,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadFunctions,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci.Pdb,PdbFile,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadTokenToSourceInfo,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci.Pdb,PdbFunction,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFunction.cs,LoadManagedFunctions,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.Pdb,PdbFunction,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFunction.cs,PdbFunction,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.Cci.Pdb,PdbFunction,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFunction.cs,ReadCustomMetadata,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci.Pdb,PdbScope,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbScope.cs,PdbScope,Cyclomatic complexity of the method is 9
Complex Method,Mono.Cecil.Pdb,NativePdbReader,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,Read,Cyclomatic complexity of the method is 10
Complex Method,Mono.Cecil.Pdb,NativePdbReader,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,ReadScopeAndLocals,Cyclomatic complexity of the method is 10
Complex Method,Mono.Cecil.Pdb,NativePdbReader,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,GetImport,Cyclomatic complexity of the method is 14
Complex Method,Mono.Cecil.Pdb,NativePdbWriter,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbWriter.cs,DefineCustomMetadata,Cyclomatic complexity of the method is 9
Complex Method,Mono.Cecil.Pdb,NativePdbWriter,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbWriter.cs,DefineScope,Cyclomatic complexity of the method is 12
Long Parameter List,Microsoft.Cci.Pdb,DataStream,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\DataStream.cs,Read,The method has 5 parameters. Parameters: reader' position' bytes' offset' data
Long Parameter List,Microsoft.Cci.Pdb,PdbFile,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadInjectedSourceInformation,The method has 6 parameters. Parameters: bits' doctype' language' vendor' checksumAlgo' checksum
Long Parameter List,Microsoft.Cci.Pdb,PdbFile,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadManagedLines,The method has 8 parameters. Parameters: funcs' names' bits' dir' nameIndex' reader' limit' sourceCache
Long Parameter List,Microsoft.Cci.Pdb,PdbFile,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadFuncsFromDbiModule,The method has 9 parameters. Parameters: bits' info' names' funcList' readStrings' dir' nameIndex' reader' sourceCache
Long Parameter List,Microsoft.Cci.Pdb,PdbFile,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadTokenToSourceInfo,The method has 8 parameters. Parameters: bits' module' names' dir' nameIndex' reader' tokenToSourceMapping' sourceCache
Long Parameter List,Microsoft.Cci.Pdb,PdbFile,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,ReadSourceFileInfo,The method has 7 parameters. Parameters: bits' limit' names' dir' nameIndex' reader' sourceCache
Long Parameter List,Microsoft.Cci.Pdb,PdbFunction,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFunction.cs,CountScopesAndSlots,The method has 6 parameters. Parameters: bits' limit' constants' scopes' slots' usedNamespaces
Long Parameter List,Microsoft.Cci.Pdb,PdbLine,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbLine.cs,PdbLine,The method has 5 parameters. Parameters: offset' lineBegin' colBegin' lineEnd' colEnd
Long Parameter List,Microsoft.Cci.Pdb,PdbScope,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbScope.cs,PdbScope,The method has 6 parameters. Parameters: address' offset' length' slots' constants' usedNamespaces
Long Parameter List,Microsoft.Cci.Pdb,PdbScope,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbScope.cs,PdbScope,The method has 5 parameters. Parameters: address' length' slots' constants' usedNamespaces
Long Parameter List,Microsoft.Cci.Pdb,PdbSource,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbSource.cs,PdbSource,The method has 6 parameters. Parameters: name' doctype' language' vendor' checksumAlgorithm' checksum
Long Parameter List,Microsoft.Cci.Pdb,PdbTokenLine,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbTokenLine.cs,PdbTokenLine,The method has 6 parameters. Parameters: token' file_id' line' column' endLine' endColumn
Long Parameter List,Mono.Cecil.Pdb,ISymUnmanagedWriter2,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ISymUnmanagedWriter2.cs,DefineDocument,The method has 5 parameters. Parameters: url' langauge' languageVendor' documentType' pRetVal
Long Parameter List,Mono.Cecil.Pdb,ISymUnmanagedWriter2,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ISymUnmanagedWriter2.cs,DefineSequencePoints,The method has 7 parameters. Parameters: document' spCount' offsets' lines' columns' endLines' endColumns
Long Parameter List,Mono.Cecil.Pdb,ISymUnmanagedWriter2,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ISymUnmanagedWriter2.cs,DefineLocalVariable2,The method has 9 parameters. Parameters: name' attributes' sigToken' addrKind' addr1' addr2' addr3' startOffset' endOffset
Long Parameter List,Mono.Cecil.Pdb,IMetaDataEmit,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,DefineNestedType,The method has 5 parameters. Parameters: szTypeDef' dwTypeDefFlags' tkExtends' rtkImplements' tdEncloser
Long Parameter List,Mono.Cecil.Pdb,IMetaDataEmit,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,DefineMethod,The method has 7 parameters. Parameters: td' zName' dwMethodFlags' pvSigBlob' cbSigBlob' ulCodeRVA' dwImplFlags
Long Parameter List,Mono.Cecil.Pdb,IMetaDataEmit,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,DefineImportType,The method has 6 parameters. Parameters: pAssemImport' pbHashValue' cbHashValue' pImport' tdImport' pAssemEmit
Long Parameter List,Mono.Cecil.Pdb,IMetaDataEmit,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,DefineImportMember,The method has 7 parameters. Parameters: pAssemImport' pbHashValue' cbHashValue' pImport' mbMember' pAssemEmit' tkParent
Long Parameter List,Mono.Cecil.Pdb,IMetaDataEmit,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,DefineEvent,The method has 8 parameters. Parameters: td' szEvent' dwEventFlags' tkEventType' mdAddOn' mdRemoveOn' mdFire' rmdOtherMethods
Long Parameter List,Mono.Cecil.Pdb,IMetaDataEmit,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,SetEventProps,The method has 7 parameters. Parameters: ev' dwEventFlags' tkEventType' mdAddOn' mdRemoveOn' mdFire' rmdOtherMethods
Long Parameter List,Mono.Cecil.Pdb,IMetaDataEmit,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,DefineField,The method has 8 parameters. Parameters: td' szName' dwFieldFlags' pvSigBlob' cbSigBlob' dwCPlusTypeFlag' pValue' cchValue
Long Parameter List,Mono.Cecil.Pdb,IMetaDataEmit,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,DefineProperty,The method has 11 parameters. Parameters: td' szProperty' dwPropFlags' pvSig' cbSig' dwCPlusTypeFlag' pValue' cchValue' mdSetter' mdGetter' rmdOtherMethods
Long Parameter List,Mono.Cecil.Pdb,IMetaDataEmit,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,DefineParam,The method has 7 parameters. Parameters: md' ulParamSeq' szName' dwParamFlags' dwCPlusTypeFlag' pValue' cchValue
Long Parameter List,Mono.Cecil.Pdb,IMetaDataEmit,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,SetFieldProps,The method has 5 parameters. Parameters: fd' dwFieldFlags' dwCPlusTypeFlag' pValue' cchValue
Long Parameter List,Mono.Cecil.Pdb,IMetaDataEmit,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,SetPropertyProps,The method has 8 parameters. Parameters: pr' dwPropFlags' dwCPlusTypeFlag' pValue' cchValue' mdSetter' mdGetter' rmdOtherMethods
Long Parameter List,Mono.Cecil.Pdb,IMetaDataEmit,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,SetParamProps,The method has 6 parameters. Parameters: pd' szName' dwParamFlags' dwCPlusTypeFlag' pValue' cchValue
Long Parameter List,Mono.Cecil.Pdb,IMetaDataEmit,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,TranslateSigWithScope,The method has 10 parameters. Parameters: pAssemImport' pbHashValue' cbHashValue' import' pbSigBlob' cbSigBlob' pAssemEmit' emit' pvTranslatedSig' cbTranslatedSigMax
Long Parameter List,Mono.Cecil.Pdb,IMetaDataImport,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,GetTypeDefProps,The method has 5 parameters. Parameters: td' szTypeDef' cchTypeDef' pchTypeDef' pdwTypeDefFlags
Long Parameter List,Mono.Cecil.Pdb,IMetaDataImport,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,EnumMembersWithName,The method has 5 parameters. Parameters: phEnum' cl' szName' rMembers' cMax
Long Parameter List,Mono.Cecil.Pdb,IMetaDataImport,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,EnumMethodsWithName,The method has 5 parameters. Parameters: phEnum' cl' szName' rMethods' cMax
Long Parameter List,Mono.Cecil.Pdb,IMetaDataImport,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,EnumFieldsWithName,The method has 5 parameters. Parameters: phEnum' cl' szName' rFields' cMax
Long Parameter List,Mono.Cecil.Pdb,IMetaDataImport,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,EnumMethodImpls,The method has 5 parameters. Parameters: phEnum' td' rMethodBody' rMethodDecl' cMax
Long Parameter List,Mono.Cecil.Pdb,IMetaDataImport,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,EnumPermissionSets,The method has 5 parameters. Parameters: phEnum' tk' dwActions' rPermission' cMax
Long Parameter List,Mono.Cecil.Pdb,IMetaDataImport,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,GetMethodProps,The method has 9 parameters. Parameters: mb' pClass' szMethod' cchMethod' pchMethod' pdwAttr' ppvSigBlob' pcbSigBlob' pulCodeRVA
Long Parameter List,Mono.Cecil.Pdb,IMetaDataImport,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,GetMemberRefProps,The method has 6 parameters. Parameters: mr' ptk' szMember' cchMember' pchMember' ppvSigBlob
Long Parameter List,Mono.Cecil.Pdb,IMetaDataImport,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,GetEventProps,The method has 12 parameters. Parameters: ev' pClass' szEvent' cchEvent' pchEvent' pdwEventFlags' ptkEventType' pmdAddOn' pmdRemoveOn' pmdFire' rmdOtherMethod' cMax
Long Parameter List,Mono.Cecil.Pdb,IMetaDataImport,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,GetClassLayout,The method has 5 parameters. Parameters: td' pdwPackSize' rFieldOffset' cMax' pcFieldOffset
Long Parameter List,Mono.Cecil.Pdb,IMetaDataImport,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,GetPinvokeMap,The method has 5 parameters. Parameters: tk' pdwMappingFlags' szImportName' cchImportName' pchImportName
Long Parameter List,Mono.Cecil.Pdb,IMetaDataImport,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,EnumCustomAttributes,The method has 5 parameters. Parameters: phEnum' tk' tkType' rCustomAttributes' cMax
Long Parameter List,Mono.Cecil.Pdb,IMetaDataImport,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,GetMemberProps,The method has 12 parameters. Parameters: mb' pClass' szMember' cchMember' pchMember' pdwAttr' ppvSigBlob' pcbSigBlob' pulCodeRVA' pdwImplFlags' pdwCPlusTypeFlag' ppValue
Long Parameter List,Mono.Cecil.Pdb,IMetaDataImport,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,GetFieldProps,The method has 10 parameters. Parameters: mb' pClass' szField' cchField' pchField' pdwAttr' ppvSigBlob' pcbSigBlob' pdwCPlusTypeFlag' ppValue
Long Parameter List,Mono.Cecil.Pdb,IMetaDataImport,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,GetPropertyProps,The method has 15 parameters. Parameters: prop' pClass' szProperty' cchProperty' pchProperty' pdwPropFlags' ppvSig' pbSig' pdwCPlusTypeFlag' ppDefaultValue' pcchDefaultValue' pmdSetter' pmdGetter' rmdOtherMethod' cMax
Long Parameter List,Mono.Cecil.Pdb,IMetaDataImport,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,GetParamProps,The method has 9 parameters. Parameters: tk' pmd' pulSequence' szName' cchName' pchName' pdwAttr' pdwCPlusTypeFlag' ppValue
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,DefineNestedType,The method has 5 parameters. Parameters: szTypeDef' dwTypeDefFlags' tkExtends' rtkImplements' tdEncloser
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,DefineMethod,The method has 7 parameters. Parameters: td' zName' dwMethodFlags' pvSigBlob' cbSigBlob' ulCodeRVA' dwImplFlags
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,DefineImportType,The method has 6 parameters. Parameters: pAssemImport' pbHashValue' cbHashValue' pImport' tdImport' pAssemEmit
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,DefineImportMember,The method has 7 parameters. Parameters: pAssemImport' pbHashValue' cbHashValue' pImport' mbMember' pAssemEmit' tkParent
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,DefineEvent,The method has 8 parameters. Parameters: td' szEvent' dwEventFlags' tkEventType' mdAddOn' mdRemoveOn' mdFire' rmdOtherMethods
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,SetEventProps,The method has 7 parameters. Parameters: ev' dwEventFlags' tkEventType' mdAddOn' mdRemoveOn' mdFire' rmdOtherMethods
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,DefineField,The method has 8 parameters. Parameters: td' szName' dwFieldFlags' pvSigBlob' cbSigBlob' dwCPlusTypeFlag' pValue' cchValue
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,DefineProperty,The method has 11 parameters. Parameters: td' szProperty' dwPropFlags' pvSig' cbSig' dwCPlusTypeFlag' pValue' cchValue' mdSetter' mdGetter' rmdOtherMethods
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,DefineParam,The method has 7 parameters. Parameters: md' ulParamSeq' szName' dwParamFlags' dwCPlusTypeFlag' pValue' cchValue
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,SetFieldProps,The method has 5 parameters. Parameters: fd' dwFieldFlags' dwCPlusTypeFlag' pValue' cchValue
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,SetPropertyProps,The method has 8 parameters. Parameters: pr' dwPropFlags' dwCPlusTypeFlag' pValue' cchValue' mdSetter' mdGetter' rmdOtherMethods
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,SetParamProps,The method has 6 parameters. Parameters: pd' szName' dwParamFlags' dwCPlusTypeFlag' pValue' cchValue
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,TranslateSigWithScope,The method has 10 parameters. Parameters: pAssemImport' pbHashValue' cbHashValue' import' pbSigBlob' cbSigBlob' pAssemEmit' emit' pvTranslatedSig' cbTranslatedSigMax
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,GetTypeDefProps,The method has 5 parameters. Parameters: td' szTypeDef' cchTypeDef' pchTypeDef' pdwTypeDefFlags
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,EnumMembersWithName,The method has 5 parameters. Parameters: phEnum' cl' szName' rMembers' cMax
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,EnumMethodsWithName,The method has 5 parameters. Parameters: phEnum' cl' szName' rMethods' cMax
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,EnumFieldsWithName,The method has 5 parameters. Parameters: phEnum' cl' szName' rFields' cMax
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,EnumMethodImpls,The method has 5 parameters. Parameters: phEnum' td' rMethodBody' rMethodDecl' cMax
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,EnumPermissionSets,The method has 5 parameters. Parameters: phEnum' tk' dwActions' rPermission' cMax
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,GetMethodProps,The method has 9 parameters. Parameters: mb' pClass' szMethod' cchMethod' pchMethod' pdwAttr' ppvSigBlob' pcbSigBlob' pulCodeRVA
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,GetMemberRefProps,The method has 6 parameters. Parameters: mr' ptk' szMember' cchMember' pchMember' ppvSigBlob
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,GetEventProps,The method has 12 parameters. Parameters: ev' pClass' szEvent' cchEvent' pchEvent' pdwEventFlags' ptkEventType' pmdAddOn' pmdRemoveOn' pmdFire' rmdOtherMethod' cMax
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,GetClassLayout,The method has 5 parameters. Parameters: td' pdwPackSize' rFieldOffset' cMax' pcFieldOffset
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,GetPinvokeMap,The method has 5 parameters. Parameters: tk' pdwMappingFlags' szImportName' cchImportName' pchImportName
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,EnumCustomAttributes,The method has 5 parameters. Parameters: phEnum' tk' tkType' rCustomAttributes' cMax
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,GetMemberProps,The method has 12 parameters. Parameters: mb' pClass' szMember' cchMember' pchMember' pdwAttr' ppvSigBlob' pcbSigBlob' pulCodeRVA' pdwImplFlags' pdwCPlusTypeFlag' ppValue
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,GetFieldProps,The method has 10 parameters. Parameters: mb' pClass' szField' cchField' pchField' pdwAttr' ppvSigBlob' pcbSigBlob' pdwCPlusTypeFlag' ppValue
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,GetPropertyProps,The method has 15 parameters. Parameters: prop' pClass' szProperty' cchProperty' pchProperty' pdwPropFlags' ppvSig' pbSig' pdwCPlusTypeFlag' ppDefaultValue' pcchDefaultValue' pmdSetter' pmdGetter' rmdOtherMethod' cMax
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,GetParamProps,The method has 9 parameters. Parameters: tk' pmd' pulSequence' szName' cchName' pchName' pdwAttr' pdwCPlusTypeFlag' ppValue
Long Parameter List,Mono.Cecil.Pdb,SymWriter,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\SymWriter.cs,CoCreateInstance,The method has 5 parameters. Parameters: rclsid' pUnkOuter' dwClsContext' riid' ppv
Long Parameter List,Mono.Cecil.Pdb,SymWriter,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\SymWriter.cs,DefineLocalVariable2,The method has 8 parameters. Parameters: name' attributes' sigToken' addr1' addr2' addr3' startOffset' endOffset
Long Parameter List,Mono.Cecil.Pdb,SymWriter,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\SymWriter.cs,DefineSequencePoints,The method has 6 parameters. Parameters: document' offsets' lines' columns' endLines' endColumns
Long Identifier,Microsoft.Cci.Pdb,PdbFunction,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFunction.cs,,The length of the parameter tokenOfMethodWhoseUsingInfoAppliesToThisMethod is 46.
Long Statement,Microsoft.Cci.Pdb,PdbFile,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadFunctions,The length of the statement  "        throw new PdbException("Could not find the '/NAMES' stream: the PDB file may be a public symbol file instead of a private symbol file"); " is 136.
Long Statement,Microsoft.Cci.Pdb,PdbFile,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,ReadSourceFileInfo,The length of the statement  "                  LoadInjectedSourceInformation(guidBits' out doctypeGuid' out languageGuid' out vendorGuid' out checksumAlgoGuid' out checksum); " is 127.
Long Statement,Microsoft.Cci.Pdb,PdbFunction,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFunction.cs,ReadCustomMetadata,The length of the statement  "                case 5: break; // dynamic locals - see http://index/#Microsoft.VisualStudio.LanguageServices/Shared/CustomDebugInfoReader.cs'a3031f7681d76e93 " is 141.
Long Statement,Mono.Cecil.Pdb,NativePdbReader,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,Read,The length of the statement  "			if (function.tokenOfMethodWhoseUsingInfoAppliesToThisMethod != method.MetadataToken.ToUInt32 () && function.tokenOfMethodWhoseUsingInfoAppliesToThisMethod != 0) " is 160.
Long Statement,Mono.Cecil.Pdb,NativePdbReader,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,Read,The length of the statement  "					state_machine.Scopes.Add (new StateMachineScope ((int) iterator_scope.Offset' (int) (iterator_scope.Offset + iterator_scope.Length + 1))); " is 138.
Long Statement,Mono.Cecil.Pdb,NativePdbReader,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,Read,The length of the statement  "				var async_debug_info = new AsyncMethodBodyDebugInformation ((int) function.synchronizationInformation.GeneratedCatchHandlerOffset); " is 131.
Long Statement,Mono.Cecil.Pdb,NativePdbReader,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,Read,The length of the statement  "				symbol.StateMachineKickOffMethod = (MethodDefinition) method.Module.LookupToken ((int) function.synchronizationInformation.kickoffMethodToken); " is 143.
Long Statement,Mono.Cecil.Pdb,NativePdbReader,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,GetImport,The length of the statement  "						target = new ImportTarget (ImportTargetKind.DefineNamespaceAlias) { alias = alias_value' @namespace = alias_target_value }; " is 123.
Long Statement,Mono.Cecil.Pdb,NativePdbWriter,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbWriter.cs,Write,The length of the statement  "			if (!info.HasSequencePoints && info.scope == null && !info.HasCustomDebugInformations && info.StateMachineKickOffMethod == null) " is 128.
Long Statement,Mono.Cecil.Pdb,NativePdbWriter,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbWriter.cs,DefineCustomMetadata,The length of the statement  "					if (!attribute_type.IsTypeOf (compiler_services' "IteratorStateMachineAttribute") && !attribute_type.IsTypeOf (compiler_services' "AsyncStateMachineAttribute")) " is 160.
Long Statement,Mono.Cecil.Pdb,NativePdbWriter,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbWriter.cs,DefineCustomMetadata,The length of the statement  "				var state_machine = info.CustomDebugInformations.FirstOrDefault (cdi => cdi.Kind == CustomDebugInformationKind.StateMachineScope) as StateMachineScopeDebugInformation; " is 167.
Long Statement,Mono.Cecil.Pdb,NativePdbWriter,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbWriter.cs,DefineAsyncCustomMetadata,The length of the statement  "					async_metadata.WriteUInt32 (info.StateMachineKickOffMethod != null ? info.StateMachineKickOffMethod.MetadataToken.ToUInt32 () : 0); " is 131.
Long Statement,Mono.Cecil.Pdb,NativePdbWriter,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbWriter.cs,DefineScope,The length of the statement  "			if (scope.Import != null && scope.Import.HasTargets && !import_info_to_parent.TryGetValue (info.scope.Import' out import_parent)) { " is 131.
Long Statement,Mono.Cecil.Pdb,SymWriter,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\SymWriter.cs,DefineLocalVariable2,The length of the statement  "			writer.DefineLocalVariable2 (name' (int)attributes' sigToken' 1 /* ILOffset*/' addr1' addr2' addr3' startOffset' endOffset); " is 124.
Complex Conditional,Mono.Cecil.Pdb,NativePdbReader,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,ReadScopeAndLocals,The conditional expression  "type != null && !type.IsValueType && value is int && (int) value == 0"  is complex.
Complex Conditional,Mono.Cecil.Pdb,NativePdbWriter,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbWriter.cs,Write,The conditional expression  "!info.HasSequencePoints && info.scope == null && !info.HasCustomDebugInformations && info.StateMachineKickOffMethod == null"  is complex.
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt16,The following statement contains a magic number: value = (short)((buffer[offset + 0] & 0xFF) |                              (buffer[offset + 1] << 8));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt16,The following statement contains a magic number: offset += 2;
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt32,The following statement contains a magic number: value = (int)((buffer[offset + 0] & 0xFF) |                            (buffer[offset + 1] << 8) |                            (buffer[offset + 2] << 16) |                            (buffer[offset + 3] << 24));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt32,The following statement contains a magic number: value = (int)((buffer[offset + 0] & 0xFF) |                            (buffer[offset + 1] << 8) |                            (buffer[offset + 2] << 16) |                            (buffer[offset + 3] << 24));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt32,The following statement contains a magic number: value = (int)((buffer[offset + 0] & 0xFF) |                            (buffer[offset + 1] << 8) |                            (buffer[offset + 2] << 16) |                            (buffer[offset + 3] << 24));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt32,The following statement contains a magic number: value = (int)((buffer[offset + 0] & 0xFF) |                            (buffer[offset + 1] << 8) |                            (buffer[offset + 2] << 16) |                            (buffer[offset + 3] << 24));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt32,The following statement contains a magic number: value = (int)((buffer[offset + 0] & 0xFF) |                            (buffer[offset + 1] << 8) |                            (buffer[offset + 2] << 16) |                            (buffer[offset + 3] << 24));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt32,The following statement contains a magic number: offset += 4;
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt64,The following statement contains a magic number: offset += 8;
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt16,The following statement contains a magic number: value = (ushort)((buffer[offset + 0] & 0xFF) |                               (buffer[offset + 1] << 8));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt16,The following statement contains a magic number: offset += 2;
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt32,The following statement contains a magic number: value = (uint)((buffer[offset + 0] & 0xFF) |                             (buffer[offset + 1] << 8) |                             (buffer[offset + 2] << 16) |                             (buffer[offset + 3] << 24));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt32,The following statement contains a magic number: value = (uint)((buffer[offset + 0] & 0xFF) |                             (buffer[offset + 1] << 8) |                             (buffer[offset + 2] << 16) |                             (buffer[offset + 3] << 24));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt32,The following statement contains a magic number: value = (uint)((buffer[offset + 0] & 0xFF) |                             (buffer[offset + 1] << 8) |                             (buffer[offset + 2] << 16) |                             (buffer[offset + 3] << 24));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt32,The following statement contains a magic number: value = (uint)((buffer[offset + 0] & 0xFF) |                             (buffer[offset + 1] << 8) |                             (buffer[offset + 2] << 16) |                             (buffer[offset + 3] << 24));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt32,The following statement contains a magic number: value = (uint)((buffer[offset + 0] & 0xFF) |                             (buffer[offset + 1] << 8) |                             (buffer[offset + 2] << 16) |                             (buffer[offset + 3] << 24));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt32,The following statement contains a magic number: offset += 4;
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt64,The following statement contains a magic number: offset += 8;
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadFloat,The following statement contains a magic number: offset += 4;
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadDouble,The following statement contains a magic number: offset += 8;
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadDecimal,The following statement contains a magic number: int[] bits = new int[4];
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadDecimal,The following statement contains a magic number: return new decimal(bits[2]' bits[3]' bits[1]' bits[0] < 0' (byte)((bits[0] & 0x00FF0000) >> 16));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadDecimal,The following statement contains a magic number: return new decimal(bits[2]' bits[3]' bits[1]' bits[0] < 0' (byte)((bits[0] & 0x00FF0000) >> 16));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadDecimal,The following statement contains a magic number: return new decimal(bits[2]' bits[3]' bits[1]' bits[0] < 0' (byte)((bits[0] & 0x00FF0000) >> 16));
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadString,The following statement contains a magic number: len+=2;
Magic Number,Microsoft.Cci.Pdb,BitAccess,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadString,The following statement contains a magic number: offset += len + 2;
Magic Number,Microsoft.Cci.Pdb,BitSet,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitSet.cs,IsSet,The following statement contains a magic number: int word = index / 32;
Magic Number,Microsoft.Cci.Pdb,BitSet,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitSet.cs,GetBit,The following statement contains a magic number: return ((uint)1 << (index % 32));
Magic Number,Microsoft.Cci.Pdb,DbiModuleInfo,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\DbiModuleInfo.cs,DbiModuleInfo,The following statement contains a magic number: bits.Align(4);
Magic Number,Microsoft.Cci.Pdb,IntHashTable,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\IntHashTable.cs,IntHashTable,The following statement contains a magic number: throw new ArgumentOutOfRangeException("loadFactorPerc"' String.Format("ArgumentOutOfRange_IntHashTableLoadFactor"' 10' 100));
Magic Number,Microsoft.Cci.Pdb,IntHashTable,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\IntHashTable.cs,IntHashTable,The following statement contains a magic number: throw new ArgumentOutOfRangeException("loadFactorPerc"' String.Format("ArgumentOutOfRange_IntHashTableLoadFactor"' 10' 100));
Magic Number,Microsoft.Cci.Pdb,IntHashTable,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\IntHashTable.cs,IntHashTable,The following statement contains a magic number: !(loadFactorPerc >= 10 && loadFactorPerc <= 100)
Magic Number,Microsoft.Cci.Pdb,IntHashTable,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\IntHashTable.cs,IntHashTable,The following statement contains a magic number: !(loadFactorPerc >= 10 && loadFactorPerc <= 100)
Magic Number,Microsoft.Cci.Pdb,IntHashTable,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\IntHashTable.cs,IntHashTable,The following statement contains a magic number: this.loadFactorPerc = (loadFactorPerc * 72) / 100;
Magic Number,Microsoft.Cci.Pdb,IntHashTable,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\IntHashTable.cs,IntHashTable,The following statement contains a magic number: this.loadFactorPerc = (loadFactorPerc * 72) / 100;
Magic Number,Microsoft.Cci.Pdb,IntHashTable,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\IntHashTable.cs,IntHashTable,The following statement contains a magic number: loadsize = (int)(this.loadFactorPerc * hashsize) / 100;
Magic Number,Microsoft.Cci.Pdb,IntHashTable,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\IntHashTable.cs,InitHash,The following statement contains a magic number: incr = (uint)(1 + (((seed >> 5) + 1) % ((uint)hashsize - 1)));
Magic Number,Microsoft.Cci.Pdb,IntHashTable,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\IntHashTable.cs,expand,The following statement contains a magic number: rehash(GetPrime(1+buckets.Length*2));
Magic Number,Microsoft.Cci.Pdb,IntHashTable,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\IntHashTable.cs,rehash,The following statement contains a magic number: loadsize = (int)(loadFactorPerc * newsize) / 100;
Magic Number,Microsoft.Cci.Pdb,IntHashTable,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\IntHashTable.cs,putEntry,The following statement contains a magic number: uint incr = (uint)(1 + (((seed >> 5) + 1) % ((uint)newBuckets.Length - 1)));
Magic Number,Microsoft.Cci.Pdb,MsfDirectory,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\MsfDirectory.cs,MsfDirectory,The following statement contains a magic number: int pagesPerPage = head.pageSize / 4;
Magic Number,Microsoft.Cci.Pdb,MsfDirectory,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\MsfDirectory.cs,MsfDirectory,The following statement contains a magic number: bits.Append(reader.reader' pagesInThisPage * 4);
Magic Number,Microsoft.Cci.Pdb,PdbFile,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: switch ((DEBUG_S_SUBSECTION)sig) {            case DEBUG_S_SUBSECTION.LINES: {                CV_LineSection sec;                  bits.ReadUInt32(out sec.off);                bits.ReadUInt16(out sec.sec);                bits.ReadUInt16(out sec.flags);                bits.ReadUInt32(out sec.cod);                int funcIndex = FindFunction(funcs' sec.sec' sec.off);                if (funcIndex < 0) break;                var func = funcs[funcIndex];                if (func.lines == null) {                  while (funcIndex > 0) {                    var f = funcs[funcIndex-1];                    if (f.lines != null || f.segment != sec.sec || f.address != sec.off) break;                    func = f;                    funcIndex--;                  }                } else {                  while (funcIndex < funcs.Length-1 && func.lines != null) {                    var f = funcs[funcIndex+1];                    if (f.segment != sec.sec || f.address != sec.off) break;                    func = f;                    funcIndex++;                  }                }                if (func.lines != null) break;                  // Count the line blocks.                int begSym = bits.Position;                int blocks = 0;                while (bits.Position < endSym) {                  CV_SourceFile file;                  bits.ReadUInt32(out file.index);                  bits.ReadUInt32(out file.count);                  bits.ReadUInt32(out file.linsiz);   // Size of payload.                  int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));                  bits.Position += linsiz;                  blocks++;                }                  func.lines = new PdbLines[blocks];                int block = 0;                  bits.Position = begSym;                while (bits.Position < endSym) {                  CV_SourceFile file;                  bits.ReadUInt32(out file.index);                  bits.ReadUInt32(out file.count);                  bits.ReadUInt32(out file.linsiz);   // Size of payload.                    PdbSource src = (PdbSource)checks[(int)file.index];                  if (src.language.Equals(BasicLanguageGuid))                  {                    func.AdjustVisualBasicScopes();                  }                    PdbLines tmp = new PdbLines(src' file.count);                  func.lines[block++] = tmp;                  PdbLine[] lines = tmp.lines;                    int plin = bits.Position;                  int pcol = bits.Position + 8 * (int)file.count;                    for (int i = 0; i < file.count; i++) {                    CV_Line line;                    CV_Column column = new CV_Column();                      bits.Position = plin + 8 * i;                    bits.ReadUInt32(out line.offset);                    bits.ReadUInt32(out line.flags);                      uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;                    uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;                    //bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);                    if ((sec.flags & 1) != 0) {                      bits.Position = pcol + 4 * i;                      bits.ReadUInt16(out column.offColumnStart);                      bits.ReadUInt16(out column.offColumnEnd);                    }                      lines[i] = new PdbLine(line.offset'                                           lineBegin'                                           column.offColumnStart'                                           lineBegin+delta'                                           column.offColumnEnd);                  }                }                break;              }          }
Magic Number,Microsoft.Cci.Pdb,PdbFile,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: switch ((DEBUG_S_SUBSECTION)sig) {            case DEBUG_S_SUBSECTION.LINES: {                CV_LineSection sec;                  bits.ReadUInt32(out sec.off);                bits.ReadUInt16(out sec.sec);                bits.ReadUInt16(out sec.flags);                bits.ReadUInt32(out sec.cod);                int funcIndex = FindFunction(funcs' sec.sec' sec.off);                if (funcIndex < 0) break;                var func = funcs[funcIndex];                if (func.lines == null) {                  while (funcIndex > 0) {                    var f = funcs[funcIndex-1];                    if (f.lines != null || f.segment != sec.sec || f.address != sec.off) break;                    func = f;                    funcIndex--;                  }                } else {                  while (funcIndex < funcs.Length-1 && func.lines != null) {                    var f = funcs[funcIndex+1];                    if (f.segment != sec.sec || f.address != sec.off) break;                    func = f;                    funcIndex++;                  }                }                if (func.lines != null) break;                  // Count the line blocks.                int begSym = bits.Position;                int blocks = 0;                while (bits.Position < endSym) {                  CV_SourceFile file;                  bits.ReadUInt32(out file.index);                  bits.ReadUInt32(out file.count);                  bits.ReadUInt32(out file.linsiz);   // Size of payload.                  int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));                  bits.Position += linsiz;                  blocks++;                }                  func.lines = new PdbLines[blocks];                int block = 0;                  bits.Position = begSym;                while (bits.Position < endSym) {                  CV_SourceFile file;                  bits.ReadUInt32(out file.index);                  bits.ReadUInt32(out file.count);                  bits.ReadUInt32(out file.linsiz);   // Size of payload.                    PdbSource src = (PdbSource)checks[(int)file.index];                  if (src.language.Equals(BasicLanguageGuid))                  {                    func.AdjustVisualBasicScopes();                  }                    PdbLines tmp = new PdbLines(src' file.count);                  func.lines[block++] = tmp;                  PdbLine[] lines = tmp.lines;                    int plin = bits.Position;                  int pcol = bits.Position + 8 * (int)file.count;                    for (int i = 0; i < file.count; i++) {                    CV_Line line;                    CV_Column column = new CV_Column();                      bits.Position = plin + 8 * i;                    bits.ReadUInt32(out line.offset);                    bits.ReadUInt32(out line.flags);                      uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;                    uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;                    //bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);                    if ((sec.flags & 1) != 0) {                      bits.Position = pcol + 4 * i;                      bits.ReadUInt16(out column.offColumnStart);                      bits.ReadUInt16(out column.offColumnEnd);                    }                      lines[i] = new PdbLine(line.offset'                                           lineBegin'                                           column.offColumnStart'                                           lineBegin+delta'                                           column.offColumnEnd);                  }                }                break;              }          }
Magic Number,Microsoft.Cci.Pdb,PdbFile,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: switch ((DEBUG_S_SUBSECTION)sig) {            case DEBUG_S_SUBSECTION.LINES: {                CV_LineSection sec;                  bits.ReadUInt32(out sec.off);                bits.ReadUInt16(out sec.sec);                bits.ReadUInt16(out sec.flags);                bits.ReadUInt32(out sec.cod);                int funcIndex = FindFunction(funcs' sec.sec' sec.off);                if (funcIndex < 0) break;                var func = funcs[funcIndex];                if (func.lines == null) {                  while (funcIndex > 0) {                    var f = funcs[funcIndex-1];                    if (f.lines != null || f.segment != sec.sec || f.address != sec.off) break;                    func = f;                    funcIndex--;                  }                } else {                  while (funcIndex < funcs.Length-1 && func.lines != null) {                    var f = funcs[funcIndex+1];                    if (f.segment != sec.sec || f.address != sec.off) break;                    func = f;                    funcIndex++;                  }                }                if (func.lines != null) break;                  // Count the line blocks.                int begSym = bits.Position;                int blocks = 0;                while (bits.Position < endSym) {                  CV_SourceFile file;                  bits.ReadUInt32(out file.index);                  bits.ReadUInt32(out file.count);                  bits.ReadUInt32(out file.linsiz);   // Size of payload.                  int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));                  bits.Position += linsiz;                  blocks++;                }                  func.lines = new PdbLines[blocks];                int block = 0;                  bits.Position = begSym;                while (bits.Position < endSym) {                  CV_SourceFile file;                  bits.ReadUInt32(out file.index);                  bits.ReadUInt32(out file.count);                  bits.ReadUInt32(out file.linsiz);   // Size of payload.                    PdbSource src = (PdbSource)checks[(int)file.index];                  if (src.language.Equals(BasicLanguageGuid))                  {                    func.AdjustVisualBasicScopes();                  }                    PdbLines tmp = new PdbLines(src' file.count);                  func.lines[block++] = tmp;                  PdbLine[] lines = tmp.lines;                    int plin = bits.Position;                  int pcol = bits.Position + 8 * (int)file.count;                    for (int i = 0; i < file.count; i++) {                    CV_Line line;                    CV_Column column = new CV_Column();                      bits.Position = plin + 8 * i;                    bits.ReadUInt32(out line.offset);                    bits.ReadUInt32(out line.flags);                      uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;                    uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;                    //bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);                    if ((sec.flags & 1) != 0) {                      bits.Position = pcol + 4 * i;                      bits.ReadUInt16(out column.offColumnStart);                      bits.ReadUInt16(out column.offColumnEnd);                    }                      lines[i] = new PdbLine(line.offset'                                           lineBegin'                                           column.offColumnStart'                                           lineBegin+delta'                                           column.offColumnEnd);                  }                }                break;              }          }
Magic Number,Microsoft.Cci.Pdb,PdbFile,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: switch ((DEBUG_S_SUBSECTION)sig) {            case DEBUG_S_SUBSECTION.LINES: {                CV_LineSection sec;                  bits.ReadUInt32(out sec.off);                bits.ReadUInt16(out sec.sec);                bits.ReadUInt16(out sec.flags);                bits.ReadUInt32(out sec.cod);                int funcIndex = FindFunction(funcs' sec.sec' sec.off);                if (funcIndex < 0) break;                var func = funcs[funcIndex];                if (func.lines == null) {                  while (funcIndex > 0) {                    var f = funcs[funcIndex-1];                    if (f.lines != null || f.segment != sec.sec || f.address != sec.off) break;                    func = f;                    funcIndex--;                  }                } else {                  while (funcIndex < funcs.Length-1 && func.lines != null) {                    var f = funcs[funcIndex+1];                    if (f.segment != sec.sec || f.address != sec.off) break;                    func = f;                    funcIndex++;                  }                }                if (func.lines != null) break;                  // Count the line blocks.                int begSym = bits.Position;                int blocks = 0;                while (bits.Position < endSym) {                  CV_SourceFile file;                  bits.ReadUInt32(out file.index);                  bits.ReadUInt32(out file.count);                  bits.ReadUInt32(out file.linsiz);   // Size of payload.                  int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));                  bits.Position += linsiz;                  blocks++;                }                  func.lines = new PdbLines[blocks];                int block = 0;                  bits.Position = begSym;                while (bits.Position < endSym) {                  CV_SourceFile file;                  bits.ReadUInt32(out file.index);                  bits.ReadUInt32(out file.count);                  bits.ReadUInt32(out file.linsiz);   // Size of payload.                    PdbSource src = (PdbSource)checks[(int)file.index];                  if (src.language.Equals(BasicLanguageGuid))                  {                    func.AdjustVisualBasicScopes();                  }                    PdbLines tmp = new PdbLines(src' file.count);                  func.lines[block++] = tmp;                  PdbLine[] lines = tmp.lines;                    int plin = bits.Position;                  int pcol = bits.Position + 8 * (int)file.count;                    for (int i = 0; i < file.count; i++) {                    CV_Line line;                    CV_Column column = new CV_Column();                      bits.Position = plin + 8 * i;                    bits.ReadUInt32(out line.offset);                    bits.ReadUInt32(out line.flags);                      uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;                    uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;                    //bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);                    if ((sec.flags & 1) != 0) {                      bits.Position = pcol + 4 * i;                      bits.ReadUInt16(out column.offColumnStart);                      bits.ReadUInt16(out column.offColumnEnd);                    }                      lines[i] = new PdbLine(line.offset'                                           lineBegin'                                           column.offColumnStart'                                           lineBegin+delta'                                           column.offColumnEnd);                  }                }                break;              }          }
Magic Number,Microsoft.Cci.Pdb,PdbFile,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: switch ((DEBUG_S_SUBSECTION)sig) {            case DEBUG_S_SUBSECTION.LINES: {                CV_LineSection sec;                  bits.ReadUInt32(out sec.off);                bits.ReadUInt16(out sec.sec);                bits.ReadUInt16(out sec.flags);                bits.ReadUInt32(out sec.cod);                int funcIndex = FindFunction(funcs' sec.sec' sec.off);                if (funcIndex < 0) break;                var func = funcs[funcIndex];                if (func.lines == null) {                  while (funcIndex > 0) {                    var f = funcs[funcIndex-1];                    if (f.lines != null || f.segment != sec.sec || f.address != sec.off) break;                    func = f;                    funcIndex--;                  }                } else {                  while (funcIndex < funcs.Length-1 && func.lines != null) {                    var f = funcs[funcIndex+1];                    if (f.segment != sec.sec || f.address != sec.off) break;                    func = f;                    funcIndex++;                  }                }                if (func.lines != null) break;                  // Count the line blocks.                int begSym = bits.Position;                int blocks = 0;                while (bits.Position < endSym) {                  CV_SourceFile file;                  bits.ReadUInt32(out file.index);                  bits.ReadUInt32(out file.count);                  bits.ReadUInt32(out file.linsiz);   // Size of payload.                  int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));                  bits.Position += linsiz;                  blocks++;                }                  func.lines = new PdbLines[blocks];                int block = 0;                  bits.Position = begSym;                while (bits.Position < endSym) {                  CV_SourceFile file;                  bits.ReadUInt32(out file.index);                  bits.ReadUInt32(out file.count);                  bits.ReadUInt32(out file.linsiz);   // Size of payload.                    PdbSource src = (PdbSource)checks[(int)file.index];                  if (src.language.Equals(BasicLanguageGuid))                  {                    func.AdjustVisualBasicScopes();                  }                    PdbLines tmp = new PdbLines(src' file.count);                  func.lines[block++] = tmp;                  PdbLine[] lines = tmp.lines;                    int plin = bits.Position;                  int pcol = bits.Position + 8 * (int)file.count;                    for (int i = 0; i < file.count; i++) {                    CV_Line line;                    CV_Column column = new CV_Column();                      bits.Position = plin + 8 * i;                    bits.ReadUInt32(out line.offset);                    bits.ReadUInt32(out line.flags);                      uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;                    uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;                    //bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);                    if ((sec.flags & 1) != 0) {                      bits.Position = pcol + 4 * i;                      bits.ReadUInt16(out column.offColumnStart);                      bits.ReadUInt16(out column.offColumnEnd);                    }                      lines[i] = new PdbLine(line.offset'                                           lineBegin'                                           column.offColumnStart'                                           lineBegin+delta'                                           column.offColumnEnd);                  }                }                break;              }          }
Magic Number,Microsoft.Cci.Pdb,PdbFile,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: switch ((DEBUG_S_SUBSECTION)sig) {            case DEBUG_S_SUBSECTION.LINES: {                CV_LineSection sec;                  bits.ReadUInt32(out sec.off);                bits.ReadUInt16(out sec.sec);                bits.ReadUInt16(out sec.flags);                bits.ReadUInt32(out sec.cod);                int funcIndex = FindFunction(funcs' sec.sec' sec.off);                if (funcIndex < 0) break;                var func = funcs[funcIndex];                if (func.lines == null) {                  while (funcIndex > 0) {                    var f = funcs[funcIndex-1];                    if (f.lines != null || f.segment != sec.sec || f.address != sec.off) break;                    func = f;                    funcIndex--;                  }                } else {                  while (funcIndex < funcs.Length-1 && func.lines != null) {                    var f = funcs[funcIndex+1];                    if (f.segment != sec.sec || f.address != sec.off) break;                    func = f;                    funcIndex++;                  }                }                if (func.lines != null) break;                  // Count the line blocks.                int begSym = bits.Position;                int blocks = 0;                while (bits.Position < endSym) {                  CV_SourceFile file;                  bits.ReadUInt32(out file.index);                  bits.ReadUInt32(out file.count);                  bits.ReadUInt32(out file.linsiz);   // Size of payload.                  int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));                  bits.Position += linsiz;                  blocks++;                }                  func.lines = new PdbLines[blocks];                int block = 0;                  bits.Position = begSym;                while (bits.Position < endSym) {                  CV_SourceFile file;                  bits.ReadUInt32(out file.index);                  bits.ReadUInt32(out file.count);                  bits.ReadUInt32(out file.linsiz);   // Size of payload.                    PdbSource src = (PdbSource)checks[(int)file.index];                  if (src.language.Equals(BasicLanguageGuid))                  {                    func.AdjustVisualBasicScopes();                  }                    PdbLines tmp = new PdbLines(src' file.count);                  func.lines[block++] = tmp;                  PdbLine[] lines = tmp.lines;                    int plin = bits.Position;                  int pcol = bits.Position + 8 * (int)file.count;                    for (int i = 0; i < file.count; i++) {                    CV_Line line;                    CV_Column column = new CV_Column();                      bits.Position = plin + 8 * i;                    bits.ReadUInt32(out line.offset);                    bits.ReadUInt32(out line.flags);                      uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;                    uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;                    //bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);                    if ((sec.flags & 1) != 0) {                      bits.Position = pcol + 4 * i;                      bits.ReadUInt16(out column.offColumnStart);                      bits.ReadUInt16(out column.offColumnEnd);                    }                      lines[i] = new PdbLine(line.offset'                                           lineBegin'                                           column.offColumnStart'                                           lineBegin+delta'                                           column.offColumnEnd);                  }                }                break;              }          }
Magic Number,Microsoft.Cci.Pdb,PdbFile,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadFuncsFromDbiModule,The following statement contains a magic number: sig != 4
Magic Number,Microsoft.Cci.Pdb,PdbFile,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadFuncsFromDbiModule,The following statement contains a magic number: bits.Position = 4;
Magic Number,Microsoft.Cci.Pdb,PdbFile,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadFunctions,The following statement contains a magic number: BitAccess bits = new BitAccess(64 * 1024);
Magic Number,Microsoft.Cci.Pdb,PdbFile,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadFunctions,The following statement contains a magic number: BitAccess bits = new BitAccess(64 * 1024);
Magic Number,Microsoft.Cci.Pdb,PdbFile,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadFunctions,The following statement contains a magic number: dir.streams[3].Read(reader' bits);
Magic Number,Microsoft.Cci.Pdb,PdbFile,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadFunctions,The following statement contains a magic number: uint[] ridMap = new uint[dir.streams[header.snTokenRidMap].Length / 4];
Magic Number,Microsoft.Cci.Pdb,PdbFile,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadTokenToSourceInfo,The following statement contains a magic number: sig != 4
Magic Number,Microsoft.Cci.Pdb,PdbFile,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadTokenToSourceInfo,The following statement contains a magic number: bits.Position = 4;
Magic Number,Microsoft.Cci.Pdb,PdbFile,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,ReadSourceFileInfo,The following statement contains a magic number: switch ((DEBUG_S_SUBSECTION)sig) {            case DEBUG_S_SUBSECTION.FILECHKSMS:              while (bits.Position < endSym) {                CV_FileCheckSum chk;                  int ni = bits.Position - place;                bits.ReadUInt32(out chk.name);                bits.ReadUInt8(out chk.len);                bits.ReadUInt8(out chk.type);                  string name = (string)names[(int)chk.name];                  PdbSource src;                if (!sourceCache.TryGetValue(name' out src))                {                  int guidStream;                  Guid doctypeGuid = SymDocumentType_Text;                  Guid languageGuid = Guid.Empty;                  Guid vendorGuid = Guid.Empty;                  Guid checksumAlgoGuid = Guid.Empty;                  byte[] checksum = null;                  if (nameIndex.TryGetValue("/SRC/FILES/" + name.ToUpperInvariant()' out guidStream))                  {                    var guidBits = new BitAccess(0x100);                    dir.streams[guidStream].Read(reader' guidBits);                    LoadInjectedSourceInformation(guidBits' out doctypeGuid' out languageGuid' out vendorGuid' out checksumAlgoGuid' out checksum);                  }                    src = new PdbSource(name' doctypeGuid' languageGuid' vendorGuid' checksumAlgoGuid' checksum);                  sourceCache.Add(name' src);                }                checks.Add(ni' src);                bits.Position += chk.len;                bits.Align(4);              }              bits.Position = endSym;              break;              default:              bits.Position = endSym;              break;          }
Magic Number,Microsoft.Cci.Pdb,PdbFileHeader,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFileHeader.cs,PdbFileHeader,The following statement contains a magic number: bits.MinCapacity(56);
Magic Number,Microsoft.Cci.Pdb,PdbFileHeader,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFileHeader.cs,PdbFileHeader,The following statement contains a magic number: bits.FillBuffer(reader' 52);
Magic Number,Microsoft.Cci.Pdb,PdbFileHeader,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFileHeader.cs,PdbFileHeader,The following statement contains a magic number: this.magic = new byte[32];
Magic Number,Microsoft.Cci.Pdb,PdbFileHeader,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFileHeader.cs,PdbFileHeader,The following statement contains a magic number: int directoryPages = ((((directorySize + pageSize - 1) / pageSize) * 4) + pageSize - 1) / pageSize;
Magic Number,Microsoft.Cci.Pdb,PdbFileHeader,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFileHeader.cs,PdbFileHeader,The following statement contains a magic number: bits.FillBuffer(reader' directoryPages * 4);
Magic Number,Microsoft.Cci.Pdb,PdbFunction,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFunction.cs,ReadMD2CustomMetadata,The following statement contains a magic number: bits.Align(4);
Magic Number,Microsoft.Cci.Pdb,PdbFunction,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFunction.cs,ReadMD2CustomMetadata,The following statement contains a magic number: version == 4
Magic Number,Microsoft.Cci.Pdb,PdbFunction,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFunction.cs,ReadCustomMetadata,The following statement contains a magic number: bits.Position += 2;
Magic Number,Microsoft.Cci.Pdb,PdbFunction,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFunction.cs,ReadCustomMetadata,The following statement contains a magic number: switch (kind)              {                  case 0: this.ReadUsingInfo(bits); break;                  case 1: this.ReadForwardInfo(bits); break;                  case 2: break; // this.ReadForwardedToModuleInfo(bits); break;                  case 3: this.ReadIteratorLocals(bits); break;                  case 4: this.ReadForwardIterator(bits); break;                  case 5: break; // dynamic locals - see http://index/#Microsoft.VisualStudio.LanguageServices/Shared/CustomDebugInfoReader.cs'a3031f7681d76e93                  case 6: break; // EnC data                  case 7: break; // EnC data for lambdas and closures                  // ignore any other unknown record types that may be added in future' instead of throwing an exception                  // see more details here: https://github.com/tmat/roslyn/blob/portable-pdb/docs/specs/PortablePdb-Metadata.md                  default: break; // throw new PdbDebugException("Unknown custom metadata item kind: {0}"' kind);              }
Magic Number,Microsoft.Cci.Pdb,PdbFunction,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFunction.cs,ReadCustomMetadata,The following statement contains a magic number: switch (kind)              {                  case 0: this.ReadUsingInfo(bits); break;                  case 1: this.ReadForwardInfo(bits); break;                  case 2: break; // this.ReadForwardedToModuleInfo(bits); break;                  case 3: this.ReadIteratorLocals(bits); break;                  case 4: this.ReadForwardIterator(bits); break;                  case 5: break; // dynamic locals - see http://index/#Microsoft.VisualStudio.LanguageServices/Shared/CustomDebugInfoReader.cs'a3031f7681d76e93                  case 6: break; // EnC data                  case 7: break; // EnC data for lambdas and closures                  // ignore any other unknown record types that may be added in future' instead of throwing an exception                  // see more details here: https://github.com/tmat/roslyn/blob/portable-pdb/docs/specs/PortablePdb-Metadata.md                  default: break; // throw new PdbDebugException("Unknown custom metadata item kind: {0}"' kind);              }
Magic Number,Microsoft.Cci.Pdb,PdbFunction,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFunction.cs,ReadCustomMetadata,The following statement contains a magic number: switch (kind)              {                  case 0: this.ReadUsingInfo(bits); break;                  case 1: this.ReadForwardInfo(bits); break;                  case 2: break; // this.ReadForwardedToModuleInfo(bits); break;                  case 3: this.ReadIteratorLocals(bits); break;                  case 4: this.ReadForwardIterator(bits); break;                  case 5: break; // dynamic locals - see http://index/#Microsoft.VisualStudio.LanguageServices/Shared/CustomDebugInfoReader.cs'a3031f7681d76e93                  case 6: break; // EnC data                  case 7: break; // EnC data for lambdas and closures                  // ignore any other unknown record types that may be added in future' instead of throwing an exception                  // see more details here: https://github.com/tmat/roslyn/blob/portable-pdb/docs/specs/PortablePdb-Metadata.md                  default: break; // throw new PdbDebugException("Unknown custom metadata item kind: {0}"' kind);              }
Magic Number,Microsoft.Cci.Pdb,PdbFunction,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFunction.cs,ReadCustomMetadata,The following statement contains a magic number: switch (kind)              {                  case 0: this.ReadUsingInfo(bits); break;                  case 1: this.ReadForwardInfo(bits); break;                  case 2: break; // this.ReadForwardedToModuleInfo(bits); break;                  case 3: this.ReadIteratorLocals(bits); break;                  case 4: this.ReadForwardIterator(bits); break;                  case 5: break; // dynamic locals - see http://index/#Microsoft.VisualStudio.LanguageServices/Shared/CustomDebugInfoReader.cs'a3031f7681d76e93                  case 6: break; // EnC data                  case 7: break; // EnC data for lambdas and closures                  // ignore any other unknown record types that may be added in future' instead of throwing an exception                  // see more details here: https://github.com/tmat/roslyn/blob/portable-pdb/docs/specs/PortablePdb-Metadata.md                  default: break; // throw new PdbDebugException("Unknown custom metadata item kind: {0}"' kind);              }
Magic Number,Microsoft.Cci.Pdb,PdbFunction,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFunction.cs,ReadCustomMetadata,The following statement contains a magic number: switch (kind)              {                  case 0: this.ReadUsingInfo(bits); break;                  case 1: this.ReadForwardInfo(bits); break;                  case 2: break; // this.ReadForwardedToModuleInfo(bits); break;                  case 3: this.ReadIteratorLocals(bits); break;                  case 4: this.ReadForwardIterator(bits); break;                  case 5: break; // dynamic locals - see http://index/#Microsoft.VisualStudio.LanguageServices/Shared/CustomDebugInfoReader.cs'a3031f7681d76e93                  case 6: break; // EnC data                  case 7: break; // EnC data for lambdas and closures                  // ignore any other unknown record types that may be added in future' instead of throwing an exception                  // see more details here: https://github.com/tmat/roslyn/blob/portable-pdb/docs/specs/PortablePdb-Metadata.md                  default: break; // throw new PdbDebugException("Unknown custom metadata item kind: {0}"' kind);              }
Magic Number,Microsoft.Cci.Pdb,PdbFunction,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFunction.cs,ReadCustomMetadata,The following statement contains a magic number: switch (kind)              {                  case 0: this.ReadUsingInfo(bits); break;                  case 1: this.ReadForwardInfo(bits); break;                  case 2: break; // this.ReadForwardedToModuleInfo(bits); break;                  case 3: this.ReadIteratorLocals(bits); break;                  case 4: this.ReadForwardIterator(bits); break;                  case 5: break; // dynamic locals - see http://index/#Microsoft.VisualStudio.LanguageServices/Shared/CustomDebugInfoReader.cs'a3031f7681d76e93                  case 6: break; // EnC data                  case 7: break; // EnC data for lambdas and closures                  // ignore any other unknown record types that may be added in future' instead of throwing an exception                  // see more details here: https://github.com/tmat/roslyn/blob/portable-pdb/docs/specs/PortablePdb-Metadata.md                  default: break; // throw new PdbDebugException("Unknown custom metadata item kind: {0}"' kind);              }
Magic Number,Microsoft.Cci.Pdb,PdbFunction,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFunction.cs,ReadCustomMetadata,The following statement contains a magic number: version == 4
Magic Number,Mono.Cecil.Pdb,ModuleMetadata,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,WriteString,The following statement contains a magic number: offset += 2;
Magic Number,Mono.Cecil.Pdb,NativePdbReader,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,ProcessDebugHeader,The following statement contains a magic number: data.Length < 24
Magic Number,Mono.Cecil.Pdb,NativePdbReader,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,ProcessDebugHeader,The following statement contains a magic number: var guid_bytes = new byte [16];
Magic Number,Mono.Cecil.Pdb,NativePdbReader,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,ProcessDebugHeader,The following statement contains a magic number: Buffer.BlockCopy (data' 4' guid_bytes' 0' 16);
Magic Number,Mono.Cecil.Pdb,NativePdbReader,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,ProcessDebugHeader,The following statement contains a magic number: Buffer.BlockCopy (data' 4' guid_bytes' 0' 16);
Magic Number,Mono.Cecil.Pdb,NativePdbReader,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,ProcessDebugHeader,The following statement contains a magic number: this.age = ReadInt32 (data' 20);
Magic Number,Mono.Cecil.Pdb,NativePdbReader,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,ReadInt32,The following statement contains a magic number: return (bytes [start]  				| (bytes [start + 1] << 8)  				| (bytes [start + 2] << 16)  				| (bytes [start + 3] << 24));
Magic Number,Mono.Cecil.Pdb,NativePdbReader,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,ReadInt32,The following statement contains a magic number: return (bytes [start]  				| (bytes [start + 1] << 8)  				| (bytes [start + 2] << 16)  				| (bytes [start + 3] << 24));
Magic Number,Mono.Cecil.Pdb,NativePdbReader,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,ReadInt32,The following statement contains a magic number: return (bytes [start]  				| (bytes [start + 1] << 8)  				| (bytes [start + 2] << 16)  				| (bytes [start + 3] << 24));
Magic Number,Mono.Cecil.Pdb,NativePdbReader,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,ReadInt32,The following statement contains a magic number: return (bytes [start]  				| (bytes [start + 1] << 8)  				| (bytes [start + 2] << 16)  				| (bytes [start + 3] << 24));
Magic Number,Mono.Cecil.Pdb,NativePdbReader,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,ReadInt32,The following statement contains a magic number: return (bytes [start]  				| (bytes [start + 1] << 8)  				| (bytes [start + 2] << 16)  				| (bytes [start + 3] << 24));
Magic Number,Mono.Cecil.Pdb,NativePdbReader,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,ReadScopeAndLocals,The following statement contains a magic number: (slot.flags & 4) != 0
Magic Number,Mono.Cecil.Pdb,NativePdbReader,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,GetImport,The following statement contains a magic number: switch (used_namespace [0]) {  				case 'U':  					target = new ImportTarget (ImportTargetKind.ImportNamespace) { @namespace = value };  					break;  				case 'T': {  					var type = TypeParser.ParseType (module' value);  					if (type != null)  						target = new ImportTarget (ImportTargetKind.ImportType) { type = type };  					break;  				}  				case 'A':  					var index = used_namespace.IndexOf (' ');  					if (index < 0) {  						target = new ImportTarget (ImportTargetKind.ImportNamespace) { @namespace = used_namespace };  						break;  					}  					var alias_value = used_namespace.Substring (1' index - 1);  					var alias_target_value = used_namespace.Substring (index + 2);  					switch (used_namespace [index + 1]) {  					case 'U':  						target = new ImportTarget (ImportTargetKind.DefineNamespaceAlias) { alias = alias_value' @namespace = alias_target_value };  						break;  					case 'T':  						var type = TypeParser.ParseType (module' alias_target_value);  						if (type != null)  							target = new ImportTarget (ImportTargetKind.DefineTypeAlias) { alias = alias_value' type = type };  						break;  					}  					break;  				case '*':  					target = new ImportTarget (ImportTargetKind.ImportNamespace) { @namespace = value };  					break;  				case '@':  					if (!value.StartsWith ("P:"))  						continue;    					target = new ImportTarget (ImportTargetKind.ImportNamespace) { @namespace = value.Substring (2) };  					break;  				}
Magic Number,Mono.Cecil.Pdb,NativePdbReader,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,GetImport,The following statement contains a magic number: switch (used_namespace [0]) {  				case 'U':  					target = new ImportTarget (ImportTargetKind.ImportNamespace) { @namespace = value };  					break;  				case 'T': {  					var type = TypeParser.ParseType (module' value);  					if (type != null)  						target = new ImportTarget (ImportTargetKind.ImportType) { type = type };  					break;  				}  				case 'A':  					var index = used_namespace.IndexOf (' ');  					if (index < 0) {  						target = new ImportTarget (ImportTargetKind.ImportNamespace) { @namespace = used_namespace };  						break;  					}  					var alias_value = used_namespace.Substring (1' index - 1);  					var alias_target_value = used_namespace.Substring (index + 2);  					switch (used_namespace [index + 1]) {  					case 'U':  						target = new ImportTarget (ImportTargetKind.DefineNamespaceAlias) { alias = alias_value' @namespace = alias_target_value };  						break;  					case 'T':  						var type = TypeParser.ParseType (module' alias_target_value);  						if (type != null)  							target = new ImportTarget (ImportTargetKind.DefineTypeAlias) { alias = alias_value' type = type };  						break;  					}  					break;  				case '*':  					target = new ImportTarget (ImportTargetKind.ImportNamespace) { @namespace = value };  					break;  				case '@':  					if (!value.StartsWith ("P:"))  						continue;    					target = new ImportTarget (ImportTargetKind.ImportNamespace) { @namespace = value.Substring (2) };  					break;  				}
Magic Number,Mono.Cecil.Pdb,CustomMetadataWriter,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbWriter.cs,CustomMetadataWriter,The following statement contains a magic number: writer.Align (4);
Magic Number,Mono.Cecil.Pdb,CustomMetadataWriter,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbWriter.cs,Write,The following statement contains a magic number: writer.Align (4);
Magic Number,Mono.Cecil.Pdb,CustomMetadataWriter,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbWriter.cs,Write,The following statement contains a magic number: writer.Align (4);
Magic Number,Mono.Cecil.Pdb,CustomMetadataWriter,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbWriter.cs,Write,The following statement contains a magic number: var length = end - length_position + 4;
Missing Default,Microsoft.Cci.Pdb,PdbFile,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadManagedLines,The following switch statement is missing a default case: switch ((DEBUG_S_SUBSECTION)sig) {            case DEBUG_S_SUBSECTION.LINES: {                CV_LineSection sec;                  bits.ReadUInt32(out sec.off);                bits.ReadUInt16(out sec.sec);                bits.ReadUInt16(out sec.flags);                bits.ReadUInt32(out sec.cod);                int funcIndex = FindFunction(funcs' sec.sec' sec.off);                if (funcIndex < 0) break;                var func = funcs[funcIndex];                if (func.lines == null) {                  while (funcIndex > 0) {                    var f = funcs[funcIndex-1];                    if (f.lines != null || f.segment != sec.sec || f.address != sec.off) break;                    func = f;                    funcIndex--;                  }                } else {                  while (funcIndex < funcs.Length-1 && func.lines != null) {                    var f = funcs[funcIndex+1];                    if (f.segment != sec.sec || f.address != sec.off) break;                    func = f;                    funcIndex++;                  }                }                if (func.lines != null) break;                  // Count the line blocks.                int begSym = bits.Position;                int blocks = 0;                while (bits.Position < endSym) {                  CV_SourceFile file;                  bits.ReadUInt32(out file.index);                  bits.ReadUInt32(out file.count);                  bits.ReadUInt32(out file.linsiz);   // Size of payload.                  int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));                  bits.Position += linsiz;                  blocks++;                }                  func.lines = new PdbLines[blocks];                int block = 0;                  bits.Position = begSym;                while (bits.Position < endSym) {                  CV_SourceFile file;                  bits.ReadUInt32(out file.index);                  bits.ReadUInt32(out file.count);                  bits.ReadUInt32(out file.linsiz);   // Size of payload.                    PdbSource src = (PdbSource)checks[(int)file.index];                  if (src.language.Equals(BasicLanguageGuid))                  {                    func.AdjustVisualBasicScopes();                  }                    PdbLines tmp = new PdbLines(src' file.count);                  func.lines[block++] = tmp;                  PdbLine[] lines = tmp.lines;                    int plin = bits.Position;                  int pcol = bits.Position + 8 * (int)file.count;                    for (int i = 0; i < file.count; i++) {                    CV_Line line;                    CV_Column column = new CV_Column();                      bits.Position = plin + 8 * i;                    bits.ReadUInt32(out line.offset);                    bits.ReadUInt32(out line.flags);                      uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;                    uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;                    //bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);                    if ((sec.flags & 1) != 0) {                      bits.Position = pcol + 4 * i;                      bits.ReadUInt16(out column.offColumnStart);                      bits.ReadUInt16(out column.offColumnEnd);                    }                      lines[i] = new PdbLine(line.offset'                                           lineBegin'                                           column.offColumnStart'                                           lineBegin+delta'                                           column.offColumnEnd);                  }                }                break;              }          }
Missing Default,Mono.Cecil.Pdb,NativePdbReader,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,GetImport,The following switch statement is missing a default case: switch (used_namespace [0]) {  				case 'U':  					target = new ImportTarget (ImportTargetKind.ImportNamespace) { @namespace = value };  					break;  				case 'T': {  					var type = TypeParser.ParseType (module' value);  					if (type != null)  						target = new ImportTarget (ImportTargetKind.ImportType) { type = type };  					break;  				}  				case 'A':  					var index = used_namespace.IndexOf (' ');  					if (index < 0) {  						target = new ImportTarget (ImportTargetKind.ImportNamespace) { @namespace = used_namespace };  						break;  					}  					var alias_value = used_namespace.Substring (1' index - 1);  					var alias_target_value = used_namespace.Substring (index + 2);  					switch (used_namespace [index + 1]) {  					case 'U':  						target = new ImportTarget (ImportTargetKind.DefineNamespaceAlias) { alias = alias_value' @namespace = alias_target_value };  						break;  					case 'T':  						var type = TypeParser.ParseType (module' alias_target_value);  						if (type != null)  							target = new ImportTarget (ImportTargetKind.DefineTypeAlias) { alias = alias_value' type = type };  						break;  					}  					break;  				case '*':  					target = new ImportTarget (ImportTargetKind.ImportNamespace) { @namespace = value };  					break;  				case '@':  					if (!value.StartsWith ("P:"))  						continue;    					target = new ImportTarget (ImportTargetKind.ImportNamespace) { @namespace = value.Substring (2) };  					break;  				}
Missing Default,Mono.Cecil.Pdb,NativePdbReader,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,GetImport,The following switch statement is missing a default case: switch (used_namespace [index + 1]) {  					case 'U':  						target = new ImportTarget (ImportTargetKind.DefineNamespaceAlias) { alias = alias_value' @namespace = alias_target_value };  						break;  					case 'T':  						var type = TypeParser.ParseType (module' alias_target_value);  						if (type != null)  							target = new ImportTarget (ImportTargetKind.DefineTypeAlias) { alias = alias_value' type = type };  						break;  					}
Missing Default,Mono.Cecil.Pdb,NativePdbWriter,D:\research\architectureSmells\repos\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbWriter.cs,DefineScope,The following switch statement is missing a default case: switch (target.Kind) {  					case ImportTargetKind.ImportNamespace:  						writer.UsingNamespace ("U" + target.@namespace);  						break;  					case ImportTargetKind.ImportType:  						writer.UsingNamespace ("T" + TypeParser.ToParseable (target.type));  						break;  					case ImportTargetKind.DefineNamespaceAlias:  						writer.UsingNamespace ("A" + target.Alias + " U" + target.@namespace);  						break;  					case ImportTargetKind.DefineTypeAlias:  						writer.UsingNamespace ("A" + target.Alias + " T" + TypeParser.ToParseable (target.type));  						break;  					}
