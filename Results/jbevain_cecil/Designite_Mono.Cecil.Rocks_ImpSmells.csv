Implementation smell,Namespace,Class,File,Method,Description
Long Method,Mono.Cecil.Rocks,MethodBodyRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\MethodBodyRocks.cs,SimplifyMacros,The method has 139 lines of code.
Long Method,Mono.Cecil.Rocks,MethodBodyRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\MethodBodyRocks.cs,OptimizeMacros,The method has 130 lines of code.
Long Statement,Mono.Cecil.Rocks,ModuleDefinitionRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\ModuleDefinitionRocks.cs,GetAllTypes,The length of the statement  "				Functional.Y<TypeDefinition' IEnumerable<TypeDefinition>> (f => type => type.NestedTypes.SelectMany (f).Prepend (type))); " is 121.
Magic Number,Mono.Cecil.Rocks,ILParser,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\ILParser.cs,ParseMethod,The following statement contains a magic number: switch (flags & 0x3) {  			case 0x2: // tiny  				int code_size = flags >> 2;  				ParseCode (code_size' context);  				break;  			case 0x3: // fat  				code.Advance (-1);  				ParseFatMethod (context);  				break;  			default:  				throw new NotSupportedException ();  			}
Magic Number,Mono.Cecil.Rocks,ILParser,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\ILParser.cs,ParseFatMethod,The following statement contains a magic number: code.Advance (4);
Magic Number,Mono.Cecil.Rocks,MethodBodyRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\MethodBodyRocks.cs,SimplifyMacros,The following statement contains a magic number: foreach (var instruction in self.Instructions) {  				if (instruction.OpCode.OpCodeType != OpCodeType.Macro)  					continue;    				switch (instruction.OpCode.Code) {  				case Code.Ldarg_0:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (0));  					break;  				case Code.Ldarg_1:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (1));  					break;  				case Code.Ldarg_2:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (2));  					break;  				case Code.Ldarg_3:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (3));  					break;  				case Code.Ldloc_0:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [0]);  					break;  				case Code.Ldloc_1:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [1]);  					break;  				case Code.Ldloc_2:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [2]);  					break;  				case Code.Ldloc_3:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [3]);  					break;  				case Code.Stloc_0:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [0]);  					break;  				case Code.Stloc_1:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [1]);  					break;  				case Code.Stloc_2:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [2]);  					break;  				case Code.Stloc_3:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [3]);  					break;  				case Code.Ldarg_S:  					instruction.OpCode = OpCodes.Ldarg;  					break;  				case Code.Ldarga_S:  					instruction.OpCode = OpCodes.Ldarga;  					break;  				case Code.Starg_S:  					instruction.OpCode = OpCodes.Starg;  					break;  				case Code.Ldloc_S:  					instruction.OpCode = OpCodes.Ldloc;  					break;  				case Code.Ldloca_S:  					instruction.OpCode = OpCodes.Ldloca;  					break;  				case Code.Stloc_S:  					instruction.OpCode = OpCodes.Stloc;  					break;  				case Code.Ldc_I4_M1:  					ExpandMacro (instruction' OpCodes.Ldc_I4' -1);  					break;  				case Code.Ldc_I4_0:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 0);  					break;  				case Code.Ldc_I4_1:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 1);  					break;  				case Code.Ldc_I4_2:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 2);  					break;  				case Code.Ldc_I4_3:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 3);  					break;  				case Code.Ldc_I4_4:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 4);  					break;  				case Code.Ldc_I4_5:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 5);  					break;  				case Code.Ldc_I4_6:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 6);  					break;  				case Code.Ldc_I4_7:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 7);  					break;  				case Code.Ldc_I4_8:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 8);  					break;  				case Code.Ldc_I4_S:  					ExpandMacro (instruction' OpCodes.Ldc_I4' (int) (sbyte) instruction.Operand);  					break;  				case Code.Br_S:  					instruction.OpCode = OpCodes.Br;  					break;  				case Code.Brfalse_S:  					instruction.OpCode = OpCodes.Brfalse;  					break;  				case Code.Brtrue_S:  					instruction.OpCode = OpCodes.Brtrue;  					break;  				case Code.Beq_S:  					instruction.OpCode = OpCodes.Beq;  					break;  				case Code.Bge_S:  					instruction.OpCode = OpCodes.Bge;  					break;  				case Code.Bgt_S:  					instruction.OpCode = OpCodes.Bgt;  					break;  				case Code.Ble_S:  					instruction.OpCode = OpCodes.Ble;  					break;  				case Code.Blt_S:  					instruction.OpCode = OpCodes.Blt;  					break;  				case Code.Bne_Un_S:  					instruction.OpCode = OpCodes.Bne_Un;  					break;  				case Code.Bge_Un_S:  					instruction.OpCode = OpCodes.Bge_Un;  					break;  				case Code.Bgt_Un_S:  					instruction.OpCode = OpCodes.Bgt_Un;  					break;  				case Code.Ble_Un_S:  					instruction.OpCode = OpCodes.Ble_Un;  					break;  				case Code.Blt_Un_S:  					instruction.OpCode = OpCodes.Blt_Un;  					break;  				case Code.Leave_S:  					instruction.OpCode = OpCodes.Leave;  					break;  				}  			}
Magic Number,Mono.Cecil.Rocks,MethodBodyRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\MethodBodyRocks.cs,SimplifyMacros,The following statement contains a magic number: foreach (var instruction in self.Instructions) {  				if (instruction.OpCode.OpCodeType != OpCodeType.Macro)  					continue;    				switch (instruction.OpCode.Code) {  				case Code.Ldarg_0:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (0));  					break;  				case Code.Ldarg_1:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (1));  					break;  				case Code.Ldarg_2:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (2));  					break;  				case Code.Ldarg_3:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (3));  					break;  				case Code.Ldloc_0:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [0]);  					break;  				case Code.Ldloc_1:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [1]);  					break;  				case Code.Ldloc_2:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [2]);  					break;  				case Code.Ldloc_3:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [3]);  					break;  				case Code.Stloc_0:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [0]);  					break;  				case Code.Stloc_1:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [1]);  					break;  				case Code.Stloc_2:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [2]);  					break;  				case Code.Stloc_3:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [3]);  					break;  				case Code.Ldarg_S:  					instruction.OpCode = OpCodes.Ldarg;  					break;  				case Code.Ldarga_S:  					instruction.OpCode = OpCodes.Ldarga;  					break;  				case Code.Starg_S:  					instruction.OpCode = OpCodes.Starg;  					break;  				case Code.Ldloc_S:  					instruction.OpCode = OpCodes.Ldloc;  					break;  				case Code.Ldloca_S:  					instruction.OpCode = OpCodes.Ldloca;  					break;  				case Code.Stloc_S:  					instruction.OpCode = OpCodes.Stloc;  					break;  				case Code.Ldc_I4_M1:  					ExpandMacro (instruction' OpCodes.Ldc_I4' -1);  					break;  				case Code.Ldc_I4_0:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 0);  					break;  				case Code.Ldc_I4_1:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 1);  					break;  				case Code.Ldc_I4_2:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 2);  					break;  				case Code.Ldc_I4_3:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 3);  					break;  				case Code.Ldc_I4_4:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 4);  					break;  				case Code.Ldc_I4_5:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 5);  					break;  				case Code.Ldc_I4_6:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 6);  					break;  				case Code.Ldc_I4_7:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 7);  					break;  				case Code.Ldc_I4_8:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 8);  					break;  				case Code.Ldc_I4_S:  					ExpandMacro (instruction' OpCodes.Ldc_I4' (int) (sbyte) instruction.Operand);  					break;  				case Code.Br_S:  					instruction.OpCode = OpCodes.Br;  					break;  				case Code.Brfalse_S:  					instruction.OpCode = OpCodes.Brfalse;  					break;  				case Code.Brtrue_S:  					instruction.OpCode = OpCodes.Brtrue;  					break;  				case Code.Beq_S:  					instruction.OpCode = OpCodes.Beq;  					break;  				case Code.Bge_S:  					instruction.OpCode = OpCodes.Bge;  					break;  				case Code.Bgt_S:  					instruction.OpCode = OpCodes.Bgt;  					break;  				case Code.Ble_S:  					instruction.OpCode = OpCodes.Ble;  					break;  				case Code.Blt_S:  					instruction.OpCode = OpCodes.Blt;  					break;  				case Code.Bne_Un_S:  					instruction.OpCode = OpCodes.Bne_Un;  					break;  				case Code.Bge_Un_S:  					instruction.OpCode = OpCodes.Bge_Un;  					break;  				case Code.Bgt_Un_S:  					instruction.OpCode = OpCodes.Bgt_Un;  					break;  				case Code.Ble_Un_S:  					instruction.OpCode = OpCodes.Ble_Un;  					break;  				case Code.Blt_Un_S:  					instruction.OpCode = OpCodes.Blt_Un;  					break;  				case Code.Leave_S:  					instruction.OpCode = OpCodes.Leave;  					break;  				}  			}
Magic Number,Mono.Cecil.Rocks,MethodBodyRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\MethodBodyRocks.cs,SimplifyMacros,The following statement contains a magic number: foreach (var instruction in self.Instructions) {  				if (instruction.OpCode.OpCodeType != OpCodeType.Macro)  					continue;    				switch (instruction.OpCode.Code) {  				case Code.Ldarg_0:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (0));  					break;  				case Code.Ldarg_1:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (1));  					break;  				case Code.Ldarg_2:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (2));  					break;  				case Code.Ldarg_3:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (3));  					break;  				case Code.Ldloc_0:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [0]);  					break;  				case Code.Ldloc_1:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [1]);  					break;  				case Code.Ldloc_2:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [2]);  					break;  				case Code.Ldloc_3:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [3]);  					break;  				case Code.Stloc_0:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [0]);  					break;  				case Code.Stloc_1:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [1]);  					break;  				case Code.Stloc_2:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [2]);  					break;  				case Code.Stloc_3:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [3]);  					break;  				case Code.Ldarg_S:  					instruction.OpCode = OpCodes.Ldarg;  					break;  				case Code.Ldarga_S:  					instruction.OpCode = OpCodes.Ldarga;  					break;  				case Code.Starg_S:  					instruction.OpCode = OpCodes.Starg;  					break;  				case Code.Ldloc_S:  					instruction.OpCode = OpCodes.Ldloc;  					break;  				case Code.Ldloca_S:  					instruction.OpCode = OpCodes.Ldloca;  					break;  				case Code.Stloc_S:  					instruction.OpCode = OpCodes.Stloc;  					break;  				case Code.Ldc_I4_M1:  					ExpandMacro (instruction' OpCodes.Ldc_I4' -1);  					break;  				case Code.Ldc_I4_0:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 0);  					break;  				case Code.Ldc_I4_1:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 1);  					break;  				case Code.Ldc_I4_2:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 2);  					break;  				case Code.Ldc_I4_3:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 3);  					break;  				case Code.Ldc_I4_4:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 4);  					break;  				case Code.Ldc_I4_5:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 5);  					break;  				case Code.Ldc_I4_6:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 6);  					break;  				case Code.Ldc_I4_7:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 7);  					break;  				case Code.Ldc_I4_8:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 8);  					break;  				case Code.Ldc_I4_S:  					ExpandMacro (instruction' OpCodes.Ldc_I4' (int) (sbyte) instruction.Operand);  					break;  				case Code.Br_S:  					instruction.OpCode = OpCodes.Br;  					break;  				case Code.Brfalse_S:  					instruction.OpCode = OpCodes.Brfalse;  					break;  				case Code.Brtrue_S:  					instruction.OpCode = OpCodes.Brtrue;  					break;  				case Code.Beq_S:  					instruction.OpCode = OpCodes.Beq;  					break;  				case Code.Bge_S:  					instruction.OpCode = OpCodes.Bge;  					break;  				case Code.Bgt_S:  					instruction.OpCode = OpCodes.Bgt;  					break;  				case Code.Ble_S:  					instruction.OpCode = OpCodes.Ble;  					break;  				case Code.Blt_S:  					instruction.OpCode = OpCodes.Blt;  					break;  				case Code.Bne_Un_S:  					instruction.OpCode = OpCodes.Bne_Un;  					break;  				case Code.Bge_Un_S:  					instruction.OpCode = OpCodes.Bge_Un;  					break;  				case Code.Bgt_Un_S:  					instruction.OpCode = OpCodes.Bgt_Un;  					break;  				case Code.Ble_Un_S:  					instruction.OpCode = OpCodes.Ble_Un;  					break;  				case Code.Blt_Un_S:  					instruction.OpCode = OpCodes.Blt_Un;  					break;  				case Code.Leave_S:  					instruction.OpCode = OpCodes.Leave;  					break;  				}  			}
Magic Number,Mono.Cecil.Rocks,MethodBodyRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\MethodBodyRocks.cs,SimplifyMacros,The following statement contains a magic number: foreach (var instruction in self.Instructions) {  				if (instruction.OpCode.OpCodeType != OpCodeType.Macro)  					continue;    				switch (instruction.OpCode.Code) {  				case Code.Ldarg_0:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (0));  					break;  				case Code.Ldarg_1:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (1));  					break;  				case Code.Ldarg_2:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (2));  					break;  				case Code.Ldarg_3:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (3));  					break;  				case Code.Ldloc_0:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [0]);  					break;  				case Code.Ldloc_1:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [1]);  					break;  				case Code.Ldloc_2:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [2]);  					break;  				case Code.Ldloc_3:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [3]);  					break;  				case Code.Stloc_0:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [0]);  					break;  				case Code.Stloc_1:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [1]);  					break;  				case Code.Stloc_2:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [2]);  					break;  				case Code.Stloc_3:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [3]);  					break;  				case Code.Ldarg_S:  					instruction.OpCode = OpCodes.Ldarg;  					break;  				case Code.Ldarga_S:  					instruction.OpCode = OpCodes.Ldarga;  					break;  				case Code.Starg_S:  					instruction.OpCode = OpCodes.Starg;  					break;  				case Code.Ldloc_S:  					instruction.OpCode = OpCodes.Ldloc;  					break;  				case Code.Ldloca_S:  					instruction.OpCode = OpCodes.Ldloca;  					break;  				case Code.Stloc_S:  					instruction.OpCode = OpCodes.Stloc;  					break;  				case Code.Ldc_I4_M1:  					ExpandMacro (instruction' OpCodes.Ldc_I4' -1);  					break;  				case Code.Ldc_I4_0:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 0);  					break;  				case Code.Ldc_I4_1:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 1);  					break;  				case Code.Ldc_I4_2:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 2);  					break;  				case Code.Ldc_I4_3:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 3);  					break;  				case Code.Ldc_I4_4:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 4);  					break;  				case Code.Ldc_I4_5:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 5);  					break;  				case Code.Ldc_I4_6:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 6);  					break;  				case Code.Ldc_I4_7:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 7);  					break;  				case Code.Ldc_I4_8:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 8);  					break;  				case Code.Ldc_I4_S:  					ExpandMacro (instruction' OpCodes.Ldc_I4' (int) (sbyte) instruction.Operand);  					break;  				case Code.Br_S:  					instruction.OpCode = OpCodes.Br;  					break;  				case Code.Brfalse_S:  					instruction.OpCode = OpCodes.Brfalse;  					break;  				case Code.Brtrue_S:  					instruction.OpCode = OpCodes.Brtrue;  					break;  				case Code.Beq_S:  					instruction.OpCode = OpCodes.Beq;  					break;  				case Code.Bge_S:  					instruction.OpCode = OpCodes.Bge;  					break;  				case Code.Bgt_S:  					instruction.OpCode = OpCodes.Bgt;  					break;  				case Code.Ble_S:  					instruction.OpCode = OpCodes.Ble;  					break;  				case Code.Blt_S:  					instruction.OpCode = OpCodes.Blt;  					break;  				case Code.Bne_Un_S:  					instruction.OpCode = OpCodes.Bne_Un;  					break;  				case Code.Bge_Un_S:  					instruction.OpCode = OpCodes.Bge_Un;  					break;  				case Code.Bgt_Un_S:  					instruction.OpCode = OpCodes.Bgt_Un;  					break;  				case Code.Ble_Un_S:  					instruction.OpCode = OpCodes.Ble_Un;  					break;  				case Code.Blt_Un_S:  					instruction.OpCode = OpCodes.Blt_Un;  					break;  				case Code.Leave_S:  					instruction.OpCode = OpCodes.Leave;  					break;  				}  			}
Magic Number,Mono.Cecil.Rocks,MethodBodyRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\MethodBodyRocks.cs,SimplifyMacros,The following statement contains a magic number: foreach (var instruction in self.Instructions) {  				if (instruction.OpCode.OpCodeType != OpCodeType.Macro)  					continue;    				switch (instruction.OpCode.Code) {  				case Code.Ldarg_0:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (0));  					break;  				case Code.Ldarg_1:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (1));  					break;  				case Code.Ldarg_2:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (2));  					break;  				case Code.Ldarg_3:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (3));  					break;  				case Code.Ldloc_0:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [0]);  					break;  				case Code.Ldloc_1:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [1]);  					break;  				case Code.Ldloc_2:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [2]);  					break;  				case Code.Ldloc_3:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [3]);  					break;  				case Code.Stloc_0:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [0]);  					break;  				case Code.Stloc_1:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [1]);  					break;  				case Code.Stloc_2:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [2]);  					break;  				case Code.Stloc_3:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [3]);  					break;  				case Code.Ldarg_S:  					instruction.OpCode = OpCodes.Ldarg;  					break;  				case Code.Ldarga_S:  					instruction.OpCode = OpCodes.Ldarga;  					break;  				case Code.Starg_S:  					instruction.OpCode = OpCodes.Starg;  					break;  				case Code.Ldloc_S:  					instruction.OpCode = OpCodes.Ldloc;  					break;  				case Code.Ldloca_S:  					instruction.OpCode = OpCodes.Ldloca;  					break;  				case Code.Stloc_S:  					instruction.OpCode = OpCodes.Stloc;  					break;  				case Code.Ldc_I4_M1:  					ExpandMacro (instruction' OpCodes.Ldc_I4' -1);  					break;  				case Code.Ldc_I4_0:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 0);  					break;  				case Code.Ldc_I4_1:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 1);  					break;  				case Code.Ldc_I4_2:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 2);  					break;  				case Code.Ldc_I4_3:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 3);  					break;  				case Code.Ldc_I4_4:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 4);  					break;  				case Code.Ldc_I4_5:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 5);  					break;  				case Code.Ldc_I4_6:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 6);  					break;  				case Code.Ldc_I4_7:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 7);  					break;  				case Code.Ldc_I4_8:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 8);  					break;  				case Code.Ldc_I4_S:  					ExpandMacro (instruction' OpCodes.Ldc_I4' (int) (sbyte) instruction.Operand);  					break;  				case Code.Br_S:  					instruction.OpCode = OpCodes.Br;  					break;  				case Code.Brfalse_S:  					instruction.OpCode = OpCodes.Brfalse;  					break;  				case Code.Brtrue_S:  					instruction.OpCode = OpCodes.Brtrue;  					break;  				case Code.Beq_S:  					instruction.OpCode = OpCodes.Beq;  					break;  				case Code.Bge_S:  					instruction.OpCode = OpCodes.Bge;  					break;  				case Code.Bgt_S:  					instruction.OpCode = OpCodes.Bgt;  					break;  				case Code.Ble_S:  					instruction.OpCode = OpCodes.Ble;  					break;  				case Code.Blt_S:  					instruction.OpCode = OpCodes.Blt;  					break;  				case Code.Bne_Un_S:  					instruction.OpCode = OpCodes.Bne_Un;  					break;  				case Code.Bge_Un_S:  					instruction.OpCode = OpCodes.Bge_Un;  					break;  				case Code.Bgt_Un_S:  					instruction.OpCode = OpCodes.Bgt_Un;  					break;  				case Code.Ble_Un_S:  					instruction.OpCode = OpCodes.Ble_Un;  					break;  				case Code.Blt_Un_S:  					instruction.OpCode = OpCodes.Blt_Un;  					break;  				case Code.Leave_S:  					instruction.OpCode = OpCodes.Leave;  					break;  				}  			}
Magic Number,Mono.Cecil.Rocks,MethodBodyRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\MethodBodyRocks.cs,SimplifyMacros,The following statement contains a magic number: foreach (var instruction in self.Instructions) {  				if (instruction.OpCode.OpCodeType != OpCodeType.Macro)  					continue;    				switch (instruction.OpCode.Code) {  				case Code.Ldarg_0:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (0));  					break;  				case Code.Ldarg_1:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (1));  					break;  				case Code.Ldarg_2:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (2));  					break;  				case Code.Ldarg_3:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (3));  					break;  				case Code.Ldloc_0:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [0]);  					break;  				case Code.Ldloc_1:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [1]);  					break;  				case Code.Ldloc_2:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [2]);  					break;  				case Code.Ldloc_3:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [3]);  					break;  				case Code.Stloc_0:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [0]);  					break;  				case Code.Stloc_1:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [1]);  					break;  				case Code.Stloc_2:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [2]);  					break;  				case Code.Stloc_3:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [3]);  					break;  				case Code.Ldarg_S:  					instruction.OpCode = OpCodes.Ldarg;  					break;  				case Code.Ldarga_S:  					instruction.OpCode = OpCodes.Ldarga;  					break;  				case Code.Starg_S:  					instruction.OpCode = OpCodes.Starg;  					break;  				case Code.Ldloc_S:  					instruction.OpCode = OpCodes.Ldloc;  					break;  				case Code.Ldloca_S:  					instruction.OpCode = OpCodes.Ldloca;  					break;  				case Code.Stloc_S:  					instruction.OpCode = OpCodes.Stloc;  					break;  				case Code.Ldc_I4_M1:  					ExpandMacro (instruction' OpCodes.Ldc_I4' -1);  					break;  				case Code.Ldc_I4_0:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 0);  					break;  				case Code.Ldc_I4_1:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 1);  					break;  				case Code.Ldc_I4_2:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 2);  					break;  				case Code.Ldc_I4_3:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 3);  					break;  				case Code.Ldc_I4_4:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 4);  					break;  				case Code.Ldc_I4_5:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 5);  					break;  				case Code.Ldc_I4_6:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 6);  					break;  				case Code.Ldc_I4_7:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 7);  					break;  				case Code.Ldc_I4_8:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 8);  					break;  				case Code.Ldc_I4_S:  					ExpandMacro (instruction' OpCodes.Ldc_I4' (int) (sbyte) instruction.Operand);  					break;  				case Code.Br_S:  					instruction.OpCode = OpCodes.Br;  					break;  				case Code.Brfalse_S:  					instruction.OpCode = OpCodes.Brfalse;  					break;  				case Code.Brtrue_S:  					instruction.OpCode = OpCodes.Brtrue;  					break;  				case Code.Beq_S:  					instruction.OpCode = OpCodes.Beq;  					break;  				case Code.Bge_S:  					instruction.OpCode = OpCodes.Bge;  					break;  				case Code.Bgt_S:  					instruction.OpCode = OpCodes.Bgt;  					break;  				case Code.Ble_S:  					instruction.OpCode = OpCodes.Ble;  					break;  				case Code.Blt_S:  					instruction.OpCode = OpCodes.Blt;  					break;  				case Code.Bne_Un_S:  					instruction.OpCode = OpCodes.Bne_Un;  					break;  				case Code.Bge_Un_S:  					instruction.OpCode = OpCodes.Bge_Un;  					break;  				case Code.Bgt_Un_S:  					instruction.OpCode = OpCodes.Bgt_Un;  					break;  				case Code.Ble_Un_S:  					instruction.OpCode = OpCodes.Ble_Un;  					break;  				case Code.Blt_Un_S:  					instruction.OpCode = OpCodes.Blt_Un;  					break;  				case Code.Leave_S:  					instruction.OpCode = OpCodes.Leave;  					break;  				}  			}
Magic Number,Mono.Cecil.Rocks,MethodBodyRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\MethodBodyRocks.cs,SimplifyMacros,The following statement contains a magic number: foreach (var instruction in self.Instructions) {  				if (instruction.OpCode.OpCodeType != OpCodeType.Macro)  					continue;    				switch (instruction.OpCode.Code) {  				case Code.Ldarg_0:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (0));  					break;  				case Code.Ldarg_1:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (1));  					break;  				case Code.Ldarg_2:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (2));  					break;  				case Code.Ldarg_3:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (3));  					break;  				case Code.Ldloc_0:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [0]);  					break;  				case Code.Ldloc_1:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [1]);  					break;  				case Code.Ldloc_2:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [2]);  					break;  				case Code.Ldloc_3:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [3]);  					break;  				case Code.Stloc_0:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [0]);  					break;  				case Code.Stloc_1:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [1]);  					break;  				case Code.Stloc_2:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [2]);  					break;  				case Code.Stloc_3:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [3]);  					break;  				case Code.Ldarg_S:  					instruction.OpCode = OpCodes.Ldarg;  					break;  				case Code.Ldarga_S:  					instruction.OpCode = OpCodes.Ldarga;  					break;  				case Code.Starg_S:  					instruction.OpCode = OpCodes.Starg;  					break;  				case Code.Ldloc_S:  					instruction.OpCode = OpCodes.Ldloc;  					break;  				case Code.Ldloca_S:  					instruction.OpCode = OpCodes.Ldloca;  					break;  				case Code.Stloc_S:  					instruction.OpCode = OpCodes.Stloc;  					break;  				case Code.Ldc_I4_M1:  					ExpandMacro (instruction' OpCodes.Ldc_I4' -1);  					break;  				case Code.Ldc_I4_0:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 0);  					break;  				case Code.Ldc_I4_1:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 1);  					break;  				case Code.Ldc_I4_2:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 2);  					break;  				case Code.Ldc_I4_3:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 3);  					break;  				case Code.Ldc_I4_4:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 4);  					break;  				case Code.Ldc_I4_5:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 5);  					break;  				case Code.Ldc_I4_6:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 6);  					break;  				case Code.Ldc_I4_7:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 7);  					break;  				case Code.Ldc_I4_8:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 8);  					break;  				case Code.Ldc_I4_S:  					ExpandMacro (instruction' OpCodes.Ldc_I4' (int) (sbyte) instruction.Operand);  					break;  				case Code.Br_S:  					instruction.OpCode = OpCodes.Br;  					break;  				case Code.Brfalse_S:  					instruction.OpCode = OpCodes.Brfalse;  					break;  				case Code.Brtrue_S:  					instruction.OpCode = OpCodes.Brtrue;  					break;  				case Code.Beq_S:  					instruction.OpCode = OpCodes.Beq;  					break;  				case Code.Bge_S:  					instruction.OpCode = OpCodes.Bge;  					break;  				case Code.Bgt_S:  					instruction.OpCode = OpCodes.Bgt;  					break;  				case Code.Ble_S:  					instruction.OpCode = OpCodes.Ble;  					break;  				case Code.Blt_S:  					instruction.OpCode = OpCodes.Blt;  					break;  				case Code.Bne_Un_S:  					instruction.OpCode = OpCodes.Bne_Un;  					break;  				case Code.Bge_Un_S:  					instruction.OpCode = OpCodes.Bge_Un;  					break;  				case Code.Bgt_Un_S:  					instruction.OpCode = OpCodes.Bgt_Un;  					break;  				case Code.Ble_Un_S:  					instruction.OpCode = OpCodes.Ble_Un;  					break;  				case Code.Blt_Un_S:  					instruction.OpCode = OpCodes.Blt_Un;  					break;  				case Code.Leave_S:  					instruction.OpCode = OpCodes.Leave;  					break;  				}  			}
Magic Number,Mono.Cecil.Rocks,MethodBodyRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\MethodBodyRocks.cs,SimplifyMacros,The following statement contains a magic number: foreach (var instruction in self.Instructions) {  				if (instruction.OpCode.OpCodeType != OpCodeType.Macro)  					continue;    				switch (instruction.OpCode.Code) {  				case Code.Ldarg_0:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (0));  					break;  				case Code.Ldarg_1:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (1));  					break;  				case Code.Ldarg_2:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (2));  					break;  				case Code.Ldarg_3:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (3));  					break;  				case Code.Ldloc_0:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [0]);  					break;  				case Code.Ldloc_1:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [1]);  					break;  				case Code.Ldloc_2:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [2]);  					break;  				case Code.Ldloc_3:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [3]);  					break;  				case Code.Stloc_0:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [0]);  					break;  				case Code.Stloc_1:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [1]);  					break;  				case Code.Stloc_2:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [2]);  					break;  				case Code.Stloc_3:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [3]);  					break;  				case Code.Ldarg_S:  					instruction.OpCode = OpCodes.Ldarg;  					break;  				case Code.Ldarga_S:  					instruction.OpCode = OpCodes.Ldarga;  					break;  				case Code.Starg_S:  					instruction.OpCode = OpCodes.Starg;  					break;  				case Code.Ldloc_S:  					instruction.OpCode = OpCodes.Ldloc;  					break;  				case Code.Ldloca_S:  					instruction.OpCode = OpCodes.Ldloca;  					break;  				case Code.Stloc_S:  					instruction.OpCode = OpCodes.Stloc;  					break;  				case Code.Ldc_I4_M1:  					ExpandMacro (instruction' OpCodes.Ldc_I4' -1);  					break;  				case Code.Ldc_I4_0:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 0);  					break;  				case Code.Ldc_I4_1:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 1);  					break;  				case Code.Ldc_I4_2:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 2);  					break;  				case Code.Ldc_I4_3:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 3);  					break;  				case Code.Ldc_I4_4:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 4);  					break;  				case Code.Ldc_I4_5:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 5);  					break;  				case Code.Ldc_I4_6:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 6);  					break;  				case Code.Ldc_I4_7:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 7);  					break;  				case Code.Ldc_I4_8:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 8);  					break;  				case Code.Ldc_I4_S:  					ExpandMacro (instruction' OpCodes.Ldc_I4' (int) (sbyte) instruction.Operand);  					break;  				case Code.Br_S:  					instruction.OpCode = OpCodes.Br;  					break;  				case Code.Brfalse_S:  					instruction.OpCode = OpCodes.Brfalse;  					break;  				case Code.Brtrue_S:  					instruction.OpCode = OpCodes.Brtrue;  					break;  				case Code.Beq_S:  					instruction.OpCode = OpCodes.Beq;  					break;  				case Code.Bge_S:  					instruction.OpCode = OpCodes.Bge;  					break;  				case Code.Bgt_S:  					instruction.OpCode = OpCodes.Bgt;  					break;  				case Code.Ble_S:  					instruction.OpCode = OpCodes.Ble;  					break;  				case Code.Blt_S:  					instruction.OpCode = OpCodes.Blt;  					break;  				case Code.Bne_Un_S:  					instruction.OpCode = OpCodes.Bne_Un;  					break;  				case Code.Bge_Un_S:  					instruction.OpCode = OpCodes.Bge_Un;  					break;  				case Code.Bgt_Un_S:  					instruction.OpCode = OpCodes.Bgt_Un;  					break;  				case Code.Ble_Un_S:  					instruction.OpCode = OpCodes.Ble_Un;  					break;  				case Code.Blt_Un_S:  					instruction.OpCode = OpCodes.Blt_Un;  					break;  				case Code.Leave_S:  					instruction.OpCode = OpCodes.Leave;  					break;  				}  			}
Magic Number,Mono.Cecil.Rocks,MethodBodyRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\MethodBodyRocks.cs,SimplifyMacros,The following statement contains a magic number: foreach (var instruction in self.Instructions) {  				if (instruction.OpCode.OpCodeType != OpCodeType.Macro)  					continue;    				switch (instruction.OpCode.Code) {  				case Code.Ldarg_0:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (0));  					break;  				case Code.Ldarg_1:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (1));  					break;  				case Code.Ldarg_2:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (2));  					break;  				case Code.Ldarg_3:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (3));  					break;  				case Code.Ldloc_0:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [0]);  					break;  				case Code.Ldloc_1:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [1]);  					break;  				case Code.Ldloc_2:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [2]);  					break;  				case Code.Ldloc_3:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [3]);  					break;  				case Code.Stloc_0:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [0]);  					break;  				case Code.Stloc_1:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [1]);  					break;  				case Code.Stloc_2:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [2]);  					break;  				case Code.Stloc_3:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [3]);  					break;  				case Code.Ldarg_S:  					instruction.OpCode = OpCodes.Ldarg;  					break;  				case Code.Ldarga_S:  					instruction.OpCode = OpCodes.Ldarga;  					break;  				case Code.Starg_S:  					instruction.OpCode = OpCodes.Starg;  					break;  				case Code.Ldloc_S:  					instruction.OpCode = OpCodes.Ldloc;  					break;  				case Code.Ldloca_S:  					instruction.OpCode = OpCodes.Ldloca;  					break;  				case Code.Stloc_S:  					instruction.OpCode = OpCodes.Stloc;  					break;  				case Code.Ldc_I4_M1:  					ExpandMacro (instruction' OpCodes.Ldc_I4' -1);  					break;  				case Code.Ldc_I4_0:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 0);  					break;  				case Code.Ldc_I4_1:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 1);  					break;  				case Code.Ldc_I4_2:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 2);  					break;  				case Code.Ldc_I4_3:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 3);  					break;  				case Code.Ldc_I4_4:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 4);  					break;  				case Code.Ldc_I4_5:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 5);  					break;  				case Code.Ldc_I4_6:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 6);  					break;  				case Code.Ldc_I4_7:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 7);  					break;  				case Code.Ldc_I4_8:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 8);  					break;  				case Code.Ldc_I4_S:  					ExpandMacro (instruction' OpCodes.Ldc_I4' (int) (sbyte) instruction.Operand);  					break;  				case Code.Br_S:  					instruction.OpCode = OpCodes.Br;  					break;  				case Code.Brfalse_S:  					instruction.OpCode = OpCodes.Brfalse;  					break;  				case Code.Brtrue_S:  					instruction.OpCode = OpCodes.Brtrue;  					break;  				case Code.Beq_S:  					instruction.OpCode = OpCodes.Beq;  					break;  				case Code.Bge_S:  					instruction.OpCode = OpCodes.Bge;  					break;  				case Code.Bgt_S:  					instruction.OpCode = OpCodes.Bgt;  					break;  				case Code.Ble_S:  					instruction.OpCode = OpCodes.Ble;  					break;  				case Code.Blt_S:  					instruction.OpCode = OpCodes.Blt;  					break;  				case Code.Bne_Un_S:  					instruction.OpCode = OpCodes.Bne_Un;  					break;  				case Code.Bge_Un_S:  					instruction.OpCode = OpCodes.Bge_Un;  					break;  				case Code.Bgt_Un_S:  					instruction.OpCode = OpCodes.Bgt_Un;  					break;  				case Code.Ble_Un_S:  					instruction.OpCode = OpCodes.Ble_Un;  					break;  				case Code.Blt_Un_S:  					instruction.OpCode = OpCodes.Blt_Un;  					break;  				case Code.Leave_S:  					instruction.OpCode = OpCodes.Leave;  					break;  				}  			}
Magic Number,Mono.Cecil.Rocks,MethodBodyRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\MethodBodyRocks.cs,SimplifyMacros,The following statement contains a magic number: foreach (var instruction in self.Instructions) {  				if (instruction.OpCode.OpCodeType != OpCodeType.Macro)  					continue;    				switch (instruction.OpCode.Code) {  				case Code.Ldarg_0:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (0));  					break;  				case Code.Ldarg_1:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (1));  					break;  				case Code.Ldarg_2:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (2));  					break;  				case Code.Ldarg_3:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (3));  					break;  				case Code.Ldloc_0:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [0]);  					break;  				case Code.Ldloc_1:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [1]);  					break;  				case Code.Ldloc_2:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [2]);  					break;  				case Code.Ldloc_3:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [3]);  					break;  				case Code.Stloc_0:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [0]);  					break;  				case Code.Stloc_1:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [1]);  					break;  				case Code.Stloc_2:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [2]);  					break;  				case Code.Stloc_3:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [3]);  					break;  				case Code.Ldarg_S:  					instruction.OpCode = OpCodes.Ldarg;  					break;  				case Code.Ldarga_S:  					instruction.OpCode = OpCodes.Ldarga;  					break;  				case Code.Starg_S:  					instruction.OpCode = OpCodes.Starg;  					break;  				case Code.Ldloc_S:  					instruction.OpCode = OpCodes.Ldloc;  					break;  				case Code.Ldloca_S:  					instruction.OpCode = OpCodes.Ldloca;  					break;  				case Code.Stloc_S:  					instruction.OpCode = OpCodes.Stloc;  					break;  				case Code.Ldc_I4_M1:  					ExpandMacro (instruction' OpCodes.Ldc_I4' -1);  					break;  				case Code.Ldc_I4_0:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 0);  					break;  				case Code.Ldc_I4_1:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 1);  					break;  				case Code.Ldc_I4_2:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 2);  					break;  				case Code.Ldc_I4_3:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 3);  					break;  				case Code.Ldc_I4_4:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 4);  					break;  				case Code.Ldc_I4_5:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 5);  					break;  				case Code.Ldc_I4_6:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 6);  					break;  				case Code.Ldc_I4_7:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 7);  					break;  				case Code.Ldc_I4_8:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 8);  					break;  				case Code.Ldc_I4_S:  					ExpandMacro (instruction' OpCodes.Ldc_I4' (int) (sbyte) instruction.Operand);  					break;  				case Code.Br_S:  					instruction.OpCode = OpCodes.Br;  					break;  				case Code.Brfalse_S:  					instruction.OpCode = OpCodes.Brfalse;  					break;  				case Code.Brtrue_S:  					instruction.OpCode = OpCodes.Brtrue;  					break;  				case Code.Beq_S:  					instruction.OpCode = OpCodes.Beq;  					break;  				case Code.Bge_S:  					instruction.OpCode = OpCodes.Bge;  					break;  				case Code.Bgt_S:  					instruction.OpCode = OpCodes.Bgt;  					break;  				case Code.Ble_S:  					instruction.OpCode = OpCodes.Ble;  					break;  				case Code.Blt_S:  					instruction.OpCode = OpCodes.Blt;  					break;  				case Code.Bne_Un_S:  					instruction.OpCode = OpCodes.Bne_Un;  					break;  				case Code.Bge_Un_S:  					instruction.OpCode = OpCodes.Bge_Un;  					break;  				case Code.Bgt_Un_S:  					instruction.OpCode = OpCodes.Bgt_Un;  					break;  				case Code.Ble_Un_S:  					instruction.OpCode = OpCodes.Ble_Un;  					break;  				case Code.Blt_Un_S:  					instruction.OpCode = OpCodes.Blt_Un;  					break;  				case Code.Leave_S:  					instruction.OpCode = OpCodes.Leave;  					break;  				}  			}
Magic Number,Mono.Cecil.Rocks,MethodBodyRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\MethodBodyRocks.cs,SimplifyMacros,The following statement contains a magic number: foreach (var instruction in self.Instructions) {  				if (instruction.OpCode.OpCodeType != OpCodeType.Macro)  					continue;    				switch (instruction.OpCode.Code) {  				case Code.Ldarg_0:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (0));  					break;  				case Code.Ldarg_1:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (1));  					break;  				case Code.Ldarg_2:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (2));  					break;  				case Code.Ldarg_3:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (3));  					break;  				case Code.Ldloc_0:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [0]);  					break;  				case Code.Ldloc_1:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [1]);  					break;  				case Code.Ldloc_2:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [2]);  					break;  				case Code.Ldloc_3:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [3]);  					break;  				case Code.Stloc_0:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [0]);  					break;  				case Code.Stloc_1:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [1]);  					break;  				case Code.Stloc_2:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [2]);  					break;  				case Code.Stloc_3:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [3]);  					break;  				case Code.Ldarg_S:  					instruction.OpCode = OpCodes.Ldarg;  					break;  				case Code.Ldarga_S:  					instruction.OpCode = OpCodes.Ldarga;  					break;  				case Code.Starg_S:  					instruction.OpCode = OpCodes.Starg;  					break;  				case Code.Ldloc_S:  					instruction.OpCode = OpCodes.Ldloc;  					break;  				case Code.Ldloca_S:  					instruction.OpCode = OpCodes.Ldloca;  					break;  				case Code.Stloc_S:  					instruction.OpCode = OpCodes.Stloc;  					break;  				case Code.Ldc_I4_M1:  					ExpandMacro (instruction' OpCodes.Ldc_I4' -1);  					break;  				case Code.Ldc_I4_0:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 0);  					break;  				case Code.Ldc_I4_1:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 1);  					break;  				case Code.Ldc_I4_2:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 2);  					break;  				case Code.Ldc_I4_3:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 3);  					break;  				case Code.Ldc_I4_4:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 4);  					break;  				case Code.Ldc_I4_5:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 5);  					break;  				case Code.Ldc_I4_6:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 6);  					break;  				case Code.Ldc_I4_7:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 7);  					break;  				case Code.Ldc_I4_8:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 8);  					break;  				case Code.Ldc_I4_S:  					ExpandMacro (instruction' OpCodes.Ldc_I4' (int) (sbyte) instruction.Operand);  					break;  				case Code.Br_S:  					instruction.OpCode = OpCodes.Br;  					break;  				case Code.Brfalse_S:  					instruction.OpCode = OpCodes.Brfalse;  					break;  				case Code.Brtrue_S:  					instruction.OpCode = OpCodes.Brtrue;  					break;  				case Code.Beq_S:  					instruction.OpCode = OpCodes.Beq;  					break;  				case Code.Bge_S:  					instruction.OpCode = OpCodes.Bge;  					break;  				case Code.Bgt_S:  					instruction.OpCode = OpCodes.Bgt;  					break;  				case Code.Ble_S:  					instruction.OpCode = OpCodes.Ble;  					break;  				case Code.Blt_S:  					instruction.OpCode = OpCodes.Blt;  					break;  				case Code.Bne_Un_S:  					instruction.OpCode = OpCodes.Bne_Un;  					break;  				case Code.Bge_Un_S:  					instruction.OpCode = OpCodes.Bge_Un;  					break;  				case Code.Bgt_Un_S:  					instruction.OpCode = OpCodes.Bgt_Un;  					break;  				case Code.Ble_Un_S:  					instruction.OpCode = OpCodes.Ble_Un;  					break;  				case Code.Blt_Un_S:  					instruction.OpCode = OpCodes.Blt_Un;  					break;  				case Code.Leave_S:  					instruction.OpCode = OpCodes.Leave;  					break;  				}  			}
Magic Number,Mono.Cecil.Rocks,MethodBodyRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\MethodBodyRocks.cs,SimplifyMacros,The following statement contains a magic number: foreach (var instruction in self.Instructions) {  				if (instruction.OpCode.OpCodeType != OpCodeType.Macro)  					continue;    				switch (instruction.OpCode.Code) {  				case Code.Ldarg_0:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (0));  					break;  				case Code.Ldarg_1:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (1));  					break;  				case Code.Ldarg_2:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (2));  					break;  				case Code.Ldarg_3:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (3));  					break;  				case Code.Ldloc_0:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [0]);  					break;  				case Code.Ldloc_1:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [1]);  					break;  				case Code.Ldloc_2:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [2]);  					break;  				case Code.Ldloc_3:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [3]);  					break;  				case Code.Stloc_0:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [0]);  					break;  				case Code.Stloc_1:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [1]);  					break;  				case Code.Stloc_2:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [2]);  					break;  				case Code.Stloc_3:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [3]);  					break;  				case Code.Ldarg_S:  					instruction.OpCode = OpCodes.Ldarg;  					break;  				case Code.Ldarga_S:  					instruction.OpCode = OpCodes.Ldarga;  					break;  				case Code.Starg_S:  					instruction.OpCode = OpCodes.Starg;  					break;  				case Code.Ldloc_S:  					instruction.OpCode = OpCodes.Ldloc;  					break;  				case Code.Ldloca_S:  					instruction.OpCode = OpCodes.Ldloca;  					break;  				case Code.Stloc_S:  					instruction.OpCode = OpCodes.Stloc;  					break;  				case Code.Ldc_I4_M1:  					ExpandMacro (instruction' OpCodes.Ldc_I4' -1);  					break;  				case Code.Ldc_I4_0:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 0);  					break;  				case Code.Ldc_I4_1:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 1);  					break;  				case Code.Ldc_I4_2:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 2);  					break;  				case Code.Ldc_I4_3:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 3);  					break;  				case Code.Ldc_I4_4:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 4);  					break;  				case Code.Ldc_I4_5:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 5);  					break;  				case Code.Ldc_I4_6:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 6);  					break;  				case Code.Ldc_I4_7:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 7);  					break;  				case Code.Ldc_I4_8:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 8);  					break;  				case Code.Ldc_I4_S:  					ExpandMacro (instruction' OpCodes.Ldc_I4' (int) (sbyte) instruction.Operand);  					break;  				case Code.Br_S:  					instruction.OpCode = OpCodes.Br;  					break;  				case Code.Brfalse_S:  					instruction.OpCode = OpCodes.Brfalse;  					break;  				case Code.Brtrue_S:  					instruction.OpCode = OpCodes.Brtrue;  					break;  				case Code.Beq_S:  					instruction.OpCode = OpCodes.Beq;  					break;  				case Code.Bge_S:  					instruction.OpCode = OpCodes.Bge;  					break;  				case Code.Bgt_S:  					instruction.OpCode = OpCodes.Bgt;  					break;  				case Code.Ble_S:  					instruction.OpCode = OpCodes.Ble;  					break;  				case Code.Blt_S:  					instruction.OpCode = OpCodes.Blt;  					break;  				case Code.Bne_Un_S:  					instruction.OpCode = OpCodes.Bne_Un;  					break;  				case Code.Bge_Un_S:  					instruction.OpCode = OpCodes.Bge_Un;  					break;  				case Code.Bgt_Un_S:  					instruction.OpCode = OpCodes.Bgt_Un;  					break;  				case Code.Ble_Un_S:  					instruction.OpCode = OpCodes.Ble_Un;  					break;  				case Code.Blt_Un_S:  					instruction.OpCode = OpCodes.Blt_Un;  					break;  				case Code.Leave_S:  					instruction.OpCode = OpCodes.Leave;  					break;  				}  			}
Magic Number,Mono.Cecil.Rocks,MethodBodyRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\MethodBodyRocks.cs,SimplifyMacros,The following statement contains a magic number: foreach (var instruction in self.Instructions) {  				if (instruction.OpCode.OpCodeType != OpCodeType.Macro)  					continue;    				switch (instruction.OpCode.Code) {  				case Code.Ldarg_0:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (0));  					break;  				case Code.Ldarg_1:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (1));  					break;  				case Code.Ldarg_2:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (2));  					break;  				case Code.Ldarg_3:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (3));  					break;  				case Code.Ldloc_0:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [0]);  					break;  				case Code.Ldloc_1:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [1]);  					break;  				case Code.Ldloc_2:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [2]);  					break;  				case Code.Ldloc_3:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [3]);  					break;  				case Code.Stloc_0:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [0]);  					break;  				case Code.Stloc_1:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [1]);  					break;  				case Code.Stloc_2:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [2]);  					break;  				case Code.Stloc_3:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [3]);  					break;  				case Code.Ldarg_S:  					instruction.OpCode = OpCodes.Ldarg;  					break;  				case Code.Ldarga_S:  					instruction.OpCode = OpCodes.Ldarga;  					break;  				case Code.Starg_S:  					instruction.OpCode = OpCodes.Starg;  					break;  				case Code.Ldloc_S:  					instruction.OpCode = OpCodes.Ldloc;  					break;  				case Code.Ldloca_S:  					instruction.OpCode = OpCodes.Ldloca;  					break;  				case Code.Stloc_S:  					instruction.OpCode = OpCodes.Stloc;  					break;  				case Code.Ldc_I4_M1:  					ExpandMacro (instruction' OpCodes.Ldc_I4' -1);  					break;  				case Code.Ldc_I4_0:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 0);  					break;  				case Code.Ldc_I4_1:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 1);  					break;  				case Code.Ldc_I4_2:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 2);  					break;  				case Code.Ldc_I4_3:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 3);  					break;  				case Code.Ldc_I4_4:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 4);  					break;  				case Code.Ldc_I4_5:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 5);  					break;  				case Code.Ldc_I4_6:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 6);  					break;  				case Code.Ldc_I4_7:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 7);  					break;  				case Code.Ldc_I4_8:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 8);  					break;  				case Code.Ldc_I4_S:  					ExpandMacro (instruction' OpCodes.Ldc_I4' (int) (sbyte) instruction.Operand);  					break;  				case Code.Br_S:  					instruction.OpCode = OpCodes.Br;  					break;  				case Code.Brfalse_S:  					instruction.OpCode = OpCodes.Brfalse;  					break;  				case Code.Brtrue_S:  					instruction.OpCode = OpCodes.Brtrue;  					break;  				case Code.Beq_S:  					instruction.OpCode = OpCodes.Beq;  					break;  				case Code.Bge_S:  					instruction.OpCode = OpCodes.Bge;  					break;  				case Code.Bgt_S:  					instruction.OpCode = OpCodes.Bgt;  					break;  				case Code.Ble_S:  					instruction.OpCode = OpCodes.Ble;  					break;  				case Code.Blt_S:  					instruction.OpCode = OpCodes.Blt;  					break;  				case Code.Bne_Un_S:  					instruction.OpCode = OpCodes.Bne_Un;  					break;  				case Code.Bge_Un_S:  					instruction.OpCode = OpCodes.Bge_Un;  					break;  				case Code.Bgt_Un_S:  					instruction.OpCode = OpCodes.Bgt_Un;  					break;  				case Code.Ble_Un_S:  					instruction.OpCode = OpCodes.Ble_Un;  					break;  				case Code.Blt_Un_S:  					instruction.OpCode = OpCodes.Blt_Un;  					break;  				case Code.Leave_S:  					instruction.OpCode = OpCodes.Leave;  					break;  				}  			}
Magic Number,Mono.Cecil.Rocks,MethodBodyRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\MethodBodyRocks.cs,OptimizeMacros,The following statement contains a magic number: foreach (var instruction in self.Instructions) {  				int index;  				switch (instruction.OpCode.Code) {  				case Code.Ldarg:  					index = ((ParameterDefinition) instruction.Operand).Index;  					if (index == -1 && instruction.Operand == self.ThisParameter)  						index = 0;  					else if (method.HasThis)  						index++;    					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Ldarg_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldarg_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldarg_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldarg_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Ldarg_S' instruction.Operand);  						break;  					}  					break;  				case Code.Ldloc:  					index = ((VariableDefinition) instruction.Operand).Index;  					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Ldloc_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldloc_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldloc_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldloc_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Ldloc_S' instruction.Operand);  						break;  					}  					break;  				case Code.Stloc:  					index = ((VariableDefinition) instruction.Operand).Index;  					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Stloc_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Stloc_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Stloc_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Stloc_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Stloc_S' instruction.Operand);  						break;  					}  					break;  				case Code.Ldarga:  					index = ((ParameterDefinition) instruction.Operand).Index;  					if (index == -1 && instruction.Operand == self.ThisParameter)  						index = 0;  					else if (method.HasThis)  						index++;  					if (index < 256)  						ExpandMacro (instruction' OpCodes.Ldarga_S' instruction.Operand);  					break;  				case Code.Ldloca:  					if (((VariableDefinition) instruction.Operand).Index < 256)  						ExpandMacro (instruction' OpCodes.Ldloca_S' instruction.Operand);  					break;  				case Code.Ldc_I4:  					int i = (int) instruction.Operand;  					switch (i) {  					case -1:  						MakeMacro (instruction' OpCodes.Ldc_I4_M1);  						break;  					case 0:  						MakeMacro (instruction' OpCodes.Ldc_I4_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldc_I4_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldc_I4_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldc_I4_3);  						break;  					case 4:  						MakeMacro (instruction' OpCodes.Ldc_I4_4);  						break;  					case 5:  						MakeMacro (instruction' OpCodes.Ldc_I4_5);  						break;  					case 6:  						MakeMacro (instruction' OpCodes.Ldc_I4_6);  						break;  					case 7:  						MakeMacro (instruction' OpCodes.Ldc_I4_7);  						break;  					case 8:  						MakeMacro (instruction' OpCodes.Ldc_I4_8);  						break;  					default:  						if (i >= -128 && i < 128)  							ExpandMacro (instruction' OpCodes.Ldc_I4_S' (sbyte) i);  						break;  					}  					break;  				}  			}
Magic Number,Mono.Cecil.Rocks,MethodBodyRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\MethodBodyRocks.cs,OptimizeMacros,The following statement contains a magic number: foreach (var instruction in self.Instructions) {  				int index;  				switch (instruction.OpCode.Code) {  				case Code.Ldarg:  					index = ((ParameterDefinition) instruction.Operand).Index;  					if (index == -1 && instruction.Operand == self.ThisParameter)  						index = 0;  					else if (method.HasThis)  						index++;    					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Ldarg_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldarg_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldarg_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldarg_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Ldarg_S' instruction.Operand);  						break;  					}  					break;  				case Code.Ldloc:  					index = ((VariableDefinition) instruction.Operand).Index;  					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Ldloc_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldloc_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldloc_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldloc_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Ldloc_S' instruction.Operand);  						break;  					}  					break;  				case Code.Stloc:  					index = ((VariableDefinition) instruction.Operand).Index;  					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Stloc_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Stloc_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Stloc_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Stloc_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Stloc_S' instruction.Operand);  						break;  					}  					break;  				case Code.Ldarga:  					index = ((ParameterDefinition) instruction.Operand).Index;  					if (index == -1 && instruction.Operand == self.ThisParameter)  						index = 0;  					else if (method.HasThis)  						index++;  					if (index < 256)  						ExpandMacro (instruction' OpCodes.Ldarga_S' instruction.Operand);  					break;  				case Code.Ldloca:  					if (((VariableDefinition) instruction.Operand).Index < 256)  						ExpandMacro (instruction' OpCodes.Ldloca_S' instruction.Operand);  					break;  				case Code.Ldc_I4:  					int i = (int) instruction.Operand;  					switch (i) {  					case -1:  						MakeMacro (instruction' OpCodes.Ldc_I4_M1);  						break;  					case 0:  						MakeMacro (instruction' OpCodes.Ldc_I4_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldc_I4_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldc_I4_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldc_I4_3);  						break;  					case 4:  						MakeMacro (instruction' OpCodes.Ldc_I4_4);  						break;  					case 5:  						MakeMacro (instruction' OpCodes.Ldc_I4_5);  						break;  					case 6:  						MakeMacro (instruction' OpCodes.Ldc_I4_6);  						break;  					case 7:  						MakeMacro (instruction' OpCodes.Ldc_I4_7);  						break;  					case 8:  						MakeMacro (instruction' OpCodes.Ldc_I4_8);  						break;  					default:  						if (i >= -128 && i < 128)  							ExpandMacro (instruction' OpCodes.Ldc_I4_S' (sbyte) i);  						break;  					}  					break;  				}  			}
Magic Number,Mono.Cecil.Rocks,MethodBodyRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\MethodBodyRocks.cs,OptimizeMacros,The following statement contains a magic number: foreach (var instruction in self.Instructions) {  				int index;  				switch (instruction.OpCode.Code) {  				case Code.Ldarg:  					index = ((ParameterDefinition) instruction.Operand).Index;  					if (index == -1 && instruction.Operand == self.ThisParameter)  						index = 0;  					else if (method.HasThis)  						index++;    					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Ldarg_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldarg_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldarg_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldarg_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Ldarg_S' instruction.Operand);  						break;  					}  					break;  				case Code.Ldloc:  					index = ((VariableDefinition) instruction.Operand).Index;  					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Ldloc_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldloc_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldloc_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldloc_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Ldloc_S' instruction.Operand);  						break;  					}  					break;  				case Code.Stloc:  					index = ((VariableDefinition) instruction.Operand).Index;  					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Stloc_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Stloc_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Stloc_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Stloc_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Stloc_S' instruction.Operand);  						break;  					}  					break;  				case Code.Ldarga:  					index = ((ParameterDefinition) instruction.Operand).Index;  					if (index == -1 && instruction.Operand == self.ThisParameter)  						index = 0;  					else if (method.HasThis)  						index++;  					if (index < 256)  						ExpandMacro (instruction' OpCodes.Ldarga_S' instruction.Operand);  					break;  				case Code.Ldloca:  					if (((VariableDefinition) instruction.Operand).Index < 256)  						ExpandMacro (instruction' OpCodes.Ldloca_S' instruction.Operand);  					break;  				case Code.Ldc_I4:  					int i = (int) instruction.Operand;  					switch (i) {  					case -1:  						MakeMacro (instruction' OpCodes.Ldc_I4_M1);  						break;  					case 0:  						MakeMacro (instruction' OpCodes.Ldc_I4_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldc_I4_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldc_I4_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldc_I4_3);  						break;  					case 4:  						MakeMacro (instruction' OpCodes.Ldc_I4_4);  						break;  					case 5:  						MakeMacro (instruction' OpCodes.Ldc_I4_5);  						break;  					case 6:  						MakeMacro (instruction' OpCodes.Ldc_I4_6);  						break;  					case 7:  						MakeMacro (instruction' OpCodes.Ldc_I4_7);  						break;  					case 8:  						MakeMacro (instruction' OpCodes.Ldc_I4_8);  						break;  					default:  						if (i >= -128 && i < 128)  							ExpandMacro (instruction' OpCodes.Ldc_I4_S' (sbyte) i);  						break;  					}  					break;  				}  			}
Magic Number,Mono.Cecil.Rocks,MethodBodyRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\MethodBodyRocks.cs,OptimizeMacros,The following statement contains a magic number: foreach (var instruction in self.Instructions) {  				int index;  				switch (instruction.OpCode.Code) {  				case Code.Ldarg:  					index = ((ParameterDefinition) instruction.Operand).Index;  					if (index == -1 && instruction.Operand == self.ThisParameter)  						index = 0;  					else if (method.HasThis)  						index++;    					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Ldarg_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldarg_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldarg_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldarg_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Ldarg_S' instruction.Operand);  						break;  					}  					break;  				case Code.Ldloc:  					index = ((VariableDefinition) instruction.Operand).Index;  					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Ldloc_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldloc_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldloc_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldloc_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Ldloc_S' instruction.Operand);  						break;  					}  					break;  				case Code.Stloc:  					index = ((VariableDefinition) instruction.Operand).Index;  					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Stloc_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Stloc_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Stloc_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Stloc_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Stloc_S' instruction.Operand);  						break;  					}  					break;  				case Code.Ldarga:  					index = ((ParameterDefinition) instruction.Operand).Index;  					if (index == -1 && instruction.Operand == self.ThisParameter)  						index = 0;  					else if (method.HasThis)  						index++;  					if (index < 256)  						ExpandMacro (instruction' OpCodes.Ldarga_S' instruction.Operand);  					break;  				case Code.Ldloca:  					if (((VariableDefinition) instruction.Operand).Index < 256)  						ExpandMacro (instruction' OpCodes.Ldloca_S' instruction.Operand);  					break;  				case Code.Ldc_I4:  					int i = (int) instruction.Operand;  					switch (i) {  					case -1:  						MakeMacro (instruction' OpCodes.Ldc_I4_M1);  						break;  					case 0:  						MakeMacro (instruction' OpCodes.Ldc_I4_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldc_I4_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldc_I4_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldc_I4_3);  						break;  					case 4:  						MakeMacro (instruction' OpCodes.Ldc_I4_4);  						break;  					case 5:  						MakeMacro (instruction' OpCodes.Ldc_I4_5);  						break;  					case 6:  						MakeMacro (instruction' OpCodes.Ldc_I4_6);  						break;  					case 7:  						MakeMacro (instruction' OpCodes.Ldc_I4_7);  						break;  					case 8:  						MakeMacro (instruction' OpCodes.Ldc_I4_8);  						break;  					default:  						if (i >= -128 && i < 128)  							ExpandMacro (instruction' OpCodes.Ldc_I4_S' (sbyte) i);  						break;  					}  					break;  				}  			}
Magic Number,Mono.Cecil.Rocks,MethodBodyRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\MethodBodyRocks.cs,OptimizeMacros,The following statement contains a magic number: foreach (var instruction in self.Instructions) {  				int index;  				switch (instruction.OpCode.Code) {  				case Code.Ldarg:  					index = ((ParameterDefinition) instruction.Operand).Index;  					if (index == -1 && instruction.Operand == self.ThisParameter)  						index = 0;  					else if (method.HasThis)  						index++;    					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Ldarg_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldarg_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldarg_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldarg_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Ldarg_S' instruction.Operand);  						break;  					}  					break;  				case Code.Ldloc:  					index = ((VariableDefinition) instruction.Operand).Index;  					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Ldloc_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldloc_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldloc_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldloc_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Ldloc_S' instruction.Operand);  						break;  					}  					break;  				case Code.Stloc:  					index = ((VariableDefinition) instruction.Operand).Index;  					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Stloc_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Stloc_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Stloc_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Stloc_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Stloc_S' instruction.Operand);  						break;  					}  					break;  				case Code.Ldarga:  					index = ((ParameterDefinition) instruction.Operand).Index;  					if (index == -1 && instruction.Operand == self.ThisParameter)  						index = 0;  					else if (method.HasThis)  						index++;  					if (index < 256)  						ExpandMacro (instruction' OpCodes.Ldarga_S' instruction.Operand);  					break;  				case Code.Ldloca:  					if (((VariableDefinition) instruction.Operand).Index < 256)  						ExpandMacro (instruction' OpCodes.Ldloca_S' instruction.Operand);  					break;  				case Code.Ldc_I4:  					int i = (int) instruction.Operand;  					switch (i) {  					case -1:  						MakeMacro (instruction' OpCodes.Ldc_I4_M1);  						break;  					case 0:  						MakeMacro (instruction' OpCodes.Ldc_I4_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldc_I4_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldc_I4_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldc_I4_3);  						break;  					case 4:  						MakeMacro (instruction' OpCodes.Ldc_I4_4);  						break;  					case 5:  						MakeMacro (instruction' OpCodes.Ldc_I4_5);  						break;  					case 6:  						MakeMacro (instruction' OpCodes.Ldc_I4_6);  						break;  					case 7:  						MakeMacro (instruction' OpCodes.Ldc_I4_7);  						break;  					case 8:  						MakeMacro (instruction' OpCodes.Ldc_I4_8);  						break;  					default:  						if (i >= -128 && i < 128)  							ExpandMacro (instruction' OpCodes.Ldc_I4_S' (sbyte) i);  						break;  					}  					break;  				}  			}
Magic Number,Mono.Cecil.Rocks,MethodBodyRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\MethodBodyRocks.cs,OptimizeMacros,The following statement contains a magic number: foreach (var instruction in self.Instructions) {  				int index;  				switch (instruction.OpCode.Code) {  				case Code.Ldarg:  					index = ((ParameterDefinition) instruction.Operand).Index;  					if (index == -1 && instruction.Operand == self.ThisParameter)  						index = 0;  					else if (method.HasThis)  						index++;    					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Ldarg_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldarg_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldarg_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldarg_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Ldarg_S' instruction.Operand);  						break;  					}  					break;  				case Code.Ldloc:  					index = ((VariableDefinition) instruction.Operand).Index;  					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Ldloc_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldloc_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldloc_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldloc_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Ldloc_S' instruction.Operand);  						break;  					}  					break;  				case Code.Stloc:  					index = ((VariableDefinition) instruction.Operand).Index;  					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Stloc_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Stloc_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Stloc_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Stloc_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Stloc_S' instruction.Operand);  						break;  					}  					break;  				case Code.Ldarga:  					index = ((ParameterDefinition) instruction.Operand).Index;  					if (index == -1 && instruction.Operand == self.ThisParameter)  						index = 0;  					else if (method.HasThis)  						index++;  					if (index < 256)  						ExpandMacro (instruction' OpCodes.Ldarga_S' instruction.Operand);  					break;  				case Code.Ldloca:  					if (((VariableDefinition) instruction.Operand).Index < 256)  						ExpandMacro (instruction' OpCodes.Ldloca_S' instruction.Operand);  					break;  				case Code.Ldc_I4:  					int i = (int) instruction.Operand;  					switch (i) {  					case -1:  						MakeMacro (instruction' OpCodes.Ldc_I4_M1);  						break;  					case 0:  						MakeMacro (instruction' OpCodes.Ldc_I4_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldc_I4_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldc_I4_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldc_I4_3);  						break;  					case 4:  						MakeMacro (instruction' OpCodes.Ldc_I4_4);  						break;  					case 5:  						MakeMacro (instruction' OpCodes.Ldc_I4_5);  						break;  					case 6:  						MakeMacro (instruction' OpCodes.Ldc_I4_6);  						break;  					case 7:  						MakeMacro (instruction' OpCodes.Ldc_I4_7);  						break;  					case 8:  						MakeMacro (instruction' OpCodes.Ldc_I4_8);  						break;  					default:  						if (i >= -128 && i < 128)  							ExpandMacro (instruction' OpCodes.Ldc_I4_S' (sbyte) i);  						break;  					}  					break;  				}  			}
Magic Number,Mono.Cecil.Rocks,MethodBodyRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\MethodBodyRocks.cs,OptimizeMacros,The following statement contains a magic number: foreach (var instruction in self.Instructions) {  				int index;  				switch (instruction.OpCode.Code) {  				case Code.Ldarg:  					index = ((ParameterDefinition) instruction.Operand).Index;  					if (index == -1 && instruction.Operand == self.ThisParameter)  						index = 0;  					else if (method.HasThis)  						index++;    					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Ldarg_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldarg_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldarg_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldarg_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Ldarg_S' instruction.Operand);  						break;  					}  					break;  				case Code.Ldloc:  					index = ((VariableDefinition) instruction.Operand).Index;  					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Ldloc_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldloc_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldloc_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldloc_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Ldloc_S' instruction.Operand);  						break;  					}  					break;  				case Code.Stloc:  					index = ((VariableDefinition) instruction.Operand).Index;  					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Stloc_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Stloc_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Stloc_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Stloc_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Stloc_S' instruction.Operand);  						break;  					}  					break;  				case Code.Ldarga:  					index = ((ParameterDefinition) instruction.Operand).Index;  					if (index == -1 && instruction.Operand == self.ThisParameter)  						index = 0;  					else if (method.HasThis)  						index++;  					if (index < 256)  						ExpandMacro (instruction' OpCodes.Ldarga_S' instruction.Operand);  					break;  				case Code.Ldloca:  					if (((VariableDefinition) instruction.Operand).Index < 256)  						ExpandMacro (instruction' OpCodes.Ldloca_S' instruction.Operand);  					break;  				case Code.Ldc_I4:  					int i = (int) instruction.Operand;  					switch (i) {  					case -1:  						MakeMacro (instruction' OpCodes.Ldc_I4_M1);  						break;  					case 0:  						MakeMacro (instruction' OpCodes.Ldc_I4_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldc_I4_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldc_I4_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldc_I4_3);  						break;  					case 4:  						MakeMacro (instruction' OpCodes.Ldc_I4_4);  						break;  					case 5:  						MakeMacro (instruction' OpCodes.Ldc_I4_5);  						break;  					case 6:  						MakeMacro (instruction' OpCodes.Ldc_I4_6);  						break;  					case 7:  						MakeMacro (instruction' OpCodes.Ldc_I4_7);  						break;  					case 8:  						MakeMacro (instruction' OpCodes.Ldc_I4_8);  						break;  					default:  						if (i >= -128 && i < 128)  							ExpandMacro (instruction' OpCodes.Ldc_I4_S' (sbyte) i);  						break;  					}  					break;  				}  			}
Magic Number,Mono.Cecil.Rocks,MethodBodyRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\MethodBodyRocks.cs,OptimizeMacros,The following statement contains a magic number: foreach (var instruction in self.Instructions) {  				int index;  				switch (instruction.OpCode.Code) {  				case Code.Ldarg:  					index = ((ParameterDefinition) instruction.Operand).Index;  					if (index == -1 && instruction.Operand == self.ThisParameter)  						index = 0;  					else if (method.HasThis)  						index++;    					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Ldarg_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldarg_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldarg_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldarg_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Ldarg_S' instruction.Operand);  						break;  					}  					break;  				case Code.Ldloc:  					index = ((VariableDefinition) instruction.Operand).Index;  					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Ldloc_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldloc_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldloc_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldloc_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Ldloc_S' instruction.Operand);  						break;  					}  					break;  				case Code.Stloc:  					index = ((VariableDefinition) instruction.Operand).Index;  					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Stloc_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Stloc_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Stloc_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Stloc_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Stloc_S' instruction.Operand);  						break;  					}  					break;  				case Code.Ldarga:  					index = ((ParameterDefinition) instruction.Operand).Index;  					if (index == -1 && instruction.Operand == self.ThisParameter)  						index = 0;  					else if (method.HasThis)  						index++;  					if (index < 256)  						ExpandMacro (instruction' OpCodes.Ldarga_S' instruction.Operand);  					break;  				case Code.Ldloca:  					if (((VariableDefinition) instruction.Operand).Index < 256)  						ExpandMacro (instruction' OpCodes.Ldloca_S' instruction.Operand);  					break;  				case Code.Ldc_I4:  					int i = (int) instruction.Operand;  					switch (i) {  					case -1:  						MakeMacro (instruction' OpCodes.Ldc_I4_M1);  						break;  					case 0:  						MakeMacro (instruction' OpCodes.Ldc_I4_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldc_I4_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldc_I4_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldc_I4_3);  						break;  					case 4:  						MakeMacro (instruction' OpCodes.Ldc_I4_4);  						break;  					case 5:  						MakeMacro (instruction' OpCodes.Ldc_I4_5);  						break;  					case 6:  						MakeMacro (instruction' OpCodes.Ldc_I4_6);  						break;  					case 7:  						MakeMacro (instruction' OpCodes.Ldc_I4_7);  						break;  					case 8:  						MakeMacro (instruction' OpCodes.Ldc_I4_8);  						break;  					default:  						if (i >= -128 && i < 128)  							ExpandMacro (instruction' OpCodes.Ldc_I4_S' (sbyte) i);  						break;  					}  					break;  				}  			}
Magic Number,Mono.Cecil.Rocks,MethodBodyRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\MethodBodyRocks.cs,OptimizeMacros,The following statement contains a magic number: foreach (var instruction in self.Instructions) {  				int index;  				switch (instruction.OpCode.Code) {  				case Code.Ldarg:  					index = ((ParameterDefinition) instruction.Operand).Index;  					if (index == -1 && instruction.Operand == self.ThisParameter)  						index = 0;  					else if (method.HasThis)  						index++;    					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Ldarg_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldarg_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldarg_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldarg_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Ldarg_S' instruction.Operand);  						break;  					}  					break;  				case Code.Ldloc:  					index = ((VariableDefinition) instruction.Operand).Index;  					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Ldloc_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldloc_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldloc_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldloc_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Ldloc_S' instruction.Operand);  						break;  					}  					break;  				case Code.Stloc:  					index = ((VariableDefinition) instruction.Operand).Index;  					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Stloc_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Stloc_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Stloc_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Stloc_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Stloc_S' instruction.Operand);  						break;  					}  					break;  				case Code.Ldarga:  					index = ((ParameterDefinition) instruction.Operand).Index;  					if (index == -1 && instruction.Operand == self.ThisParameter)  						index = 0;  					else if (method.HasThis)  						index++;  					if (index < 256)  						ExpandMacro (instruction' OpCodes.Ldarga_S' instruction.Operand);  					break;  				case Code.Ldloca:  					if (((VariableDefinition) instruction.Operand).Index < 256)  						ExpandMacro (instruction' OpCodes.Ldloca_S' instruction.Operand);  					break;  				case Code.Ldc_I4:  					int i = (int) instruction.Operand;  					switch (i) {  					case -1:  						MakeMacro (instruction' OpCodes.Ldc_I4_M1);  						break;  					case 0:  						MakeMacro (instruction' OpCodes.Ldc_I4_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldc_I4_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldc_I4_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldc_I4_3);  						break;  					case 4:  						MakeMacro (instruction' OpCodes.Ldc_I4_4);  						break;  					case 5:  						MakeMacro (instruction' OpCodes.Ldc_I4_5);  						break;  					case 6:  						MakeMacro (instruction' OpCodes.Ldc_I4_6);  						break;  					case 7:  						MakeMacro (instruction' OpCodes.Ldc_I4_7);  						break;  					case 8:  						MakeMacro (instruction' OpCodes.Ldc_I4_8);  						break;  					default:  						if (i >= -128 && i < 128)  							ExpandMacro (instruction' OpCodes.Ldc_I4_S' (sbyte) i);  						break;  					}  					break;  				}  			}
Magic Number,Mono.Cecil.Rocks,MethodBodyRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\MethodBodyRocks.cs,OptimizeMacros,The following statement contains a magic number: foreach (var instruction in self.Instructions) {  				int index;  				switch (instruction.OpCode.Code) {  				case Code.Ldarg:  					index = ((ParameterDefinition) instruction.Operand).Index;  					if (index == -1 && instruction.Operand == self.ThisParameter)  						index = 0;  					else if (method.HasThis)  						index++;    					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Ldarg_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldarg_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldarg_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldarg_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Ldarg_S' instruction.Operand);  						break;  					}  					break;  				case Code.Ldloc:  					index = ((VariableDefinition) instruction.Operand).Index;  					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Ldloc_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldloc_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldloc_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldloc_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Ldloc_S' instruction.Operand);  						break;  					}  					break;  				case Code.Stloc:  					index = ((VariableDefinition) instruction.Operand).Index;  					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Stloc_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Stloc_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Stloc_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Stloc_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Stloc_S' instruction.Operand);  						break;  					}  					break;  				case Code.Ldarga:  					index = ((ParameterDefinition) instruction.Operand).Index;  					if (index == -1 && instruction.Operand == self.ThisParameter)  						index = 0;  					else if (method.HasThis)  						index++;  					if (index < 256)  						ExpandMacro (instruction' OpCodes.Ldarga_S' instruction.Operand);  					break;  				case Code.Ldloca:  					if (((VariableDefinition) instruction.Operand).Index < 256)  						ExpandMacro (instruction' OpCodes.Ldloca_S' instruction.Operand);  					break;  				case Code.Ldc_I4:  					int i = (int) instruction.Operand;  					switch (i) {  					case -1:  						MakeMacro (instruction' OpCodes.Ldc_I4_M1);  						break;  					case 0:  						MakeMacro (instruction' OpCodes.Ldc_I4_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldc_I4_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldc_I4_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldc_I4_3);  						break;  					case 4:  						MakeMacro (instruction' OpCodes.Ldc_I4_4);  						break;  					case 5:  						MakeMacro (instruction' OpCodes.Ldc_I4_5);  						break;  					case 6:  						MakeMacro (instruction' OpCodes.Ldc_I4_6);  						break;  					case 7:  						MakeMacro (instruction' OpCodes.Ldc_I4_7);  						break;  					case 8:  						MakeMacro (instruction' OpCodes.Ldc_I4_8);  						break;  					default:  						if (i >= -128 && i < 128)  							ExpandMacro (instruction' OpCodes.Ldc_I4_S' (sbyte) i);  						break;  					}  					break;  				}  			}
Magic Number,Mono.Cecil.Rocks,MethodBodyRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\MethodBodyRocks.cs,OptimizeMacros,The following statement contains a magic number: foreach (var instruction in self.Instructions) {  				int index;  				switch (instruction.OpCode.Code) {  				case Code.Ldarg:  					index = ((ParameterDefinition) instruction.Operand).Index;  					if (index == -1 && instruction.Operand == self.ThisParameter)  						index = 0;  					else if (method.HasThis)  						index++;    					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Ldarg_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldarg_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldarg_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldarg_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Ldarg_S' instruction.Operand);  						break;  					}  					break;  				case Code.Ldloc:  					index = ((VariableDefinition) instruction.Operand).Index;  					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Ldloc_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldloc_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldloc_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldloc_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Ldloc_S' instruction.Operand);  						break;  					}  					break;  				case Code.Stloc:  					index = ((VariableDefinition) instruction.Operand).Index;  					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Stloc_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Stloc_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Stloc_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Stloc_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Stloc_S' instruction.Operand);  						break;  					}  					break;  				case Code.Ldarga:  					index = ((ParameterDefinition) instruction.Operand).Index;  					if (index == -1 && instruction.Operand == self.ThisParameter)  						index = 0;  					else if (method.HasThis)  						index++;  					if (index < 256)  						ExpandMacro (instruction' OpCodes.Ldarga_S' instruction.Operand);  					break;  				case Code.Ldloca:  					if (((VariableDefinition) instruction.Operand).Index < 256)  						ExpandMacro (instruction' OpCodes.Ldloca_S' instruction.Operand);  					break;  				case Code.Ldc_I4:  					int i = (int) instruction.Operand;  					switch (i) {  					case -1:  						MakeMacro (instruction' OpCodes.Ldc_I4_M1);  						break;  					case 0:  						MakeMacro (instruction' OpCodes.Ldc_I4_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldc_I4_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldc_I4_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldc_I4_3);  						break;  					case 4:  						MakeMacro (instruction' OpCodes.Ldc_I4_4);  						break;  					case 5:  						MakeMacro (instruction' OpCodes.Ldc_I4_5);  						break;  					case 6:  						MakeMacro (instruction' OpCodes.Ldc_I4_6);  						break;  					case 7:  						MakeMacro (instruction' OpCodes.Ldc_I4_7);  						break;  					case 8:  						MakeMacro (instruction' OpCodes.Ldc_I4_8);  						break;  					default:  						if (i >= -128 && i < 128)  							ExpandMacro (instruction' OpCodes.Ldc_I4_S' (sbyte) i);  						break;  					}  					break;  				}  			}
Magic Number,Mono.Cecil.Rocks,MethodBodyRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\MethodBodyRocks.cs,OptimizeMacros,The following statement contains a magic number: foreach (var instruction in self.Instructions) {  				int index;  				switch (instruction.OpCode.Code) {  				case Code.Ldarg:  					index = ((ParameterDefinition) instruction.Operand).Index;  					if (index == -1 && instruction.Operand == self.ThisParameter)  						index = 0;  					else if (method.HasThis)  						index++;    					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Ldarg_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldarg_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldarg_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldarg_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Ldarg_S' instruction.Operand);  						break;  					}  					break;  				case Code.Ldloc:  					index = ((VariableDefinition) instruction.Operand).Index;  					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Ldloc_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldloc_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldloc_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldloc_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Ldloc_S' instruction.Operand);  						break;  					}  					break;  				case Code.Stloc:  					index = ((VariableDefinition) instruction.Operand).Index;  					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Stloc_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Stloc_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Stloc_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Stloc_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Stloc_S' instruction.Operand);  						break;  					}  					break;  				case Code.Ldarga:  					index = ((ParameterDefinition) instruction.Operand).Index;  					if (index == -1 && instruction.Operand == self.ThisParameter)  						index = 0;  					else if (method.HasThis)  						index++;  					if (index < 256)  						ExpandMacro (instruction' OpCodes.Ldarga_S' instruction.Operand);  					break;  				case Code.Ldloca:  					if (((VariableDefinition) instruction.Operand).Index < 256)  						ExpandMacro (instruction' OpCodes.Ldloca_S' instruction.Operand);  					break;  				case Code.Ldc_I4:  					int i = (int) instruction.Operand;  					switch (i) {  					case -1:  						MakeMacro (instruction' OpCodes.Ldc_I4_M1);  						break;  					case 0:  						MakeMacro (instruction' OpCodes.Ldc_I4_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldc_I4_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldc_I4_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldc_I4_3);  						break;  					case 4:  						MakeMacro (instruction' OpCodes.Ldc_I4_4);  						break;  					case 5:  						MakeMacro (instruction' OpCodes.Ldc_I4_5);  						break;  					case 6:  						MakeMacro (instruction' OpCodes.Ldc_I4_6);  						break;  					case 7:  						MakeMacro (instruction' OpCodes.Ldc_I4_7);  						break;  					case 8:  						MakeMacro (instruction' OpCodes.Ldc_I4_8);  						break;  					default:  						if (i >= -128 && i < 128)  							ExpandMacro (instruction' OpCodes.Ldc_I4_S' (sbyte) i);  						break;  					}  					break;  				}  			}
Magic Number,Mono.Cecil.Rocks,MethodBodyRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\MethodBodyRocks.cs,OptimizeMacros,The following statement contains a magic number: foreach (var instruction in self.Instructions) {  				int index;  				switch (instruction.OpCode.Code) {  				case Code.Ldarg:  					index = ((ParameterDefinition) instruction.Operand).Index;  					if (index == -1 && instruction.Operand == self.ThisParameter)  						index = 0;  					else if (method.HasThis)  						index++;    					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Ldarg_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldarg_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldarg_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldarg_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Ldarg_S' instruction.Operand);  						break;  					}  					break;  				case Code.Ldloc:  					index = ((VariableDefinition) instruction.Operand).Index;  					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Ldloc_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldloc_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldloc_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldloc_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Ldloc_S' instruction.Operand);  						break;  					}  					break;  				case Code.Stloc:  					index = ((VariableDefinition) instruction.Operand).Index;  					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Stloc_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Stloc_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Stloc_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Stloc_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Stloc_S' instruction.Operand);  						break;  					}  					break;  				case Code.Ldarga:  					index = ((ParameterDefinition) instruction.Operand).Index;  					if (index == -1 && instruction.Operand == self.ThisParameter)  						index = 0;  					else if (method.HasThis)  						index++;  					if (index < 256)  						ExpandMacro (instruction' OpCodes.Ldarga_S' instruction.Operand);  					break;  				case Code.Ldloca:  					if (((VariableDefinition) instruction.Operand).Index < 256)  						ExpandMacro (instruction' OpCodes.Ldloca_S' instruction.Operand);  					break;  				case Code.Ldc_I4:  					int i = (int) instruction.Operand;  					switch (i) {  					case -1:  						MakeMacro (instruction' OpCodes.Ldc_I4_M1);  						break;  					case 0:  						MakeMacro (instruction' OpCodes.Ldc_I4_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldc_I4_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldc_I4_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldc_I4_3);  						break;  					case 4:  						MakeMacro (instruction' OpCodes.Ldc_I4_4);  						break;  					case 5:  						MakeMacro (instruction' OpCodes.Ldc_I4_5);  						break;  					case 6:  						MakeMacro (instruction' OpCodes.Ldc_I4_6);  						break;  					case 7:  						MakeMacro (instruction' OpCodes.Ldc_I4_7);  						break;  					case 8:  						MakeMacro (instruction' OpCodes.Ldc_I4_8);  						break;  					default:  						if (i >= -128 && i < 128)  							ExpandMacro (instruction' OpCodes.Ldc_I4_S' (sbyte) i);  						break;  					}  					break;  				}  			}
Magic Number,Mono.Cecil.Rocks,MethodBodyRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\MethodBodyRocks.cs,OptimizeMacros,The following statement contains a magic number: foreach (var instruction in self.Instructions) {  				int index;  				switch (instruction.OpCode.Code) {  				case Code.Ldarg:  					index = ((ParameterDefinition) instruction.Operand).Index;  					if (index == -1 && instruction.Operand == self.ThisParameter)  						index = 0;  					else if (method.HasThis)  						index++;    					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Ldarg_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldarg_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldarg_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldarg_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Ldarg_S' instruction.Operand);  						break;  					}  					break;  				case Code.Ldloc:  					index = ((VariableDefinition) instruction.Operand).Index;  					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Ldloc_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldloc_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldloc_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldloc_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Ldloc_S' instruction.Operand);  						break;  					}  					break;  				case Code.Stloc:  					index = ((VariableDefinition) instruction.Operand).Index;  					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Stloc_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Stloc_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Stloc_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Stloc_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Stloc_S' instruction.Operand);  						break;  					}  					break;  				case Code.Ldarga:  					index = ((ParameterDefinition) instruction.Operand).Index;  					if (index == -1 && instruction.Operand == self.ThisParameter)  						index = 0;  					else if (method.HasThis)  						index++;  					if (index < 256)  						ExpandMacro (instruction' OpCodes.Ldarga_S' instruction.Operand);  					break;  				case Code.Ldloca:  					if (((VariableDefinition) instruction.Operand).Index < 256)  						ExpandMacro (instruction' OpCodes.Ldloca_S' instruction.Operand);  					break;  				case Code.Ldc_I4:  					int i = (int) instruction.Operand;  					switch (i) {  					case -1:  						MakeMacro (instruction' OpCodes.Ldc_I4_M1);  						break;  					case 0:  						MakeMacro (instruction' OpCodes.Ldc_I4_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldc_I4_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldc_I4_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldc_I4_3);  						break;  					case 4:  						MakeMacro (instruction' OpCodes.Ldc_I4_4);  						break;  					case 5:  						MakeMacro (instruction' OpCodes.Ldc_I4_5);  						break;  					case 6:  						MakeMacro (instruction' OpCodes.Ldc_I4_6);  						break;  					case 7:  						MakeMacro (instruction' OpCodes.Ldc_I4_7);  						break;  					case 8:  						MakeMacro (instruction' OpCodes.Ldc_I4_8);  						break;  					default:  						if (i >= -128 && i < 128)  							ExpandMacro (instruction' OpCodes.Ldc_I4_S' (sbyte) i);  						break;  					}  					break;  				}  			}
Magic Number,Mono.Cecil.Rocks,MethodBodyRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\MethodBodyRocks.cs,OptimizeMacros,The following statement contains a magic number: foreach (var instruction in self.Instructions) {  				int index;  				switch (instruction.OpCode.Code) {  				case Code.Ldarg:  					index = ((ParameterDefinition) instruction.Operand).Index;  					if (index == -1 && instruction.Operand == self.ThisParameter)  						index = 0;  					else if (method.HasThis)  						index++;    					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Ldarg_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldarg_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldarg_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldarg_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Ldarg_S' instruction.Operand);  						break;  					}  					break;  				case Code.Ldloc:  					index = ((VariableDefinition) instruction.Operand).Index;  					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Ldloc_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldloc_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldloc_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldloc_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Ldloc_S' instruction.Operand);  						break;  					}  					break;  				case Code.Stloc:  					index = ((VariableDefinition) instruction.Operand).Index;  					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Stloc_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Stloc_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Stloc_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Stloc_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Stloc_S' instruction.Operand);  						break;  					}  					break;  				case Code.Ldarga:  					index = ((ParameterDefinition) instruction.Operand).Index;  					if (index == -1 && instruction.Operand == self.ThisParameter)  						index = 0;  					else if (method.HasThis)  						index++;  					if (index < 256)  						ExpandMacro (instruction' OpCodes.Ldarga_S' instruction.Operand);  					break;  				case Code.Ldloca:  					if (((VariableDefinition) instruction.Operand).Index < 256)  						ExpandMacro (instruction' OpCodes.Ldloca_S' instruction.Operand);  					break;  				case Code.Ldc_I4:  					int i = (int) instruction.Operand;  					switch (i) {  					case -1:  						MakeMacro (instruction' OpCodes.Ldc_I4_M1);  						break;  					case 0:  						MakeMacro (instruction' OpCodes.Ldc_I4_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldc_I4_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldc_I4_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldc_I4_3);  						break;  					case 4:  						MakeMacro (instruction' OpCodes.Ldc_I4_4);  						break;  					case 5:  						MakeMacro (instruction' OpCodes.Ldc_I4_5);  						break;  					case 6:  						MakeMacro (instruction' OpCodes.Ldc_I4_6);  						break;  					case 7:  						MakeMacro (instruction' OpCodes.Ldc_I4_7);  						break;  					case 8:  						MakeMacro (instruction' OpCodes.Ldc_I4_8);  						break;  					default:  						if (i >= -128 && i < 128)  							ExpandMacro (instruction' OpCodes.Ldc_I4_S' (sbyte) i);  						break;  					}  					break;  				}  			}
Magic Number,Mono.Cecil.Rocks,MethodBodyRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\MethodBodyRocks.cs,OptimizeMacros,The following statement contains a magic number: foreach (var instruction in self.Instructions) {  				int index;  				switch (instruction.OpCode.Code) {  				case Code.Ldarg:  					index = ((ParameterDefinition) instruction.Operand).Index;  					if (index == -1 && instruction.Operand == self.ThisParameter)  						index = 0;  					else if (method.HasThis)  						index++;    					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Ldarg_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldarg_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldarg_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldarg_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Ldarg_S' instruction.Operand);  						break;  					}  					break;  				case Code.Ldloc:  					index = ((VariableDefinition) instruction.Operand).Index;  					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Ldloc_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldloc_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldloc_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldloc_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Ldloc_S' instruction.Operand);  						break;  					}  					break;  				case Code.Stloc:  					index = ((VariableDefinition) instruction.Operand).Index;  					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Stloc_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Stloc_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Stloc_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Stloc_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Stloc_S' instruction.Operand);  						break;  					}  					break;  				case Code.Ldarga:  					index = ((ParameterDefinition) instruction.Operand).Index;  					if (index == -1 && instruction.Operand == self.ThisParameter)  						index = 0;  					else if (method.HasThis)  						index++;  					if (index < 256)  						ExpandMacro (instruction' OpCodes.Ldarga_S' instruction.Operand);  					break;  				case Code.Ldloca:  					if (((VariableDefinition) instruction.Operand).Index < 256)  						ExpandMacro (instruction' OpCodes.Ldloca_S' instruction.Operand);  					break;  				case Code.Ldc_I4:  					int i = (int) instruction.Operand;  					switch (i) {  					case -1:  						MakeMacro (instruction' OpCodes.Ldc_I4_M1);  						break;  					case 0:  						MakeMacro (instruction' OpCodes.Ldc_I4_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldc_I4_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldc_I4_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldc_I4_3);  						break;  					case 4:  						MakeMacro (instruction' OpCodes.Ldc_I4_4);  						break;  					case 5:  						MakeMacro (instruction' OpCodes.Ldc_I4_5);  						break;  					case 6:  						MakeMacro (instruction' OpCodes.Ldc_I4_6);  						break;  					case 7:  						MakeMacro (instruction' OpCodes.Ldc_I4_7);  						break;  					case 8:  						MakeMacro (instruction' OpCodes.Ldc_I4_8);  						break;  					default:  						if (i >= -128 && i < 128)  							ExpandMacro (instruction' OpCodes.Ldc_I4_S' (sbyte) i);  						break;  					}  					break;  				}  			}
Magic Number,Mono.Cecil.Rocks,MethodBodyRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\MethodBodyRocks.cs,OptimizeMacros,The following statement contains a magic number: foreach (var instruction in self.Instructions) {  				int index;  				switch (instruction.OpCode.Code) {  				case Code.Ldarg:  					index = ((ParameterDefinition) instruction.Operand).Index;  					if (index == -1 && instruction.Operand == self.ThisParameter)  						index = 0;  					else if (method.HasThis)  						index++;    					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Ldarg_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldarg_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldarg_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldarg_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Ldarg_S' instruction.Operand);  						break;  					}  					break;  				case Code.Ldloc:  					index = ((VariableDefinition) instruction.Operand).Index;  					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Ldloc_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldloc_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldloc_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldloc_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Ldloc_S' instruction.Operand);  						break;  					}  					break;  				case Code.Stloc:  					index = ((VariableDefinition) instruction.Operand).Index;  					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Stloc_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Stloc_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Stloc_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Stloc_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Stloc_S' instruction.Operand);  						break;  					}  					break;  				case Code.Ldarga:  					index = ((ParameterDefinition) instruction.Operand).Index;  					if (index == -1 && instruction.Operand == self.ThisParameter)  						index = 0;  					else if (method.HasThis)  						index++;  					if (index < 256)  						ExpandMacro (instruction' OpCodes.Ldarga_S' instruction.Operand);  					break;  				case Code.Ldloca:  					if (((VariableDefinition) instruction.Operand).Index < 256)  						ExpandMacro (instruction' OpCodes.Ldloca_S' instruction.Operand);  					break;  				case Code.Ldc_I4:  					int i = (int) instruction.Operand;  					switch (i) {  					case -1:  						MakeMacro (instruction' OpCodes.Ldc_I4_M1);  						break;  					case 0:  						MakeMacro (instruction' OpCodes.Ldc_I4_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldc_I4_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldc_I4_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldc_I4_3);  						break;  					case 4:  						MakeMacro (instruction' OpCodes.Ldc_I4_4);  						break;  					case 5:  						MakeMacro (instruction' OpCodes.Ldc_I4_5);  						break;  					case 6:  						MakeMacro (instruction' OpCodes.Ldc_I4_6);  						break;  					case 7:  						MakeMacro (instruction' OpCodes.Ldc_I4_7);  						break;  					case 8:  						MakeMacro (instruction' OpCodes.Ldc_I4_8);  						break;  					default:  						if (i >= -128 && i < 128)  							ExpandMacro (instruction' OpCodes.Ldc_I4_S' (sbyte) i);  						break;  					}  					break;  				}  			}
Magic Number,Mono.Cecil.Rocks,MethodBodyRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\MethodBodyRocks.cs,OptimizeMacros,The following statement contains a magic number: foreach (var instruction in self.Instructions) {  				int index;  				switch (instruction.OpCode.Code) {  				case Code.Ldarg:  					index = ((ParameterDefinition) instruction.Operand).Index;  					if (index == -1 && instruction.Operand == self.ThisParameter)  						index = 0;  					else if (method.HasThis)  						index++;    					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Ldarg_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldarg_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldarg_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldarg_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Ldarg_S' instruction.Operand);  						break;  					}  					break;  				case Code.Ldloc:  					index = ((VariableDefinition) instruction.Operand).Index;  					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Ldloc_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldloc_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldloc_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldloc_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Ldloc_S' instruction.Operand);  						break;  					}  					break;  				case Code.Stloc:  					index = ((VariableDefinition) instruction.Operand).Index;  					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Stloc_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Stloc_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Stloc_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Stloc_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Stloc_S' instruction.Operand);  						break;  					}  					break;  				case Code.Ldarga:  					index = ((ParameterDefinition) instruction.Operand).Index;  					if (index == -1 && instruction.Operand == self.ThisParameter)  						index = 0;  					else if (method.HasThis)  						index++;  					if (index < 256)  						ExpandMacro (instruction' OpCodes.Ldarga_S' instruction.Operand);  					break;  				case Code.Ldloca:  					if (((VariableDefinition) instruction.Operand).Index < 256)  						ExpandMacro (instruction' OpCodes.Ldloca_S' instruction.Operand);  					break;  				case Code.Ldc_I4:  					int i = (int) instruction.Operand;  					switch (i) {  					case -1:  						MakeMacro (instruction' OpCodes.Ldc_I4_M1);  						break;  					case 0:  						MakeMacro (instruction' OpCodes.Ldc_I4_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldc_I4_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldc_I4_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldc_I4_3);  						break;  					case 4:  						MakeMacro (instruction' OpCodes.Ldc_I4_4);  						break;  					case 5:  						MakeMacro (instruction' OpCodes.Ldc_I4_5);  						break;  					case 6:  						MakeMacro (instruction' OpCodes.Ldc_I4_6);  						break;  					case 7:  						MakeMacro (instruction' OpCodes.Ldc_I4_7);  						break;  					case 8:  						MakeMacro (instruction' OpCodes.Ldc_I4_8);  						break;  					default:  						if (i >= -128 && i < 128)  							ExpandMacro (instruction' OpCodes.Ldc_I4_S' (sbyte) i);  						break;  					}  					break;  				}  			}
Magic Number,Mono.Cecil.Rocks,MethodBodyRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\MethodBodyRocks.cs,OptimizeMacros,The following statement contains a magic number: foreach (var instruction in self.Instructions) {  				int index;  				switch (instruction.OpCode.Code) {  				case Code.Ldarg:  					index = ((ParameterDefinition) instruction.Operand).Index;  					if (index == -1 && instruction.Operand == self.ThisParameter)  						index = 0;  					else if (method.HasThis)  						index++;    					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Ldarg_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldarg_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldarg_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldarg_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Ldarg_S' instruction.Operand);  						break;  					}  					break;  				case Code.Ldloc:  					index = ((VariableDefinition) instruction.Operand).Index;  					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Ldloc_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldloc_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldloc_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldloc_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Ldloc_S' instruction.Operand);  						break;  					}  					break;  				case Code.Stloc:  					index = ((VariableDefinition) instruction.Operand).Index;  					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Stloc_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Stloc_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Stloc_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Stloc_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Stloc_S' instruction.Operand);  						break;  					}  					break;  				case Code.Ldarga:  					index = ((ParameterDefinition) instruction.Operand).Index;  					if (index == -1 && instruction.Operand == self.ThisParameter)  						index = 0;  					else if (method.HasThis)  						index++;  					if (index < 256)  						ExpandMacro (instruction' OpCodes.Ldarga_S' instruction.Operand);  					break;  				case Code.Ldloca:  					if (((VariableDefinition) instruction.Operand).Index < 256)  						ExpandMacro (instruction' OpCodes.Ldloca_S' instruction.Operand);  					break;  				case Code.Ldc_I4:  					int i = (int) instruction.Operand;  					switch (i) {  					case -1:  						MakeMacro (instruction' OpCodes.Ldc_I4_M1);  						break;  					case 0:  						MakeMacro (instruction' OpCodes.Ldc_I4_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldc_I4_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldc_I4_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldc_I4_3);  						break;  					case 4:  						MakeMacro (instruction' OpCodes.Ldc_I4_4);  						break;  					case 5:  						MakeMacro (instruction' OpCodes.Ldc_I4_5);  						break;  					case 6:  						MakeMacro (instruction' OpCodes.Ldc_I4_6);  						break;  					case 7:  						MakeMacro (instruction' OpCodes.Ldc_I4_7);  						break;  					case 8:  						MakeMacro (instruction' OpCodes.Ldc_I4_8);  						break;  					default:  						if (i >= -128 && i < 128)  							ExpandMacro (instruction' OpCodes.Ldc_I4_S' (sbyte) i);  						break;  					}  					break;  				}  			}
Magic Number,Mono.Cecil.Rocks,MethodBodyRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\MethodBodyRocks.cs,OptimizeMacros,The following statement contains a magic number: foreach (var instruction in self.Instructions) {  				int index;  				switch (instruction.OpCode.Code) {  				case Code.Ldarg:  					index = ((ParameterDefinition) instruction.Operand).Index;  					if (index == -1 && instruction.Operand == self.ThisParameter)  						index = 0;  					else if (method.HasThis)  						index++;    					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Ldarg_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldarg_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldarg_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldarg_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Ldarg_S' instruction.Operand);  						break;  					}  					break;  				case Code.Ldloc:  					index = ((VariableDefinition) instruction.Operand).Index;  					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Ldloc_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldloc_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldloc_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldloc_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Ldloc_S' instruction.Operand);  						break;  					}  					break;  				case Code.Stloc:  					index = ((VariableDefinition) instruction.Operand).Index;  					switch (index) {  					case 0:  						MakeMacro (instruction' OpCodes.Stloc_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Stloc_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Stloc_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Stloc_3);  						break;  					default:  						if (index < 256)  							ExpandMacro (instruction' OpCodes.Stloc_S' instruction.Operand);  						break;  					}  					break;  				case Code.Ldarga:  					index = ((ParameterDefinition) instruction.Operand).Index;  					if (index == -1 && instruction.Operand == self.ThisParameter)  						index = 0;  					else if (method.HasThis)  						index++;  					if (index < 256)  						ExpandMacro (instruction' OpCodes.Ldarga_S' instruction.Operand);  					break;  				case Code.Ldloca:  					if (((VariableDefinition) instruction.Operand).Index < 256)  						ExpandMacro (instruction' OpCodes.Ldloca_S' instruction.Operand);  					break;  				case Code.Ldc_I4:  					int i = (int) instruction.Operand;  					switch (i) {  					case -1:  						MakeMacro (instruction' OpCodes.Ldc_I4_M1);  						break;  					case 0:  						MakeMacro (instruction' OpCodes.Ldc_I4_0);  						break;  					case 1:  						MakeMacro (instruction' OpCodes.Ldc_I4_1);  						break;  					case 2:  						MakeMacro (instruction' OpCodes.Ldc_I4_2);  						break;  					case 3:  						MakeMacro (instruction' OpCodes.Ldc_I4_3);  						break;  					case 4:  						MakeMacro (instruction' OpCodes.Ldc_I4_4);  						break;  					case 5:  						MakeMacro (instruction' OpCodes.Ldc_I4_5);  						break;  					case 6:  						MakeMacro (instruction' OpCodes.Ldc_I4_6);  						break;  					case 7:  						MakeMacro (instruction' OpCodes.Ldc_I4_7);  						break;  					case 8:  						MakeMacro (instruction' OpCodes.Ldc_I4_8);  						break;  					default:  						if (i >= -128 && i < 128)  							ExpandMacro (instruction' OpCodes.Ldc_I4_S' (sbyte) i);  						break;  					}  					break;  				}  			}
Magic Number,Mono.Cecil.Rocks,MethodBodyRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\MethodBodyRocks.cs,OptimizeBranch,The following statement contains a magic number: var offset = ((Instruction) instruction.Operand).Offset - (instruction.Offset + instruction.OpCode.Size + 4);
Magic Number,Mono.Cecil.Rocks,MethodBodyRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\MethodBodyRocks.cs,OptimizeBranch,The following statement contains a magic number: if (!(offset >= -128 && offset <= 127))  				return false;
Magic Number,Mono.Cecil.Rocks,MethodBodyRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\MethodBodyRocks.cs,OptimizeBranch,The following statement contains a magic number: if (!(offset >= -128 && offset <= 127))  				return false;
Missing Default,Mono.Cecil.Rocks,ILParser,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\ILParser.cs,ParseCode,The following switch statement is missing a default case: switch (opcode.OperandType) {  				case OperandType.InlineNone:  					visitor.OnInlineNone (opcode);  					break;  				case OperandType.InlineSwitch:  					var length = code.ReadInt32 ();  					var branches = new int [length];  					for (int i = 0; i < length; i++)  						branches [i] = code.ReadInt32 ();  					visitor.OnInlineSwitch (opcode' branches);  					break;  				case OperandType.ShortInlineBrTarget:  					visitor.OnInlineBranch (opcode' code.ReadSByte ());  					break;  				case OperandType.InlineBrTarget:  					visitor.OnInlineBranch (opcode' code.ReadInt32 ());  					break;  				case OperandType.ShortInlineI:  					if (opcode == OpCodes.Ldc_I4_S)  						visitor.OnInlineSByte (opcode' code.ReadSByte ());  					else  						visitor.OnInlineByte (opcode' code.ReadByte ());  					break;  				case OperandType.InlineI:  					visitor.OnInlineInt32 (opcode' code.ReadInt32 ());  					break;  				case OperandType.InlineI8:  					visitor.OnInlineInt64 (opcode' code.ReadInt64 ());  					break;  				case OperandType.ShortInlineR:  					visitor.OnInlineSingle (opcode' code.ReadSingle ());  					break;  				case OperandType.InlineR:  					visitor.OnInlineDouble (opcode' code.ReadDouble ());  					break;  				case OperandType.InlineSig:  					visitor.OnInlineSignature (opcode' code.GetCallSite (code.ReadToken ()));  					break;  				case OperandType.InlineString:  					visitor.OnInlineString (opcode' code.GetString (code.ReadToken ()));  					break;  				case OperandType.ShortInlineArg:  					visitor.OnInlineArgument (opcode' code.GetParameter (code.ReadByte ()));  					break;  				case OperandType.InlineArg:  					visitor.OnInlineArgument (opcode' code.GetParameter (code.ReadInt16 ()));  					break;  				case OperandType.ShortInlineVar:  					visitor.OnInlineVariable (opcode' GetVariable (context' code.ReadByte ()));  					break;  				case OperandType.InlineVar:  					visitor.OnInlineVariable (opcode' GetVariable (context' code.ReadInt16 ()));  					break;  				case OperandType.InlineTok:  				case OperandType.InlineField:  				case OperandType.InlineMethod:  				case OperandType.InlineType:  					var member = metadata.LookupToken (code.ReadToken ());  					switch (member.MetadataToken.TokenType) {  					case TokenType.TypeDef:  					case TokenType.TypeRef:  					case TokenType.TypeSpec:  						visitor.OnInlineType (opcode' (TypeReference) member);  						break;  					case TokenType.Method:  					case TokenType.MethodSpec:  						visitor.OnInlineMethod (opcode' (MethodReference) member);  						break;  					case TokenType.Field:  						visitor.OnInlineField (opcode' (FieldReference) member);  						break;  					case TokenType.MemberRef:  						var field_ref = member as FieldReference;  						if (field_ref != null) {  							visitor.OnInlineField (opcode' field_ref);  							break;  						}    						var method_ref = member as MethodReference;  						if (method_ref != null) {  							visitor.OnInlineMethod (opcode' method_ref);  							break;  						}    						throw new InvalidOperationException ();  					}  					break;  				}
Missing Default,Mono.Cecil.Rocks,ILParser,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\ILParser.cs,ParseCode,The following switch statement is missing a default case: switch (member.MetadataToken.TokenType) {  					case TokenType.TypeDef:  					case TokenType.TypeRef:  					case TokenType.TypeSpec:  						visitor.OnInlineType (opcode' (TypeReference) member);  						break;  					case TokenType.Method:  					case TokenType.MethodSpec:  						visitor.OnInlineMethod (opcode' (MethodReference) member);  						break;  					case TokenType.Field:  						visitor.OnInlineField (opcode' (FieldReference) member);  						break;  					case TokenType.MemberRef:  						var field_ref = member as FieldReference;  						if (field_ref != null) {  							visitor.OnInlineField (opcode' field_ref);  							break;  						}    						var method_ref = member as MethodReference;  						if (method_ref != null) {  							visitor.OnInlineMethod (opcode' method_ref);  							break;  						}    						throw new InvalidOperationException ();  					}
Missing Default,Mono.Cecil.Rocks,MethodBodyRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\MethodBodyRocks.cs,SimplifyMacros,The following switch statement is missing a default case: switch (instruction.OpCode.Code) {  				case Code.Ldarg_0:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (0));  					break;  				case Code.Ldarg_1:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (1));  					break;  				case Code.Ldarg_2:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (2));  					break;  				case Code.Ldarg_3:  					ExpandMacro (instruction' OpCodes.Ldarg' self.GetParameter (3));  					break;  				case Code.Ldloc_0:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [0]);  					break;  				case Code.Ldloc_1:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [1]);  					break;  				case Code.Ldloc_2:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [2]);  					break;  				case Code.Ldloc_3:  					ExpandMacro (instruction' OpCodes.Ldloc' self.Variables [3]);  					break;  				case Code.Stloc_0:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [0]);  					break;  				case Code.Stloc_1:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [1]);  					break;  				case Code.Stloc_2:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [2]);  					break;  				case Code.Stloc_3:  					ExpandMacro (instruction' OpCodes.Stloc' self.Variables [3]);  					break;  				case Code.Ldarg_S:  					instruction.OpCode = OpCodes.Ldarg;  					break;  				case Code.Ldarga_S:  					instruction.OpCode = OpCodes.Ldarga;  					break;  				case Code.Starg_S:  					instruction.OpCode = OpCodes.Starg;  					break;  				case Code.Ldloc_S:  					instruction.OpCode = OpCodes.Ldloc;  					break;  				case Code.Ldloca_S:  					instruction.OpCode = OpCodes.Ldloca;  					break;  				case Code.Stloc_S:  					instruction.OpCode = OpCodes.Stloc;  					break;  				case Code.Ldc_I4_M1:  					ExpandMacro (instruction' OpCodes.Ldc_I4' -1);  					break;  				case Code.Ldc_I4_0:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 0);  					break;  				case Code.Ldc_I4_1:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 1);  					break;  				case Code.Ldc_I4_2:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 2);  					break;  				case Code.Ldc_I4_3:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 3);  					break;  				case Code.Ldc_I4_4:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 4);  					break;  				case Code.Ldc_I4_5:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 5);  					break;  				case Code.Ldc_I4_6:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 6);  					break;  				case Code.Ldc_I4_7:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 7);  					break;  				case Code.Ldc_I4_8:  					ExpandMacro (instruction' OpCodes.Ldc_I4' 8);  					break;  				case Code.Ldc_I4_S:  					ExpandMacro (instruction' OpCodes.Ldc_I4' (int) (sbyte) instruction.Operand);  					break;  				case Code.Br_S:  					instruction.OpCode = OpCodes.Br;  					break;  				case Code.Brfalse_S:  					instruction.OpCode = OpCodes.Brfalse;  					break;  				case Code.Brtrue_S:  					instruction.OpCode = OpCodes.Brtrue;  					break;  				case Code.Beq_S:  					instruction.OpCode = OpCodes.Beq;  					break;  				case Code.Bge_S:  					instruction.OpCode = OpCodes.Bge;  					break;  				case Code.Bgt_S:  					instruction.OpCode = OpCodes.Bgt;  					break;  				case Code.Ble_S:  					instruction.OpCode = OpCodes.Ble;  					break;  				case Code.Blt_S:  					instruction.OpCode = OpCodes.Blt;  					break;  				case Code.Bne_Un_S:  					instruction.OpCode = OpCodes.Bne_Un;  					break;  				case Code.Bge_Un_S:  					instruction.OpCode = OpCodes.Bge_Un;  					break;  				case Code.Bgt_Un_S:  					instruction.OpCode = OpCodes.Bgt_Un;  					break;  				case Code.Ble_Un_S:  					instruction.OpCode = OpCodes.Ble_Un;  					break;  				case Code.Blt_Un_S:  					instruction.OpCode = OpCodes.Blt_Un;  					break;  				case Code.Leave_S:  					instruction.OpCode = OpCodes.Leave;  					break;  				}
Missing Default,Mono.Cecil.Rocks,MethodBodyRocks,C:\repos\jbevain_cecil\rocks\Mono.Cecil.Rocks\MethodBodyRocks.cs,OptimizeBranch,The following switch statement is missing a default case: switch (instruction.OpCode.Code) {  			case Code.Br:  				instruction.OpCode = OpCodes.Br_S;  				break;  			case Code.Brfalse:  				instruction.OpCode = OpCodes.Brfalse_S;  				break;  			case Code.Brtrue:  				instruction.OpCode = OpCodes.Brtrue_S;  				break;  			case Code.Beq:  				instruction.OpCode = OpCodes.Beq_S;  				break;  			case Code.Bge:  				instruction.OpCode = OpCodes.Bge_S;  				break;  			case Code.Bgt:  				instruction.OpCode = OpCodes.Bgt_S;  				break;  			case Code.Ble:  				instruction.OpCode = OpCodes.Ble_S;  				break;  			case Code.Blt:  				instruction.OpCode = OpCodes.Blt_S;  				break;  			case Code.Bne_Un:  				instruction.OpCode = OpCodes.Bne_Un_S;  				break;  			case Code.Bge_Un:  				instruction.OpCode = OpCodes.Bge_Un_S;  				break;  			case Code.Bgt_Un:  				instruction.OpCode = OpCodes.Bgt_Un_S;  				break;  			case Code.Ble_Un:  				instruction.OpCode = OpCodes.Ble_Un_S;  				break;  			case Code.Blt_Un:  				instruction.OpCode = OpCodes.Blt_Un_S;  				break;  			case Code.Leave:  				instruction.OpCode = OpCodes.Leave_S;  				break;  			}
