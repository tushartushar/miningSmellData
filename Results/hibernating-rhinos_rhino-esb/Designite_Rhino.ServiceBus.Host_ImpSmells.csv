Implementation smell,Namespace,Class,File,Method,Description
Long Method,CommandLine,Parser,C:\repos\hibernating-rhinos_rhino-esb\Rhino.ServiceBus.Host\CommandLineArguments.cs,LexFileArguments,The method has 105 lines of code.
Complex Method,CommandLine,Parser,C:\repos\hibernating-rhinos_rhino-esb\Rhino.ServiceBus.Host\CommandLineArguments.cs,Parser,Cyclomatic complexity of the method is 10
Complex Method,CommandLine,Parser,C:\repos\hibernating-rhinos_rhino-esb\Rhino.ServiceBus.Host\CommandLineArguments.cs,GetUsageString,Cyclomatic complexity of the method is 9
Long Identifier,CommandLine,Parser,C:\repos\hibernating-rhinos_rhino-esb\Rhino.ServiceBus.Host\CommandLineArguments.cs,GetUsageString,The length of the parameter minimumNumberOfCharsForHelpText is 31.
Complex Conditional,CommandLine,Argument,C:\repos\hibernating-rhinos_rhino-esb\Rhino.ServiceBus.Host\CommandLineArguments.cs,ParseValue,The conditional expression  "(stringData != null || type == typeof(bool)) && (stringData == null || stringData.Length > 0)"  is complex.
Complex Conditional,CommandLine,Argument,C:\repos\hibernating-rhinos_rhino-esb\Rhino.ServiceBus.Host\CommandLineArguments.cs,AppendValue,The conditional expression  "value is string || value is int || value is uint || value.GetType().IsEnum"  is complex.
Empty Catch Block,CommandLine,Argument,C:\repos\hibernating-rhinos_rhino-esb\Rhino.ServiceBus.Host\CommandLineArguments.cs,ParseValue,The method has an empty catch block.
Magic Number,CommandLine,Parser,C:\repos\hibernating-rhinos_rhino-esb\Rhino.ServiceBus.Host\CommandLineArguments.cs,ArgumentsUsage,The following statement contains a magic number: if (screenWidth == 0)                  screenWidth = 80;
Magic Number,CommandLine,Parser,C:\repos\hibernating-rhinos_rhino-esb\Rhino.ServiceBus.Host\CommandLineArguments.cs,ParseArgumentList,The following statement contains a magic number: if (args != null)              {                  foreach (string argument in args)                  {                      if (argument.Length > 0)                      {                          switch (argument[0])                          {                              case '-':                              case '/':                                  int endIndex = argument.IndexOfAny(new char[] {':'' '+'' '-'}' 1);                                  string option = argument.Substring(1' endIndex == -1 ? argument.Length - 1 : endIndex - 1);                                  string optionArgument;                                  if (option.Length + 1 == argument.Length)                                  {                                      optionArgument = null;                                  }                                  else if (argument.Length > 1 + option.Length && argument[1 + option.Length] == ':')                                  {                                      optionArgument = argument.Substring(option.Length + 2);                                  }                                  else                                  {                                      optionArgument = argument.Substring(option.Length + 1);                                  }                                                                    Argument arg = (Argument) this.argumentMap[option];                                  if (arg == null)                                  {                                      ReportUnrecognizedArgument(argument);                                      hadError = true;                                  }                                  else                                  {                                      hadError |= !arg.SetValue(optionArgument' destination);                                  }                                  break;                              case '@':                                  string[] nestedArguments;                                  hadError |= LexFileArguments(argument.Substring(1)' out nestedArguments);                                  hadError |= ParseArgumentList(nestedArguments' destination);                                  break;                              default:                                  if (this.defaultArgument != null)                                  {                                      hadError |= !this.defaultArgument.SetValue(argument' destination);                                  }                                  else                                  {                                      ReportUnrecognizedArgument(argument);                                      hadError = true;                                  }                                  break;                          }                      }                  }              }
Magic Number,CommandLine,Parser,C:\repos\hibernating-rhinos_rhino-esb\Rhino.ServiceBus.Host\CommandLineArguments.cs,GetUsageString,The following statement contains a magic number: const int minimumNumberOfCharsForHelpText = 10;
Magic Number,CommandLine,Parser,C:\repos\hibernating-rhinos_rhino-esb\Rhino.ServiceBus.Host\CommandLineArguments.cs,GetUsageString,The following statement contains a magic number: const int minimumHelpTextColumn = 5;
Magic Number,Rhino.ServiceBus.Host,Program,C:\repos\hibernating-rhinos_rhino-esb\Rhino.ServiceBus.Host\Program.cs,Main,The following statement contains a magic number: try              {                  log.Debug("Executing action: " + action);                  actions[action].Execute(executingOptions);                    return 0;              }              catch (Exception e)              {                  Console.WriteLine(e);                  log.Fatal("Host has crashed because of an error"' e);  				// want to put the error in the error log  				if(action == Action.Server)  					throw;                    return 2;              }
Missing Default,Rhino.ServiceBus.Host.Actions,DebugAction,C:\repos\hibernating-rhinos_rhino-esb\Rhino.ServiceBus.Host\Actions\DebugAction.cs,Execute,The following switch statement is missing a default case: switch (op.ToLowerInvariant())              		{  						case "q":              				keepGoing = false;              				break;  						case "cls":  							Console.Clear();              				break;              		}
