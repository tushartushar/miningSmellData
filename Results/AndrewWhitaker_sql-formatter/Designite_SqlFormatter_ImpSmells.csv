Implementation smell,Namespace,Class,File,Method,Description
Long Method,SqlFormatter,SqlFormatter,C:\repos\AndrewWhitaker_sql-formatter\SqlFormatter\SqlFormatter.cs,Format,The method has 176 lines of code.
Complex Method,SqlFormatter,SqlFormatter,C:\repos\AndrewWhitaker_sql-formatter\SqlFormatter\SqlFormatter.cs,Format,Cyclomatic complexity of the method is 43
Complex Method,SqlFormatter,SqlFormatter,C:\repos\AndrewWhitaker_sql-formatter\SqlFormatter\SqlFormatter.cs,GetNextToken,Cyclomatic complexity of the method is 17
Long Statement,SqlFormatter,SqlFormatter,C:\repos\AndrewWhitaker_sql-formatter\SqlFormatter\SqlFormatter.cs,Format,The length of the statement  "				if (next.Type == TokenType.ReservedTopLevel || next.Type == TokenType.ReservedNewline || next.Type == TokenType.Comment || next.Type == TokenType.BlockComment) { " is 161.
Long Statement,SqlFormatter,SqlFormatter,C:\repos\AndrewWhitaker_sql-formatter\SqlFormatter\SqlFormatter.cs,GetQuotedString,The length of the statement  "	Match match = Regex.Match (str' "^(((`[^`]*($|`))+)|((\\[[^\\]]*($|\\]))(\\][^\\]]*($|\\]))*)|((\"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*(\"|$))+)|((\'[^\'\\\\]*(?:\\\\.[^\'\\\\]*)*(\'|$))+))"); " is 185.
Complex Conditional,SqlFormatter,SqlFormatter,C:\repos\AndrewWhitaker_sql-formatter\SqlFormatter\SqlFormatter.cs,Format,The conditional expression  "next.Type == TokenType.ReservedTopLevel || next.Type == TokenType.ReservedNewline || next.Type == TokenType.Comment || next.Type == TokenType.BlockComment"  is complex.
Complex Conditional,SqlFormatter,SqlFormatter,C:\repos\AndrewWhitaker_sql-formatter\SqlFormatter\SqlFormatter.cs,Format,The conditional expression  "clauseLimit && token.Value != "'" && token.Type != TokenType.Number && token.Type != TokenType.Whitespace"  is complex.
Complex Conditional,SqlFormatter,SqlFormatter,C:\repos\AndrewWhitaker_sql-formatter\SqlFormatter\SqlFormatter.cs,Format,The conditional expression  "token.Value == "-" && i + 1 < tokens.Count && tokens [i + 1].Type == TokenType.Number && i - 1 >= 0"  is complex.
Complex Conditional,SqlFormatter,SqlFormatter,C:\repos\AndrewWhitaker_sql-formatter\SqlFormatter\SqlFormatter.cs,Format,The conditional expression  "prev != TokenType.Quote && prev != TokenType.BacktickQuote && prev != TokenType.Word && prev != TokenType.Number"  is complex.
Complex Conditional,SqlFormatter,SqlFormatter,C:\repos\AndrewWhitaker_sql-formatter\SqlFormatter\SqlFormatter.cs,GetNextToken,The conditional expression  "str [0] == '#' || (str.Length > 1 && ((str [0] == '-' && str [1] == '-') || (str [0] == '/' && str [1] == '*')))"  is complex.
Complex Conditional,SqlFormatter,SqlFormatter,C:\repos\AndrewWhitaker_sql-formatter\SqlFormatter\SqlFormatter.cs,GetNextToken,The conditional expression  "str [0] == '"' || str [0] == '\'' || str [0] == '`' || str [0] == '['"  is complex.
Magic Number,SqlFormatter,SqlFormatter,C:\repos\AndrewWhitaker_sql-formatter\SqlFormatter\SqlFormatter.cs,Format,The following statement contains a magic number: for (int i = 0; i < tokens.Count; i++) {  	Token token = tokens [i];  	string highlighted = token.Value;  	if (increaseSpecialIndent) {  		indentLevel++;  		increaseSpecialIndent = false;  		indentTypes.Push (IndentType.Special);  	}  	if (increaseBlockIndent) {  		indentLevel++;  		increaseBlockIndent = false;  		indentTypes.Push (IndentType.Block);  	}  	if (newline) {  		result += Environment.NewLine + new string (Tab' indentLevel);  		newline = false;  		addedNewline = true;  	}  	else {  		addedNewline = false;  	}  	if (token.Type == TokenType.Comment || token.Type == TokenType.BlockComment) {  		if (token.Type == TokenType.BlockComment) {  			var indent = new string (Tab' indentLevel);  			result = Environment.NewLine + indent;  			highlighted = highlighted.Replace (Environment.NewLine' Environment.NewLine + indent);  		}  		result += highlighted;  		newline = true;  		continue;  	}  	if (inlineParentheses) {  		if (token.Value == ")") {  			result = result.TrimEnd (' ');  			if (inlineIndented) {  				indentTypes.Pop ();  				indentLevel--;  				result += Environment.NewLine + new string (Tab' indentLevel);  			}  			inlineParentheses = false;  			result += highlighted + ' ';  			continue;  		}  		if (token.Value == "'") {  			if (inlineCount >= 30) {  				inlineCount = 0;  				newline = true;  			}  		}  		inlineCount += token.Value.Length;  	}  	if (token.Value == "(") {  		int length = 0;  		for (int j = 1; j < 250; j++) {  			if (i + j >= tokens.Count) {  				break;  			}  			Token next = tokens [i + j];  			if (next.Value == ")") {  				inlineParentheses = true;  				inlineCount = 0;  				inlineIndented = false;  				break;  			}  			if (next.Value == ";" || next.Value == "(") {  				break;  			}  			if (next.Type == TokenType.ReservedTopLevel || next.Type == TokenType.ReservedNewline || next.Type == TokenType.Comment || next.Type == TokenType.BlockComment) {  				break;  			}  			length += next.Value.Length;  		}  		if (i < originalTokens.Count && originalTokens [i].Type == TokenType.Whitespace) {  			result = result.TrimEnd (' ');  		}  		if (!inlineParentheses) {  			increaseBlockIndent = true;  			newline = true;  		}  	}  	else if (token.Value == ")") {  		result = result.TrimEnd (' ');  		indentLevel--;  		while (indentTypes.Count > 0) {  			IndentType type = indentTypes.Pop ();  			if (type == IndentType.Special) {  				indentLevel--;  			}  			else {  				break;  			}  		}  		if (indentLevel < 0) {  			continue;  		}  		if (!addedNewline) {  			result += Environment.NewLine + new string (Tab' indentLevel);  		}  	}  	else if (token.Type == TokenType.ReservedTopLevel) {  		increaseSpecialIndent = true;  		if (indentTypes.Count > 0 && indentTypes.Peek () == IndentType.Special) {  			indentLevel--;  			indentTypes.Pop ();  		}  		newline = true;  		if (!addedNewline) {  			result += Environment.NewLine + new string (Tab' indentLevel);  		}  		else {  			result = result.TrimEnd () + new string (Tab' indentLevel);  		}  		if (!token.Value.Contains (' ') || !token.Value.Contains ('\n') || !token.Value.Contains (Tab)) {  			highlighted = Regex.Replace (highlighted' @"\s+"' " ");  		}  		if (token.Value == "LIMIT" && !inlineParentheses) {  			clauseLimit = true;  		}  	}  	else if (clauseLimit && token.Value != "'" && token.Type != TokenType.Number && token.Type != TokenType.Whitespace) {  		clauseLimit = false;  	}  	else if (token.Value == "'" && !inlineParentheses) {  		if (clauseLimit) {  			newline = false;  			clauseLimit = false;  		}  		else {  			newline = true;  		}  	}  	else if (token.Type == TokenType.ReservedNewline) {  		if (!addedNewline) {  			result += Environment.NewLine + new string (Tab' indentLevel);  		}  		if (!token.Value.Contains (' ') || !token.Value.Contains ('\n') || !token.Value.Contains (Tab)) {  			highlighted = Regex.Replace (highlighted' @"\s+"' " ");  		}  	}  	else if (token.Type == TokenType.Boundary) {  		if (i - 1 >= 0 && tokens [i - 1].Type == TokenType.Boundary) {  			if (i < originalTokens.Count && originalTokens [i - 1].Type != TokenType.Whitespace) {  				result = result.TrimEnd (' ');  			}  		}  	}  	if (token.Value == "." || token.Value == "'" || token.Value == ";") {  		result = result.TrimEnd (' ');  	}  	result += highlighted + ' ';  	if (token.Value == "(" || token.Value == ".") {  		result = result.TrimEnd (' ');  	}  	if (token.Value == "-" && i + 1 < tokens.Count && tokens [i + 1].Type == TokenType.Number && i - 1 >= 0) {  		TokenType prev = tokens [i - 1].Type;  		if (prev != TokenType.Quote && prev != TokenType.BacktickQuote && prev != TokenType.Word && prev != TokenType.Number) {  			result = result.TrimEnd (' ');  		}  	}  }  
Magic Number,SqlFormatter,SqlFormatter,C:\repos\AndrewWhitaker_sql-formatter\SqlFormatter\SqlFormatter.cs,Format,The following statement contains a magic number: for (int i = 0; i < tokens.Count; i++) {  	Token token = tokens [i];  	string highlighted = token.Value;  	if (increaseSpecialIndent) {  		indentLevel++;  		increaseSpecialIndent = false;  		indentTypes.Push (IndentType.Special);  	}  	if (increaseBlockIndent) {  		indentLevel++;  		increaseBlockIndent = false;  		indentTypes.Push (IndentType.Block);  	}  	if (newline) {  		result += Environment.NewLine + new string (Tab' indentLevel);  		newline = false;  		addedNewline = true;  	}  	else {  		addedNewline = false;  	}  	if (token.Type == TokenType.Comment || token.Type == TokenType.BlockComment) {  		if (token.Type == TokenType.BlockComment) {  			var indent = new string (Tab' indentLevel);  			result = Environment.NewLine + indent;  			highlighted = highlighted.Replace (Environment.NewLine' Environment.NewLine + indent);  		}  		result += highlighted;  		newline = true;  		continue;  	}  	if (inlineParentheses) {  		if (token.Value == ")") {  			result = result.TrimEnd (' ');  			if (inlineIndented) {  				indentTypes.Pop ();  				indentLevel--;  				result += Environment.NewLine + new string (Tab' indentLevel);  			}  			inlineParentheses = false;  			result += highlighted + ' ';  			continue;  		}  		if (token.Value == "'") {  			if (inlineCount >= 30) {  				inlineCount = 0;  				newline = true;  			}  		}  		inlineCount += token.Value.Length;  	}  	if (token.Value == "(") {  		int length = 0;  		for (int j = 1; j < 250; j++) {  			if (i + j >= tokens.Count) {  				break;  			}  			Token next = tokens [i + j];  			if (next.Value == ")") {  				inlineParentheses = true;  				inlineCount = 0;  				inlineIndented = false;  				break;  			}  			if (next.Value == ";" || next.Value == "(") {  				break;  			}  			if (next.Type == TokenType.ReservedTopLevel || next.Type == TokenType.ReservedNewline || next.Type == TokenType.Comment || next.Type == TokenType.BlockComment) {  				break;  			}  			length += next.Value.Length;  		}  		if (i < originalTokens.Count && originalTokens [i].Type == TokenType.Whitespace) {  			result = result.TrimEnd (' ');  		}  		if (!inlineParentheses) {  			increaseBlockIndent = true;  			newline = true;  		}  	}  	else if (token.Value == ")") {  		result = result.TrimEnd (' ');  		indentLevel--;  		while (indentTypes.Count > 0) {  			IndentType type = indentTypes.Pop ();  			if (type == IndentType.Special) {  				indentLevel--;  			}  			else {  				break;  			}  		}  		if (indentLevel < 0) {  			continue;  		}  		if (!addedNewline) {  			result += Environment.NewLine + new string (Tab' indentLevel);  		}  	}  	else if (token.Type == TokenType.ReservedTopLevel) {  		increaseSpecialIndent = true;  		if (indentTypes.Count > 0 && indentTypes.Peek () == IndentType.Special) {  			indentLevel--;  			indentTypes.Pop ();  		}  		newline = true;  		if (!addedNewline) {  			result += Environment.NewLine + new string (Tab' indentLevel);  		}  		else {  			result = result.TrimEnd () + new string (Tab' indentLevel);  		}  		if (!token.Value.Contains (' ') || !token.Value.Contains ('\n') || !token.Value.Contains (Tab)) {  			highlighted = Regex.Replace (highlighted' @"\s+"' " ");  		}  		if (token.Value == "LIMIT" && !inlineParentheses) {  			clauseLimit = true;  		}  	}  	else if (clauseLimit && token.Value != "'" && token.Type != TokenType.Number && token.Type != TokenType.Whitespace) {  		clauseLimit = false;  	}  	else if (token.Value == "'" && !inlineParentheses) {  		if (clauseLimit) {  			newline = false;  			clauseLimit = false;  		}  		else {  			newline = true;  		}  	}  	else if (token.Type == TokenType.ReservedNewline) {  		if (!addedNewline) {  			result += Environment.NewLine + new string (Tab' indentLevel);  		}  		if (!token.Value.Contains (' ') || !token.Value.Contains ('\n') || !token.Value.Contains (Tab)) {  			highlighted = Regex.Replace (highlighted' @"\s+"' " ");  		}  	}  	else if (token.Type == TokenType.Boundary) {  		if (i - 1 >= 0 && tokens [i - 1].Type == TokenType.Boundary) {  			if (i < originalTokens.Count && originalTokens [i - 1].Type != TokenType.Whitespace) {  				result = result.TrimEnd (' ');  			}  		}  	}  	if (token.Value == "." || token.Value == "'" || token.Value == ";") {  		result = result.TrimEnd (' ');  	}  	result += highlighted + ' ';  	if (token.Value == "(" || token.Value == ".") {  		result = result.TrimEnd (' ');  	}  	if (token.Value == "-" && i + 1 < tokens.Count && tokens [i + 1].Type == TokenType.Number && i - 1 >= 0) {  		TokenType prev = tokens [i - 1].Type;  		if (prev != TokenType.Quote && prev != TokenType.BacktickQuote && prev != TokenType.Word && prev != TokenType.Number) {  			result = result.TrimEnd (' ');  		}  	}  }  
Magic Number,SqlFormatter,SqlFormatter,C:\repos\AndrewWhitaker_sql-formatter\SqlFormatter\SqlFormatter.cs,Format,The following statement contains a magic number: if (inlineParentheses) {  	if (token.Value == ")") {  		result = result.TrimEnd (' ');  		if (inlineIndented) {  			indentTypes.Pop ();  			indentLevel--;  			result += Environment.NewLine + new string (Tab' indentLevel);  		}  		inlineParentheses = false;  		result += highlighted + ' ';  		continue;  	}  	if (token.Value == "'") {  		if (inlineCount >= 30) {  			inlineCount = 0;  			newline = true;  		}  	}  	inlineCount += token.Value.Length;  }  
Magic Number,SqlFormatter,SqlFormatter,C:\repos\AndrewWhitaker_sql-formatter\SqlFormatter\SqlFormatter.cs,Format,The following statement contains a magic number: if (token.Value == "'") {  	if (inlineCount >= 30) {  		inlineCount = 0;  		newline = true;  	}  }  
Magic Number,SqlFormatter,SqlFormatter,C:\repos\AndrewWhitaker_sql-formatter\SqlFormatter\SqlFormatter.cs,Format,The following statement contains a magic number: if (inlineCount >= 30) {  	inlineCount = 0;  	newline = true;  }  
Magic Number,SqlFormatter,SqlFormatter,C:\repos\AndrewWhitaker_sql-formatter\SqlFormatter\SqlFormatter.cs,Format,The following statement contains a magic number: if (token.Value == "(") {  	int length = 0;  	for (int j = 1; j < 250; j++) {  		if (i + j >= tokens.Count) {  			break;  		}  		Token next = tokens [i + j];  		if (next.Value == ")") {  			inlineParentheses = true;  			inlineCount = 0;  			inlineIndented = false;  			break;  		}  		if (next.Value == ";" || next.Value == "(") {  			break;  		}  		if (next.Type == TokenType.ReservedTopLevel || next.Type == TokenType.ReservedNewline || next.Type == TokenType.Comment || next.Type == TokenType.BlockComment) {  			break;  		}  		length += next.Value.Length;  	}  	if (i < originalTokens.Count && originalTokens [i].Type == TokenType.Whitespace) {  		result = result.TrimEnd (' ');  	}  	if (!inlineParentheses) {  		increaseBlockIndent = true;  		newline = true;  	}  }  else if (token.Value == ")") {  	result = result.TrimEnd (' ');  	indentLevel--;  	while (indentTypes.Count > 0) {  		IndentType type = indentTypes.Pop ();  		if (type == IndentType.Special) {  			indentLevel--;  		}  		else {  			break;  		}  	}  	if (indentLevel < 0) {  		continue;  	}  	if (!addedNewline) {  		result += Environment.NewLine + new string (Tab' indentLevel);  	}  }  else if (token.Type == TokenType.ReservedTopLevel) {  	increaseSpecialIndent = true;  	if (indentTypes.Count > 0 && indentTypes.Peek () == IndentType.Special) {  		indentLevel--;  		indentTypes.Pop ();  	}  	newline = true;  	if (!addedNewline) {  		result += Environment.NewLine + new string (Tab' indentLevel);  	}  	else {  		result = result.TrimEnd () + new string (Tab' indentLevel);  	}  	if (!token.Value.Contains (' ') || !token.Value.Contains ('\n') || !token.Value.Contains (Tab)) {  		highlighted = Regex.Replace (highlighted' @"\s+"' " ");  	}  	if (token.Value == "LIMIT" && !inlineParentheses) {  		clauseLimit = true;  	}  }  else if (clauseLimit && token.Value != "'" && token.Type != TokenType.Number && token.Type != TokenType.Whitespace) {  	clauseLimit = false;  }  else if (token.Value == "'" && !inlineParentheses) {  	if (clauseLimit) {  		newline = false;  		clauseLimit = false;  	}  	else {  		newline = true;  	}  }  else if (token.Type == TokenType.ReservedNewline) {  	if (!addedNewline) {  		result += Environment.NewLine + new string (Tab' indentLevel);  	}  	if (!token.Value.Contains (' ') || !token.Value.Contains ('\n') || !token.Value.Contains (Tab)) {  		highlighted = Regex.Replace (highlighted' @"\s+"' " ");  	}  }  else if (token.Type == TokenType.Boundary) {  	if (i - 1 >= 0 && tokens [i - 1].Type == TokenType.Boundary) {  		if (i < originalTokens.Count && originalTokens [i - 1].Type != TokenType.Whitespace) {  			result = result.TrimEnd (' ');  		}  	}  }  
Magic Number,SqlFormatter,SqlFormatter,C:\repos\AndrewWhitaker_sql-formatter\SqlFormatter\SqlFormatter.cs,Format,The following statement contains a magic number: for (int j = 1; j < 250; j++) {  	if (i + j >= tokens.Count) {  		break;  	}  	Token next = tokens [i + j];  	if (next.Value == ")") {  		inlineParentheses = true;  		inlineCount = 0;  		inlineIndented = false;  		break;  	}  	if (next.Value == ";" || next.Value == "(") {  		break;  	}  	if (next.Type == TokenType.ReservedTopLevel || next.Type == TokenType.ReservedNewline || next.Type == TokenType.Comment || next.Type == TokenType.BlockComment) {  		break;  	}  	length += next.Value.Length;  }  
Magic Number,SqlFormatter,SqlFormatter,C:\repos\AndrewWhitaker_sql-formatter\SqlFormatter\SqlFormatter.cs,GetNextToken,The following statement contains a magic number: if (str [0] == '#' || (str.Length > 1 && ((str [0] == '-' && str [1] == '-') || (str [0] == '/' && str [1] == '*')))) {  	if (str [0] == '-' || str [0] == '#') {  		last = str.IndexOf ('\n');  		type = TokenType.Comment;  	}  	else {  		last = str.IndexOf ("*/"' 2);  		type = TokenType.BlockComment;  	}  	if (last == null) {  		last = str.Length;  	}  	return new Token (type' str);  }  
Magic Number,SqlFormatter,SqlFormatter,C:\repos\AndrewWhitaker_sql-formatter\SqlFormatter\SqlFormatter.cs,GetNextToken,The following statement contains a magic number: if (str [0] == '-' || str [0] == '#') {  	last = str.IndexOf ('\n');  	type = TokenType.Comment;  }  else {  	last = str.IndexOf ("*/"' 2);  	type = TokenType.BlockComment;  }  
Magic Number,SqlFormatter,SqlFormatter,C:\repos\AndrewWhitaker_sql-formatter\SqlFormatter\SqlFormatter.cs,GetNextToken,The following statement contains a magic number: last = str.IndexOf ("*/"' 2);  
