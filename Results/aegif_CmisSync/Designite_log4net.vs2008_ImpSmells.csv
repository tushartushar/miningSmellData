Implementation smell,Namespace,Class,File,Method,Description
Long Method,log4net.Appender,ColoredConsoleAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\ColoredConsoleAppender.cs,Append,The method has 127 lines of code.
Long Method,log4net.Appender,SmtpAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\SmtpAppender.cs,SendEmail,The method has 119 lines of code.
Long Method,log4net.Core,DefaultRepositorySelector,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\DefaultRepositorySelector.cs,ConfigureRepository,The method has 126 lines of code.
Long Method,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,Configure,The method has 125 lines of code.
Long Method,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,SetParameter,The method has 218 lines of code.
Long Method,log4net.Util,PatternParser,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\PatternParser.cs,ParseInternal,The method has 105 lines of code.
Complex Method,log4net.Appender,LevelColors,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\AnsiColorTerminalAppender.cs,ActivateOptions,Cyclomatic complexity of the method is 8
Complex Method,log4net.Core,DefaultRepositorySelector,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\DefaultRepositorySelector.cs,ConfigureRepository,Cyclomatic complexity of the method is 10
Complex Method,log4net.Core,LocationInfo,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\LocationInfo.cs,LocationInfo,Cyclomatic complexity of the method is 11
Complex Method,log4net.Core,LoggingEvent,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\LoggingEvent.cs,FixVolatileData,Cyclomatic complexity of the method is 11
Complex Method,log4net.Layout,XmlLayout,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Layout\XmlLayout.cs,FormatXml,Cyclomatic complexity of the method is 10
Complex Method,log4net.Layout,XmlLayoutSchemaLog4j,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Layout\XmlLayoutSchemaLog4j.cs,FormatXml,Cyclomatic complexity of the method is 11
Complex Method,log4net.ObjectRenderer,DefaultRenderer,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\ObjectRenderer\DefaultRenderer.cs,RenderObject,Cyclomatic complexity of the method is 9
Complex Method,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,Configure,Cyclomatic complexity of the method is 15
Complex Method,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,CreateObjectFromXml,Cyclomatic complexity of the method is 10
Long Parameter List,log4net.Appender,LockingStream,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\FileAppender.cs,BeginRead,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,log4net.Appender,LockingStream,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\FileAppender.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,log4net.Appender,NetSendAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\NetSendAppender.cs,NetMessageBufferSend,The method has 5 parameters. Parameters: serverName' msgName' fromName' buffer' bufferSize
Long Parameter List,log4net.Core,LoggingEvent,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\LoggingEvent.cs,LoggingEvent,The method has 6 parameters. Parameters: callerStackBoundaryDeclaringType' repository' loggerName' level' message' exception
Long Parameter List,log4net.Util,NativeError,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\NativeError.cs,FormatMessage,The method has 7 parameters. Parameters: dwFlags' lpSource' dwMessageId' dwLanguageId' lpBuffer' nSize' Arguments
Long Parameter List,log4net.Util,WindowsSecurityContext,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\WindowsSecurityContext.cs,LogonUser,The method has 6 parameters. Parameters: lpszUsername' lpszDomain' lpszPassword' dwLogonType' dwLogonProvider' phToken
Long Identifier,log4net.Appender,RollingFileAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\RollingFileAppender.cs,,The length of the parameter m_preserveLogFileNameExtension is 30.
Long Identifier,log4net.Config,XmlConfigurator,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Config\XmlConfigurator.cs,,The length of the parameter m_repositoryName2ConfigAndWatchHandler is 38.
Long Identifier,log4net.Core,ILogger,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\ILogger.cs,Log,The length of the parameter callerStackBoundaryDeclaringType is 32.
Long Identifier,log4net.Core,LocationInfo,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\LocationInfo.cs,LocationInfo,The length of the parameter callerStackBoundaryDeclaringType is 32.
Long Identifier,log4net.Core,LoggingEvent,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\LoggingEvent.cs,LoggingEvent,The length of the parameter callerStackBoundaryDeclaringType is 32.
Long Identifier,log4net.Core,LoggingEvent,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\LoggingEvent.cs,LoggingEvent,The length of the parameter callerStackBoundaryDeclaringType is 32.
Long Identifier,log4net.Core,LoggingEvent,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\LoggingEvent.cs,LoggingEvent,The length of the parameter callerStackBoundaryDeclaringType is 32.
Long Identifier,log4net.Core,LoggingEvent,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\LoggingEvent.cs,,The length of the parameter m_callerStackBoundaryDeclaringType is 34.
Long Identifier,log4net.Repository.Hierarchy,Logger,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Repository\Hierarchy\Logger.cs,Log,The length of the parameter callerStackBoundaryDeclaringType is 32.
Long Identifier,log4net.Repository.Hierarchy,Logger,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Repository\Hierarchy\Logger.cs,ForcedLog,The length of the parameter callerStackBoundaryDeclaringType is 32.
Long Identifier,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,SetParameter,The length of the parameter parsedObjectConversionTargetType is 32.
Long Identifier,log4net.Util,NativeError,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\NativeError.cs,GetErrorMessage,The length of the parameter FORMAT_MESSAGE_ALLOCATE_BUFFER is 30.
Long Statement,log4net.Appender,AdoNetAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\AdoNetAppender.cs,SendBuffer,The length of the statement  "				LogLog.Debug(declaringType' "Attempting to reconnect to database. Current Connection State: " + ((m_dbConnection==null)?SystemInfo.NullText:m_dbConnection.State.ToString()) ); " is 175.
Long Statement,log4net.Appender,AdoNetAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\AdoNetAppender.cs,ResolveConnectionString,The length of the statement  "            connectionStringContext = "Unable to resolve connection string from ConnectionString' ConnectionStrings' or AppSettings."; " is 122.
Long Statement,log4net.Appender,AdoNetAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\AdoNetAppender.cs,InitializeDatabaseConnection,The length of the statement  "                ErrorHandler.Error("Could not open database connection [" + resolvedConnectionString + "]. Connection string context [" + connectionStringContext + "]."' e); " is 157.
Long Statement,log4net.Appender,AppenderCollection,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\AppenderCollection.cs,Remove,The length of the statement  "				throw new System.ArgumentException("Cannot remove the specified item because it was not found in the specified Collection."); " is 125.
Long Statement,log4net.Appender,AppenderCollection,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\AppenderCollection.cs,ValidateIndex,The length of the statement  "				throw log4net.Util.SystemInfo.CreateArgumentOutOfRangeException("i"' (object)i' "Index was out of range. Must be non-negative and less than the size of the collection. [" + (object)i + "] Specified argument was out of the range of valid values."); " is 247.
Long Statement,log4net.Appender,EventLogAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\EventLogAppender.cs,ActivateOptions,The length of the statement  "                    LogLog.Debug(declaringType' "Changing event source [" + m_applicationName + "] from log [" + currentLogName + "] to log [" + m_logName + "]"); " is 142.
Long Statement,log4net.Appender,NetSendAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\NetSendAppender.cs,Append,The length of the statement  "				int returnValue = NetMessageBufferSend(this.Server' this.Recipient' this.Sender' renderedLoggingEvent' renderedLoggingEvent.Length * Marshal.SystemDefaultCharSize);    " is 164.
Long Statement,log4net.Appender,NetSendAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\NetSendAppender.cs,Append,The length of the statement  "				ErrorHandler.Error(nativeError.ToString() + " (Params: Server=" + this.Server + "' Recipient=" + this.Recipient + "' Sender=" + this.Sender + ")"); " is 147.
Long Statement,log4net.Appender,RollingFileAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\RollingFileAppender.cs,OpenFile,The length of the statement  "							LogLog.Error(declaringType' "RollingFileAppender: INTERNAL ERROR. Append is False but OutputFile ["+fileName+"] already exists."); " is 130.
Long Statement,log4net.Appender,RollingFileAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\RollingFileAppender.cs,RollOverIfDateBoundaryCrossing,The length of the statement  "					LogLog.Debug(declaringType' "["+last.ToString(m_datePattern'System.Globalization.DateTimeFormatInfo.InvariantInfo)+"] vs. ["+m_now.ToString(m_datePattern'System.Globalization.DateTimeFormatInfo.InvariantInfo)+"]"); " is 214.
Long Statement,log4net.Appender,RollingFileAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\RollingFileAppender.cs,RollOverIfDateBoundaryCrossing,The length of the statement  "					if (!(last.ToString(m_datePattern'System.Globalization.DateTimeFormatInfo.InvariantInfo).Equals(m_now.ToString(m_datePattern' System.Globalization.DateTimeFormatInfo.InvariantInfo))))  " is 183.
Long Statement,log4net.Appender,RollingFileAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\RollingFileAppender.cs,RollOverIfDateBoundaryCrossing,The length of the statement  "						m_scheduledFilename = m_baseFileName + last.ToString(m_datePattern' System.Globalization.DateTimeFormatInfo.InvariantInfo); " is 123.
Long Statement,log4net.Appender,RollingFileAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\RollingFileAppender.cs,ExistingInit,The length of the statement  "						LogLog.Debug(declaringType' "Output file ["+fileName+"] already exists. MaxSizeRollBackups is 0; cannot roll. Overwriting existing file."); " is 139.
Long Statement,log4net.Appender,RollingFileAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\RollingFileAppender.cs,ExistingInit,The length of the statement  "						LogLog.Debug(declaringType' "Output file ["+fileName+"] already exists. Not appending to file. Rolling existing file out of the way."); " is 135.
Long Statement,log4net.Appender,RollingFileAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\RollingFileAppender.cs,InitializeFromOneFile,The length of the statement  "				if (! curFileName.StartsWith(CombinePath(baseFile' m_dateTime.Now.ToString(m_datePattern' System.Globalization.DateTimeFormatInfo.InvariantInfo)))) " is 147.
Long Statement,log4net.Appender,RollingFileAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\RollingFileAppender.cs,ComputeCheckPeriod,The length of the statement  "				string r1 = NextCheckDate(s_date1970' (RollPoint)i).ToString(datePattern' System.Globalization.DateTimeFormatInfo.InvariantInfo); " is 129.
Long Statement,log4net.Appender,RollingFileAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\RollingFileAppender.cs,ActivateOptions,The length of the statement  "                m_scheduledFilename = CombinePath(File' m_now.ToString(m_datePattern' System.Globalization.DateTimeFormatInfo.InvariantInfo)); " is 126.
Long Statement,log4net.Appender,RollingFileAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\RollingFileAppender.cs,RollOverTime,The length of the statement  "            m_scheduledFilename = CombinePath(File' m_now.ToString(m_datePattern' System.Globalization.DateTimeFormatInfo.InvariantInfo)); " is 126.
Long Statement,log4net.Appender,RollingFileAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\RollingFileAppender.cs,RollFile,The length of the statement  "					ErrorHandler.Error("Exception while rolling file [" + fromFile + "] -> [" + toFile + "]"' moveEx' ErrorCode.GenericFailure); " is 124.
Long Statement,log4net.Appender,RollingFileAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\RollingFileAppender.cs,DeleteFile,The length of the statement  "					LogLog.Debug(declaringType' "Exception while moving file to be deleted [" + fileName + "] -> [" + tempFileName + "]"' moveEx); " is 126.
Long Statement,log4net.Appender,SmtpAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\SmtpAppender.cs,SendEmail,The length of the statement  "                    // 'ReplyTo is obsoleted for this type.  Please use ReplyToList instead which can accept multiple addresses. http://go.microsoft.com/fwlink/?linkid=14202' " is 154.
Long Statement,log4net.Appender,SmtpAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\SmtpAppender.cs,SendEmail,The length of the statement  "					ErrorHandler.Error("SmtpAppender: Authentication and server Port are only supported when running on the MS .NET 1.1 framework"' missingMethodException); " is 152.
Long Statement,log4net.Appender,SmtpAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\SmtpAppender.cs,SendEmail,The length of the statement  "					ErrorHandler.Error("SmtpAppender: Authentication is only supported on the MS .NET 1.1 or MS .NET 2.0 builds of log4net"); " is 121.
Long Statement,log4net.Config,BasicConfigurator,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Config\BasicConfigurator.cs,InternalConfigure,The length of the statement  "                LogLog.Warn(declaringType' "BasicConfigurator: Repository [" + repository + "] does not support the BasicConfigurator"); " is 120.
Long Statement,log4net.Config,XmlConfigurator,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Config\XmlConfigurator.cs,InternalConfigure,The length of the statement  "					LogLog.Error(declaringType' "Failed to find configuration section 'log4net' in the application's .config file. Check your .config file for the <log4net> and <configSections> elements. The configuration section should look like: <section name=\"log4net\" type=\"log4net.Config.Log4NetConfigurationSectionHandler'log4net\" />"); " is 326.
Long Statement,log4net.Config,XmlConfigurator,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Config\XmlConfigurator.cs,InternalConfigure,The length of the statement  "					string configSectionStr = "<section name=\"log4net\" type=\"log4net.Config.Log4NetConfigurationSectionHandler'" + Assembly.GetExecutingAssembly().FullName + "\" />"; " is 165.
Long Statement,log4net.Config,XmlConfigurator,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Config\XmlConfigurator.cs,InternalConfigure,The length of the statement  "					LogLog.Error(declaringType' "Failed to parse config file. Is the <configSections> specified as: " + configSectionStr' confEx); " is 126.
Long Statement,log4net.Config,XmlConfigurator,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Config\XmlConfigurator.cs,InternalConfigure,The length of the statement  "						LogLog.Error(declaringType' "XML configuration contains [" + configNodeList.Count + "] <log4net> elements. Only one is allowed. Configuration Aborted."); " is 153.
Long Statement,log4net.Config,XmlConfigurator,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Config\XmlConfigurator.cs,InternalConfigureAndWatch,The length of the statement  "			LogLog.Debug(declaringType' "configuring repository [" + repository.Name + "] using file [" + configFile + "] watching for file updates"); " is 138.
Long Statement,log4net.Config,XmlConfiguratorAttribute,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Config\XmlConfiguratorAttribute.cs,ConfigureFromFile,The length of the statement  "						LogLog.Error(declaringType' "XmlConfiguratorAttribute: Exception getting ConfigurationFileLocation. Must be able to resolve ConfigurationFileLocation when ConfigFile and ConfigFileExtension properties are not set."' ex); " is 220.
Long Statement,log4net.Config,XmlConfiguratorAttribute,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Config\XmlConfiguratorAttribute.cs,ConfigureFromFile,The length of the statement  "						LogLog.Error(declaringType' "Exception getting ApplicationBaseDirectory. Must be able to resolve ApplicationBaseDirectory and AssemblyFileName when ConfigFileExtension property is set."' ex); " is 191.
Long Statement,log4net.Config,XmlConfiguratorAttribute,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Config\XmlConfiguratorAttribute.cs,ConfigureFromFile,The length of the statement  "						fullPath2ConfigFile = Path.Combine(applicationBaseDirectory' SystemInfo.AssemblyFileName(sourceAssembly) + m_configFileExtension); " is 130.
Long Statement,log4net.Config,XmlConfiguratorAttribute,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Config\XmlConfiguratorAttribute.cs,ConfigureFromFile,The length of the statement  "					LogLog.Warn(declaringType' "Exception getting ApplicationBaseDirectory. ConfigFile property path ["+m_configFile+"] will be treated as an absolute path."' ex); " is 159.
Long Statement,log4net.Config,XmlConfiguratorAttribute,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Config\XmlConfiguratorAttribute.cs,ConfigureFromUri,The length of the statement  "						LogLog.Error(declaringType' "XmlConfiguratorAttribute: Exception getting ConfigurationFileLocation. Must be able to resolve ConfigurationFileLocation when ConfigFile and ConfigFileExtension properties are not set."' ex); " is 220.
Long Statement,log4net.Config,XmlConfiguratorAttribute,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Config\XmlConfiguratorAttribute.cs,ConfigureFromUri,The length of the statement  "						LogLog.Error(declaringType' "XmlConfiguratorAttribute: Exception getting ConfigurationFileLocation. Must be able to resolve ConfigurationFileLocation when the ConfigFile property are not set."' ex); " is 198.
Long Statement,log4net.Config,XmlConfiguratorAttribute,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Config\XmlConfiguratorAttribute.cs,ConfigureFromUri,The length of the statement  "					LogLog.Warn(declaringType' "Exception getting ApplicationBaseDirectory. ConfigFile property path ["+m_configFile+"] will be treated as an absolute URI."' ex); " is 158.
Long Statement,log4net.Core,DefaultRepositorySelector,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\DefaultRepositorySelector.cs,CreateRepository,The length of the statement  "					LogLog.Debug(declaringType' "Assembly [" + repositoryAssembly + "] using repository [" + actualRepositoryName + "] and repository type [" + actualRepositoryType + "]"); " is 168.
Long Statement,log4net.Core,DefaultRepositorySelector,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\DefaultRepositorySelector.cs,CreateRepository,The length of the statement  "								LogLog.Error(declaringType' "Failed to configure repository [" + actualRepositoryName + "] from assembly attributes."' ex); " is 123.
Long Statement,log4net.Core,DefaultRepositorySelector,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\DefaultRepositorySelector.cs,CreateRepository,The length of the statement  "						LogLog.Debug(declaringType' "repository [" + actualRepositoryName + "] already exists' using repository type [" + rep.GetType().FullName + "]"); " is 144.
Long Statement,log4net.Core,DefaultRepositorySelector,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\DefaultRepositorySelector.cs,CreateRepository,The length of the statement  "								LogLog.Error(declaringType' "Failed to configure repository [" + actualRepositoryName + "] from assembly attributes."' ex); " is 123.
Long Statement,log4net.Core,DefaultRepositorySelector,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\DefaultRepositorySelector.cs,CreateRepository,The length of the statement  "							LogLog.Debug(declaringType' "Aliasing repository [" + repositoryName + "] to existing repository [" + aliasedRepository.Name + "]"); " is 132.
Long Statement,log4net.Core,DefaultRepositorySelector,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\DefaultRepositorySelector.cs,CreateRepository,The length of the statement  "							LogLog.Error(declaringType' "Failed to alias repository [" + repositoryName + "] to existing repository ["+aliasedRepository.Name+"]. Requested repository type ["+repositoryType.FullName+"] is not compatible with existing type [" + aliasedRepository.GetType().FullName + "]"); " is 276.
Long Statement,log4net.Core,DefaultRepositorySelector,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\DefaultRepositorySelector.cs,AliasRepository,The length of the statement  "						throw new InvalidOperationException("Repository [" + repositoryAlias + "] is already aliased to repository [" + ((ILoggerRepository)m_alias2repositoryMap[repositoryAlias]).Name + "]. Aliases cannot be redefined."); " is 214.
Long Statement,log4net.Core,DefaultRepositorySelector,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\DefaultRepositorySelector.cs,AliasRepository,The length of the statement  "						throw new InvalidOperationException("Repository [" + repositoryAlias + "] already exists and cannot be aliased to repository [" + repositoryTarget.Name + "]."); " is 160.
Long Statement,log4net.Core,DefaultRepositorySelector,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\DefaultRepositorySelector.cs,GetInfoForAssembly,The length of the statement  "				LogLog.Debug(declaringType' "Assembly [" + assembly.FullName + "] Loaded From [" + SystemInfo.AssemblyLocationInfo(assembly) + "]"); " is 132.
Long Statement,log4net.Core,DefaultRepositorySelector,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\DefaultRepositorySelector.cs,GetInfoForAssembly,The length of the statement  "				object[] repositoryAttributes = Attribute.GetCustomAttributes(assembly' typeof(log4net.Config.RepositoryAttribute)' false); " is 123.
Long Statement,log4net.Core,DefaultRepositorySelector,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\DefaultRepositorySelector.cs,GetInfoForAssembly,The length of the statement  "						LogLog.Error(declaringType' "Assembly [" + assembly + "] has multiple log4net.Config.RepositoryAttribute assembly attributes. Only using first occurrence."); " is 157.
Long Statement,log4net.Core,DefaultRepositorySelector,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\DefaultRepositorySelector.cs,GetInfoForAssembly,The length of the statement  "								LogLog.Error(declaringType' "DefaultRepositorySelector: Repository Type [" + domAttr.RepositoryType + "] must implement the ILoggerRepository interface."); " is 155.
Long Statement,log4net.Core,DefaultRepositorySelector,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\DefaultRepositorySelector.cs,ConfigureRepository,The length of the statement  "			object[] configAttributes = Attribute.GetCustomAttributes(assembly' typeof(log4net.Config.ConfiguratorAttribute)' false); " is 121.
Long Statement,log4net.Core,DefaultRepositorySelector,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\DefaultRepositorySelector.cs,ConfigureRepository,The length of the statement  "						LogLog.Warn(declaringType' "Exception getting ApplicationBaseDirectory. appSettings log4net.Config path ["+repositoryConfigFile+"] will be treated as an absolute URI"' ex); " is 172.
Long Statement,log4net.Core,DefaultRepositorySelector,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\DefaultRepositorySelector.cs,ConfigureRepository,The length of the statement  "                            LogLog.Error(declaringType' "DefaultRepositorySelector: Exception while parsing log4net.Config file physical path [" + repositoryConfigFilePath + "]"' ex); " is 155.
Long Statement,log4net.Core,DefaultRepositorySelector,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\DefaultRepositorySelector.cs,ConfigureRepository,The length of the statement  "                            LogLog.Debug(declaringType' "Loading and watching configuration for default repository from AppSettings specified Config path [" + repositoryConfigFilePath + "]"); " is 163.
Long Statement,log4net.Core,DefaultRepositorySelector,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\DefaultRepositorySelector.cs,ConfigureRepository,The length of the statement  "                            LogLog.Error(declaringType' "DefaultRepositorySelector: Exception calling XmlConfigurator.ConfigureAndWatch method with ConfigFilePath [" + repositoryConfigFilePath + "]"' ex); " is 176.
Long Statement,log4net.Core,DefaultRepositorySelector,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\DefaultRepositorySelector.cs,ConfigureRepository,The length of the statement  "						LogLog.Debug(declaringType' "Loading configuration for default repository from AppSettings specified Config URI ["+repositoryConfigUri.ToString()+"]"); " is 151.
Long Statement,log4net.Core,DefaultRepositorySelector,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\DefaultRepositorySelector.cs,ConfigureRepository,The length of the statement  "							LogLog.Error(declaringType' "Exception calling XmlConfigurator.Configure method with ConfigUri ["+repositoryConfigUri+"]"' ex); " is 127.
Long Statement,log4net.Core,DefaultRepositorySelector,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\DefaultRepositorySelector.cs,LoadAliases,The length of the statement  "			object[] configAttributes = Attribute.GetCustomAttributes(assembly' typeof(log4net.Config.AliasRepositoryAttribute)' false); " is 124.
Long Statement,log4net.Core,LevelCollection,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\LevelCollection.cs,Remove,The length of the statement  "				throw new System.ArgumentException("Cannot remove the specified item because it was not found in the specified Collection."); " is 125.
Long Statement,log4net.Core,LevelCollection,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\LevelCollection.cs,ValidateIndex,The length of the statement  "				throw log4net.Util.SystemInfo.CreateArgumentOutOfRangeException("i"' (object)i' "Index was out of range. Must be non-negative and less than the size of the collection. [" + (object)i + "] Specified argument was out of the range of valid values."); " is 247.
Long Statement,log4net.Core,LevelMap,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\LevelMap.cs,Add,The length of the statement  "				throw log4net.Util.SystemInfo.CreateArgumentOutOfRangeException("name"' name' "Parameter: name' Value: ["+name+"] out of range. Level name must not be empty"); " is 159.
Long Statement,log4net.Core,LogImpl,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\LogImpl.cs,DebugFormat,The length of the statement  "				Logger.Log(ThisDeclaringType' m_levelDebug' new SystemStringFormat(CultureInfo.InvariantCulture' format' new object[] { arg0 })' null); " is 135.
Long Statement,log4net.Core,LogImpl,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\LogImpl.cs,DebugFormat,The length of the statement  "				Logger.Log(ThisDeclaringType' m_levelDebug' new SystemStringFormat(CultureInfo.InvariantCulture' format' new object[] { arg0' arg1 })' null); " is 141.
Long Statement,log4net.Core,LogImpl,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\LogImpl.cs,DebugFormat,The length of the statement  "				Logger.Log(ThisDeclaringType' m_levelDebug' new SystemStringFormat(CultureInfo.InvariantCulture' format' new object[] { arg0' arg1' arg2 })' null); " is 147.
Long Statement,log4net.Core,LogImpl,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\LogImpl.cs,InfoFormat,The length of the statement  "				Logger.Log(ThisDeclaringType' m_levelInfo' new SystemStringFormat(CultureInfo.InvariantCulture' format' new object[] { arg0 })' null); " is 134.
Long Statement,log4net.Core,LogImpl,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\LogImpl.cs,InfoFormat,The length of the statement  "				Logger.Log(ThisDeclaringType' m_levelInfo' new SystemStringFormat(CultureInfo.InvariantCulture' format' new object[] { arg0' arg1 })' null); " is 140.
Long Statement,log4net.Core,LogImpl,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\LogImpl.cs,InfoFormat,The length of the statement  "				Logger.Log(ThisDeclaringType' m_levelInfo' new SystemStringFormat(CultureInfo.InvariantCulture' format' new object[] { arg0' arg1' arg2 })' null); " is 146.
Long Statement,log4net.Core,LogImpl,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\LogImpl.cs,WarnFormat,The length of the statement  "				Logger.Log(ThisDeclaringType' m_levelWarn' new SystemStringFormat(CultureInfo.InvariantCulture' format' new object[] { arg0 })' null); " is 134.
Long Statement,log4net.Core,LogImpl,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\LogImpl.cs,WarnFormat,The length of the statement  "				Logger.Log(ThisDeclaringType' m_levelWarn' new SystemStringFormat(CultureInfo.InvariantCulture' format' new object[] { arg0' arg1 })' null); " is 140.
Long Statement,log4net.Core,LogImpl,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\LogImpl.cs,WarnFormat,The length of the statement  "				Logger.Log(ThisDeclaringType' m_levelWarn' new SystemStringFormat(CultureInfo.InvariantCulture' format' new object[] { arg0' arg1' arg2 })' null); " is 146.
Long Statement,log4net.Core,LogImpl,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\LogImpl.cs,ErrorFormat,The length of the statement  "				Logger.Log(ThisDeclaringType' m_levelError' new SystemStringFormat(CultureInfo.InvariantCulture' format' new object[] { arg0 })' null); " is 135.
Long Statement,log4net.Core,LogImpl,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\LogImpl.cs,ErrorFormat,The length of the statement  "				Logger.Log(ThisDeclaringType' m_levelError' new SystemStringFormat(CultureInfo.InvariantCulture' format' new object[] { arg0' arg1 })' null); " is 141.
Long Statement,log4net.Core,LogImpl,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\LogImpl.cs,ErrorFormat,The length of the statement  "				Logger.Log(ThisDeclaringType' m_levelError' new SystemStringFormat(CultureInfo.InvariantCulture' format' new object[] { arg0' arg1' arg2 })' null); " is 147.
Long Statement,log4net.Core,LogImpl,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\LogImpl.cs,FatalFormat,The length of the statement  "				Logger.Log(ThisDeclaringType' m_levelFatal' new SystemStringFormat(CultureInfo.InvariantCulture' format' new object[] { arg0 })' null); " is 135.
Long Statement,log4net.Core,LogImpl,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\LogImpl.cs,FatalFormat,The length of the statement  "				Logger.Log(ThisDeclaringType' m_levelFatal' new SystemStringFormat(CultureInfo.InvariantCulture' format' new object[] { arg0' arg1 })' null); " is 141.
Long Statement,log4net.Core,LogImpl,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\LogImpl.cs,FatalFormat,The length of the statement  "				Logger.Log(ThisDeclaringType' m_levelFatal' new SystemStringFormat(CultureInfo.InvariantCulture' format' new object[] { arg0' arg1' arg2 })' null); " is 147.
Long Statement,log4net.Layout,PatternLayout,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Layout\PatternLayout.cs,AddConverter,The length of the statement  "                throw new ArgumentException("The converter type specified [" + converterInfo.Type + "] must be a subclass of log4net.Util.PatternConverter"' "converterInfo"); " is 158.
Long Statement,log4net.Layout,XmlLayout,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Layout\XmlLayout.cs,FormatXml,The length of the statement  "			writer.WriteAttributeString(ATTR_TIMESTAMP' XmlConvert.ToString(loggingEvent.TimeStamp' XmlDateTimeSerializationMode.Local)); " is 125.
Long Statement,log4net.Layout,XmlLayout,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Layout\XmlLayout.cs,FormatXml,The length of the statement  "					writer.WriteAttributeString(ATTR_NAME' Transform.MaskXmlInvalidCharacters((string)entry.Key'this.InvalidCharReplacement)); " is 122.
Long Statement,log4net.Layout,XmlLayout,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Layout\XmlLayout.cs,FormatXml,The length of the statement  "						valueStr = Transform.MaskXmlInvalidCharacters(loggingEvent.Repository.RendererMap.FindAndRender(entry.Value)'this.InvalidCharReplacement); " is 138.
Long Statement,log4net.Layout.Pattern,DatePatternConverter,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Layout\Pattern\DatePatternConverter.cs,ActivateOptions,The length of the statement  "			if (string.Compare(dateFormatStr' AbsoluteTimeDateFormatter.Iso8601TimeDateFormat' true' System.Globalization.CultureInfo.InvariantCulture) == 0)  " is 145.
Long Statement,log4net.Layout.Pattern,DatePatternConverter,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Layout\Pattern\DatePatternConverter.cs,ActivateOptions,The length of the statement  "			else if (string.Compare(dateFormatStr' AbsoluteTimeDateFormatter.AbsoluteTimeDateFormat' true' System.Globalization.CultureInfo.InvariantCulture) == 0) " is 151.
Long Statement,log4net.Layout.Pattern,DatePatternConverter,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Layout\Pattern\DatePatternConverter.cs,ActivateOptions,The length of the statement  "			else if (string.Compare(dateFormatStr' AbsoluteTimeDateFormatter.DateAndTimeDateFormat' true' System.Globalization.CultureInfo.InvariantCulture) == 0) " is 150.
Long Statement,log4net.Layout.Pattern,RelativeTimePatternConverter,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Layout\Pattern\RelativeTimePatternConverter.cs,Convert,The length of the statement  "			writer.Write( TimeDifferenceInMillis(LoggingEvent.StartTime' loggingEvent.TimeStamp).ToString(System.Globalization.NumberFormatInfo.InvariantInfo) ); " is 149.
Long Statement,log4net.Layout.Pattern,StackTracePatternConverter,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Layout\Pattern\StackTracePatternConverter.cs,ActivateOptions,The length of the statement  "						LogLog.Error(declaringType' "StackTracePatternConverter: StackeFrameLevel option (" + optStr + ") isn't a positive integer."); " is 126.
Long Statement,log4net.Layout.Pattern,StackTracePatternConverter,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Layout\Pattern\StackTracePatternConverter.cs,ActivateOptions,The length of the statement  "					LogLog.Error(declaringType' "StackTracePatternConverter: StackFrameLevel option \"" + optStr + "\" not a decimal integer."); " is 124.
Long Statement,log4net.Plugin,PluginCollection,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Plugin\PluginCollection.cs,Remove,The length of the statement  "				throw new System.ArgumentException("Cannot remove the specified item because it was not found in the specified Collection."); " is 125.
Long Statement,log4net.Plugin,PluginCollection,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Plugin\PluginCollection.cs,ValidateIndex,The length of the statement  "				throw log4net.Util.SystemInfo.CreateArgumentOutOfRangeException("i"' (object)i' "Index was out of range. Must be non-negative and less than the size of the collection. [" + (object)i + "] Specified argument was out of the range of valid values."); " is 247.
Long Statement,log4net.Repository.Hierarchy,Hierarchy,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Repository\Hierarchy\Hierarchy.cs,AddLevel,The length of the statement  "					throw new InvalidOperationException("Cannot redefine level ["+levelEntry.Name+"] because it is not defined in the LevelMap. To define the level supply the level value."); " is 170.
Long Statement,log4net.Repository.Hierarchy,Logger,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Repository\Hierarchy\Logger.cs,Log,The length of the statement  "                    ForcedLog((callerStackBoundaryDeclaringType != null) ? callerStackBoundaryDeclaringType : declaringType' level' message' exception); " is 132.
Long Statement,log4net.Repository.Hierarchy,Logger,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Repository\Hierarchy\Logger.cs,CallAppenders,The length of the statement  "				LogLog.Debug(declaringType' "No appenders could be found for logger [" + Name + "] repository [" + Repository.Name + "]"); " is 122.
Long Statement,log4net.Repository.Hierarchy,Logger,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Repository\Hierarchy\Logger.cs,ForcedLog,The length of the statement  "			CallAppenders(new LoggingEvent(callerStackBoundaryDeclaringType' this.Hierarchy' this.Name' level' message' exception)); " is 120.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,Configure,The length of the statement  "					configUpdateMode = (ConfigUpdateMode)OptionConverter.ConvertStringTo(typeof(ConfigUpdateMode)' configUpdateModeAttribute); " is 122.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,Configure,The length of the statement  "					LogLog.Error(declaringType' "Invalid " + CONFIG_UPDATE_MODE_ATTR + " attribute value [" + configUpdateModeAttribute + "]"); " is 123.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,Configure,The length of the statement  "					LogLog.Warn(declaringType' "Unable to set hierarchy threshold using value [" + thresholdStr + "] (with acceptable conversion types)"); " is 134.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,ParseAppender,The length of the statement  "								LogLog.Error(declaringType' "Requesting attachment of appender named ["+refName+ "] to appender named [" + appender.Name + "] which does not implement log4net.Core.IAppenderAttachable."); " is 187.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,ParseAppender,The length of the statement  "				LogLog.Error(declaringType' "Could not create Appender [" + appenderName + "] of type [" + typeName + "]. Reported error follows."' ex); " is 136.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,ParseRenderer,The length of the statement  "			LogLog.Debug(declaringType' "Rendering class [" + renderingClassName + "]' Rendered class [" + renderedClassName + "]."); " is 121.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,ParseRenderer,The length of the statement  "			IObjectRenderer renderer = (IObjectRenderer)OptionConverter.InstantiateByClassName(renderingClassName' typeof(IObjectRenderer)' null); " is 134.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,ParseLevel,The length of the statement  "					LogLog.Debug(declaringType' "Logger [" + loggerName + "] level set to [name=\"" + log.Level.Name + "\"'value=" + log.Level.Value + "].");	 " is 137.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,SetParameter,The length of the statement  "			propInfo = targetType.GetProperty(name' BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.IgnoreCase); " is 136.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,SetParameter,The length of the statement  "				LogLog.Error(declaringType' "XmlHierarchyConfigurator: Cannot find Property [" + name + "] to set object on [" + target.ToString() + "]"); " is 138.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,SetParameter,The length of the statement  "						LogLog.Debug(declaringType' "Security exception while trying to expand environment variables. Error Ignored. No Expansion."); " is 125.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,SetParameter,The length of the statement  "									LogLog.Error(declaringType' "subtype ["+subType.FullName+"] set on ["+name+"] is not a subclass of property type ["+propertyType.FullName+"] and there are no acceptable type conversions."); " is 189.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,SetParameter,The length of the statement  "						LogLog.Debug(declaringType' "Performing additional conversion of value from [" + convertedValue.GetType().Name + "] to [" + parsedObjectConversionTargetType.Name + "]"); " is 169.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,SetParameter,The length of the statement  "							LogLog.Debug(declaringType' "Setting Property [" + propInfo.Name + "] to " + convertedValue.GetType().Name + " value [" + convertedValue.ToString() + "]"); " is 155.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,SetParameter,The length of the statement  "								LogLog.Error(declaringType' "Failed to set parameter [" + propInfo.Name + "] on object [" + target + "] using value [" + convertedValue + "]"' targetInvocationEx.InnerException); " is 178.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,SetParameter,The length of the statement  "							LogLog.Debug(declaringType' "Setting Collection Property [" + methInfo.Name + "] to " + convertedValue.GetType().Name + " value [" + convertedValue.ToString() + "]"); " is 166.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,SetParameter,The length of the statement  "								LogLog.Error(declaringType' "Failed to set parameter [" + name + "] on object [" + target + "] using value [" + convertedValue + "]"' targetInvocationEx.InnerException); " is 169.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,SetParameter,The length of the statement  "						LogLog.Warn(declaringType' "Unable to set property [" + name + "] on object [" + target + "] using value [" + propertyValue + "] (with acceptable conversion types)"); " is 166.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,SetParameter,The length of the statement  "								LogLog.Error(declaringType' "Failed to set parameter [" + propInfo.Name + "] on object [" + target + "] using value [" + createdObject + "]"' targetInvocationEx.InnerException); " is 177.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,SetParameter,The length of the statement  "								LogLog.Error(declaringType' "Failed to set parameter [" + methInfo.Name + "] on object [" + target + "] using value [" + createdObject + "]"' targetInvocationEx.InnerException); " is 177.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,CreateObjectFromXml,The length of the statement  "					LogLog.Error(declaringType' "Object type not specified. Cannot create object of type ["+typeConstraint.FullName+"]. Missing Value or Type."); " is 141.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,CreateObjectFromXml,The length of the statement  "						LogLog.Error(declaringType' "Object type ["+objectType.FullName+"] is not assignable to type ["+typeConstraint.FullName+"]. There are no acceptable type conversions."); " is 168.
Long Statement,log4net.Repository.Hierarchy,XmlHierarchyConfigurator,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Repository\Hierarchy\XmlHierarchyConfigurator.cs,CreateObjectFromXml,The length of the statement  "				LogLog.Error(declaringType' "XmlHierarchyConfigurator: Failed to construct object of type [" + objectType.FullName + "] Exception: "+createInstanceEx.ToString()); " is 162.
Long Statement,log4net.Util,LogicalThreadContextProperties,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\LogicalThreadContextProperties.cs,GetProperties,The length of the statement  "					LogLog.Warn(declaringType' "SecurityException while accessing CallContext. Disabling LogicalThreadContextProperties"' secEx); " is 125.
Long Statement,log4net.Util,NativeError,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\NativeError.cs,GetErrorMessage,The length of the statement  "			int FORMAT_MESSAGE_ALLOCATE_BUFFER = 0x00000100;	// The function should allocates a buffer large enough to hold the formatted message " is 133.
Long Statement,log4net.Util,NativeError,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\NativeError.cs,GetErrorMessage,The length of the statement  "			int FORMAT_MESSAGE_FROM_SYSTEM  = 0x00001000;		// The function should search the system message-table resource(s) for the requested message " is 139.
Long Statement,log4net.Util,NativeError,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\NativeError.cs,GetErrorMessage,The length of the statement  "				// If the function succeeds' the return value is the number of TCHARs stored in the output buffer' excluding the terminating null character " is 139.
Long Statement,log4net.Util,NativeError,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\NativeError.cs,ToString,The length of the statement  "			return string.Format(CultureInfo.InvariantCulture' "0x{0:x8}"' this.Number) + (this.Message != null ? ": " + this.Message : ""); " is 128.
Long Statement,log4net.Util,OptionConverter,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\OptionConverter.cs,ConvertTypeTo,The length of the statement  "			throw new ArgumentException("Cannot convert source object [" + sourceInstance.ToString() + "] to target type [" + targetType.Name + "]"' "sourceInstance"); " is 155.
Long Statement,log4net.Util,OptionConverter,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\OptionConverter.cs,InstantiateByClassName,The length of the statement  "						LogLog.Error(declaringType' "OptionConverter: A [" + className + "] object is not assignable to a [" + superClass.FullName + "] variable."); " is 140.
Long Statement,log4net.Util,PatternParser,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\PatternParser.cs,ParseInternal,The length of the statement  "							formattingInfo.Min = (formattingInfo.Min * 10) + int.Parse(pattern[offset].ToString(CultureInfo.InvariantCulture)' System.Globalization.NumberFormatInfo.InvariantInfo); " is 168.
Long Statement,log4net.Util,PatternParser,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\PatternParser.cs,ParseInternal,The length of the statement  "							formattingInfo.Max = (formattingInfo.Max * 10) + int.Parse(pattern[offset].ToString(CultureInfo.InvariantCulture)' System.Globalization.NumberFormatInfo.InvariantInfo); " is 168.
Long Statement,log4net.Util,PatternParser,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\PatternParser.cs,ParseInternal,The length of the statement  "								if (String.Compare(pattern' offset' matches[m]' 0' matches[m].Length' false' System.Globalization.CultureInfo.InvariantCulture) == 0) " is 133.
Long Statement,log4net.Util,PatternParser,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\PatternParser.cs,ProcessConverter,The length of the statement  "			LogLog.Debug(declaringType' "Converter ["+converterName+"] Option ["+option+"] Format [min="+formattingInfo.Min+"'max="+formattingInfo.Max+"'leftAlign="+formattingInfo.LeftAlign+"]"); " is 183.
Long Statement,log4net.Util,PatternParser,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\PatternParser.cs,ProcessConverter,The length of the statement  "                    LogLog.Error(declaringType' "Failed to create instance of Type [" + converterInfo.Type.FullName + "] using default constructor. Exception: " + createInstanceEx.ToString()); " is 172.
Long Statement,log4net.Util,PatternString,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\PatternString.cs,AddConverter,The length of the statement  "                throw new ArgumentException("The converter type specified [" + converterInfo.Type + "] must be a subclass of log4net.Util.PatternConverter"' "converterInfo"); " is 158.
Long Statement,log4net.Util,SystemInfo,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\SystemInfo.cs,GetTypeFromString,The length of the statement  "							LogLog.Debug(declaringType' "Loaded type ["+typeName+"] from assembly ["+assembly.FullName+"] by searching loaded assemblies."); " is 128.
Long Statement,log4net.Util,SystemInfo,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\SystemInfo.cs,GetTypeFromString,The length of the statement  "					throw new TypeLoadException("Could not load type ["+typeName+"]. Tried assembly ["+relativeAssembly.FullName+"] and all loaded assemblies"); " is 140.
Long Statement,log4net.Util,SystemInfo,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\SystemInfo.cs,TryParse,The length of the statement  "				if (Double.TryParse(s' System.Globalization.NumberStyles.Integer' System.Globalization.CultureInfo.InvariantCulture' out doubleVal)) " is 132.
Long Statement,log4net.Util,SystemInfo,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\SystemInfo.cs,TryParse,The length of the statement  "				if (Double.TryParse(s' System.Globalization.NumberStyles.Integer' System.Globalization.CultureInfo.InvariantCulture' out doubleVal)) " is 132.
Long Statement,log4net.Util,SystemInfo,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\SystemInfo.cs,TryParse,The length of the statement  "                if (Double.TryParse(s' System.Globalization.NumberStyles.Integer' System.Globalization.CultureInfo.InvariantCulture' out doubleVal)) " is 132.
Long Statement,log4net.Util,SystemInfo,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\SystemInfo.cs,GetAppSetting,The length of the statement  "				LogLog.Error(declaringType' "Exception while reading ConfigurationSettings. Check your .config file is well formed XML."' ex); " is 126.
Long Statement,log4net.Util,Transform,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\Transform.cs,WriteEscapedXmlString,The length of the statement  "			int weightStringEscapes = 3*(CountSubstrings(stringData' "<") + CountSubstrings(stringData' ">")) + 4*CountSubstrings(stringData' "&"); " is 135.
Long Statement,log4net.Util.PatternStringConverters,DatePatternConverter,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\PatternStringConverters\DatePatternConverter.cs,ActivateOptions,The length of the statement  "			if (string.Compare(dateFormatStr' AbsoluteTimeDateFormatter.Iso8601TimeDateFormat' true' System.Globalization.CultureInfo.InvariantCulture) == 0)  " is 145.
Long Statement,log4net.Util.PatternStringConverters,DatePatternConverter,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\PatternStringConverters\DatePatternConverter.cs,ActivateOptions,The length of the statement  "			else if (string.Compare(dateFormatStr' AbsoluteTimeDateFormatter.AbsoluteTimeDateFormat' true' System.Globalization.CultureInfo.InvariantCulture) == 0) " is 151.
Long Statement,log4net.Util.PatternStringConverters,DatePatternConverter,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\PatternStringConverters\DatePatternConverter.cs,ActivateOptions,The length of the statement  "			else if (string.Compare(dateFormatStr' AbsoluteTimeDateFormatter.DateAndTimeDateFormat' true' System.Globalization.CultureInfo.InvariantCulture) == 0) " is 150.
Long Statement,log4net.Util.PatternStringConverters,EnvironmentFolderPathPatternConverter,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\PatternStringConverters\EnvironmentFolderPathPatternConverter.cs,Convert,The length of the statement  "                LogLog.Debug(declaringType' "Security exception while trying to expand environment variables. Error Ignored. No Expansion."' secEx); " is 132.
Long Statement,log4net.Util.PatternStringConverters,EnvironmentPatternConverter,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\PatternStringConverters\EnvironmentPatternConverter.cs,Convert,The length of the statement  "				LogLog.Debug(declaringType' "Security exception while trying to expand environment variables. Error Ignored. No Expansion."' secEx); " is 132.
Long Statement,log4net.Util.TypeConverters,ConversionNotSupportedException,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\TypeConverters\ConversionNotSupportedException.cs,Create,The length of the statement  "				return new ConversionNotSupportedException("Cannot convert value [null] to type ["+destinationType+"]"' innerException); " is 120.
Long Statement,log4net.Util.TypeConverters,ConversionNotSupportedException,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\TypeConverters\ConversionNotSupportedException.cs,Create,The length of the statement  "				return new ConversionNotSupportedException("Cannot convert from type ["+sourceValue.GetType()+"] value ["+sourceValue+"] to type ["+destinationType+"]"' innerException); " is 169.
Long Statement,log4net.Util.TypeConverters,ConverterRegistry,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\TypeConverters\ConverterRegistry.cs,CreateConverterInstance,The length of the statement  "				throw new ArgumentNullException("converterType"' "CreateConverterInstance cannot create instance' converterType is null"); " is 122.
Long Statement,log4net.Util.TypeConverters,ConverterRegistry,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\TypeConverters\ConverterRegistry.cs,CreateConverterInstance,The length of the statement  "					LogLog.Error(declaringType' "Cannot CreateConverterInstance of type ["+converterType.FullName+"]' Exception in call to Activator.CreateInstance"' ex); " is 150.
Long Statement,log4net.Util.TypeConverters,ConverterRegistry,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\TypeConverters\ConverterRegistry.cs,CreateConverterInstance,The length of the statement  "				LogLog.Error(declaringType' "Cannot CreateConverterInstance of type ["+converterType.FullName+"]' type does not implement IConvertFrom or IConvertTo"); " is 151.
Complex Conditional,log4net.Appender,BufferingAppenderSkeleton,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\BufferingAppenderSkeleton.cs,Append,The conditional expression  "(!m_lossy) ||   					(m_evaluator != null && m_evaluator.IsTriggeringEvent(loggingEvent)) ||   					(m_lossyEvaluator != null && m_lossyEvaluator.IsTriggeringEvent(loggingEvent))"  is complex.
Complex Conditional,log4net.Util.TypeConverters,IPAddressConverter,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\TypeConverters\IPAddressConverter.cs,ConvertFrom,The conditional expression  "host != null &&   						host.AddressList != null &&   						host.AddressList.Length > 0 &&  						host.AddressList[0] != null"  is complex.
Virtual Method Call from Constructor,log4net.Appender,AppenderCollection,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\AppenderCollection.cs,AppenderCollection,The constructor "AppenderCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,log4net.Appender,AppenderCollection,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\AppenderCollection.cs,AppenderCollection,The constructor "AppenderCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,log4net.Appender,AppenderCollection,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\AppenderCollection.cs,AppenderCollection,The constructor "AppenderCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,log4net.Core,LevelCollection,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\LevelCollection.cs,LevelCollection,The constructor "LevelCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,log4net.Core,LevelCollection,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\LevelCollection.cs,LevelCollection,The constructor "LevelCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,log4net.Core,LevelCollection,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\LevelCollection.cs,LevelCollection,The constructor "LevelCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,log4net.Core,LogImpl,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\LogImpl.cs,LogImpl,The constructor "LogImpl" calls a virtual method "ReloadLevels".
Virtual Method Call from Constructor,log4net.Plugin,PluginCollection,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Plugin\PluginCollection.cs,PluginCollection,The constructor "PluginCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,log4net.Plugin,PluginCollection,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Plugin\PluginCollection.cs,PluginCollection,The constructor "PluginCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,log4net.Plugin,PluginCollection,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Plugin\PluginCollection.cs,PluginCollection,The constructor "PluginCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,log4net.Util,PatternString,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\PatternString.cs,PatternString,The constructor "PatternString" calls a virtual method "ActivateOptions".
Empty Catch Block,log4net.Appender,AdoNetAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\AdoNetAppender.cs,SendBuffer,The method has an empty catch block.
Empty Catch Block,log4net.Appender,LocalSyslogAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\LocalSyslogAppender.cs,OnClose,The method has an empty catch block.
Empty Catch Block,log4net.Appender,SocketHandler,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\TelnetAppender.cs,OnConnect,The method has an empty catch block.
Empty Catch Block,log4net.Appender,SocketHandler,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\TelnetAppender.cs,Dispose,The method has an empty catch block.
Empty Catch Block,log4net.Appender,SocketHandler,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\TelnetAppender.cs,Dispose,The method has an empty catch block.
Empty Catch Block,log4net.Appender,SocketClient,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\TelnetAppender.cs,Dispose,The method has an empty catch block.
Empty Catch Block,log4net.Appender,SocketClient,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\TelnetAppender.cs,Dispose,The method has an empty catch block.
Empty Catch Block,log4net.Appender,SocketClient,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\TelnetAppender.cs,Dispose,The method has an empty catch block.
Empty Catch Block,log4net.Config,XmlConfigurator,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Config\XmlConfigurator.cs,InternalConfigure,The method has an empty catch block.
Empty Catch Block,log4net.Config,XmlConfiguratorAttribute,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Config\XmlConfiguratorAttribute.cs,Configure,The method has an empty catch block.
Empty Catch Block,log4net.Core,DefaultRepositorySelector,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\DefaultRepositorySelector.cs,GetInfoForAssembly,The method has an empty catch block.
Empty Catch Block,log4net.ObjectRenderer,RendererMap,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\ObjectRenderer\RendererMap.cs,FindAndRender,The method has an empty catch block.
Empty Catch Block,log4net.Repository.Hierarchy,Logger,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Repository\Hierarchy\Logger.cs,CallAppenders,The method has an empty catch block.
Empty Catch Block,log4net.Util,LogLog,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\LogLog.cs,EmitOutLine,The method has an empty catch block.
Empty Catch Block,log4net.Util,LogLog,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\LogLog.cs,EmitErrorLine,The method has an empty catch block.
Empty Catch Block,log4net.Util,SystemInfo,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\SystemInfo.cs,GetTypeFromString,The method has an empty catch block.
Empty Catch Block,log4net.Util,SystemInfo,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\SystemInfo.cs,TryParse,The method has an empty catch block.
Empty Catch Block,log4net.Util,SystemInfo,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\SystemInfo.cs,TryParse,The method has an empty catch block.
Empty Catch Block,log4net.Util,SystemInfo,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\SystemInfo.cs,TryParse,The method has an empty catch block.
Empty Catch Block,log4net.Util,SystemInfo,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\SystemInfo.cs,ConvertToFullPath,The method has an empty catch block.
Magic Number,log4net.Appender,AnsiColorTerminalAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\AnsiColorTerminalAppender.cs,Append,The following statement contains a magic number: if (loggingMessage.Length > 1)  			{  				if (loggingMessage.EndsWith("\r\n") || loggingMessage.EndsWith("\n\r"))   				{  					loggingMessage = loggingMessage.Insert(loggingMessage.Length - 2' PostEventCodes);  				}   				else if (loggingMessage.EndsWith("\n") || loggingMessage.EndsWith("\r"))   				{  					loggingMessage = loggingMessage.Insert(loggingMessage.Length - 1' PostEventCodes);  				}   				else   				{  					loggingMessage = loggingMessage + PostEventCodes;  				}  			}  			else  			{  				if (loggingMessage[0] == '\n' || loggingMessage[0] == '\r')   				{  					loggingMessage = PostEventCodes + loggingMessage;  				}   				else   				{  					loggingMessage = loggingMessage + PostEventCodes;  				}  			}
Magic Number,log4net.Appender,LevelColors,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\AnsiColorTerminalAppender.cs,ActivateOptions,The following statement contains a magic number: buf.Append(30 + (int)m_foreColor);
Magic Number,log4net.Appender,LevelColors,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\AnsiColorTerminalAppender.cs,ActivateOptions,The following statement contains a magic number: buf.Append(40 + (int)m_backColor);
Magic Number,log4net.Appender,LevelColors,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\AnsiColorTerminalAppender.cs,ActivateOptions,The following statement contains a magic number: m_combinedColor = (ushort)( (int)m_foreColor + (((int)m_backColor) << 4) );
Magic Number,log4net.Appender,AppenderCollection,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\AppenderCollection.cs,EnsureCapacity,The following statement contains a magic number: int newCapacity = ((m_array.Length == 0) ? DEFAULT_CAPACITY : m_array.Length * 2);
Magic Number,log4net.Appender,ColoredConsoleAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\ColoredConsoleAppender.cs,Append,The following statement contains a magic number: if (m_consoleOutputWriter != null)  			{  				IntPtr consoleHandle = IntPtr.Zero;  				if (m_writeToErrorStream)  				{  					// Write to the error stream  					consoleHandle = GetStdHandle(STD_ERROR_HANDLE);  				}  				else  				{  					// Write to the output stream  					consoleHandle = GetStdHandle(STD_OUTPUT_HANDLE);  				}    				// Default to white on black  				ushort colorInfo = (ushort)Colors.White;    				// see if there is a specified lookup  				LevelColors levelColors = m_levelMapping.Lookup(loggingEvent.Level) as LevelColors;  				if (levelColors != null)  				{  					colorInfo = levelColors.CombinedColor;  				}    				// Render the event to a string  				string strLoggingMessage = RenderLoggingEvent(loggingEvent);    				// get the current console color - to restore later  				CONSOLE_SCREEN_BUFFER_INFO bufferInfo;  				GetConsoleScreenBufferInfo(consoleHandle' out bufferInfo);    				// set the console colors  				SetConsoleTextAttribute(consoleHandle' colorInfo);    				// Using WriteConsoleW seems to be unreliable.  				// If a large buffer is written' say 15'000 chars  				// Followed by a larger buffer' say 20'000 chars  				// then WriteConsoleW will fail' last error 8  				// 'Not enough storage is available to process this command.'  				//   				// Although the documentation states that the buffer must  				// be less that 64KB (i.e. 32'000 WCHARs) the longest string  				// that I can write out a the first call to WriteConsoleW  				// is only 30'704 chars.  				//  				// Unlike the WriteFile API the WriteConsoleW method does not   				// seem to be able to partially write out from the input buffer.  				// It does have a lpNumberOfCharsWritten parameter' but this is  				// either the length of the input buffer if any output was written'  				// or 0 when an error occurs.  				//  				// All results above were observed on Windows XP SP1 running  				// .NET runtime 1.1 SP1.  				//  				// Old call to WriteConsoleW:  				//  				// WriteConsoleW(  				//     consoleHandle'  				//     strLoggingMessage'  				//     (UInt32)strLoggingMessage.Length'  				//     out (UInt32)ignoreWrittenCount'  				//     IntPtr.Zero);  				//  				// Instead of calling WriteConsoleW we use WriteFile which   				// handles large buffers correctly. Because WriteFile does not  				// handle the codepage conversion as WriteConsoleW does we   				// need to use a System.IO.StreamWriter with the appropriate  				// Encoding. The WriteFile calls are wrapped up in the  				// System.IO.__ConsoleStream internal class obtained through  				// the System.Console.OpenStandardOutput method.  				//  				// See the ActivateOptions method below for the code that  				// retrieves and wraps the stream.      				// The windows console uses ScrollConsoleScreenBuffer internally to  				// scroll the console buffer when the display buffer of the console  				// has been used up. ScrollConsoleScreenBuffer fills the area uncovered  				// by moving the current content with the background color   				// currently specified on the console. This means that it fills the  				// whole line in front of the cursor position with the current   				// background color.  				// This causes an issue when writing out text with a non default  				// background color. For example; We write a message with a Blue  				// background color and the scrollable area of the console is full.  				// When we write the newline at the end of the message the console  				// needs to scroll the buffer to make space available for the new line.  				// The ScrollConsoleScreenBuffer internals will fill the newly created  				// space with the current background color: Blue.  				// We then change the console color back to default (White text on a  				// Black background). We write some text to the console' the text is  				// written correctly in White with a Black background' however the  				// remainder of the line still has a Blue background.  				//   				// This causes a disjointed appearance to the output where the background  				// colors change.  				//  				// This can be remedied by restoring the console colors before causing  				// the buffer to scroll' i.e. before writing the last newline. This does  				// assume that the rendered message will end with a newline.  				//  				// Therefore we identify a trailing newline in the message and don't  				// write this to the output' then we restore the console color and write  				// a newline. Note that we must AutoFlush before we restore the console  				// color otherwise we will have no effect.  				//  				// There will still be a slight artefact for the last line of the message  				// will have the background extended to the end of the line' however this  				// is unlikely to cause any user issues.  				//  				// Note that none of the above is visible while the console buffer is scrollable  				// within the console window viewport' the effects only arise when the actual  				// buffer is full and needs to be scrolled.    				char[] messageCharArray = strLoggingMessage.ToCharArray();  				int arrayLength = messageCharArray.Length;  				bool appendNewline = false;    				// Trim off last newline' if it exists  				if (arrayLength > 1 && messageCharArray[arrayLength-2] == '\r' && messageCharArray[arrayLength-1] == '\n')  				{  					arrayLength -= 2;  					appendNewline = true;  				}    				// Write to the output stream  				m_consoleOutputWriter.Write(messageCharArray' 0' arrayLength);    				// Restore the console back to its previous color scheme  				SetConsoleTextAttribute(consoleHandle' bufferInfo.wAttributes);    				if (appendNewline)  				{  					// Write the newline' after changing the color scheme  					m_consoleOutputWriter.Write(s_windowsNewline' 0' 2);  				}  			}
Magic Number,log4net.Appender,ColoredConsoleAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\ColoredConsoleAppender.cs,Append,The following statement contains a magic number: if (m_consoleOutputWriter != null)  			{  				IntPtr consoleHandle = IntPtr.Zero;  				if (m_writeToErrorStream)  				{  					// Write to the error stream  					consoleHandle = GetStdHandle(STD_ERROR_HANDLE);  				}  				else  				{  					// Write to the output stream  					consoleHandle = GetStdHandle(STD_OUTPUT_HANDLE);  				}    				// Default to white on black  				ushort colorInfo = (ushort)Colors.White;    				// see if there is a specified lookup  				LevelColors levelColors = m_levelMapping.Lookup(loggingEvent.Level) as LevelColors;  				if (levelColors != null)  				{  					colorInfo = levelColors.CombinedColor;  				}    				// Render the event to a string  				string strLoggingMessage = RenderLoggingEvent(loggingEvent);    				// get the current console color - to restore later  				CONSOLE_SCREEN_BUFFER_INFO bufferInfo;  				GetConsoleScreenBufferInfo(consoleHandle' out bufferInfo);    				// set the console colors  				SetConsoleTextAttribute(consoleHandle' colorInfo);    				// Using WriteConsoleW seems to be unreliable.  				// If a large buffer is written' say 15'000 chars  				// Followed by a larger buffer' say 20'000 chars  				// then WriteConsoleW will fail' last error 8  				// 'Not enough storage is available to process this command.'  				//   				// Although the documentation states that the buffer must  				// be less that 64KB (i.e. 32'000 WCHARs) the longest string  				// that I can write out a the first call to WriteConsoleW  				// is only 30'704 chars.  				//  				// Unlike the WriteFile API the WriteConsoleW method does not   				// seem to be able to partially write out from the input buffer.  				// It does have a lpNumberOfCharsWritten parameter' but this is  				// either the length of the input buffer if any output was written'  				// or 0 when an error occurs.  				//  				// All results above were observed on Windows XP SP1 running  				// .NET runtime 1.1 SP1.  				//  				// Old call to WriteConsoleW:  				//  				// WriteConsoleW(  				//     consoleHandle'  				//     strLoggingMessage'  				//     (UInt32)strLoggingMessage.Length'  				//     out (UInt32)ignoreWrittenCount'  				//     IntPtr.Zero);  				//  				// Instead of calling WriteConsoleW we use WriteFile which   				// handles large buffers correctly. Because WriteFile does not  				// handle the codepage conversion as WriteConsoleW does we   				// need to use a System.IO.StreamWriter with the appropriate  				// Encoding. The WriteFile calls are wrapped up in the  				// System.IO.__ConsoleStream internal class obtained through  				// the System.Console.OpenStandardOutput method.  				//  				// See the ActivateOptions method below for the code that  				// retrieves and wraps the stream.      				// The windows console uses ScrollConsoleScreenBuffer internally to  				// scroll the console buffer when the display buffer of the console  				// has been used up. ScrollConsoleScreenBuffer fills the area uncovered  				// by moving the current content with the background color   				// currently specified on the console. This means that it fills the  				// whole line in front of the cursor position with the current   				// background color.  				// This causes an issue when writing out text with a non default  				// background color. For example; We write a message with a Blue  				// background color and the scrollable area of the console is full.  				// When we write the newline at the end of the message the console  				// needs to scroll the buffer to make space available for the new line.  				// The ScrollConsoleScreenBuffer internals will fill the newly created  				// space with the current background color: Blue.  				// We then change the console color back to default (White text on a  				// Black background). We write some text to the console' the text is  				// written correctly in White with a Black background' however the  				// remainder of the line still has a Blue background.  				//   				// This causes a disjointed appearance to the output where the background  				// colors change.  				//  				// This can be remedied by restoring the console colors before causing  				// the buffer to scroll' i.e. before writing the last newline. This does  				// assume that the rendered message will end with a newline.  				//  				// Therefore we identify a trailing newline in the message and don't  				// write this to the output' then we restore the console color and write  				// a newline. Note that we must AutoFlush before we restore the console  				// color otherwise we will have no effect.  				//  				// There will still be a slight artefact for the last line of the message  				// will have the background extended to the end of the line' however this  				// is unlikely to cause any user issues.  				//  				// Note that none of the above is visible while the console buffer is scrollable  				// within the console window viewport' the effects only arise when the actual  				// buffer is full and needs to be scrolled.    				char[] messageCharArray = strLoggingMessage.ToCharArray();  				int arrayLength = messageCharArray.Length;  				bool appendNewline = false;    				// Trim off last newline' if it exists  				if (arrayLength > 1 && messageCharArray[arrayLength-2] == '\r' && messageCharArray[arrayLength-1] == '\n')  				{  					arrayLength -= 2;  					appendNewline = true;  				}    				// Write to the output stream  				m_consoleOutputWriter.Write(messageCharArray' 0' arrayLength);    				// Restore the console back to its previous color scheme  				SetConsoleTextAttribute(consoleHandle' bufferInfo.wAttributes);    				if (appendNewline)  				{  					// Write the newline' after changing the color scheme  					m_consoleOutputWriter.Write(s_windowsNewline' 0' 2);  				}  			}
Magic Number,log4net.Appender,ColoredConsoleAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\ColoredConsoleAppender.cs,Append,The following statement contains a magic number: if (m_consoleOutputWriter != null)  			{  				IntPtr consoleHandle = IntPtr.Zero;  				if (m_writeToErrorStream)  				{  					// Write to the error stream  					consoleHandle = GetStdHandle(STD_ERROR_HANDLE);  				}  				else  				{  					// Write to the output stream  					consoleHandle = GetStdHandle(STD_OUTPUT_HANDLE);  				}    				// Default to white on black  				ushort colorInfo = (ushort)Colors.White;    				// see if there is a specified lookup  				LevelColors levelColors = m_levelMapping.Lookup(loggingEvent.Level) as LevelColors;  				if (levelColors != null)  				{  					colorInfo = levelColors.CombinedColor;  				}    				// Render the event to a string  				string strLoggingMessage = RenderLoggingEvent(loggingEvent);    				// get the current console color - to restore later  				CONSOLE_SCREEN_BUFFER_INFO bufferInfo;  				GetConsoleScreenBufferInfo(consoleHandle' out bufferInfo);    				// set the console colors  				SetConsoleTextAttribute(consoleHandle' colorInfo);    				// Using WriteConsoleW seems to be unreliable.  				// If a large buffer is written' say 15'000 chars  				// Followed by a larger buffer' say 20'000 chars  				// then WriteConsoleW will fail' last error 8  				// 'Not enough storage is available to process this command.'  				//   				// Although the documentation states that the buffer must  				// be less that 64KB (i.e. 32'000 WCHARs) the longest string  				// that I can write out a the first call to WriteConsoleW  				// is only 30'704 chars.  				//  				// Unlike the WriteFile API the WriteConsoleW method does not   				// seem to be able to partially write out from the input buffer.  				// It does have a lpNumberOfCharsWritten parameter' but this is  				// either the length of the input buffer if any output was written'  				// or 0 when an error occurs.  				//  				// All results above were observed on Windows XP SP1 running  				// .NET runtime 1.1 SP1.  				//  				// Old call to WriteConsoleW:  				//  				// WriteConsoleW(  				//     consoleHandle'  				//     strLoggingMessage'  				//     (UInt32)strLoggingMessage.Length'  				//     out (UInt32)ignoreWrittenCount'  				//     IntPtr.Zero);  				//  				// Instead of calling WriteConsoleW we use WriteFile which   				// handles large buffers correctly. Because WriteFile does not  				// handle the codepage conversion as WriteConsoleW does we   				// need to use a System.IO.StreamWriter with the appropriate  				// Encoding. The WriteFile calls are wrapped up in the  				// System.IO.__ConsoleStream internal class obtained through  				// the System.Console.OpenStandardOutput method.  				//  				// See the ActivateOptions method below for the code that  				// retrieves and wraps the stream.      				// The windows console uses ScrollConsoleScreenBuffer internally to  				// scroll the console buffer when the display buffer of the console  				// has been used up. ScrollConsoleScreenBuffer fills the area uncovered  				// by moving the current content with the background color   				// currently specified on the console. This means that it fills the  				// whole line in front of the cursor position with the current   				// background color.  				// This causes an issue when writing out text with a non default  				// background color. For example; We write a message with a Blue  				// background color and the scrollable area of the console is full.  				// When we write the newline at the end of the message the console  				// needs to scroll the buffer to make space available for the new line.  				// The ScrollConsoleScreenBuffer internals will fill the newly created  				// space with the current background color: Blue.  				// We then change the console color back to default (White text on a  				// Black background). We write some text to the console' the text is  				// written correctly in White with a Black background' however the  				// remainder of the line still has a Blue background.  				//   				// This causes a disjointed appearance to the output where the background  				// colors change.  				//  				// This can be remedied by restoring the console colors before causing  				// the buffer to scroll' i.e. before writing the last newline. This does  				// assume that the rendered message will end with a newline.  				//  				// Therefore we identify a trailing newline in the message and don't  				// write this to the output' then we restore the console color and write  				// a newline. Note that we must AutoFlush before we restore the console  				// color otherwise we will have no effect.  				//  				// There will still be a slight artefact for the last line of the message  				// will have the background extended to the end of the line' however this  				// is unlikely to cause any user issues.  				//  				// Note that none of the above is visible while the console buffer is scrollable  				// within the console window viewport' the effects only arise when the actual  				// buffer is full and needs to be scrolled.    				char[] messageCharArray = strLoggingMessage.ToCharArray();  				int arrayLength = messageCharArray.Length;  				bool appendNewline = false;    				// Trim off last newline' if it exists  				if (arrayLength > 1 && messageCharArray[arrayLength-2] == '\r' && messageCharArray[arrayLength-1] == '\n')  				{  					arrayLength -= 2;  					appendNewline = true;  				}    				// Write to the output stream  				m_consoleOutputWriter.Write(messageCharArray' 0' arrayLength);    				// Restore the console back to its previous color scheme  				SetConsoleTextAttribute(consoleHandle' bufferInfo.wAttributes);    				if (appendNewline)  				{  					// Write the newline' after changing the color scheme  					m_consoleOutputWriter.Write(s_windowsNewline' 0' 2);  				}  			}
Magic Number,log4net.Appender,EventLogAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\EventLogAppender.cs,Append,The following statement contains a magic number: try  			{  				string eventTxt = RenderLoggingEvent(loggingEvent);    				// There is a limit of 32K characters for an event log message  				if (eventTxt.Length > 32000)  				{  					eventTxt = eventTxt.Substring(0' 32000);  				}    				EventLogEntryType entryType = GetEntryType(loggingEvent.Level);    				using(SecurityContext.Impersonate(this))  				{  					EventLog.WriteEntry(m_applicationName' eventTxt' entryType' eventID' category);  				}  			}  			catch(Exception ex)  			{  				ErrorHandler.Error("Unable to write to event log [" + m_logName + "] using source [" + m_applicationName + "]"' ex);  			}
Magic Number,log4net.Appender,EventLogAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\EventLogAppender.cs,Append,The following statement contains a magic number: try  			{  				string eventTxt = RenderLoggingEvent(loggingEvent);    				// There is a limit of 32K characters for an event log message  				if (eventTxt.Length > 32000)  				{  					eventTxt = eventTxt.Substring(0' 32000);  				}    				EventLogEntryType entryType = GetEntryType(loggingEvent.Level);    				using(SecurityContext.Impersonate(this))  				{  					EventLog.WriteEntry(m_applicationName' eventTxt' entryType' eventID' category);  				}  			}  			catch(Exception ex)  			{  				ErrorHandler.Error("Unable to write to event log [" + m_logName + "] using source [" + m_applicationName + "]"' ex);  			}
Magic Number,log4net.Appender,LocalSyslogAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\LocalSyslogAppender.cs,GeneratePriority,The following statement contains a magic number: return ((int)facility * 8) + (int)severity;
Magic Number,log4net.Appender,RemoteSyslogAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\RemoteSyslogAppender.cs,GeneratePriority,The following statement contains a magic number: unchecked  			{  				return ((int)facility * 8) + (int)severity;  			}
Magic Number,log4net.Appender,RemotingAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\RemotingAppender.cs,OnClose,The following statement contains a magic number: if (!m_workQueueEmptyEvent.WaitOne(30 * 1000' false))  			{  				ErrorHandler.Error("RemotingAppender ["+Name+"] failed to send all queued events before close' in OnClose.");  			}
Magic Number,log4net.Appender,RemotingAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\RemotingAppender.cs,OnClose,The following statement contains a magic number: if (!m_workQueueEmptyEvent.WaitOne(30 * 1000' false))  			{  				ErrorHandler.Error("RemotingAppender ["+Name+"] failed to send all queued events before close' in OnClose.");  			}
Magic Number,log4net.Appender,RollingFileAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\RollingFileAppender.cs,NextCheckDate,The following statement contains a magic number: switch(rollPoint)   			{  				case RollPoint.TopOfMinute:  					current = current.AddMilliseconds(-current.Millisecond);  					current = current.AddSeconds(-current.Second);  					current = current.AddMinutes(1);  					break;    				case RollPoint.TopOfHour:  					current = current.AddMilliseconds(-current.Millisecond);  					current = current.AddSeconds(-current.Second);  					current = current.AddMinutes(-current.Minute);  					current = current.AddHours(1);  					break;    				case RollPoint.HalfDay:  					current = current.AddMilliseconds(-current.Millisecond);  					current = current.AddSeconds(-current.Second);  					current = current.AddMinutes(-current.Minute);    					if (current.Hour < 12)   					{  						current = current.AddHours(12 - current.Hour);  					}   					else   					{  						current = current.AddHours(-current.Hour);  						current = current.AddDays(1);  					}  					break;    				case RollPoint.TopOfDay:  					current = current.AddMilliseconds(-current.Millisecond);  					current = current.AddSeconds(-current.Second);  					current = current.AddMinutes(-current.Minute);  					current = current.AddHours(-current.Hour);  					current = current.AddDays(1);  					break;    				case RollPoint.TopOfWeek:  					current = current.AddMilliseconds(-current.Millisecond);  					current = current.AddSeconds(-current.Second);  					current = current.AddMinutes(-current.Minute);  					current = current.AddHours(-current.Hour);  					current = current.AddDays(7 - (int)current.DayOfWeek);  					break;    				case RollPoint.TopOfMonth:  					current = current.AddMilliseconds(-current.Millisecond);  					current = current.AddSeconds(-current.Second);  					current = current.AddMinutes(-current.Minute);  					current = current.AddHours(-current.Hour);  					current = current.AddDays(1 - current.Day); /* first day of month is 1 not 0 */  					current = current.AddMonths(1);  					break;  			}
Magic Number,log4net.Appender,RollingFileAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\RollingFileAppender.cs,NextCheckDate,The following statement contains a magic number: switch(rollPoint)   			{  				case RollPoint.TopOfMinute:  					current = current.AddMilliseconds(-current.Millisecond);  					current = current.AddSeconds(-current.Second);  					current = current.AddMinutes(1);  					break;    				case RollPoint.TopOfHour:  					current = current.AddMilliseconds(-current.Millisecond);  					current = current.AddSeconds(-current.Second);  					current = current.AddMinutes(-current.Minute);  					current = current.AddHours(1);  					break;    				case RollPoint.HalfDay:  					current = current.AddMilliseconds(-current.Millisecond);  					current = current.AddSeconds(-current.Second);  					current = current.AddMinutes(-current.Minute);    					if (current.Hour < 12)   					{  						current = current.AddHours(12 - current.Hour);  					}   					else   					{  						current = current.AddHours(-current.Hour);  						current = current.AddDays(1);  					}  					break;    				case RollPoint.TopOfDay:  					current = current.AddMilliseconds(-current.Millisecond);  					current = current.AddSeconds(-current.Second);  					current = current.AddMinutes(-current.Minute);  					current = current.AddHours(-current.Hour);  					current = current.AddDays(1);  					break;    				case RollPoint.TopOfWeek:  					current = current.AddMilliseconds(-current.Millisecond);  					current = current.AddSeconds(-current.Second);  					current = current.AddMinutes(-current.Minute);  					current = current.AddHours(-current.Hour);  					current = current.AddDays(7 - (int)current.DayOfWeek);  					break;    				case RollPoint.TopOfMonth:  					current = current.AddMilliseconds(-current.Millisecond);  					current = current.AddSeconds(-current.Second);  					current = current.AddMinutes(-current.Minute);  					current = current.AddHours(-current.Hour);  					current = current.AddDays(1 - current.Day); /* first day of month is 1 not 0 */  					current = current.AddMonths(1);  					break;  			}
Magic Number,log4net.Appender,RollingFileAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\RollingFileAppender.cs,NextCheckDate,The following statement contains a magic number: switch(rollPoint)   			{  				case RollPoint.TopOfMinute:  					current = current.AddMilliseconds(-current.Millisecond);  					current = current.AddSeconds(-current.Second);  					current = current.AddMinutes(1);  					break;    				case RollPoint.TopOfHour:  					current = current.AddMilliseconds(-current.Millisecond);  					current = current.AddSeconds(-current.Second);  					current = current.AddMinutes(-current.Minute);  					current = current.AddHours(1);  					break;    				case RollPoint.HalfDay:  					current = current.AddMilliseconds(-current.Millisecond);  					current = current.AddSeconds(-current.Second);  					current = current.AddMinutes(-current.Minute);    					if (current.Hour < 12)   					{  						current = current.AddHours(12 - current.Hour);  					}   					else   					{  						current = current.AddHours(-current.Hour);  						current = current.AddDays(1);  					}  					break;    				case RollPoint.TopOfDay:  					current = current.AddMilliseconds(-current.Millisecond);  					current = current.AddSeconds(-current.Second);  					current = current.AddMinutes(-current.Minute);  					current = current.AddHours(-current.Hour);  					current = current.AddDays(1);  					break;    				case RollPoint.TopOfWeek:  					current = current.AddMilliseconds(-current.Millisecond);  					current = current.AddSeconds(-current.Second);  					current = current.AddMinutes(-current.Minute);  					current = current.AddHours(-current.Hour);  					current = current.AddDays(7 - (int)current.DayOfWeek);  					break;    				case RollPoint.TopOfMonth:  					current = current.AddMilliseconds(-current.Millisecond);  					current = current.AddSeconds(-current.Second);  					current = current.AddMinutes(-current.Minute);  					current = current.AddHours(-current.Hour);  					current = current.AddDays(1 - current.Day); /* first day of month is 1 not 0 */  					current = current.AddMonths(1);  					break;  			}
Magic Number,log4net.Appender,SocketHandler,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\TelnetAppender.cs,SocketHandler,The following statement contains a magic number: m_serverSocket.Listen(5);
Magic Number,log4net.Config,XmlConfigurator,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Config\XmlConfigurator.cs,InternalConfigure,The following statement contains a magic number: if (configFile == null)  			{  				LogLog.Error(declaringType' "Configure called with null 'configFile' parameter");  			}  			else  			{  				// Have to use File.Exists() rather than configFile.Exists()  				// because configFile.Exists() caches the value' not what we want.  				if (File.Exists(configFile.FullName))  				{  					// Open the file for reading  					FileStream fs = null;  					  					// Try hard to open the file  					for(int retry = 5; --retry >= 0; )  					{  						try  						{  							fs = configFile.Open(FileMode.Open' FileAccess.Read' FileShare.Read);  							break;  						}  						catch(IOException ex)  						{  							if (retry == 0)  							{  								LogLog.Error(declaringType' "Failed to open XML config file [" + configFile.Name + "]"' ex);    								// The stream cannot be valid  								fs = null;  							}  							System.Threading.Thread.Sleep(250);  						}  					}    					if (fs != null)  					{  						try  						{  							// Load the configuration from the stream  							InternalConfigure(repository' fs);  						}  						finally  						{  							// Force the file closed whatever happens  							fs.Close();  						}  					}  				}  				else  				{  					LogLog.Debug(declaringType' "config file [" + configFile.FullName + "] not found. Configuration unchanged.");  				}  			}
Magic Number,log4net.Config,XmlConfigurator,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Config\XmlConfigurator.cs,InternalConfigure,The following statement contains a magic number: if (configFile == null)  			{  				LogLog.Error(declaringType' "Configure called with null 'configFile' parameter");  			}  			else  			{  				// Have to use File.Exists() rather than configFile.Exists()  				// because configFile.Exists() caches the value' not what we want.  				if (File.Exists(configFile.FullName))  				{  					// Open the file for reading  					FileStream fs = null;  					  					// Try hard to open the file  					for(int retry = 5; --retry >= 0; )  					{  						try  						{  							fs = configFile.Open(FileMode.Open' FileAccess.Read' FileShare.Read);  							break;  						}  						catch(IOException ex)  						{  							if (retry == 0)  							{  								LogLog.Error(declaringType' "Failed to open XML config file [" + configFile.Name + "]"' ex);    								// The stream cannot be valid  								fs = null;  							}  							System.Threading.Thread.Sleep(250);  						}  					}    					if (fs != null)  					{  						try  						{  							// Load the configuration from the stream  							InternalConfigure(repository' fs);  						}  						finally  						{  							// Force the file closed whatever happens  							fs.Close();  						}  					}  				}  				else  				{  					LogLog.Debug(declaringType' "config file [" + configFile.FullName + "] not found. Configuration unchanged.");  				}  			}
Magic Number,log4net.Core,LevelCollection,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Core\LevelCollection.cs,EnsureCapacity,The following statement contains a magic number: int newCapacity = ((m_array.Length == 0) ? DEFAULT_CAPACITY : m_array.Length * 2);
Magic Number,log4net.DateFormatter,AbsoluteTimeDateFormatter,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\DateFormatter\AbsoluteTimeDateFormatter.cs,FormatDateWithoutMillis,The following statement contains a magic number: if (hour < 10)   			{  				buffer.Append('0');  			}
Magic Number,log4net.DateFormatter,AbsoluteTimeDateFormatter,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\DateFormatter\AbsoluteTimeDateFormatter.cs,FormatDateWithoutMillis,The following statement contains a magic number: if (mins < 10)   			{  				buffer.Append('0');  			}
Magic Number,log4net.DateFormatter,AbsoluteTimeDateFormatter,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\DateFormatter\AbsoluteTimeDateFormatter.cs,FormatDateWithoutMillis,The following statement contains a magic number: if (secs < 10)   			{  				buffer.Append('0');  			}
Magic Number,log4net.DateFormatter,AbsoluteTimeDateFormatter,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\DateFormatter\AbsoluteTimeDateFormatter.cs,FormatDate,The following statement contains a magic number: if (millis < 100)   			{  				writer.Write('0');  			}
Magic Number,log4net.DateFormatter,AbsoluteTimeDateFormatter,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\DateFormatter\AbsoluteTimeDateFormatter.cs,FormatDate,The following statement contains a magic number: if (millis < 10)   			{  				writer.Write('0');  			}
Magic Number,log4net.DateFormatter,DateTimeDateFormatter,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\DateFormatter\DateTimeDateFormatter.cs,FormatDateWithoutMillis,The following statement contains a magic number: if (day < 10)   			{  				buffer.Append('0');  			}
Magic Number,log4net.DateFormatter,Iso8601DateFormatter,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\DateFormatter\Iso8601DateFormatter.cs,FormatDateWithoutMillis,The following statement contains a magic number: if (month < 10)  			{  				buffer.Append('0');  			}
Magic Number,log4net.DateFormatter,Iso8601DateFormatter,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\DateFormatter\Iso8601DateFormatter.cs,FormatDateWithoutMillis,The following statement contains a magic number: if (day < 10)   			{  				buffer.Append('0');  			}
Magic Number,log4net.Layout,PatternLayout,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Layout\PatternLayout.cs,PatternLayout,The following statement contains a magic number: s_globalRulesRegistry = new Hashtable(45);
Magic Number,log4net.Layout.Pattern,NamedPatternConverter,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Layout\Pattern\NamedPatternConverter.cs,Convert,The following statement contains a magic number: if (m_precision <= 0 || name == null || name.Length < 2)  			{  				writer.Write(name);  			}  			else   			{  				int len = name.Length;                  string trailingDot = string.Empty;                  if (name.EndsWith(DOT))                  {                      trailingDot = DOT;                      name = name.Substring(0' len - 1);                      len--;                  }                    int end = name.LastIndexOf(DOT);  				for(int i = 1; end > 0 && i < m_precision; i++)   				{                      end = name.LastIndexOf('.'' end - 1);                  }                  if (end == -1)                  {                      writer.Write(name + trailingDot);                  }                  else                  {                      writer.Write(name.Substring(end + 1' len - end - 1) + trailingDot);                  }  			}
Magic Number,log4net.Layout.Pattern,StackTraceDetailPatternConverter,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Layout\Pattern\StackTraceDetailPatternConverter.cs,GetMethodInformation,The following statement contains a magic number: try              {                  string param = "";                  string[] names = GetMethodParameterNames(method);                  StringBuilder sb = new StringBuilder();                  if (names != null && names.GetUpperBound(0) > 0)                  {                      for (int i = 0; i <= names.GetUpperBound(0); i++)                      {                          sb.AppendFormat("{0}' "' names[i]);                      }                  }                    if (sb.Length > 0)                  {                      sb.Remove(sb.Length - 2' 2);                      param = sb.ToString();                  }                    returnValue=base.GetMethodInformation(method) + "(" + param + ")";              }              catch (Exception ex)              {                  LogLog.Error(declaringType' "An exception ocurred while retreiving method information."' ex);              }
Magic Number,log4net.Layout.Pattern,StackTraceDetailPatternConverter,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Layout\Pattern\StackTraceDetailPatternConverter.cs,GetMethodInformation,The following statement contains a magic number: try              {                  string param = "";                  string[] names = GetMethodParameterNames(method);                  StringBuilder sb = new StringBuilder();                  if (names != null && names.GetUpperBound(0) > 0)                  {                      for (int i = 0; i <= names.GetUpperBound(0); i++)                      {                          sb.AppendFormat("{0}' "' names[i]);                      }                  }                    if (sb.Length > 0)                  {                      sb.Remove(sb.Length - 2' 2);                      param = sb.ToString();                  }                    returnValue=base.GetMethodInformation(method) + "(" + param + ")";              }              catch (Exception ex)              {                  LogLog.Error(declaringType' "An exception ocurred while retreiving method information."' ex);              }
Magic Number,log4net.Plugin,PluginCollection,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Plugin\PluginCollection.cs,EnsureCapacity,The following statement contains a magic number: int newCapacity = ((m_array.Length == 0) ? DEFAULT_CAPACITY : m_array.Length * 2);
Magic Number,log4net.Util,NativeError,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\NativeError.cs,GetErrorMessage,The following statement contains a magic number: if (messageId != 0)   			{  				// If the function succeeds' the return value is the number of TCHARs stored in the output buffer' excluding the terminating null character  				int messageSize = FormatMessage(  					FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS'   					ref sourcePtr'   					messageId'   					0'   					ref msgBuf'   					255'   					argumentsPtr);    				if (messageSize > 0)   				{  					// Remove trailing null-terminating characters (\r\n) from the message  					msgBuf = msgBuf.TrimEnd(new char[] {'\r'' '\n'});  				}  				else   				{  					// A message could not be located.  					msgBuf = null;  				}  			}   			else   			{  				msgBuf = null;  			}
Magic Number,log4net.Util,OptionConverter,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\OptionConverter.cs,ToFileSize,The following statement contains a magic number: if ((index = s.IndexOf("KB")) != -1)   			{	    				multiplier = 1024;  				s = s.Substring(0' index);  			}  			else if ((index = s.IndexOf("MB")) != -1)   			{  				multiplier = 1024 * 1024;  				s = s.Substring(0' index);  			}  			else if ((index = s.IndexOf("GB")) != -1)   			{  				multiplier = 1024 * 1024 * 1024;  				s = s.Substring(0' index);  			}
Magic Number,log4net.Util,OptionConverter,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\OptionConverter.cs,ToFileSize,The following statement contains a magic number: if ((index = s.IndexOf("KB")) != -1)   			{	    				multiplier = 1024;  				s = s.Substring(0' index);  			}  			else if ((index = s.IndexOf("MB")) != -1)   			{  				multiplier = 1024 * 1024;  				s = s.Substring(0' index);  			}  			else if ((index = s.IndexOf("GB")) != -1)   			{  				multiplier = 1024 * 1024 * 1024;  				s = s.Substring(0' index);  			}
Magic Number,log4net.Util,OptionConverter,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\OptionConverter.cs,ToFileSize,The following statement contains a magic number: if ((index = s.IndexOf("KB")) != -1)   			{	    				multiplier = 1024;  				s = s.Substring(0' index);  			}  			else if ((index = s.IndexOf("MB")) != -1)   			{  				multiplier = 1024 * 1024;  				s = s.Substring(0' index);  			}  			else if ((index = s.IndexOf("GB")) != -1)   			{  				multiplier = 1024 * 1024 * 1024;  				s = s.Substring(0' index);  			}
Magic Number,log4net.Util,OptionConverter,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\OptionConverter.cs,ToFileSize,The following statement contains a magic number: if ((index = s.IndexOf("KB")) != -1)   			{	    				multiplier = 1024;  				s = s.Substring(0' index);  			}  			else if ((index = s.IndexOf("MB")) != -1)   			{  				multiplier = 1024 * 1024;  				s = s.Substring(0' index);  			}  			else if ((index = s.IndexOf("GB")) != -1)   			{  				multiplier = 1024 * 1024 * 1024;  				s = s.Substring(0' index);  			}
Magic Number,log4net.Util,OptionConverter,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\OptionConverter.cs,ToFileSize,The following statement contains a magic number: if ((index = s.IndexOf("KB")) != -1)   			{	    				multiplier = 1024;  				s = s.Substring(0' index);  			}  			else if ((index = s.IndexOf("MB")) != -1)   			{  				multiplier = 1024 * 1024;  				s = s.Substring(0' index);  			}  			else if ((index = s.IndexOf("GB")) != -1)   			{  				multiplier = 1024 * 1024 * 1024;  				s = s.Substring(0' index);  			}
Magic Number,log4net.Util,OptionConverter,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\OptionConverter.cs,ToFileSize,The following statement contains a magic number: if ((index = s.IndexOf("KB")) != -1)   			{	    				multiplier = 1024;  				s = s.Substring(0' index);  			}  			else if ((index = s.IndexOf("MB")) != -1)   			{  				multiplier = 1024 * 1024;  				s = s.Substring(0' index);  			}  			else if ((index = s.IndexOf("GB")) != -1)   			{  				multiplier = 1024 * 1024 * 1024;  				s = s.Substring(0' index);  			}
Magic Number,log4net.Util,PatternConverter,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\PatternConverter.cs,SpacePad,The following statement contains a magic number: while(length >= 32)   			{  				writer.Write(SPACES[5]);  				length -= 32;  			}
Magic Number,log4net.Util,PatternConverter,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\PatternConverter.cs,SpacePad,The following statement contains a magic number: while(length >= 32)   			{  				writer.Write(SPACES[5]);  				length -= 32;  			}
Magic Number,log4net.Util,PatternConverter,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\PatternConverter.cs,SpacePad,The following statement contains a magic number: while(length >= 32)   			{  				writer.Write(SPACES[5]);  				length -= 32;  			}
Magic Number,log4net.Util,PatternConverter,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\PatternConverter.cs,SpacePad,The following statement contains a magic number: for(int i = 4; i >= 0; i--)   			{	  				if ((length & (1<<i)) != 0)   				{  					writer.Write(SPACES[i]);  				}  			}
Magic Number,log4net.Util,PatternParser,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\PatternParser.cs,ParseInternal,The following statement contains a magic number: while(offset < pattern.Length)  			{  				int i = pattern.IndexOf('%'' offset);  				if (i < 0 || i == pattern.Length - 1)  				{  					ProcessLiteral(pattern.Substring(offset));  					offset = pattern.Length;  				}  				else  				{  					if (pattern[i+1] == '%')  					{  						// Escaped  						ProcessLiteral(pattern.Substring(offset' i - offset + 1));  						offset = i + 2;  					}  					else  					{  						ProcessLiteral(pattern.Substring(offset' i - offset));  						offset = i + 1;    						FormattingInfo formattingInfo = new FormattingInfo();    						// Process formatting options    						// Look for the align flag  						if (offset < pattern.Length)  						{  							if (pattern[offset] == '-')  							{  								// Seen align flag  								formattingInfo.LeftAlign = true;  								offset++;  							}  						}  						// Look for the minimum length  						while (offset < pattern.Length && char.IsDigit(pattern[offset]))  						{  							// Seen digit  							if (formattingInfo.Min < 0)  							{  								formattingInfo.Min = 0;  							}  							formattingInfo.Min = (formattingInfo.Min * 10) + int.Parse(pattern[offset].ToString(CultureInfo.InvariantCulture)' System.Globalization.NumberFormatInfo.InvariantInfo);  							offset++;  						}  						// Look for the separator between min and max  						if (offset < pattern.Length)  						{  							if (pattern[offset] == '.')  							{  								// Seen separator  								offset++;  							}  						}  						// Look for the maximum length  						while (offset < pattern.Length && char.IsDigit(pattern[offset]))  						{  							// Seen digit  							if (formattingInfo.Max == int.MaxValue)  							{  								formattingInfo.Max = 0;  							}  							formattingInfo.Max = (formattingInfo.Max * 10) + int.Parse(pattern[offset].ToString(CultureInfo.InvariantCulture)' System.Globalization.NumberFormatInfo.InvariantInfo);  							offset++;  						}    						int remainingStringLength = pattern.Length - offset;    						// Look for pattern  						for(int m=0; m<matches.Length; m++)  						{  							if (matches[m].Length <= remainingStringLength)  							{  								if (String.Compare(pattern' offset' matches[m]' 0' matches[m].Length' false' System.Globalization.CultureInfo.InvariantCulture) == 0)  								{  									// Found match  									offset = offset + matches[m].Length;    									string option = null;    									// Look for option  									if (offset < pattern.Length)  									{  										if (pattern[offset] == '{')  										{  											// Seen option start  											offset++;  											  											int optEnd = pattern.IndexOf('}'' offset);  											if (optEnd < 0)  											{  												// error  											}  											else  											{  												option = pattern.Substring(offset' optEnd - offset);  												offset = optEnd + 1;  											}  										}  									}    									ProcessConverter(matches[m]' option' formattingInfo);  									break;  								}  							}  						}  					}  				}  			}
Magic Number,log4net.Util,PatternParser,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\PatternParser.cs,ParseInternal,The following statement contains a magic number: while(offset < pattern.Length)  			{  				int i = pattern.IndexOf('%'' offset);  				if (i < 0 || i == pattern.Length - 1)  				{  					ProcessLiteral(pattern.Substring(offset));  					offset = pattern.Length;  				}  				else  				{  					if (pattern[i+1] == '%')  					{  						// Escaped  						ProcessLiteral(pattern.Substring(offset' i - offset + 1));  						offset = i + 2;  					}  					else  					{  						ProcessLiteral(pattern.Substring(offset' i - offset));  						offset = i + 1;    						FormattingInfo formattingInfo = new FormattingInfo();    						// Process formatting options    						// Look for the align flag  						if (offset < pattern.Length)  						{  							if (pattern[offset] == '-')  							{  								// Seen align flag  								formattingInfo.LeftAlign = true;  								offset++;  							}  						}  						// Look for the minimum length  						while (offset < pattern.Length && char.IsDigit(pattern[offset]))  						{  							// Seen digit  							if (formattingInfo.Min < 0)  							{  								formattingInfo.Min = 0;  							}  							formattingInfo.Min = (formattingInfo.Min * 10) + int.Parse(pattern[offset].ToString(CultureInfo.InvariantCulture)' System.Globalization.NumberFormatInfo.InvariantInfo);  							offset++;  						}  						// Look for the separator between min and max  						if (offset < pattern.Length)  						{  							if (pattern[offset] == '.')  							{  								// Seen separator  								offset++;  							}  						}  						// Look for the maximum length  						while (offset < pattern.Length && char.IsDigit(pattern[offset]))  						{  							// Seen digit  							if (formattingInfo.Max == int.MaxValue)  							{  								formattingInfo.Max = 0;  							}  							formattingInfo.Max = (formattingInfo.Max * 10) + int.Parse(pattern[offset].ToString(CultureInfo.InvariantCulture)' System.Globalization.NumberFormatInfo.InvariantInfo);  							offset++;  						}    						int remainingStringLength = pattern.Length - offset;    						// Look for pattern  						for(int m=0; m<matches.Length; m++)  						{  							if (matches[m].Length <= remainingStringLength)  							{  								if (String.Compare(pattern' offset' matches[m]' 0' matches[m].Length' false' System.Globalization.CultureInfo.InvariantCulture) == 0)  								{  									// Found match  									offset = offset + matches[m].Length;    									string option = null;    									// Look for option  									if (offset < pattern.Length)  									{  										if (pattern[offset] == '{')  										{  											// Seen option start  											offset++;  											  											int optEnd = pattern.IndexOf('}'' offset);  											if (optEnd < 0)  											{  												// error  											}  											else  											{  												option = pattern.Substring(offset' optEnd - offset);  												offset = optEnd + 1;  											}  										}  									}    									ProcessConverter(matches[m]' option' formattingInfo);  									break;  								}  							}  						}  					}  				}  			}
Magic Number,log4net.Util,PatternParser,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\PatternParser.cs,ParseInternal,The following statement contains a magic number: while(offset < pattern.Length)  			{  				int i = pattern.IndexOf('%'' offset);  				if (i < 0 || i == pattern.Length - 1)  				{  					ProcessLiteral(pattern.Substring(offset));  					offset = pattern.Length;  				}  				else  				{  					if (pattern[i+1] == '%')  					{  						// Escaped  						ProcessLiteral(pattern.Substring(offset' i - offset + 1));  						offset = i + 2;  					}  					else  					{  						ProcessLiteral(pattern.Substring(offset' i - offset));  						offset = i + 1;    						FormattingInfo formattingInfo = new FormattingInfo();    						// Process formatting options    						// Look for the align flag  						if (offset < pattern.Length)  						{  							if (pattern[offset] == '-')  							{  								// Seen align flag  								formattingInfo.LeftAlign = true;  								offset++;  							}  						}  						// Look for the minimum length  						while (offset < pattern.Length && char.IsDigit(pattern[offset]))  						{  							// Seen digit  							if (formattingInfo.Min < 0)  							{  								formattingInfo.Min = 0;  							}  							formattingInfo.Min = (formattingInfo.Min * 10) + int.Parse(pattern[offset].ToString(CultureInfo.InvariantCulture)' System.Globalization.NumberFormatInfo.InvariantInfo);  							offset++;  						}  						// Look for the separator between min and max  						if (offset < pattern.Length)  						{  							if (pattern[offset] == '.')  							{  								// Seen separator  								offset++;  							}  						}  						// Look for the maximum length  						while (offset < pattern.Length && char.IsDigit(pattern[offset]))  						{  							// Seen digit  							if (formattingInfo.Max == int.MaxValue)  							{  								formattingInfo.Max = 0;  							}  							formattingInfo.Max = (formattingInfo.Max * 10) + int.Parse(pattern[offset].ToString(CultureInfo.InvariantCulture)' System.Globalization.NumberFormatInfo.InvariantInfo);  							offset++;  						}    						int remainingStringLength = pattern.Length - offset;    						// Look for pattern  						for(int m=0; m<matches.Length; m++)  						{  							if (matches[m].Length <= remainingStringLength)  							{  								if (String.Compare(pattern' offset' matches[m]' 0' matches[m].Length' false' System.Globalization.CultureInfo.InvariantCulture) == 0)  								{  									// Found match  									offset = offset + matches[m].Length;    									string option = null;    									// Look for option  									if (offset < pattern.Length)  									{  										if (pattern[offset] == '{')  										{  											// Seen option start  											offset++;  											  											int optEnd = pattern.IndexOf('}'' offset);  											if (optEnd < 0)  											{  												// error  											}  											else  											{  												option = pattern.Substring(offset' optEnd - offset);  												offset = optEnd + 1;  											}  										}  									}    									ProcessConverter(matches[m]' option' formattingInfo);  									break;  								}  							}  						}  					}  				}  			}
Magic Number,log4net.Util,PatternString,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\PatternString.cs,PatternString,The following statement contains a magic number: s_globalRulesRegistry = new Hashtable(15);
Magic Number,log4net.Util,Transform,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\Transform.cs,WriteEscapedXmlString,The following statement contains a magic number: int weightCData = 12 * (1 + CountSubstrings(stringData' CDATA_END));
Magic Number,log4net.Util,Transform,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\Transform.cs,WriteEscapedXmlString,The following statement contains a magic number: int weightStringEscapes = 3*(CountSubstrings(stringData' "<") + CountSubstrings(stringData' ">")) + 4*CountSubstrings(stringData' "&");
Magic Number,log4net.Util,Transform,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\Transform.cs,WriteEscapedXmlString,The following statement contains a magic number: int weightStringEscapes = 3*(CountSubstrings(stringData' "<") + CountSubstrings(stringData' ">")) + 4*CountSubstrings(stringData' "&");
Magic Number,log4net.Util,Transform,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\Transform.cs,WriteEscapedXmlString,The following statement contains a magic number: if (weightStringEscapes <= weightCData)  			{  				// Write string using string escapes  				writer.WriteString(stringData);  			}  			else  			{  				// Write string using CDATA section    				int end = stringData.IndexOf(CDATA_END);  	  				if (end < 0)   				{  					writer.WriteCData(stringData);  				}  				else  				{  					int start = 0;  					while (end > -1)   					{  						writer.WriteCData(stringData.Substring(start' end - start));  						if (end == stringData.Length - 3)  						{  							start = stringData.Length;  							writer.WriteString(CDATA_END);  							break;  						}  						else  						{  							writer.WriteString(CDATA_UNESCAPABLE_TOKEN);  							start = end + 2;  							end = stringData.IndexOf(CDATA_END' start);  						}  					}  	  					if (start < stringData.Length)  					{  						writer.WriteCData(stringData.Substring(start));  					}  				}  			}
Magic Number,log4net.Util,Transform,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\Transform.cs,WriteEscapedXmlString,The following statement contains a magic number: if (weightStringEscapes <= weightCData)  			{  				// Write string using string escapes  				writer.WriteString(stringData);  			}  			else  			{  				// Write string using CDATA section    				int end = stringData.IndexOf(CDATA_END);  	  				if (end < 0)   				{  					writer.WriteCData(stringData);  				}  				else  				{  					int start = 0;  					while (end > -1)   					{  						writer.WriteCData(stringData.Substring(start' end - start));  						if (end == stringData.Length - 3)  						{  							start = stringData.Length;  							writer.WriteString(CDATA_END);  							break;  						}  						else  						{  							writer.WriteString(CDATA_UNESCAPABLE_TOKEN);  							start = end + 2;  							end = stringData.IndexOf(CDATA_END' start);  						}  					}  	  					if (start < stringData.Length)  					{  						writer.WriteCData(stringData.Substring(start));  					}  				}  			}
Magic Number,log4net.Util,WindowsSecurityContext,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\WindowsSecurityContext.cs,LogonUser,The following statement contains a magic number: const int LOGON32_LOGON_INTERACTIVE = 2;
Magic Number,log4net.Util,WindowsSecurityContext,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\WindowsSecurityContext.cs,LogonUser,The following statement contains a magic number: const int SecurityImpersonation = 2;
Magic Number,log4net.Util.PatternStringConverters,RandomStringPatternConverter,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\PatternStringConverters\RandomStringPatternConverter.cs,Convert,The following statement contains a magic number: try   			{  				lock(s_random)  				{  					for(int i=0; i<m_length; i++)  					{  						int randValue = s_random.Next(36);    						if (randValue < 26)  						{  							// Letter  							char ch = (char)('A' + randValue);  							writer.Write(ch);  						}  						else if (randValue < 36)  						{  							// Number  							char ch = (char)('0' + (randValue - 26));  							writer.Write(ch);  						}  						else  						{  							// Should not get here  							writer.Write('X');  						}  					}  				}  			}  			catch (Exception ex)   			{  				LogLog.Error(declaringType' "Error occurred while converting."' ex);  			}
Magic Number,log4net.Util.PatternStringConverters,RandomStringPatternConverter,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\PatternStringConverters\RandomStringPatternConverter.cs,Convert,The following statement contains a magic number: try   			{  				lock(s_random)  				{  					for(int i=0; i<m_length; i++)  					{  						int randValue = s_random.Next(36);    						if (randValue < 26)  						{  							// Letter  							char ch = (char)('A' + randValue);  							writer.Write(ch);  						}  						else if (randValue < 36)  						{  							// Number  							char ch = (char)('0' + (randValue - 26));  							writer.Write(ch);  						}  						else  						{  							// Should not get here  							writer.Write('X');  						}  					}  				}  			}  			catch (Exception ex)   			{  				LogLog.Error(declaringType' "Error occurred while converting."' ex);  			}
Magic Number,log4net.Util.PatternStringConverters,RandomStringPatternConverter,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\PatternStringConverters\RandomStringPatternConverter.cs,Convert,The following statement contains a magic number: try   			{  				lock(s_random)  				{  					for(int i=0; i<m_length; i++)  					{  						int randValue = s_random.Next(36);    						if (randValue < 26)  						{  							// Letter  							char ch = (char)('A' + randValue);  							writer.Write(ch);  						}  						else if (randValue < 36)  						{  							// Number  							char ch = (char)('0' + (randValue - 26));  							writer.Write(ch);  						}  						else  						{  							// Should not get here  							writer.Write('X');  						}  					}  				}  			}  			catch (Exception ex)   			{  				LogLog.Error(declaringType' "Error occurred while converting."' ex);  			}
Magic Number,log4net.Util.PatternStringConverters,RandomStringPatternConverter,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Util\PatternStringConverters\RandomStringPatternConverter.cs,Convert,The following statement contains a magic number: try   			{  				lock(s_random)  				{  					for(int i=0; i<m_length; i++)  					{  						int randValue = s_random.Next(36);    						if (randValue < 26)  						{  							// Letter  							char ch = (char)('A' + randValue);  							writer.Write(ch);  						}  						else if (randValue < 36)  						{  							// Number  							char ch = (char)('0' + (randValue - 26));  							writer.Write(ch);  						}  						else  						{  							// Should not get here  							writer.Write('X');  						}  					}  				}  			}  			catch (Exception ex)   			{  				LogLog.Error(declaringType' "Error occurred while converting."' ex);  			}
Missing Default,log4net.Appender,AppenderSkeleton,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\AppenderSkeleton.cs,FilterEvent,The following switch statement is missing a default case: switch(f.Decide(loggingEvent))   				{  					case FilterDecision.Deny:   						return false;	// Return without appending    					case FilterDecision.Accept:  						f = null;		// Break out of the loop  						break;    					case FilterDecision.Neutral:  						f = f.Next;		// Move to next filter  						break;  				}
Missing Default,log4net.Appender,RollingFileAppender,C:\repos\aegif_CmisSync\Extras\log4net-1.2.11\src\Appender\RollingFileAppender.cs,NextCheckDate,The following switch statement is missing a default case: switch(rollPoint)   			{  				case RollPoint.TopOfMinute:  					current = current.AddMilliseconds(-current.Millisecond);  					current = current.AddSeconds(-current.Second);  					current = current.AddMinutes(1);  					break;    				case RollPoint.TopOfHour:  					current = current.AddMilliseconds(-current.Millisecond);  					current = current.AddSeconds(-current.Second);  					current = current.AddMinutes(-current.Minute);  					current = current.AddHours(1);  					break;    				case RollPoint.HalfDay:  					current = current.AddMilliseconds(-current.Millisecond);  					current = current.AddSeconds(-current.Second);  					current = current.AddMinutes(-current.Minute);    					if (current.Hour < 12)   					{  						current = current.AddHours(12 - current.Hour);  					}   					else   					{  						current = current.AddHours(-current.Hour);  						current = current.AddDays(1);  					}  					break;    				case RollPoint.TopOfDay:  					current = current.AddMilliseconds(-current.Millisecond);  					current = current.AddSeconds(-current.Second);  					current = current.AddMinutes(-current.Minute);  					current = current.AddHours(-current.Hour);  					current = current.AddDays(1);  					break;    				case RollPoint.TopOfWeek:  					current = current.AddMilliseconds(-current.Millisecond);  					current = current.AddSeconds(-current.Second);  					current = current.AddMinutes(-current.Minute);  					current = current.AddHours(-current.Hour);  					current = current.AddDays(7 - (int)current.DayOfWeek);  					break;    				case RollPoint.TopOfMonth:  					current = current.AddMilliseconds(-current.Millisecond);  					current = current.AddSeconds(-current.Second);  					current = current.AddMinutes(-current.Minute);  					current = current.AddHours(-current.Hour);  					current = current.AddDays(1 - current.Day); /* first day of month is 1 not 0 */  					current = current.AddMonths(1);  					break;  			}
