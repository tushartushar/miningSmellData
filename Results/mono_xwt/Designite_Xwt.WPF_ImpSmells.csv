Implementation smell,Namespace,Class,File,Method,Description
Long Method,Xwt.WPFBackend.Utilities,CellUtil,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend.Utilities\CellUtil.cs,CreateBoundCellRenderer,The method has 115 lines of code.
Complex Method,Xwt.WPFBackend,TextLayoutBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\TextLayoutBackendHandler.cs,Rebuild,Cyclomatic complexity of the method is 8
Complex Method,Xwt.WPFBackend,DataConverter,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\DataConverter.cs,ToXwtFontStretch,Cyclomatic complexity of the method is 9
Complex Method,Xwt.WPFBackend,DataConverter,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\DataConverter.cs,ToWpfFontStretch,Cyclomatic complexity of the method is 9
Complex Method,Xwt.WPFBackend,DataConverter,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\DataConverter.cs,ToXwtFontWeight,Cyclomatic complexity of the method is 15
Complex Method,Xwt.WPFBackend,DataConverter,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\DataConverter.cs,ToWpfFontWeight,Cyclomatic complexity of the method is 12
Complex Method,Xwt.WPFBackend,PanedBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\PanedBackend.cs,ArrangeChildren,Cyclomatic complexity of the method is 11
Complex Method,Xwt.WPFBackend,WidgetBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WidgetBackend.cs,MeasureOverride,Cyclomatic complexity of the method is 9
Complex Method,Xwt.WPFBackend,CustomScrollViewPort,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\CustomScrollViewPort.cs,SetOffset,Cyclomatic complexity of the method is 8
Complex Method,Xwt.WPFBackend.Utilities,CellUtil,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend.Utilities\CellUtil.cs,CreateBoundCellRenderer,Cyclomatic complexity of the method is 15
Long Parameter List,Xwt.WPFBackend,ScrollbarBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ScrollbarBackend.cs,SetRange,The method has 6 parameters. Parameters: lowerValue' upperValue' pageSize' pageIncrement' stepIncrement' value
Long Parameter List,Xwt.WPFBackend,WpfGradientBackendHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\GradientBackendHandler.cs,CreateRadial,The method has 6 parameters. Parameters: cx0' cy0' radius0' cx1' cy1' radius1
Long Parameter List,Xwt.WPFBackend,WpfContextBackendHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ContextBackendHandler.cs,Arc,The method has 6 parameters. Parameters: backend' xc' yc' radius' angle1' angle2
Long Parameter List,Xwt.WPFBackend,WpfContextBackendHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ContextBackendHandler.cs,ArcNegative,The method has 6 parameters. Parameters: backend' xc' yc' radius' angle1' angle2
Long Parameter List,Xwt.WPFBackend,WpfContextBackendHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ContextBackendHandler.cs,Arc,The method has 7 parameters. Parameters: backend' xc' yc' radius' angle1' angle2' inverse
Long Parameter List,Xwt.WPFBackend,WpfContextBackendHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ContextBackendHandler.cs,CurveTo,The method has 7 parameters. Parameters: backend' x1' y1' x2' y2' x3' y3
Long Parameter List,Xwt.WPFBackend,WpfContextBackendHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ContextBackendHandler.cs,Rectangle,The method has 5 parameters. Parameters: backend' x' y' width' height
Long Parameter List,Xwt.WPFBackend,WpfContextBackendHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ContextBackendHandler.cs,RelCurveTo,The method has 7 parameters. Parameters: backend' dx1' dy1' dx2' dy2' dx3' dy3
Long Parameter List,Xwt.WPFBackend,ImageHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,CropBitmap,The method has 5 parameters. Parameters: handle' srcX' srcY' w' h
Long Parameter List,Xwt.WPFBackend,ImageHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,CopyBitmapArea,The method has 8 parameters. Parameters: srcHandle' srcX' srcY' width' height' destHandle' destX' destY
Long Parameter List,Xwt.WPFBackend,WpfImage,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,GetBestFrame,The method has 5 parameters. Parameters: actx' w' width' height' forceExactSize
Long Parameter List,Xwt.WPFBackend,WpfImage,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,GetBestFrame,The method has 5 parameters. Parameters: actx' scaleFactor' width' height' forceExactSize
Long Parameter List,Xwt.WPFBackend,WpfImage,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,Draw,The method has 6 parameters. Parameters: actx' dc' scaleFactor' x' y' idesc
Long Parameter List,Xwt.WPFBackend,LabelBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\LabelBackend.cs,GenerateBlocks,The method has 6 parameters. Parameters: col' text' i' spanEnd' attributes' attrIndex
Long Parameter List,Xwt.WPFBackend,WpfFontBackendHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\FontBackendHandler.cs,Create,The method has 5 parameters. Parameters: fontName' size' style' weight' stretch
Long Parameter List,Xwt.WPFBackend,WPFEngine,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WPFEngine.cs,RenderImage,The method has 5 parameters. Parameters: nativeWidget' nativeContext' img' x' y
Long Parameter List,Xwt.WPFBackend,ScrollAdjustmentBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ScrollAdjustmentBackend.cs,SetRange,The method has 6 parameters. Parameters: lowerValue' upperValue' pageSize' pageIncrement' stepIncrement' value
Long Parameter List,Xwt.WPFBackend,RichTextBuffer,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\RichTextViewBackend.cs,GenerateBlocks,The method has 6 parameters. Parameters: col' text' i' spanEnd' attributes' attrIndex
Long Parameter List,Xwt.WPFBackend,WebViewBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WebViewBackend.cs,ShowUI,The method has 5 parameters. Parameters: dwID' pActiveObject' pCommandTarget' pFrame' pDoc
Long Parameter List,Xwt.NativeMSHTML,IDocHostUIHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend.Interop\IDocHostUIHandler.cs,ShowUI,The method has 5 parameters. Parameters: dwID' pActiveObject' pCommandTarget' pFrame' pDoc
Long Identifier,Xwt.WPFBackend,ExTreeView,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ExTreeView.cs,,The length of the parameter IsSelectionChangeActiveProperty is 31.
Long Statement,Xwt.WPFBackend,CanvasCellViewPanel,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend.CellViews\CanvasCellViewPanel.cs,OnRender,The length of the statement  "                ((ICanvasCellViewFrontend)CellViewBackend.CellView).Draw(ctx' new Rectangle(this.RenderTransform.Value.OffsetX' this.RenderTransform.Value.OffsetY' this.RenderSize.Width' this.RenderSize.Height)); " is 196.
Long Statement,Xwt.WPFBackend,PlaceholderTextAdorner,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\PlaceholderTextAdorner.cs,OnRender,The length of the statement  "				alignment = AdornedTextBox.ReadLocalValue (TextBox.TextAlignmentProperty) !=DependencyProperty.UnsetValue ? AdornedTextBox.TextAlignment : ConvertAlignment (AdornedTextBox.HorizontalContentAlignment); " is 200.
Long Statement,Xwt.WPFBackend,PlaceholderTextAdorner,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\PlaceholderTextAdorner.cs,OnRender,The length of the statement  "			var text = new System.Windows.Media.FormattedText (PlaceholderText ?? ""' CultureInfo.CurrentCulture' flowDirection' typeFace' fontSize' System.Windows.Media.Brushes.LightGray); " is 177.
Long Statement,Xwt.WPFBackend,TextLayoutBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\TextLayoutBackendHandler.cs,ApplyAttribute,The length of the statement  "				var dec = new TextDecoration(TextDecorationLocation.Strikethrough' null' 0' TextDecorationUnit.FontRecommended' TextDecorationUnit.FontRecommended);" is 148.
Long Statement,Xwt.WPFBackend,TextLayoutBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\TextLayoutBackendHandler.cs,ApplyAttribute,The length of the statement  "				var dec = new TextDecoration(TextDecorationLocation.Underline' null' 0' TextDecorationUnit.FontRecommended' TextDecorationUnit.FontRecommended);" is 144.
Long Statement,Xwt.WPFBackend,TextLayoutBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\TextLayoutBackendHandler.cs,Rebuild,The length of the statement  "			formattedText = new System.Windows.Media.FormattedText(text' System.Globalization.CultureInfo.CurrentCulture' dir' defaultFont' 36' brush);" is 139.
Long Statement,Xwt.WPFBackend,WpfImageBuilderBackendHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageBuilderBackendHandler.cs,CreateImage,The length of the statement  "			var bmp = new RenderTargetBitmap (visual.Width' visual.Height' ratios.Height * 96' ratios.Width * 96' PixelFormats.Pbgra32); " is 124.
Long Statement,Xwt.WPFBackend,WpfContextBackendHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ContextBackendHandler.cs,Arc,The length of the statement  "				var p1 = new SW.Point (xc + radius * Math.Cos (angle1 * Math.PI / 180.0)' yc + radius * Math.Sin (angle1 * Math.PI / 180.0)); " is 125.
Long Statement,Xwt.WPFBackend,WpfContextBackendHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ContextBackendHandler.cs,Arc,The length of the statement  "				var p2 = new SW.Point (xc + radius * Math.Cos (nextAngle * Math.PI / 180.0)' yc + radius * Math.Sin (nextAngle * Math.PI / 180.0)); " is 131.
Long Statement,Xwt.WPFBackend,WpfContextBackendHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ContextBackendHandler.cs,Rectangle,The length of the statement  "			var points = new SW.Point[] { new SW.Point (x + width' y)' new SW.Point (x + width' y + height)' new SW.Point (x' y + height)' new SW.Point (x' y) }; " is 149.
Long Statement,Xwt.WPFBackend,PopoverBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\PopoverBackend.cs,Show,The length of the statement  "					new System.Windows.Controls.Primitives.CustomPopupPlacement (location' System.Windows.Controls.Primitives.PopupPrimaryAxis.Horizontal) " is 134.
Long Statement,Xwt.WPFBackend,DialogBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\DialogBackend.cs,UpdateSeparatorVisibility,The length of the statement  "			buttonContainer.Visibility = separator.Visibility = leftButtons.Concat(rightButtons).Any (b => b.Button.Visible) ? Visibility.Visible : Visibility.Collapsed; " is 157.
Long Statement,Xwt.WPFBackend,ExTreeViewItem,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ExTreeViewItem.cs,OnKeyDown,The length of the statement  "			//We can't allow TreeViewItem(our base class) to get this message(OnKeyDown) because it will mess with our ExTreeView handling" is 126.
Long Statement,Xwt.WPFBackend,ExTreeViewItem,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ExTreeViewItem.cs,OnGotFocus,The length of the statement  "			//We can't allow TreeViewItem(our base class) to get this message(OnGotFocus) because it will also select this item which we don't want" is 135.
Long Statement,Xwt.WPFBackend,ImageHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,CreateMultiResolutionImage,The length of the statement  "			var frames = images.Cast<WpfImage> ().Select (img => new WpfImage.ImageFrame (img.Frames[0].ImageSource' f.Width' f.Height));" is 125.
Long Statement,Xwt.WPFBackend,ImageHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,GetBitmapPixel,The length of the statement  "			return Xwt.Drawing.Color.FromBytes (wpfImage.PixelData[offset + 2]' wpfImage.PixelData[offset + 1]' wpfImage.PixelData[offset]' wpfImage.PixelData[offset + 3]);" is 160.
Long Statement,Xwt.WPFBackend,WpfImage,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,FindFrame,The length of the statement  "				var resolutionMatch = ((double)f.ImageSource.Width * (double)f.ImageSource.Height) / ((double)width * (double)height * scaleFactor);" is 132.
Long Statement,Xwt.WPFBackend,WpfImage,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,FindFrame,The length of the statement  "					(bestResolutionMatch >= 1 && resolutionMatch >= 1 && resolutionMatch <= bestResolutionMatch && (sizeMatch >= bestSizeMatch))) {" is 127.
Long Statement,Xwt.WPFBackend,WpfImage,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,GetBestFrame,The length of the statement  "			return GetBestFrame (actx' scaleFactor' new ImageDescription { Alpha = 1.0' Size = new Size (width' height) }' forceExactSize);" is 127.
Long Statement,Xwt.WPFBackend,WpfImage,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,GetBestFrame,The length of the statement  "			if (f == null || (forceExactSize && (Math.Abs (f.Width - width * scaleFactor) > 0.01 || Math.Abs (f.Height - height * scaleFactor) > 0.01)))" is 140.
Long Statement,Xwt.WPFBackend,WpfImage,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,RenderFrame,The length of the statement  "			SWMI.RenderTargetBitmap bmp = new SWMI.RenderTargetBitmap ((int)(idesc.Size.Width * scaleFactor)' (int)(idesc.Size.Height * scaleFactor)' 96' 96' PixelFormats.Pbgra32);" is 168.
Long Statement,Xwt.WPFBackend,WpfImage,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,Draw,The length of the statement  "				// When an image is a single bitmap that doesn't have the same intrinsic size as the drawing size' dc.DrawImage makes a very poor job of down/up scaling it." is 156.
Long Statement,Xwt.WPFBackend,WpfImage,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,Draw,The length of the statement  "				if (bmpImage != null && (Math.Abs (bmpImage.PixelHeight - scaledHeight) > 0.001 || Math.Abs (bmpImage.PixelWidth - scaledWidth) > 0.001))" is 137.
Long Statement,Xwt.WPFBackend,WpfImage,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,Draw,The length of the statement  "					f = new TransformedBitmap (bmpImage' new ScaleTransform (scaledWidth / bmpImage.PixelWidth' scaledHeight / bmpImage.PixelHeight));" is 130.
Long Statement,Xwt.WPFBackend,LabelBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\LabelBackend.cs,GenerateBlocks,The length of the statement  "					var dec = new TextDecoration (TextDecorationLocation.Underline' null' 0' TextDecorationUnit.FontRecommended' TextDecorationUnit.FontRecommended); " is 145.
Long Statement,Xwt.WPFBackend,LabelBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\LabelBackend.cs,GenerateBlocks,The length of the statement  "					var dec = new TextDecoration (TextDecorationLocation.Strikethrough' null' 0' TextDecorationUnit.FontRecommended' TextDecorationUnit.FontRecommended); " is 149.
Long Statement,Xwt.WPFBackend,ListViewBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ListViewBackend.cs,AddColumn,The length of the statement  "				column.HeaderTemplate = new DataTemplate { VisualTree = CellUtil.CreateBoundCellRenderer (Context' this' col.HeaderView) }; " is 123.
Long Statement,Xwt.WPFBackend,ListViewBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ListViewBackend.cs,UpdateColumn,The length of the statement  "                column.HeaderTemplate = new DataTemplate { VisualTree = CellUtil.CreateBoundCellRenderer(Context' this' col.HeaderView) }; " is 122.
Long Statement,Xwt.WPFBackend,ListViewBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ListViewBackend.cs,GetCellBounds,The length of the statement  "					var position = cellpresenter.TransformToAncestor (ListView).Transform(new System.Windows.Point(-ListView.Padding.Left' 0)); " is 123.
Long Statement,Xwt.WPFBackend,TreeViewBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\TreeViewBackend.cs,UpdateColumn,The length of the statement  "				style.Setters.Add(new Setter(Control.HorizontalContentAlignmentProperty' Util.ToWpfHorizontalAlignment(column.Alignment)));" is 123.
Long Statement,Xwt.WPFBackend,TreeViewBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\TreeViewBackend.cs,GetCellBounds,The length of the statement  "					var cellpresenter = VisualTreeHelper.GetChild (childStack' cellViews [cell].ColumnIndex == 0 ? cellViews [cell].CellIndex + 1 : cellViews [cell].CellIndex) as FrameworkElement;" is 176.
Long Statement,Xwt.WPFBackend,WidgetBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WidgetBackend.cs,GetPreferredSize,The length of the statement  "			GetWidgetDesiredSize (widthConstraint.IsConstrained ? widthConstraint.AvailableSize : Double.PositiveInfinity' heightConstraint.IsConstrained ? heightConstraint.AvailableSize : Double.PositiveInfinity' out size); " is 212.
Long Statement,Xwt.WPFBackend,WidgetBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WidgetBackend.cs,MeasureOverride,The length of the statement  "					// if we are not given a constraint. If there is a width constraint' we'll use that constraint value for calculating the height " is 127.
Long Statement,Xwt.WPFBackend,WidgetBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WidgetBackend.cs,SetChildPlacement,The length of the statement  "			w.Widget.Margin = new Thickness (w.Frontend.MarginLeft' w.Frontend.MarginTop' w.Frontend.MarginRight' w.Frontend.MarginBottom); " is 127.
Long Statement,Xwt.WPFBackend,WindowFrameBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WindowFrameBackend.cs,ToNonClientRect,The length of the statement  "			// We can't rely then on ToNonClientRect and ToClientRect to return 100% correct values' so they are not used for calculating " is 125.
Long Statement,Xwt.WPFBackend,WindowFrameBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WindowFrameBackend.cs,ToNonClientRect,The length of the statement  "			// the required client area. However' the result of those methods is good enough for calculating the position of the window. " is 124.
Long Statement,Xwt.WPFBackend,WPFEngine,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WPFEngine.cs,RenderWidget,The length of the statement  "				RenderTargetBitmap rtb = new RenderTargetBitmap ((int)w.ActualWidth' (int)w.ActualHeight' 96' 96' PixelFormats.Pbgra32); " is 120.
Long Statement,Xwt.WPFBackend,CustomScrollViewPort,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\CustomScrollViewPort.cs,UpdateCustomExtent,The length of the statement  "			var newExtent = new WSize (horizontalBackend.UpperValue - horizontalBackend.LowerValue' verticalBackend.UpperValue - verticalBackend.LowerValue);" is 145.
Long Statement,Xwt.WPFBackend,RichTextBuffer,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\RichTextViewBackend.cs,GenerateBlocks,The length of the statement  "						var dec = new TextDecoration(TextDecorationLocation.Underline' null' 0' TextDecorationUnit.FontRecommended' TextDecorationUnit.FontRecommended); " is 144.
Long Statement,Xwt.WPFBackend,RichTextBuffer,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\RichTextViewBackend.cs,GenerateBlocks,The length of the statement  "						var dec = new TextDecoration(TextDecorationLocation.Strikethrough' null' 0' TextDecorationUnit.FontRecommended' TextDecorationUnit.FontRecommended); " is 148.
Long Statement,Xwt.WPFBackend,WebViewBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WebViewBackend.cs,HandleViewLoaded,The length of the statement  "				mshtmlBrowserField = typeof(SWC.WebBrowser).GetField("_axIWebBrowser2"' BindingFlags.Instance | BindingFlags.NonPublic); " is 120.
Long Statement,Xwt.WPFBackend.Utilities,CellUtil,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend.Utilities\CellUtil.cs,CreateBoundColumnTemplate,The length of the statement  "				factory.SetValue (FrameworkElement.HorizontalAlignmentProperty' view.Expands ? HorizontalAlignment.Stretch : HorizontalAlignment.Left);" is 135.
Long Statement,Xwt.WPFBackend.Utilities,CellUtil,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend.Utilities\CellUtil.cs,CreateBoundColumnTemplate,The length of the statement  "				column.SetValue (ColumnDefinition.WidthProperty' new GridLength (1' view.Expands ? GridUnitType.Star : GridUnitType.Auto));" is 123.
Long Statement,Xwt.WPFBackend.Utilities,CellUtil,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend.Utilities\CellUtil.cs,CreateBoundCellRenderer,The length of the statement  "						factory.SetBinding(SWC.TextBlock.TextProperty' new Binding(dataPath + "[" + textView.MarkupField.Index + "]") { Converter = new MarkupToPlainTextConverter () });" is 161.
Long Statement,Xwt.WPFBackend.Utilities,CellUtil,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend.Utilities\CellUtil.cs,CreateBoundCellRenderer,The length of the statement  "					factory.SetBinding(SWC.CheckBox.IsThreeStateProperty' new Binding(dataPath + "[" + cellView.AllowMixedField.Index + "]"));" is 122.
Long Statement,Xwt.WPFBackend.Utilities,CellUtil,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend.Utilities\CellUtil.cs,CreateBoundCellRenderer,The length of the statement  "					factory.SetBinding(SWC.Primitives.ToggleButton.IsCheckedProperty' new Binding(dataPath + "[" + radioButton.ActiveField.Index + "]"));" is 133.
Complex Conditional,Xwt.WPFBackend,WpfImage,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,FindFrame,The conditional expression  "best == null || 					(bestResolutionMatch < 1 && resolutionMatch > bestResolutionMatch) || 					(bestResolutionMatch >= 1 && resolutionMatch >= 1 && resolutionMatch <= bestResolutionMatch && (sizeMatch >= bestSizeMatch))"  is complex.
Complex Conditional,Xwt.WPFBackend,WpfImage,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,GetBestFrame,The conditional expression  "f == null || (forceExactSize && (Math.Abs (f.Width - width * scaleFactor) > 0.01 || Math.Abs (f.Height - height * scaleFactor) > 0.01))"  is complex.
Complex Conditional,Xwt.WPFBackend,WindowsSpinButton,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WindowsSpinButton.xaml.cs,textBox_PreviewKeyUp,The conditional expression  "e.Key == Key.PageUp || e.Key == Key.PageDown || e.Key == Key.Down || e.Key == Key.Up"  is complex.
Empty Catch Block,Xwt.WPFBackend,WebViewBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WebViewBackend.cs,GetTitle,The method has an empty catch block.
Magic Number,Xwt.WPFBackend,AlertDialogBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\AlertDialogBackend.cs,Run,The following statement contains a magic number: if (ConvertButtons (message.Buttons' out buttons) && message.Options.Count == 0) {  				// Use a system message box  				if (message.SecondaryText == null)  					message.SecondaryText = String.Empty;  				else {  					message.Text = message.Text + "\r\n\r\n" + message.SecondaryText;  					message.SecondaryText = String.Empty;  				}  				var parent =  context.Toolkit.GetNativeWindow(transientFor) as System.Windows.Window;  				if (parent != null) {  					this.dialogResult = MessageBox.Show (parent' message.Text' message.SecondaryText'  														this.buttons' this.icon' this.defaultResult' this.options);  				}  				else {  					this.dialogResult = MessageBox.Show (message.Text' message.SecondaryText' this.buttons'  														this.icon' this.defaultResult' this.options);  				}  				return ConvertResultToCommand (this.dialogResult);  			}  			else {  				// Custom message box required  				Dialog dlg = new Dialog ();  				dlg.Resizable = false;  				dlg.Padding = 0;  				HBox mainBox = new HBox { Margin = 25 };    				if (message.Icon != null) {  					var image = new ImageView (message.Icon.WithSize (32'32));  					mainBox.PackStart (image' vpos: WidgetPlacement.Start);  				}  				VBox box = new VBox () { Margin = 3' MarginLeft = 8' Spacing = 15 };  				mainBox.PackStart (box' true);  				var text = new Label {  					Text = message.Text ?? ""  				};  				Label stext = null;  				box.PackStart (text);  				if (!string.IsNullOrEmpty (message.SecondaryText)) {  					stext = new Label {  						Text = message.SecondaryText  					};  					box.PackStart (stext);  				}  				foreach (var option in message.Options) {  					var check = new CheckBox (option.Text);  					check.Active = option.Value;  					box.PackStart(check);  					check.Toggled += (sender' e) => message.SetOptionValue(option.Id' check.Active);  				}  				dlg.Buttons.Add (message.Buttons.ToArray ());  				if (message.DefaultButton >= 0 && message.DefaultButton < message.Buttons.Count)  					dlg.DefaultCommand = message.Buttons[message.DefaultButton];  				if (mainBox.Surface.GetPreferredSize (true).Width > 480) {  					text.Wrap = WrapMode.Word;  					if (stext != null)  						stext.Wrap = WrapMode.Word;  					mainBox.WidthRequest = 480;  				}  				var s = mainBox.Surface.GetPreferredSize (true);    				dlg.Content = mainBox;  				return dlg.Run ();  			}
Magic Number,Xwt.WPFBackend,AlertDialogBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\AlertDialogBackend.cs,Run,The following statement contains a magic number: if (ConvertButtons (message.Buttons' out buttons) && message.Options.Count == 0) {  				// Use a system message box  				if (message.SecondaryText == null)  					message.SecondaryText = String.Empty;  				else {  					message.Text = message.Text + "\r\n\r\n" + message.SecondaryText;  					message.SecondaryText = String.Empty;  				}  				var parent =  context.Toolkit.GetNativeWindow(transientFor) as System.Windows.Window;  				if (parent != null) {  					this.dialogResult = MessageBox.Show (parent' message.Text' message.SecondaryText'  														this.buttons' this.icon' this.defaultResult' this.options);  				}  				else {  					this.dialogResult = MessageBox.Show (message.Text' message.SecondaryText' this.buttons'  														this.icon' this.defaultResult' this.options);  				}  				return ConvertResultToCommand (this.dialogResult);  			}  			else {  				// Custom message box required  				Dialog dlg = new Dialog ();  				dlg.Resizable = false;  				dlg.Padding = 0;  				HBox mainBox = new HBox { Margin = 25 };    				if (message.Icon != null) {  					var image = new ImageView (message.Icon.WithSize (32'32));  					mainBox.PackStart (image' vpos: WidgetPlacement.Start);  				}  				VBox box = new VBox () { Margin = 3' MarginLeft = 8' Spacing = 15 };  				mainBox.PackStart (box' true);  				var text = new Label {  					Text = message.Text ?? ""  				};  				Label stext = null;  				box.PackStart (text);  				if (!string.IsNullOrEmpty (message.SecondaryText)) {  					stext = new Label {  						Text = message.SecondaryText  					};  					box.PackStart (stext);  				}  				foreach (var option in message.Options) {  					var check = new CheckBox (option.Text);  					check.Active = option.Value;  					box.PackStart(check);  					check.Toggled += (sender' e) => message.SetOptionValue(option.Id' check.Active);  				}  				dlg.Buttons.Add (message.Buttons.ToArray ());  				if (message.DefaultButton >= 0 && message.DefaultButton < message.Buttons.Count)  					dlg.DefaultCommand = message.Buttons[message.DefaultButton];  				if (mainBox.Surface.GetPreferredSize (true).Width > 480) {  					text.Wrap = WrapMode.Word;  					if (stext != null)  						stext.Wrap = WrapMode.Word;  					mainBox.WidthRequest = 480;  				}  				var s = mainBox.Surface.GetPreferredSize (true);    				dlg.Content = mainBox;  				return dlg.Run ();  			}
Magic Number,Xwt.WPFBackend,AlertDialogBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\AlertDialogBackend.cs,Run,The following statement contains a magic number: if (ConvertButtons (message.Buttons' out buttons) && message.Options.Count == 0) {  				// Use a system message box  				if (message.SecondaryText == null)  					message.SecondaryText = String.Empty;  				else {  					message.Text = message.Text + "\r\n\r\n" + message.SecondaryText;  					message.SecondaryText = String.Empty;  				}  				var parent =  context.Toolkit.GetNativeWindow(transientFor) as System.Windows.Window;  				if (parent != null) {  					this.dialogResult = MessageBox.Show (parent' message.Text' message.SecondaryText'  														this.buttons' this.icon' this.defaultResult' this.options);  				}  				else {  					this.dialogResult = MessageBox.Show (message.Text' message.SecondaryText' this.buttons'  														this.icon' this.defaultResult' this.options);  				}  				return ConvertResultToCommand (this.dialogResult);  			}  			else {  				// Custom message box required  				Dialog dlg = new Dialog ();  				dlg.Resizable = false;  				dlg.Padding = 0;  				HBox mainBox = new HBox { Margin = 25 };    				if (message.Icon != null) {  					var image = new ImageView (message.Icon.WithSize (32'32));  					mainBox.PackStart (image' vpos: WidgetPlacement.Start);  				}  				VBox box = new VBox () { Margin = 3' MarginLeft = 8' Spacing = 15 };  				mainBox.PackStart (box' true);  				var text = new Label {  					Text = message.Text ?? ""  				};  				Label stext = null;  				box.PackStart (text);  				if (!string.IsNullOrEmpty (message.SecondaryText)) {  					stext = new Label {  						Text = message.SecondaryText  					};  					box.PackStart (stext);  				}  				foreach (var option in message.Options) {  					var check = new CheckBox (option.Text);  					check.Active = option.Value;  					box.PackStart(check);  					check.Toggled += (sender' e) => message.SetOptionValue(option.Id' check.Active);  				}  				dlg.Buttons.Add (message.Buttons.ToArray ());  				if (message.DefaultButton >= 0 && message.DefaultButton < message.Buttons.Count)  					dlg.DefaultCommand = message.Buttons[message.DefaultButton];  				if (mainBox.Surface.GetPreferredSize (true).Width > 480) {  					text.Wrap = WrapMode.Word;  					if (stext != null)  						stext.Wrap = WrapMode.Word;  					mainBox.WidthRequest = 480;  				}  				var s = mainBox.Surface.GetPreferredSize (true);    				dlg.Content = mainBox;  				return dlg.Run ();  			}
Magic Number,Xwt.WPFBackend,AlertDialogBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\AlertDialogBackend.cs,Run,The following statement contains a magic number: if (ConvertButtons (message.Buttons' out buttons) && message.Options.Count == 0) {  				// Use a system message box  				if (message.SecondaryText == null)  					message.SecondaryText = String.Empty;  				else {  					message.Text = message.Text + "\r\n\r\n" + message.SecondaryText;  					message.SecondaryText = String.Empty;  				}  				var parent =  context.Toolkit.GetNativeWindow(transientFor) as System.Windows.Window;  				if (parent != null) {  					this.dialogResult = MessageBox.Show (parent' message.Text' message.SecondaryText'  														this.buttons' this.icon' this.defaultResult' this.options);  				}  				else {  					this.dialogResult = MessageBox.Show (message.Text' message.SecondaryText' this.buttons'  														this.icon' this.defaultResult' this.options);  				}  				return ConvertResultToCommand (this.dialogResult);  			}  			else {  				// Custom message box required  				Dialog dlg = new Dialog ();  				dlg.Resizable = false;  				dlg.Padding = 0;  				HBox mainBox = new HBox { Margin = 25 };    				if (message.Icon != null) {  					var image = new ImageView (message.Icon.WithSize (32'32));  					mainBox.PackStart (image' vpos: WidgetPlacement.Start);  				}  				VBox box = new VBox () { Margin = 3' MarginLeft = 8' Spacing = 15 };  				mainBox.PackStart (box' true);  				var text = new Label {  					Text = message.Text ?? ""  				};  				Label stext = null;  				box.PackStart (text);  				if (!string.IsNullOrEmpty (message.SecondaryText)) {  					stext = new Label {  						Text = message.SecondaryText  					};  					box.PackStart (stext);  				}  				foreach (var option in message.Options) {  					var check = new CheckBox (option.Text);  					check.Active = option.Value;  					box.PackStart(check);  					check.Toggled += (sender' e) => message.SetOptionValue(option.Id' check.Active);  				}  				dlg.Buttons.Add (message.Buttons.ToArray ());  				if (message.DefaultButton >= 0 && message.DefaultButton < message.Buttons.Count)  					dlg.DefaultCommand = message.Buttons[message.DefaultButton];  				if (mainBox.Surface.GetPreferredSize (true).Width > 480) {  					text.Wrap = WrapMode.Word;  					if (stext != null)  						stext.Wrap = WrapMode.Word;  					mainBox.WidthRequest = 480;  				}  				var s = mainBox.Surface.GetPreferredSize (true);    				dlg.Content = mainBox;  				return dlg.Run ();  			}
Magic Number,Xwt.WPFBackend,AlertDialogBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\AlertDialogBackend.cs,Run,The following statement contains a magic number: if (ConvertButtons (message.Buttons' out buttons) && message.Options.Count == 0) {  				// Use a system message box  				if (message.SecondaryText == null)  					message.SecondaryText = String.Empty;  				else {  					message.Text = message.Text + "\r\n\r\n" + message.SecondaryText;  					message.SecondaryText = String.Empty;  				}  				var parent =  context.Toolkit.GetNativeWindow(transientFor) as System.Windows.Window;  				if (parent != null) {  					this.dialogResult = MessageBox.Show (parent' message.Text' message.SecondaryText'  														this.buttons' this.icon' this.defaultResult' this.options);  				}  				else {  					this.dialogResult = MessageBox.Show (message.Text' message.SecondaryText' this.buttons'  														this.icon' this.defaultResult' this.options);  				}  				return ConvertResultToCommand (this.dialogResult);  			}  			else {  				// Custom message box required  				Dialog dlg = new Dialog ();  				dlg.Resizable = false;  				dlg.Padding = 0;  				HBox mainBox = new HBox { Margin = 25 };    				if (message.Icon != null) {  					var image = new ImageView (message.Icon.WithSize (32'32));  					mainBox.PackStart (image' vpos: WidgetPlacement.Start);  				}  				VBox box = new VBox () { Margin = 3' MarginLeft = 8' Spacing = 15 };  				mainBox.PackStart (box' true);  				var text = new Label {  					Text = message.Text ?? ""  				};  				Label stext = null;  				box.PackStart (text);  				if (!string.IsNullOrEmpty (message.SecondaryText)) {  					stext = new Label {  						Text = message.SecondaryText  					};  					box.PackStart (stext);  				}  				foreach (var option in message.Options) {  					var check = new CheckBox (option.Text);  					check.Active = option.Value;  					box.PackStart(check);  					check.Toggled += (sender' e) => message.SetOptionValue(option.Id' check.Active);  				}  				dlg.Buttons.Add (message.Buttons.ToArray ());  				if (message.DefaultButton >= 0 && message.DefaultButton < message.Buttons.Count)  					dlg.DefaultCommand = message.Buttons[message.DefaultButton];  				if (mainBox.Surface.GetPreferredSize (true).Width > 480) {  					text.Wrap = WrapMode.Word;  					if (stext != null)  						stext.Wrap = WrapMode.Word;  					mainBox.WidthRequest = 480;  				}  				var s = mainBox.Surface.GetPreferredSize (true);    				dlg.Content = mainBox;  				return dlg.Run ();  			}
Magic Number,Xwt.WPFBackend,AlertDialogBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\AlertDialogBackend.cs,Run,The following statement contains a magic number: if (ConvertButtons (message.Buttons' out buttons) && message.Options.Count == 0) {  				// Use a system message box  				if (message.SecondaryText == null)  					message.SecondaryText = String.Empty;  				else {  					message.Text = message.Text + "\r\n\r\n" + message.SecondaryText;  					message.SecondaryText = String.Empty;  				}  				var parent =  context.Toolkit.GetNativeWindow(transientFor) as System.Windows.Window;  				if (parent != null) {  					this.dialogResult = MessageBox.Show (parent' message.Text' message.SecondaryText'  														this.buttons' this.icon' this.defaultResult' this.options);  				}  				else {  					this.dialogResult = MessageBox.Show (message.Text' message.SecondaryText' this.buttons'  														this.icon' this.defaultResult' this.options);  				}  				return ConvertResultToCommand (this.dialogResult);  			}  			else {  				// Custom message box required  				Dialog dlg = new Dialog ();  				dlg.Resizable = false;  				dlg.Padding = 0;  				HBox mainBox = new HBox { Margin = 25 };    				if (message.Icon != null) {  					var image = new ImageView (message.Icon.WithSize (32'32));  					mainBox.PackStart (image' vpos: WidgetPlacement.Start);  				}  				VBox box = new VBox () { Margin = 3' MarginLeft = 8' Spacing = 15 };  				mainBox.PackStart (box' true);  				var text = new Label {  					Text = message.Text ?? ""  				};  				Label stext = null;  				box.PackStart (text);  				if (!string.IsNullOrEmpty (message.SecondaryText)) {  					stext = new Label {  						Text = message.SecondaryText  					};  					box.PackStart (stext);  				}  				foreach (var option in message.Options) {  					var check = new CheckBox (option.Text);  					check.Active = option.Value;  					box.PackStart(check);  					check.Toggled += (sender' e) => message.SetOptionValue(option.Id' check.Active);  				}  				dlg.Buttons.Add (message.Buttons.ToArray ());  				if (message.DefaultButton >= 0 && message.DefaultButton < message.Buttons.Count)  					dlg.DefaultCommand = message.Buttons[message.DefaultButton];  				if (mainBox.Surface.GetPreferredSize (true).Width > 480) {  					text.Wrap = WrapMode.Word;  					if (stext != null)  						stext.Wrap = WrapMode.Word;  					mainBox.WidthRequest = 480;  				}  				var s = mainBox.Surface.GetPreferredSize (true);    				dlg.Content = mainBox;  				return dlg.Run ();  			}
Magic Number,Xwt.WPFBackend,AlertDialogBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\AlertDialogBackend.cs,Run,The following statement contains a magic number: if (ConvertButtons (message.Buttons' out buttons) && message.Options.Count == 0) {  				// Use a system message box  				if (message.SecondaryText == null)  					message.SecondaryText = String.Empty;  				else {  					message.Text = message.Text + "\r\n\r\n" + message.SecondaryText;  					message.SecondaryText = String.Empty;  				}  				var parent =  context.Toolkit.GetNativeWindow(transientFor) as System.Windows.Window;  				if (parent != null) {  					this.dialogResult = MessageBox.Show (parent' message.Text' message.SecondaryText'  														this.buttons' this.icon' this.defaultResult' this.options);  				}  				else {  					this.dialogResult = MessageBox.Show (message.Text' message.SecondaryText' this.buttons'  														this.icon' this.defaultResult' this.options);  				}  				return ConvertResultToCommand (this.dialogResult);  			}  			else {  				// Custom message box required  				Dialog dlg = new Dialog ();  				dlg.Resizable = false;  				dlg.Padding = 0;  				HBox mainBox = new HBox { Margin = 25 };    				if (message.Icon != null) {  					var image = new ImageView (message.Icon.WithSize (32'32));  					mainBox.PackStart (image' vpos: WidgetPlacement.Start);  				}  				VBox box = new VBox () { Margin = 3' MarginLeft = 8' Spacing = 15 };  				mainBox.PackStart (box' true);  				var text = new Label {  					Text = message.Text ?? ""  				};  				Label stext = null;  				box.PackStart (text);  				if (!string.IsNullOrEmpty (message.SecondaryText)) {  					stext = new Label {  						Text = message.SecondaryText  					};  					box.PackStart (stext);  				}  				foreach (var option in message.Options) {  					var check = new CheckBox (option.Text);  					check.Active = option.Value;  					box.PackStart(check);  					check.Toggled += (sender' e) => message.SetOptionValue(option.Id' check.Active);  				}  				dlg.Buttons.Add (message.Buttons.ToArray ());  				if (message.DefaultButton >= 0 && message.DefaultButton < message.Buttons.Count)  					dlg.DefaultCommand = message.Buttons[message.DefaultButton];  				if (mainBox.Surface.GetPreferredSize (true).Width > 480) {  					text.Wrap = WrapMode.Word;  					if (stext != null)  						stext.Wrap = WrapMode.Word;  					mainBox.WidthRequest = 480;  				}  				var s = mainBox.Surface.GetPreferredSize (true);    				dlg.Content = mainBox;  				return dlg.Run ();  			}
Magic Number,Xwt.WPFBackend,AlertDialogBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\AlertDialogBackend.cs,Run,The following statement contains a magic number: if (ConvertButtons (message.Buttons' out buttons) && message.Options.Count == 0) {  				// Use a system message box  				if (message.SecondaryText == null)  					message.SecondaryText = String.Empty;  				else {  					message.Text = message.Text + "\r\n\r\n" + message.SecondaryText;  					message.SecondaryText = String.Empty;  				}  				var parent =  context.Toolkit.GetNativeWindow(transientFor) as System.Windows.Window;  				if (parent != null) {  					this.dialogResult = MessageBox.Show (parent' message.Text' message.SecondaryText'  														this.buttons' this.icon' this.defaultResult' this.options);  				}  				else {  					this.dialogResult = MessageBox.Show (message.Text' message.SecondaryText' this.buttons'  														this.icon' this.defaultResult' this.options);  				}  				return ConvertResultToCommand (this.dialogResult);  			}  			else {  				// Custom message box required  				Dialog dlg = new Dialog ();  				dlg.Resizable = false;  				dlg.Padding = 0;  				HBox mainBox = new HBox { Margin = 25 };    				if (message.Icon != null) {  					var image = new ImageView (message.Icon.WithSize (32'32));  					mainBox.PackStart (image' vpos: WidgetPlacement.Start);  				}  				VBox box = new VBox () { Margin = 3' MarginLeft = 8' Spacing = 15 };  				mainBox.PackStart (box' true);  				var text = new Label {  					Text = message.Text ?? ""  				};  				Label stext = null;  				box.PackStart (text);  				if (!string.IsNullOrEmpty (message.SecondaryText)) {  					stext = new Label {  						Text = message.SecondaryText  					};  					box.PackStart (stext);  				}  				foreach (var option in message.Options) {  					var check = new CheckBox (option.Text);  					check.Active = option.Value;  					box.PackStart(check);  					check.Toggled += (sender' e) => message.SetOptionValue(option.Id' check.Active);  				}  				dlg.Buttons.Add (message.Buttons.ToArray ());  				if (message.DefaultButton >= 0 && message.DefaultButton < message.Buttons.Count)  					dlg.DefaultCommand = message.Buttons[message.DefaultButton];  				if (mainBox.Surface.GetPreferredSize (true).Width > 480) {  					text.Wrap = WrapMode.Word;  					if (stext != null)  						stext.Wrap = WrapMode.Word;  					mainBox.WidthRequest = 480;  				}  				var s = mainBox.Surface.GetPreferredSize (true);    				dlg.Content = mainBox;  				return dlg.Run ();  			}
Magic Number,Xwt.WPFBackend,AlertDialogBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\AlertDialogBackend.cs,ConvertButtons,The following statement contains a magic number: switch (buttons.Count){  			case 1:  					if (buttons.Contains (Command.Ok)) {  						result = MessageBoxButton.OK;  						return true;  					}  					break;  			case 2:  				if (buttons.Contains (Command.Ok) && buttons.Contains (Command.Cancel)) {  					result = MessageBoxButton.OKCancel;  					return true;  				} else if (buttons.Contains (Command.Yes) && buttons.Contains (Command.No)) {  					result = MessageBoxButton.YesNo;  					return true;  				}  				break;  			case 3:  				if (buttons.Contains (Command.Yes) && buttons.Contains (Command.No) && buttons.Contains (Command.Cancel)) {  					result = MessageBoxButton.YesNoCancel;  					return true;  				}  				break;  			}
Magic Number,Xwt.WPFBackend,AlertDialogBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\AlertDialogBackend.cs,ConvertButtons,The following statement contains a magic number: switch (buttons.Count){  			case 1:  					if (buttons.Contains (Command.Ok)) {  						result = MessageBoxButton.OK;  						return true;  					}  					break;  			case 2:  				if (buttons.Contains (Command.Ok) && buttons.Contains (Command.Cancel)) {  					result = MessageBoxButton.OKCancel;  					return true;  				} else if (buttons.Contains (Command.Yes) && buttons.Contains (Command.No)) {  					result = MessageBoxButton.YesNo;  					return true;  				}  				break;  			case 3:  				if (buttons.Contains (Command.Yes) && buttons.Contains (Command.No) && buttons.Contains (Command.Cancel)) {  					result = MessageBoxButton.YesNoCancel;  					return true;  				}  				break;  			}
Magic Number,Xwt.WPFBackend,PlaceholderTextAdorner,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\PlaceholderTextAdorner.cs,OnRender,The following statement contains a magic number: double ypos = 3' xpos = 6;
Magic Number,Xwt.WPFBackend,PlaceholderTextAdorner,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\PlaceholderTextAdorner.cs,OnRender,The following statement contains a magic number: double ypos = 3' xpos = 6;
Magic Number,Xwt.WPFBackend,PlaceholderTextAdorner,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\PlaceholderTextAdorner.cs,OnRender,The following statement contains a magic number: if (!multiline)  				ypos = (RenderSize.Height - text.Height) / 2;
Magic Number,Xwt.WPFBackend,PlaceholderTextAdorner,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\PlaceholderTextAdorner.cs,OnRender,The following statement contains a magic number: switch (alignment) {  			case TextAlignment.Center:  				xpos = (RenderSize.Width - text.Width) * 0.5;  				break;  			case TextAlignment.Right:  				xpos = (RenderSize.Width - text.Width) - 6;  				break;  			}
Magic Number,Xwt.WPFBackend,PlaceholderTextAdorner,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\PlaceholderTextAdorner.cs,OnRender,The following statement contains a magic number: switch (alignment) {  			case TextAlignment.Center:  				xpos = (RenderSize.Width - text.Width) * 0.5;  				break;  			case TextAlignment.Right:  				xpos = (RenderSize.Width - text.Width) - 6;  				break;  			}
Magic Number,Xwt.WPFBackend,SliderBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\SliderBackend.cs,HandleMouseWheel,The following statement contains a magic number: int jumps = e.Delta / 120;
Magic Number,Xwt.WPFBackend,SliderBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\SliderBackend.cs,ValueChanged,The following statement contains a magic number: if (SnapToTicks && Math.Abs (StepIncrement) > double.Epsilon)  			{  				var offset = Math.Abs (Value) % StepIncrement;  				if (Math.Abs (offset) > double.Epsilon) {  					if (offset > StepIncrement / 2) {  						if (Value >= 0)  							Value += -offset + StepIncrement;  						else  							Value += offset - StepIncrement;  					}  					else  						if (Value >= 0)  							Value -= offset;  						else  							Value += offset;  				}  			}
Magic Number,Xwt.WPFBackend,TextLayoutBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\TextLayoutBackendHandler.cs,Rebuild,The following statement contains a magic number: formattedText = new System.Windows.Media.FormattedText(text' System.Globalization.CultureInfo.CurrentCulture' dir' defaultFont' 36' brush);
Magic Number,Xwt.WPFBackend,WpfImageBuilderBackendHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageBuilderBackendHandler.cs,CreateImage,The following statement contains a magic number: var bmp = new RenderTargetBitmap (visual.Width' visual.Height' ratios.Height * 96' ratios.Width * 96' PixelFormats.Pbgra32);
Magic Number,Xwt.WPFBackend,WpfImageBuilderBackendHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageBuilderBackendHandler.cs,CreateImage,The following statement contains a magic number: var bmp = new RenderTargetBitmap (visual.Width' visual.Height' ratios.Height * 96' ratios.Width * 96' PixelFormats.Pbgra32);
Magic Number,Xwt.WPFBackend,WpfContextBackendHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ContextBackendHandler.cs,Arc,The following statement contains a magic number: if (angle1 > angle2)  				angle2 += (Math.Truncate (angle1 / 360) + 1) * 360;
Magic Number,Xwt.WPFBackend,WpfContextBackendHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ContextBackendHandler.cs,Arc,The following statement contains a magic number: if (angle1 > angle2)  				angle2 += (Math.Truncate (angle1 / 360) + 1) * 360;
Magic Number,Xwt.WPFBackend,WpfContextBackendHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ContextBackendHandler.cs,Arc,The following statement contains a magic number: do {  				nextAngle = angle2 - angle1 < 360 ? angle2 : angle1 + 359;    				var p1 = new SW.Point (xc + radius * Math.Cos (angle1 * Math.PI / 180.0)' yc + radius * Math.Sin (angle1 * Math.PI / 180.0));  				var p2 = new SW.Point (xc + radius * Math.Cos (nextAngle * Math.PI / 180.0)' yc + radius * Math.Sin (nextAngle * Math.PI / 180.0));    				c.ConnectToLastFigure (p1' true);    				var largeArc = inverse ? nextAngle - angle1 < 180 : nextAngle - angle1 > 180;  				var direction = inverse ? SweepDirection.Counterclockwise : SweepDirection.Clockwise;  				c.Path.Segments.Add (new ArcSegment (p2' new SW.Size (radius' radius)' 0' largeArc' direction' true));  				angle1 = nextAngle;  				c.EndPoint = p2;  			}  			while (nextAngle < angle2);
Magic Number,Xwt.WPFBackend,WpfContextBackendHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ContextBackendHandler.cs,Arc,The following statement contains a magic number: do {  				nextAngle = angle2 - angle1 < 360 ? angle2 : angle1 + 359;    				var p1 = new SW.Point (xc + radius * Math.Cos (angle1 * Math.PI / 180.0)' yc + radius * Math.Sin (angle1 * Math.PI / 180.0));  				var p2 = new SW.Point (xc + radius * Math.Cos (nextAngle * Math.PI / 180.0)' yc + radius * Math.Sin (nextAngle * Math.PI / 180.0));    				c.ConnectToLastFigure (p1' true);    				var largeArc = inverse ? nextAngle - angle1 < 180 : nextAngle - angle1 > 180;  				var direction = inverse ? SweepDirection.Counterclockwise : SweepDirection.Clockwise;  				c.Path.Segments.Add (new ArcSegment (p2' new SW.Size (radius' radius)' 0' largeArc' direction' true));  				angle1 = nextAngle;  				c.EndPoint = p2;  			}  			while (nextAngle < angle2);
Magic Number,Xwt.WPFBackend,WpfContextBackendHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ContextBackendHandler.cs,Arc,The following statement contains a magic number: do {  				nextAngle = angle2 - angle1 < 360 ? angle2 : angle1 + 359;    				var p1 = new SW.Point (xc + radius * Math.Cos (angle1 * Math.PI / 180.0)' yc + radius * Math.Sin (angle1 * Math.PI / 180.0));  				var p2 = new SW.Point (xc + radius * Math.Cos (nextAngle * Math.PI / 180.0)' yc + radius * Math.Sin (nextAngle * Math.PI / 180.0));    				c.ConnectToLastFigure (p1' true);    				var largeArc = inverse ? nextAngle - angle1 < 180 : nextAngle - angle1 > 180;  				var direction = inverse ? SweepDirection.Counterclockwise : SweepDirection.Clockwise;  				c.Path.Segments.Add (new ArcSegment (p2' new SW.Size (radius' radius)' 0' largeArc' direction' true));  				angle1 = nextAngle;  				c.EndPoint = p2;  			}  			while (nextAngle < angle2);
Magic Number,Xwt.WPFBackend,WpfContextBackendHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ContextBackendHandler.cs,Arc,The following statement contains a magic number: do {  				nextAngle = angle2 - angle1 < 360 ? angle2 : angle1 + 359;    				var p1 = new SW.Point (xc + radius * Math.Cos (angle1 * Math.PI / 180.0)' yc + radius * Math.Sin (angle1 * Math.PI / 180.0));  				var p2 = new SW.Point (xc + radius * Math.Cos (nextAngle * Math.PI / 180.0)' yc + radius * Math.Sin (nextAngle * Math.PI / 180.0));    				c.ConnectToLastFigure (p1' true);    				var largeArc = inverse ? nextAngle - angle1 < 180 : nextAngle - angle1 > 180;  				var direction = inverse ? SweepDirection.Counterclockwise : SweepDirection.Clockwise;  				c.Path.Segments.Add (new ArcSegment (p2' new SW.Size (radius' radius)' 0' largeArc' direction' true));  				angle1 = nextAngle;  				c.EndPoint = p2;  			}  			while (nextAngle < angle2);
Magic Number,Xwt.WPFBackend,WpfContextBackendHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ContextBackendHandler.cs,Arc,The following statement contains a magic number: do {  				nextAngle = angle2 - angle1 < 360 ? angle2 : angle1 + 359;    				var p1 = new SW.Point (xc + radius * Math.Cos (angle1 * Math.PI / 180.0)' yc + radius * Math.Sin (angle1 * Math.PI / 180.0));  				var p2 = new SW.Point (xc + radius * Math.Cos (nextAngle * Math.PI / 180.0)' yc + radius * Math.Sin (nextAngle * Math.PI / 180.0));    				c.ConnectToLastFigure (p1' true);    				var largeArc = inverse ? nextAngle - angle1 < 180 : nextAngle - angle1 > 180;  				var direction = inverse ? SweepDirection.Counterclockwise : SweepDirection.Clockwise;  				c.Path.Segments.Add (new ArcSegment (p2' new SW.Size (radius' radius)' 0' largeArc' direction' true));  				angle1 = nextAngle;  				c.EndPoint = p2;  			}  			while (nextAngle < angle2);
Magic Number,Xwt.WPFBackend,WpfContextBackendHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ContextBackendHandler.cs,Arc,The following statement contains a magic number: do {  				nextAngle = angle2 - angle1 < 360 ? angle2 : angle1 + 359;    				var p1 = new SW.Point (xc + radius * Math.Cos (angle1 * Math.PI / 180.0)' yc + radius * Math.Sin (angle1 * Math.PI / 180.0));  				var p2 = new SW.Point (xc + radius * Math.Cos (nextAngle * Math.PI / 180.0)' yc + radius * Math.Sin (nextAngle * Math.PI / 180.0));    				c.ConnectToLastFigure (p1' true);    				var largeArc = inverse ? nextAngle - angle1 < 180 : nextAngle - angle1 > 180;  				var direction = inverse ? SweepDirection.Counterclockwise : SweepDirection.Clockwise;  				c.Path.Segments.Add (new ArcSegment (p2' new SW.Size (radius' radius)' 0' largeArc' direction' true));  				angle1 = nextAngle;  				c.EndPoint = p2;  			}  			while (nextAngle < angle2);
Magic Number,Xwt.WPFBackend,WpfContextBackendHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ContextBackendHandler.cs,Arc,The following statement contains a magic number: do {  				nextAngle = angle2 - angle1 < 360 ? angle2 : angle1 + 359;    				var p1 = new SW.Point (xc + radius * Math.Cos (angle1 * Math.PI / 180.0)' yc + radius * Math.Sin (angle1 * Math.PI / 180.0));  				var p2 = new SW.Point (xc + radius * Math.Cos (nextAngle * Math.PI / 180.0)' yc + radius * Math.Sin (nextAngle * Math.PI / 180.0));    				c.ConnectToLastFigure (p1' true);    				var largeArc = inverse ? nextAngle - angle1 < 180 : nextAngle - angle1 > 180;  				var direction = inverse ? SweepDirection.Counterclockwise : SweepDirection.Clockwise;  				c.Path.Segments.Add (new ArcSegment (p2' new SW.Size (radius' radius)' 0' largeArc' direction' true));  				angle1 = nextAngle;  				c.EndPoint = p2;  			}  			while (nextAngle < angle2);
Magic Number,Xwt.WPFBackend,WpfContextBackendHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ContextBackendHandler.cs,Arc,The following statement contains a magic number: do {  				nextAngle = angle2 - angle1 < 360 ? angle2 : angle1 + 359;    				var p1 = new SW.Point (xc + radius * Math.Cos (angle1 * Math.PI / 180.0)' yc + radius * Math.Sin (angle1 * Math.PI / 180.0));  				var p2 = new SW.Point (xc + radius * Math.Cos (nextAngle * Math.PI / 180.0)' yc + radius * Math.Sin (nextAngle * Math.PI / 180.0));    				c.ConnectToLastFigure (p1' true);    				var largeArc = inverse ? nextAngle - angle1 < 180 : nextAngle - angle1 > 180;  				var direction = inverse ? SweepDirection.Counterclockwise : SweepDirection.Clockwise;  				c.Path.Segments.Add (new ArcSegment (p2' new SW.Size (radius' radius)' 0' largeArc' direction' true));  				angle1 = nextAngle;  				c.EndPoint = p2;  			}  			while (nextAngle < angle2);
Magic Number,Xwt.WPFBackend,PopoverBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\PopoverBackend.cs,PopoverBackend,The following statement contains a magic number: Border = new System.Windows.Controls.Border {  				Padding = new Thickness (15' 10' 15' 15)'  				BorderThickness = new Thickness (1)'  				Margin = new System.Windows.Thickness (10)'  				Effect = new System.Windows.Media.Effects.DropShadowEffect () {  					Color = Colors.Black'  					Direction = 270'  					BlurRadius = 15'  					Opacity = .15'  					ShadowDepth = 1'  				}  			};
Magic Number,Xwt.WPFBackend,PopoverBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\PopoverBackend.cs,PopoverBackend,The following statement contains a magic number: Border = new System.Windows.Controls.Border {  				Padding = new Thickness (15' 10' 15' 15)'  				BorderThickness = new Thickness (1)'  				Margin = new System.Windows.Thickness (10)'  				Effect = new System.Windows.Media.Effects.DropShadowEffect () {  					Color = Colors.Black'  					Direction = 270'  					BlurRadius = 15'  					Opacity = .15'  					ShadowDepth = 1'  				}  			};
Magic Number,Xwt.WPFBackend,PopoverBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\PopoverBackend.cs,PopoverBackend,The following statement contains a magic number: Border = new System.Windows.Controls.Border {  				Padding = new Thickness (15' 10' 15' 15)'  				BorderThickness = new Thickness (1)'  				Margin = new System.Windows.Thickness (10)'  				Effect = new System.Windows.Media.Effects.DropShadowEffect () {  					Color = Colors.Black'  					Direction = 270'  					BlurRadius = 15'  					Opacity = .15'  					ShadowDepth = 1'  				}  			};
Magic Number,Xwt.WPFBackend,PopoverBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\PopoverBackend.cs,PopoverBackend,The following statement contains a magic number: Border = new System.Windows.Controls.Border {  				Padding = new Thickness (15' 10' 15' 15)'  				BorderThickness = new Thickness (1)'  				Margin = new System.Windows.Thickness (10)'  				Effect = new System.Windows.Media.Effects.DropShadowEffect () {  					Color = Colors.Black'  					Direction = 270'  					BlurRadius = 15'  					Opacity = .15'  					ShadowDepth = 1'  				}  			};
Magic Number,Xwt.WPFBackend,PopoverBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\PopoverBackend.cs,PopoverBackend,The following statement contains a magic number: Border = new System.Windows.Controls.Border {  				Padding = new Thickness (15' 10' 15' 15)'  				BorderThickness = new Thickness (1)'  				Margin = new System.Windows.Thickness (10)'  				Effect = new System.Windows.Media.Effects.DropShadowEffect () {  					Color = Colors.Black'  					Direction = 270'  					BlurRadius = 15'  					Opacity = .15'  					ShadowDepth = 1'  				}  			};
Magic Number,Xwt.WPFBackend,PopoverBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\PopoverBackend.cs,PopoverBackend,The following statement contains a magic number: Border = new System.Windows.Controls.Border {  				Padding = new Thickness (15' 10' 15' 15)'  				BorderThickness = new Thickness (1)'  				Margin = new System.Windows.Thickness (10)'  				Effect = new System.Windows.Media.Effects.DropShadowEffect () {  					Color = Colors.Black'  					Direction = 270'  					BlurRadius = 15'  					Opacity = .15'  					ShadowDepth = 1'  				}  			};
Magic Number,Xwt.WPFBackend,PopoverBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\PopoverBackend.cs,PopoverBackend,The following statement contains a magic number: Border = new System.Windows.Controls.Border {  				Padding = new Thickness (15' 10' 15' 15)'  				BorderThickness = new Thickness (1)'  				Margin = new System.Windows.Thickness (10)'  				Effect = new System.Windows.Media.Effects.DropShadowEffect () {  					Color = Colors.Black'  					Direction = 270'  					BlurRadius = 15'  					Opacity = .15'  					ShadowDepth = 1'  				}  			};
Magic Number,Xwt.WPFBackend,PopoverBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\PopoverBackend.cs,PopoverBackend,The following statement contains a magic number: Border = new System.Windows.Controls.Border {  				Padding = new Thickness (15' 10' 15' 15)'  				BorderThickness = new Thickness (1)'  				Margin = new System.Windows.Thickness (10)'  				Effect = new System.Windows.Media.Effects.DropShadowEffect () {  					Color = Colors.Black'  					Direction = 270'  					BlurRadius = 15'  					Opacity = .15'  					ShadowDepth = 1'  				}  			};
Magic Number,Xwt.WPFBackend,PopoverBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\PopoverBackend.cs,PopoverBackend,The following statement contains a magic number: BackgroundColor = Xwt.Drawing.Color.FromBytes (230' 230' 230' 230);
Magic Number,Xwt.WPFBackend,PopoverBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\PopoverBackend.cs,PopoverBackend,The following statement contains a magic number: BackgroundColor = Xwt.Drawing.Color.FromBytes (230' 230' 230' 230);
Magic Number,Xwt.WPFBackend,PopoverBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\PopoverBackend.cs,PopoverBackend,The following statement contains a magic number: BackgroundColor = Xwt.Drawing.Color.FromBytes (230' 230' 230' 230);
Magic Number,Xwt.WPFBackend,PopoverBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\PopoverBackend.cs,PopoverBackend,The following statement contains a magic number: BackgroundColor = Xwt.Drawing.Color.FromBytes (230' 230' 230' 230);
Magic Number,Xwt.WPFBackend,PopoverBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\PopoverBackend.cs,Show,The following statement contains a magic number: NativeWidget.CustomPopupPlacementCallback = (popupSize' targetSize' offset) => {  				System.Windows.Point location;  				if (ActualPosition == Popover.Position.Top)  					location = new System.Windows.Point (positionRect.Left - popupSize.Width / 2'  					                                     positionRect.Height > 0 ? positionRect.Bottom : targetSize.Height);  				else  					location = new System.Windows.Point (positionRect.Left - popupSize.Width / 2'  					                                     positionRect.Top - popupSize.Height);    				return new[] {  					new System.Windows.Controls.Primitives.CustomPopupPlacement (location' System.Windows.Controls.Primitives.PopupPrimaryAxis.Horizontal)  				};  			};
Magic Number,Xwt.WPFBackend,PopoverBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\PopoverBackend.cs,Show,The following statement contains a magic number: NativeWidget.CustomPopupPlacementCallback = (popupSize' targetSize' offset) => {  				System.Windows.Point location;  				if (ActualPosition == Popover.Position.Top)  					location = new System.Windows.Point (positionRect.Left - popupSize.Width / 2'  					                                     positionRect.Height > 0 ? positionRect.Bottom : targetSize.Height);  				else  					location = new System.Windows.Point (positionRect.Left - popupSize.Width / 2'  					                                     positionRect.Top - popupSize.Height);    				return new[] {  					new System.Windows.Controls.Primitives.CustomPopupPlacement (location' System.Windows.Controls.Primitives.PopupPrimaryAxis.Horizontal)  				};  			};
Magic Number,Xwt.WPFBackend,DialogBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\DialogBackend.cs,DialogBackend,The following statement contains a magic number: panelFactory.SetValue (FrameworkElement.MarginProperty' new Thickness (0' 7' 7' 7));
Magic Number,Xwt.WPFBackend,DialogBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\DialogBackend.cs,DialogBackend,The following statement contains a magic number: panelFactory.SetValue (FrameworkElement.MarginProperty' new Thickness (0' 7' 7' 7));
Magic Number,Xwt.WPFBackend,DialogBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\DialogBackend.cs,DialogBackend,The following statement contains a magic number: panelFactory.SetValue (FrameworkElement.MarginProperty' new Thickness (0' 7' 7' 7));
Magic Number,Xwt.WPFBackend,DialogBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\DialogBackend.cs,DialogBackend,The following statement contains a magic number: panelFactory.SetValue(FrameworkElement.MarginProperty' new Thickness(0' 7' 0' 7));
Magic Number,Xwt.WPFBackend,DialogBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\DialogBackend.cs,DialogBackend,The following statement contains a magic number: panelFactory.SetValue(FrameworkElement.MarginProperty' new Thickness(0' 7' 0' 7));
Magic Number,Xwt.WPFBackend,DialogBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\DialogBackend.cs,DialogBackend,The following statement contains a magic number: ButtonStyle.Setters.Add (new Setter (FrameworkElement.MarginProperty' new Thickness (7' 0' 0' 0)));
Magic Number,Xwt.WPFBackend,DialogBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\DialogBackend.cs,DialogBackend,The following statement contains a magic number: Grid.SetRow (separator' 2);
Magic Number,Xwt.WPFBackend,DialogBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\DialogBackend.cs,DialogBackend,The following statement contains a magic number: Grid.SetColumn(this.rightButtonContainer' 2);
Magic Number,Xwt.WPFBackend,DialogBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\DialogBackend.cs,DialogBackend,The following statement contains a magic number: Grid.SetRow (buttonContainer' 3);
Magic Number,Xwt.WPFBackend,FrameBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\FrameBackend.cs,FrameBackend,The following statement contains a magic number: this.flippedGroupBox.RenderTransformOrigin = new System.Windows.Point (0.5' 0.5);
Magic Number,Xwt.WPFBackend,FrameBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\FrameBackend.cs,FrameBackend,The following statement contains a magic number: this.flippedGroupBox.RenderTransformOrigin = new System.Windows.Point (0.5' 0.5);
Magic Number,Xwt.WPFBackend,ImageHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,LoadFromImageSource,The following statement contains a magic number: if (bmp != null && (bmp.DpiX != 96 || bmp.DpiY != 96))  				return new WpfImage (ConvertBitmapTo96DPI (bmp));
Magic Number,Xwt.WPFBackend,ImageHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,LoadFromImageSource,The following statement contains a magic number: if (bmp != null && (bmp.DpiX != 96 || bmp.DpiY != 96))  				return new WpfImage (ConvertBitmapTo96DPI (bmp));
Magic Number,Xwt.WPFBackend,ImageHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,ConvertBitmapTo96DPI,The following statement contains a magic number: double dpi = 96;
Magic Number,Xwt.WPFBackend,ImageHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,ConvertBitmapTo96DPI,The following statement contains a magic number: int stride = width * (bitmapImage.Format.BitsPerPixel + 7) / 8;
Magic Number,Xwt.WPFBackend,ImageHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,ConvertBitmapTo96DPI,The following statement contains a magic number: int stride = width * (bitmapImage.Format.BitsPerPixel + 7) / 8;
Magic Number,Xwt.WPFBackend,ImageHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,RenderStockIcon,The following statement contains a magic number: if (Environment.OSVersion.Version.Major <= 5) 				throw new NotImplementedException ();
Magic Number,Xwt.WPFBackend,ImageHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,GetBitmapPixel,The following statement contains a magic number: if (img.Format.BitsPerPixel != 32) 				throw new NotSupportedException ("Image format not supported");
Magic Number,Xwt.WPFBackend,ImageHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,GetBitmapPixel,The following statement contains a magic number: return Xwt.Drawing.Color.FromBytes (wpfImage.PixelData[offset + 2]' wpfImage.PixelData[offset + 1]' wpfImage.PixelData[offset]' wpfImage.PixelData[offset + 3]);
Magic Number,Xwt.WPFBackend,ImageHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,GetBitmapPixel,The following statement contains a magic number: return Xwt.Drawing.Color.FromBytes (wpfImage.PixelData[offset + 2]' wpfImage.PixelData[offset + 1]' wpfImage.PixelData[offset]' wpfImage.PixelData[offset + 3]);
Magic Number,Xwt.WPFBackend,ImageHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,SetBitmapPixel,The following statement contains a magic number: if (img.Format.BitsPerPixel != 32) 				throw new NotSupportedException ("Image format not supported");
Magic Number,Xwt.WPFBackend,ImageHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,SetBitmapPixel,The following statement contains a magic number: wpfImage.PixelData[offset] = (byte)(color.Blue * 255);
Magic Number,Xwt.WPFBackend,ImageHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,SetBitmapPixel,The following statement contains a magic number: wpfImage.PixelData[offset + 1] = (byte)(color.Green * 255);
Magic Number,Xwt.WPFBackend,ImageHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,SetBitmapPixel,The following statement contains a magic number: wpfImage.PixelData[offset + 2] = (byte)(color.Red * 255);
Magic Number,Xwt.WPFBackend,ImageHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,SetBitmapPixel,The following statement contains a magic number: wpfImage.PixelData[offset + 2] = (byte)(color.Red * 255);
Magic Number,Xwt.WPFBackend,ImageHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,SetBitmapPixel,The following statement contains a magic number: wpfImage.PixelData[offset + 3] = (byte)(color.Alpha * 255);
Magic Number,Xwt.WPFBackend,ImageHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,SetBitmapPixel,The following statement contains a magic number: wpfImage.PixelData[offset + 3] = (byte)(color.Alpha * 255);
Magic Number,Xwt.WPFBackend,ImageHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,WidthToDPI,The following statement contains a magic number: return pixels * 96 / img.DpiX;
Magic Number,Xwt.WPFBackend,ImageHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,HeightToDPI,The following statement contains a magic number: return pixels * 96 / img.DpiY;
Magic Number,Xwt.WPFBackend,ImageHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,WidthToPixels,The following statement contains a magic number: if (img is SWMI.BitmapSource) { 				var bs = (BitmapSource)img; 				return (bs.DpiX * bs.Width) / 96; 			} 			else 				return img.Width;
Magic Number,Xwt.WPFBackend,ImageHandler,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,HeightToPixels,The following statement contains a magic number: if (img is SWMI.BitmapSource) { 				var bs = (BitmapSource)img; 				return (bs.DpiY * bs.Height) / 96; 			} 			else 				return img.Height;
Magic Number,Xwt.WPFBackend,WpfImage,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,GetPixelOffset,The following statement contains a magic number: return y * Stride + x * ((img.Format.BitsPerPixel + 7) / 8);
Magic Number,Xwt.WPFBackend,WpfImage,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,GetPixelOffset,The following statement contains a magic number: return y * Stride + x * ((img.Format.BitsPerPixel + 7) / 8);
Magic Number,Xwt.WPFBackend,WpfImage,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,AllocatePixelData,The following statement contains a magic number: if (PixelData == null) { 				BitmapSource img = frames[0].ImageSource as BitmapSource; 				var height = (int) ImageHandler.HeightToPixels (img); 				var width = (int) ImageHandler.WidthToPixels (img); 				Stride = (width * img.Format.BitsPerPixel + 7) / 8; 				PixelData = new byte[height * Stride]; 				img.CopyPixels (PixelData' Stride' 0); 			}
Magic Number,Xwt.WPFBackend,WpfImage,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,AllocatePixelData,The following statement contains a magic number: if (PixelData == null) { 				BitmapSource img = frames[0].ImageSource as BitmapSource; 				var height = (int) ImageHandler.HeightToPixels (img); 				var width = (int) ImageHandler.WidthToPixels (img); 				Stride = (width * img.Format.BitsPerPixel + 7) / 8; 				PixelData = new byte[height * Stride]; 				img.CopyPixels (PixelData' Stride' 0); 			}
Magic Number,Xwt.WPFBackend,WpfImage,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,FindFrame,The following statement contains a magic number: foreach (var f in frames) { 				int sizeMatch; 				if (f.Width == width && f.Height == height) { 					if (f.Scale == scaleFactor) 						return f.ImageSource; // Exact match 					sizeMatch = 2; // Exact size 				} 				else if (f.Width >= width && f.Height >= height) 					sizeMatch = 1; // Bigger size 				else 					sizeMatch = 0; // Smaller size  				var resolutionMatch = ((double)f.ImageSource.Width * (double)f.ImageSource.Height) / ((double)width * (double)height * scaleFactor);  				if (best == null || 					(bestResolutionMatch < 1 && resolutionMatch > bestResolutionMatch) || 					(bestResolutionMatch >= 1 && resolutionMatch >= 1 && resolutionMatch <= bestResolutionMatch && (sizeMatch >= bestSizeMatch))) { 					best = f.ImageSource; 					bestSizeMatch = sizeMatch; 					bestResolutionMatch = resolutionMatch; 				} 			}
Magic Number,Xwt.WPFBackend,WpfImage,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,GetBestFrame,The following statement contains a magic number: if (f == null || (forceExactSize && (Math.Abs (f.Width - width * scaleFactor) > 0.01 || Math.Abs (f.Height - height * scaleFactor) > 0.01))) 				return RenderFrame (actx' scaleFactor' idesc); 			else 				return f;
Magic Number,Xwt.WPFBackend,WpfImage,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,GetBestFrame,The following statement contains a magic number: if (f == null || (forceExactSize && (Math.Abs (f.Width - width * scaleFactor) > 0.01 || Math.Abs (f.Height - height * scaleFactor) > 0.01))) 				return RenderFrame (actx' scaleFactor' idesc); 			else 				return f;
Magic Number,Xwt.WPFBackend,WpfImage,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,RenderFrame,The following statement contains a magic number: SWMI.RenderTargetBitmap bmp = new SWMI.RenderTargetBitmap ((int)(idesc.Size.Width * scaleFactor)' (int)(idesc.Size.Height * scaleFactor)' 96' 96' PixelFormats.Pbgra32);
Magic Number,Xwt.WPFBackend,WpfImage,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,RenderFrame,The following statement contains a magic number: SWMI.RenderTargetBitmap bmp = new SWMI.RenderTargetBitmap ((int)(idesc.Size.Width * scaleFactor)' (int)(idesc.Size.Height * scaleFactor)' 96' 96' PixelFormats.Pbgra32);
Magic Number,Xwt.WPFBackend,WpfImage,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,Draw,The following statement contains a magic number: if (drawCallback != null) { 				DrawingContext c = new DrawingContext (dc' scaleFactor); 				actx.InvokeUserCode (delegate { 					drawCallback (c' new Rectangle (x' y' idesc.Size.Width' idesc.Size.Height)' idesc' actx.Toolkit); 				}); 			} 			else { 				if (idesc.Alpha < 1) 					dc.PushOpacity (idesc.Alpha);  				var f = GetBestFrame (actx' scaleFactor' idesc.Size.Width' idesc.Size.Height' false); 				var bmpImage = f as BitmapSource;  				// When an image is a single bitmap that doesn't have the same intrinsic size as the drawing size' dc.DrawImage makes a very poor job of down/up scaling it. 				// Thus we handle this manually by using a TransformedBitmap to handle the conversion in a better way when it's needed.  				var scaledWidth = idesc.Size.Width * scaleFactor; 				var scaledHeight = idesc.Size.Height * scaleFactor; 				if (bmpImage != null && (Math.Abs (bmpImage.PixelHeight - scaledHeight) > 0.001 || Math.Abs (bmpImage.PixelWidth - scaledWidth) > 0.001)) 					f = new TransformedBitmap (bmpImage' new ScaleTransform (scaledWidth / bmpImage.PixelWidth' scaledHeight / bmpImage.PixelHeight));  				dc.DrawImage (f' new Rect (x' y' idesc.Size.Width' idesc.Size.Height));  				if (idesc.Alpha < 1) 					dc.Pop (); 			}
Magic Number,Xwt.WPFBackend,WpfImage,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,Draw,The following statement contains a magic number: if (drawCallback != null) { 				DrawingContext c = new DrawingContext (dc' scaleFactor); 				actx.InvokeUserCode (delegate { 					drawCallback (c' new Rectangle (x' y' idesc.Size.Width' idesc.Size.Height)' idesc' actx.Toolkit); 				}); 			} 			else { 				if (idesc.Alpha < 1) 					dc.PushOpacity (idesc.Alpha);  				var f = GetBestFrame (actx' scaleFactor' idesc.Size.Width' idesc.Size.Height' false); 				var bmpImage = f as BitmapSource;  				// When an image is a single bitmap that doesn't have the same intrinsic size as the drawing size' dc.DrawImage makes a very poor job of down/up scaling it. 				// Thus we handle this manually by using a TransformedBitmap to handle the conversion in a better way when it's needed.  				var scaledWidth = idesc.Size.Width * scaleFactor; 				var scaledHeight = idesc.Size.Height * scaleFactor; 				if (bmpImage != null && (Math.Abs (bmpImage.PixelHeight - scaledHeight) > 0.001 || Math.Abs (bmpImage.PixelWidth - scaledWidth) > 0.001)) 					f = new TransformedBitmap (bmpImage' new ScaleTransform (scaledWidth / bmpImage.PixelWidth' scaledHeight / bmpImage.PixelHeight));  				dc.DrawImage (f' new Rect (x' y' idesc.Size.Width' idesc.Size.Height));  				if (idesc.Alpha < 1) 					dc.Pop (); 			}
Magic Number,Xwt.WPFBackend,ImageBox,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,OnRender,The following statement contains a magic number: if (!image.IsNull) { 				var x = (RenderSize.Width - image.Size.Width) / 2; 				var y = (RenderSize.Height - image.Size.Height) / 2; 				((WpfImage)image.Backend).Draw (actx' dc' this.GetScaleFactor ()' x' y' image); 			}
Magic Number,Xwt.WPFBackend,ImageBox,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ImageHandler.cs,OnRender,The following statement contains a magic number: if (!image.IsNull) { 				var x = (RenderSize.Width - image.Size.Width) / 2; 				var y = (RenderSize.Height - image.Size.Height) / 2; 				((WpfImage)image.Backend).Draw (actx' dc' this.GetScaleFactor ()' x' y' image); 			}
Magic Number,Xwt.WPFBackend,DataConverter,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\DataConverter.cs,ToWpfColor,The following statement contains a magic number: return SW.Media.Color.FromArgb (  				(byte)(color.Alpha * 255.0)'  				(byte)(color.Red * 255.0)'  				(byte)(color.Green * 255.0)'  				(byte)(color.Blue * 255.0));
Magic Number,Xwt.WPFBackend,DataConverter,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\DataConverter.cs,ToWpfColor,The following statement contains a magic number: return SW.Media.Color.FromArgb (  				(byte)(color.Alpha * 255.0)'  				(byte)(color.Red * 255.0)'  				(byte)(color.Green * 255.0)'  				(byte)(color.Blue * 255.0));
Magic Number,Xwt.WPFBackend,DataConverter,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\DataConverter.cs,ToWpfColor,The following statement contains a magic number: return SW.Media.Color.FromArgb (  				(byte)(color.Alpha * 255.0)'  				(byte)(color.Red * 255.0)'  				(byte)(color.Green * 255.0)'  				(byte)(color.Blue * 255.0));
Magic Number,Xwt.WPFBackend,DataConverter,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\DataConverter.cs,ToWpfColor,The following statement contains a magic number: return SW.Media.Color.FromArgb (  				(byte)(color.Alpha * 255.0)'  				(byte)(color.Red * 255.0)'  				(byte)(color.Green * 255.0)'  				(byte)(color.Blue * 255.0));
Magic Number,Xwt.WPFBackend,PanedBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\PanedBackend.cs,Initialize,The following statement contains a magic number: panel2.PanelIndex = 2;
Magic Number,Xwt.WPFBackend,PanedBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\PanedBackend.cs,ArrangeChildren,The following statement contains a magic number: if (panel1.Widget != null && panel2.Widget != null) {    				// If the bounds have changed' we have to calculate a new current position  				if (lastSize != newSize || position == -1) {  					double oldAvailableSize = lastSize - SplitterSize;  					if (position == -1)  						position = availableSize / 2;  					else if (IsFixed (panel2)) {  						var oldPanel2Size = oldAvailableSize - position - SplitterSize;  						position = availableSize - oldPanel2Size - SplitterSize;  					}  					else if (!IsFixed (panel1) && lastSize != 0)  						position = availableSize * (position / oldAvailableSize);  				}    				if (!panel1.Shrink) {  					var w = panel1.WidgetSurface;  					var min = direction == Orientation.Horizontal ? w.GetPreferredSize ().Width: w.GetPreferredSize ().Height;  					if (position < min)  						position = min;  				}  				if (!panel2.Shrink) {  					var w = panel2.WidgetSurface;  					var min = direction == Orientation.Horizontal ? w.GetPreferredSize ().Width : w.GetPreferredSize ().Height;  					if (availableSize - position < min) {  						position = availableSize - min;  					}  				}    				if (position < 0)  					position = 0;  				if (position > availableSize)  					position = availableSize;    				panel1.Size = new GridLength (position' GridUnitType.Star);  				panel2.Size = new GridLength (availableSize - position' GridUnitType.Star);  			} else if (panel1.Widget != null) {  				panel1.Size = new GridLength (1' GridUnitType.Star);  				panel2.Size = new GridLength(0);  			} else if (panel2 != null) {  				panel2.Size = new GridLength(1' GridUnitType.Star);  				panel1.Size = new GridLength(0);  			}
Magic Number,Xwt.WPFBackend,WpfSpinButton,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\SpinnerBackend.cs,WpfSpinButton,The following statement contains a magic number: var width = 25;
Magic Number,Xwt.WPFBackend,WpfSpinButton,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\SpinnerBackend.cs,WpfSpinButton,The following statement contains a magic number: var height = 25;
Magic Number,Xwt.WPFBackend,WpfSpinButton,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\SpinnerBackend.cs,WpfSpinButton,The following statement contains a magic number: for (int i = 0; i < 360; i += 30) {  				// Create the rectangle and centre it in our widget  				var rect = new WpfRectangle { Width = 2' Height = 8' Fill = new SolidColorBrush (Colors.Black)' RadiusX = 1' RadiusY = 1' Opacity = Values[0] };  				WpfCanvas.SetTop (rect' (height - rect.Height) / 2);  				WpfCanvas.SetLeft (rect' (width - rect.Width) / 2);    				// Rotate the element by 'i' degrees' creating a circle out of all the elements  				var group = new TransformGroup ();  				group.Children.Add (new RotateTransform (i' 0.5' -6));  				group.Children.Add (new TranslateTransform (0' 10));  				rect.RenderTransform = group;    				// Set the animation  				var timeline = new DoubleAnimationUsingKeyFrames ();  				Storyboard.SetTarget (timeline' rect);  				Storyboard.SetTargetProperty (timeline' new PropertyPath ("Opacity"));    				var offset = Duration * (i / 360.0);  				for (int j = 0; j < StartTimes.Length; j++) {  					var start = (StartTimes[j] + offset) % Duration;  					timeline.KeyFrames.Add (new EasingDoubleKeyFrame { KeyTime = KeyTime.FromTimeSpan (TimeSpan.FromMilliseconds (start))' Value = Values[j] });  				}  				Storyboard.Children.Add (timeline);  				Children.Add (rect);  			}
Magic Number,Xwt.WPFBackend,WpfSpinButton,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\SpinnerBackend.cs,WpfSpinButton,The following statement contains a magic number: for (int i = 0; i < 360; i += 30) {  				// Create the rectangle and centre it in our widget  				var rect = new WpfRectangle { Width = 2' Height = 8' Fill = new SolidColorBrush (Colors.Black)' RadiusX = 1' RadiusY = 1' Opacity = Values[0] };  				WpfCanvas.SetTop (rect' (height - rect.Height) / 2);  				WpfCanvas.SetLeft (rect' (width - rect.Width) / 2);    				// Rotate the element by 'i' degrees' creating a circle out of all the elements  				var group = new TransformGroup ();  				group.Children.Add (new RotateTransform (i' 0.5' -6));  				group.Children.Add (new TranslateTransform (0' 10));  				rect.RenderTransform = group;    				// Set the animation  				var timeline = new DoubleAnimationUsingKeyFrames ();  				Storyboard.SetTarget (timeline' rect);  				Storyboard.SetTargetProperty (timeline' new PropertyPath ("Opacity"));    				var offset = Duration * (i / 360.0);  				for (int j = 0; j < StartTimes.Length; j++) {  					var start = (StartTimes[j] + offset) % Duration;  					timeline.KeyFrames.Add (new EasingDoubleKeyFrame { KeyTime = KeyTime.FromTimeSpan (TimeSpan.FromMilliseconds (start))' Value = Values[j] });  				}  				Storyboard.Children.Add (timeline);  				Children.Add (rect);  			}
Magic Number,Xwt.WPFBackend,WpfSpinButton,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\SpinnerBackend.cs,WpfSpinButton,The following statement contains a magic number: for (int i = 0; i < 360; i += 30) {  				// Create the rectangle and centre it in our widget  				var rect = new WpfRectangle { Width = 2' Height = 8' Fill = new SolidColorBrush (Colors.Black)' RadiusX = 1' RadiusY = 1' Opacity = Values[0] };  				WpfCanvas.SetTop (rect' (height - rect.Height) / 2);  				WpfCanvas.SetLeft (rect' (width - rect.Width) / 2);    				// Rotate the element by 'i' degrees' creating a circle out of all the elements  				var group = new TransformGroup ();  				group.Children.Add (new RotateTransform (i' 0.5' -6));  				group.Children.Add (new TranslateTransform (0' 10));  				rect.RenderTransform = group;    				// Set the animation  				var timeline = new DoubleAnimationUsingKeyFrames ();  				Storyboard.SetTarget (timeline' rect);  				Storyboard.SetTargetProperty (timeline' new PropertyPath ("Opacity"));    				var offset = Duration * (i / 360.0);  				for (int j = 0; j < StartTimes.Length; j++) {  					var start = (StartTimes[j] + offset) % Duration;  					timeline.KeyFrames.Add (new EasingDoubleKeyFrame { KeyTime = KeyTime.FromTimeSpan (TimeSpan.FromMilliseconds (start))' Value = Values[j] });  				}  				Storyboard.Children.Add (timeline);  				Children.Add (rect);  			}
Magic Number,Xwt.WPFBackend,WpfSpinButton,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\SpinnerBackend.cs,WpfSpinButton,The following statement contains a magic number: for (int i = 0; i < 360; i += 30) {  				// Create the rectangle and centre it in our widget  				var rect = new WpfRectangle { Width = 2' Height = 8' Fill = new SolidColorBrush (Colors.Black)' RadiusX = 1' RadiusY = 1' Opacity = Values[0] };  				WpfCanvas.SetTop (rect' (height - rect.Height) / 2);  				WpfCanvas.SetLeft (rect' (width - rect.Width) / 2);    				// Rotate the element by 'i' degrees' creating a circle out of all the elements  				var group = new TransformGroup ();  				group.Children.Add (new RotateTransform (i' 0.5' -6));  				group.Children.Add (new TranslateTransform (0' 10));  				rect.RenderTransform = group;    				// Set the animation  				var timeline = new DoubleAnimationUsingKeyFrames ();  				Storyboard.SetTarget (timeline' rect);  				Storyboard.SetTargetProperty (timeline' new PropertyPath ("Opacity"));    				var offset = Duration * (i / 360.0);  				for (int j = 0; j < StartTimes.Length; j++) {  					var start = (StartTimes[j] + offset) % Duration;  					timeline.KeyFrames.Add (new EasingDoubleKeyFrame { KeyTime = KeyTime.FromTimeSpan (TimeSpan.FromMilliseconds (start))' Value = Values[j] });  				}  				Storyboard.Children.Add (timeline);  				Children.Add (rect);  			}
Magic Number,Xwt.WPFBackend,WpfSpinButton,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\SpinnerBackend.cs,WpfSpinButton,The following statement contains a magic number: for (int i = 0; i < 360; i += 30) {  				// Create the rectangle and centre it in our widget  				var rect = new WpfRectangle { Width = 2' Height = 8' Fill = new SolidColorBrush (Colors.Black)' RadiusX = 1' RadiusY = 1' Opacity = Values[0] };  				WpfCanvas.SetTop (rect' (height - rect.Height) / 2);  				WpfCanvas.SetLeft (rect' (width - rect.Width) / 2);    				// Rotate the element by 'i' degrees' creating a circle out of all the elements  				var group = new TransformGroup ();  				group.Children.Add (new RotateTransform (i' 0.5' -6));  				group.Children.Add (new TranslateTransform (0' 10));  				rect.RenderTransform = group;    				// Set the animation  				var timeline = new DoubleAnimationUsingKeyFrames ();  				Storyboard.SetTarget (timeline' rect);  				Storyboard.SetTargetProperty (timeline' new PropertyPath ("Opacity"));    				var offset = Duration * (i / 360.0);  				for (int j = 0; j < StartTimes.Length; j++) {  					var start = (StartTimes[j] + offset) % Duration;  					timeline.KeyFrames.Add (new EasingDoubleKeyFrame { KeyTime = KeyTime.FromTimeSpan (TimeSpan.FromMilliseconds (start))' Value = Values[j] });  				}  				Storyboard.Children.Add (timeline);  				Children.Add (rect);  			}
Magic Number,Xwt.WPFBackend,WpfSpinButton,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\SpinnerBackend.cs,WpfSpinButton,The following statement contains a magic number: for (int i = 0; i < 360; i += 30) {  				// Create the rectangle and centre it in our widget  				var rect = new WpfRectangle { Width = 2' Height = 8' Fill = new SolidColorBrush (Colors.Black)' RadiusX = 1' RadiusY = 1' Opacity = Values[0] };  				WpfCanvas.SetTop (rect' (height - rect.Height) / 2);  				WpfCanvas.SetLeft (rect' (width - rect.Width) / 2);    				// Rotate the element by 'i' degrees' creating a circle out of all the elements  				var group = new TransformGroup ();  				group.Children.Add (new RotateTransform (i' 0.5' -6));  				group.Children.Add (new TranslateTransform (0' 10));  				rect.RenderTransform = group;    				// Set the animation  				var timeline = new DoubleAnimationUsingKeyFrames ();  				Storyboard.SetTarget (timeline' rect);  				Storyboard.SetTargetProperty (timeline' new PropertyPath ("Opacity"));    				var offset = Duration * (i / 360.0);  				for (int j = 0; j < StartTimes.Length; j++) {  					var start = (StartTimes[j] + offset) % Duration;  					timeline.KeyFrames.Add (new EasingDoubleKeyFrame { KeyTime = KeyTime.FromTimeSpan (TimeSpan.FromMilliseconds (start))' Value = Values[j] });  				}  				Storyboard.Children.Add (timeline);  				Children.Add (rect);  			}
Magic Number,Xwt.WPFBackend,WpfSpinButton,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\SpinnerBackend.cs,WpfSpinButton,The following statement contains a magic number: for (int i = 0; i < 360; i += 30) {  				// Create the rectangle and centre it in our widget  				var rect = new WpfRectangle { Width = 2' Height = 8' Fill = new SolidColorBrush (Colors.Black)' RadiusX = 1' RadiusY = 1' Opacity = Values[0] };  				WpfCanvas.SetTop (rect' (height - rect.Height) / 2);  				WpfCanvas.SetLeft (rect' (width - rect.Width) / 2);    				// Rotate the element by 'i' degrees' creating a circle out of all the elements  				var group = new TransformGroup ();  				group.Children.Add (new RotateTransform (i' 0.5' -6));  				group.Children.Add (new TranslateTransform (0' 10));  				rect.RenderTransform = group;    				// Set the animation  				var timeline = new DoubleAnimationUsingKeyFrames ();  				Storyboard.SetTarget (timeline' rect);  				Storyboard.SetTargetProperty (timeline' new PropertyPath ("Opacity"));    				var offset = Duration * (i / 360.0);  				for (int j = 0; j < StartTimes.Length; j++) {  					var start = (StartTimes[j] + offset) % Duration;  					timeline.KeyFrames.Add (new EasingDoubleKeyFrame { KeyTime = KeyTime.FromTimeSpan (TimeSpan.FromMilliseconds (start))' Value = Values[j] });  				}  				Storyboard.Children.Add (timeline);  				Children.Add (rect);  			}
Magic Number,Xwt.WPFBackend,WpfSpinButton,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\SpinnerBackend.cs,WpfSpinButton,The following statement contains a magic number: for (int i = 0; i < 360; i += 30) {  				// Create the rectangle and centre it in our widget  				var rect = new WpfRectangle { Width = 2' Height = 8' Fill = new SolidColorBrush (Colors.Black)' RadiusX = 1' RadiusY = 1' Opacity = Values[0] };  				WpfCanvas.SetTop (rect' (height - rect.Height) / 2);  				WpfCanvas.SetLeft (rect' (width - rect.Width) / 2);    				// Rotate the element by 'i' degrees' creating a circle out of all the elements  				var group = new TransformGroup ();  				group.Children.Add (new RotateTransform (i' 0.5' -6));  				group.Children.Add (new TranslateTransform (0' 10));  				rect.RenderTransform = group;    				// Set the animation  				var timeline = new DoubleAnimationUsingKeyFrames ();  				Storyboard.SetTarget (timeline' rect);  				Storyboard.SetTargetProperty (timeline' new PropertyPath ("Opacity"));    				var offset = Duration * (i / 360.0);  				for (int j = 0; j < StartTimes.Length; j++) {  					var start = (StartTimes[j] + offset) % Duration;  					timeline.KeyFrames.Add (new EasingDoubleKeyFrame { KeyTime = KeyTime.FromTimeSpan (TimeSpan.FromMilliseconds (start))' Value = Values[j] });  				}  				Storyboard.Children.Add (timeline);  				Children.Add (rect);  			}
Magic Number,Xwt.WPFBackend,WpfSpinButton,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\SpinnerBackend.cs,WpfSpinButton,The following statement contains a magic number: for (int i = 0; i < 360; i += 30) {  				// Create the rectangle and centre it in our widget  				var rect = new WpfRectangle { Width = 2' Height = 8' Fill = new SolidColorBrush (Colors.Black)' RadiusX = 1' RadiusY = 1' Opacity = Values[0] };  				WpfCanvas.SetTop (rect' (height - rect.Height) / 2);  				WpfCanvas.SetLeft (rect' (width - rect.Width) / 2);    				// Rotate the element by 'i' degrees' creating a circle out of all the elements  				var group = new TransformGroup ();  				group.Children.Add (new RotateTransform (i' 0.5' -6));  				group.Children.Add (new TranslateTransform (0' 10));  				rect.RenderTransform = group;    				// Set the animation  				var timeline = new DoubleAnimationUsingKeyFrames ();  				Storyboard.SetTarget (timeline' rect);  				Storyboard.SetTargetProperty (timeline' new PropertyPath ("Opacity"));    				var offset = Duration * (i / 360.0);  				for (int j = 0; j < StartTimes.Length; j++) {  					var start = (StartTimes[j] + offset) % Duration;  					timeline.KeyFrames.Add (new EasingDoubleKeyFrame { KeyTime = KeyTime.FromTimeSpan (TimeSpan.FromMilliseconds (start))' Value = Values[j] });  				}  				Storyboard.Children.Add (timeline);  				Children.Add (rect);  			}
Magic Number,Xwt.WPFBackend,WpfSpinButton,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\SpinnerBackend.cs,WpfSpinButton,The following statement contains a magic number: for (int i = 0; i < 360; i += 30) {  				// Create the rectangle and centre it in our widget  				var rect = new WpfRectangle { Width = 2' Height = 8' Fill = new SolidColorBrush (Colors.Black)' RadiusX = 1' RadiusY = 1' Opacity = Values[0] };  				WpfCanvas.SetTop (rect' (height - rect.Height) / 2);  				WpfCanvas.SetLeft (rect' (width - rect.Width) / 2);    				// Rotate the element by 'i' degrees' creating a circle out of all the elements  				var group = new TransformGroup ();  				group.Children.Add (new RotateTransform (i' 0.5' -6));  				group.Children.Add (new TranslateTransform (0' 10));  				rect.RenderTransform = group;    				// Set the animation  				var timeline = new DoubleAnimationUsingKeyFrames ();  				Storyboard.SetTarget (timeline' rect);  				Storyboard.SetTargetProperty (timeline' new PropertyPath ("Opacity"));    				var offset = Duration * (i / 360.0);  				for (int j = 0; j < StartTimes.Length; j++) {  					var start = (StartTimes[j] + offset) % Duration;  					timeline.KeyFrames.Add (new EasingDoubleKeyFrame { KeyTime = KeyTime.FromTimeSpan (TimeSpan.FromMilliseconds (start))' Value = Values[j] });  				}  				Storyboard.Children.Add (timeline);  				Children.Add (rect);  			}
Magic Number,Xwt.WPFBackend,WpfSpinButton,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\SpinnerBackend.cs,ArrangeOverride,The following statement contains a magic number: if (width > height) {  				dx = (width - height) / 2;  				width = height;  			}  			else if (height > width) {  				dy = (height - width) / 2;  				height = width;  			}
Magic Number,Xwt.WPFBackend,WpfSpinButton,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\SpinnerBackend.cs,ArrangeOverride,The following statement contains a magic number: if (width > height) {  				dx = (width - height) / 2;  				width = height;  			}  			else if (height > width) {  				dy = (height - width) / 2;  				height = width;  			}
Magic Number,Xwt.WPFBackend,WpfSpinButton,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\SpinnerBackend.cs,MeasureOverride,The following statement contains a magic number: s.Width = Math.Max (s.Width' MinWidth == 0 ? 25 : MinWidth);
Magic Number,Xwt.WPFBackend,WpfSpinButton,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\SpinnerBackend.cs,MeasureOverride,The following statement contains a magic number: s.Height = Math.Max (s.Height' MinHeight == 0 ? 25 : MinHeight);
Magic Number,Xwt.WPFBackend,TreeViewBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\TreeViewBackend.cs,GetDropTargetRow,The following statement contains a magic number: double edge = element.ActualHeight * 0.15;
Magic Number,Xwt.WPFBackend,TreeViewBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\TreeViewBackend.cs,CreateExpanderDock,The following statement contains a magic number: innerBorderFactory.SetValue (Control.BorderBrushProperty' new SolidColorBrush (Color.FromRgb (120' 152' 181)));
Magic Number,Xwt.WPFBackend,TreeViewBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\TreeViewBackend.cs,CreateExpanderDock,The following statement contains a magic number: innerBorderFactory.SetValue (Control.BorderBrushProperty' new SolidColorBrush (Color.FromRgb (120' 152' 181)));
Magic Number,Xwt.WPFBackend,TreeViewBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\TreeViewBackend.cs,CreateExpanderDock,The following statement contains a magic number: innerBorderFactory.SetValue (Control.BorderBrushProperty' new SolidColorBrush (Color.FromRgb (120' 152' 181)));
Magic Number,Xwt.WPFBackend,TreeViewDropAdorner,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\TreeViewDropAdorner.cs,TreeViewDropAdorner,The following statement contains a magic number: double indent = ((item.Level + 1) * LevelToIndentConverter.IndentSize) + 5;
Magic Number,Xwt.WPFBackend,WidgetBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WidgetBackend.cs,MeasureOverride,The following statement contains a magic number: if (nw == -1) {  				nw = defNaturalSize.Width;  				if (nw == 0)  					nw = wpfMeasure.Width;  				wpfMeasure.Width = nw;  			}  			else if (nw != -2)  				wpfMeasure.Width = nw;
Magic Number,Xwt.WPFBackend,WidgetBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WidgetBackend.cs,MeasureOverride,The following statement contains a magic number: if (nh == -1) {  				nh = defNaturalSize.Height;  				if (nh == 0)  					nh = wpfMeasure.Height;  				wpfMeasure.Height = nh;  			}  			else if (nh != -2)  				wpfMeasure.Height = nh;
Magic Number,Xwt.WPFBackend,WidgetBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WidgetBackend.cs,SetupDragRect,The following statement contains a magic number: DragDropInfo.DragRect = new Rect (loc.X - width / 2' loc.Y - height / 2' width' height);
Magic Number,Xwt.WPFBackend,WidgetBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WidgetBackend.cs,SetupDragRect,The following statement contains a magic number: DragDropInfo.DragRect = new Rect (loc.X - width / 2' loc.Y - height / 2' width' height);
Magic Number,Xwt.WPFBackend,WidgetBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WidgetBackend.cs,WidgetMouseWheelHandler,The following statement contains a magic number: int jumps = mouseScrollCumulation / 120;
Magic Number,Xwt.WPFBackend,WidgetBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WidgetBackend.cs,WidgetMouseWheelHandler,The following statement contains a magic number: mouseScrollCumulation %= 120;
Magic Number,Xwt.WPFBackend,WindowFrameBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WindowFrameBackend.cs,ToNonClientRect,The following statement contains a magic number: size.Height += border.Height * 2;
Magic Number,Xwt.WPFBackend,WindowFrameBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WindowFrameBackend.cs,ToNonClientRect,The following statement contains a magic number: size.Width += border.Width * 2;
Magic Number,Xwt.WPFBackend,WindowFrameBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WindowFrameBackend.cs,ToClientRect,The following statement contains a magic number: size.Height -= border.Height * 2;
Magic Number,Xwt.WPFBackend,WindowFrameBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WindowFrameBackend.cs,ToClientRect,The following statement contains a magic number: size.Width -= border.Width * 2;
Magic Number,Xwt.WPFBackend,WPFEngine,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WPFEngine.cs,RenderWidget,The following statement contains a magic number: try {  				var w = ((WidgetBackend)widget.GetBackend ()).Widget;  				RenderTargetBitmap rtb = new RenderTargetBitmap ((int)w.ActualWidth' (int)w.ActualHeight' 96' 96' PixelFormats.Pbgra32);  				rtb.Render(w);  				return new WpfImage(rtb);  			} catch (Exception ex) {  				throw new InvalidOperationException ("Rendering element not supported"' ex);  			}
Magic Number,Xwt.WPFBackend,WPFEngine,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WPFEngine.cs,RenderWidget,The following statement contains a magic number: try {  				var w = ((WidgetBackend)widget.GetBackend ()).Widget;  				RenderTargetBitmap rtb = new RenderTargetBitmap ((int)w.ActualWidth' (int)w.ActualHeight' 96' 96' PixelFormats.Pbgra32);  				rtb.Render(w);  				return new WpfImage(rtb);  			} catch (Exception ex) {  				throw new InvalidOperationException ("Rendering element not supported"' ex);  			}
Magic Number,Xwt.WPFBackend,CustomScrollViewPort,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\CustomScrollViewPort.cs,MouseWheelDown,The following statement contains a magic number: SetVerticalOffset (VerticalOffset + 12);
Magic Number,Xwt.WPFBackend,CustomScrollViewPort,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\CustomScrollViewPort.cs,MouseWheelLeft,The following statement contains a magic number: SetHorizontalOffset (HorizontalOffset - 12);
Magic Number,Xwt.WPFBackend,CustomScrollViewPort,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\CustomScrollViewPort.cs,MouseWheelRight,The following statement contains a magic number: SetHorizontalOffset (HorizontalOffset + 12);
Magic Number,Xwt.WPFBackend,CustomScrollViewPort,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\CustomScrollViewPort.cs,MouseWheelUp,The following statement contains a magic number: SetVerticalOffset (VerticalOffset - 12);
Magic Number,Xwt.WPFBackend,RichTextBuffer,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\RichTextViewBackend.cs,EmitCodeBlock,The following statement contains a magic number: container.Margin = new Thickness(15' 15' 15' 15);
Magic Number,Xwt.WPFBackend,RichTextBuffer,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\RichTextViewBackend.cs,EmitCodeBlock,The following statement contains a magic number: container.Margin = new Thickness(15' 15' 15' 15);
Magic Number,Xwt.WPFBackend,RichTextBuffer,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\RichTextViewBackend.cs,EmitCodeBlock,The following statement contains a magic number: container.Margin = new Thickness(15' 15' 15' 15);
Magic Number,Xwt.WPFBackend,RichTextBuffer,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\RichTextViewBackend.cs,EmitCodeBlock,The following statement contains a magic number: container.Margin = new Thickness(15' 15' 15' 15);
Magic Number,Xwt.WPFBackend,WindowsSpinButton,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WindowsSpinButton.xaml.cs,WindowsSpinButton,The following statement contains a magic number: mainGrid.ColumnDefinitions.Add(new ColumnDefinition() { Width = new GridLength(16) });
Magic Number,Xwt.WPFBackend,WindowsSpinButton,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WindowsSpinButton.xaml.cs,WindowsSpinButton,The following statement contains a magic number: textBox.MinWidth = 25;
Magic Number,Xwt.WPFBackend,WindowsSpinButton,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WindowsSpinButton.xaml.cs,WindowsSpinButton,The following statement contains a magic number: buttonUp.Interval = 20;
Magic Number,Xwt.WPFBackend,WindowsSpinButton,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WindowsSpinButton.xaml.cs,WindowsSpinButton,The following statement contains a magic number: buttonUp.Delay = 400;
Magic Number,Xwt.WPFBackend,WindowsSpinButton,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WindowsSpinButton.xaml.cs,WindowsSpinButton,The following statement contains a magic number: var buttonUpPolygonPoints = new PointCollection(3);
Magic Number,Xwt.WPFBackend,WindowsSpinButton,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WindowsSpinButton.xaml.cs,WindowsSpinButton,The following statement contains a magic number: buttonUpPolygonPoints.Add(new System.Windows.Point(0' 5));
Magic Number,Xwt.WPFBackend,WindowsSpinButton,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WindowsSpinButton.xaml.cs,WindowsSpinButton,The following statement contains a magic number: buttonUpPolygonPoints.Add(new System.Windows.Point(3' 0));
Magic Number,Xwt.WPFBackend,WindowsSpinButton,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WindowsSpinButton.xaml.cs,WindowsSpinButton,The following statement contains a magic number: buttonUpPolygonPoints.Add(new System.Windows.Point(6' 5));
Magic Number,Xwt.WPFBackend,WindowsSpinButton,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WindowsSpinButton.xaml.cs,WindowsSpinButton,The following statement contains a magic number: buttonUpPolygonPoints.Add(new System.Windows.Point(6' 5));
Magic Number,Xwt.WPFBackend,WindowsSpinButton,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WindowsSpinButton.xaml.cs,WindowsSpinButton,The following statement contains a magic number: buttonDown.Interval = 20;
Magic Number,Xwt.WPFBackend,WindowsSpinButton,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WindowsSpinButton.xaml.cs,WindowsSpinButton,The following statement contains a magic number: buttonDown.Delay = 400;
Magic Number,Xwt.WPFBackend,WindowsSpinButton,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WindowsSpinButton.xaml.cs,WindowsSpinButton,The following statement contains a magic number: var buttonDownPolygonPoints = new PointCollection(3);
Magic Number,Xwt.WPFBackend,WindowsSpinButton,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WindowsSpinButton.xaml.cs,WindowsSpinButton,The following statement contains a magic number: buttonDownPolygonPoints.Add(new System.Windows.Point(3' 5));
Magic Number,Xwt.WPFBackend,WindowsSpinButton,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WindowsSpinButton.xaml.cs,WindowsSpinButton,The following statement contains a magic number: buttonDownPolygonPoints.Add(new System.Windows.Point(3' 5));
Magic Number,Xwt.WPFBackend,WindowsSpinButton,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WindowsSpinButton.xaml.cs,WindowsSpinButton,The following statement contains a magic number: buttonDownPolygonPoints.Add(new System.Windows.Point(6' 0));
Magic Number,Xwt.WPFBackend,WindowsSpinButton,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WindowsSpinButton.xaml.cs,textBox_PreviewKeyDown,The following statement contains a magic number: if (e.Key == Key.Return || e.Key == Key.Tab)                  parseTextBox();              else if (e.Key == Key.Up)              {                  IncreaseValue(Increment);                  StartKeyboardTimer();              }              else if (e.Key == Key.Down)              {                  DecreaseValue(Increment);                  StartKeyboardTimer();              }              else if (e.Key == Key.PageDown)              {                  DecreaseValue(Increment * 10);                  StartKeyboardTimer();              }              else if (e.Key == Key.PageUp)              {                  IncreaseValue(Increment * 10);                  StartKeyboardTimer();              }
Magic Number,Xwt.WPFBackend,WindowsSpinButton,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WindowsSpinButton.xaml.cs,textBox_PreviewKeyDown,The following statement contains a magic number: if (e.Key == Key.Return || e.Key == Key.Tab)                  parseTextBox();              else if (e.Key == Key.Up)              {                  IncreaseValue(Increment);                  StartKeyboardTimer();              }              else if (e.Key == Key.Down)              {                  DecreaseValue(Increment);                  StartKeyboardTimer();              }              else if (e.Key == Key.PageDown)              {                  DecreaseValue(Increment * 10);                  StartKeyboardTimer();              }              else if (e.Key == Key.PageUp)              {                  IncreaseValue(Increment * 10);                  StartKeyboardTimer();              }
Magic Number,Xwt.WPFBackend,WindowsSpinButton,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WindowsSpinButton.xaml.cs,OnKeyboardTimeout,The following statement contains a magic number: switch (pressedKey)              {                  case Key.Up:                      IncreaseValue((Increment + ClimbRate));                      break;                  case Key.Down:                      DecreaseValue((Increment + ClimbRate));                      break;                  case Key.PageUp:                      IncreaseValue((Increment + ClimbRate) * 10);                      break;                  case Key.PageDown:                      DecreaseValue((Increment + ClimbRate) * 10);                      break;                  default:                      keyboardTimer.Stop();                      break;              }
Magic Number,Xwt.WPFBackend,WindowsSpinButton,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WindowsSpinButton.xaml.cs,OnKeyboardTimeout,The following statement contains a magic number: switch (pressedKey)              {                  case Key.Up:                      IncreaseValue((Increment + ClimbRate));                      break;                  case Key.Down:                      DecreaseValue((Increment + ClimbRate));                      break;                  case Key.PageUp:                      IncreaseValue((Increment + ClimbRate) * 10);                      break;                  case Key.PageDown:                      DecreaseValue((Increment + ClimbRate) * 10);                      break;                  default:                      keyboardTimer.Stop();                      break;              }
Missing Default,Xwt.WPFBackend,CheckBoxStateToBoolConverter,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend.CellViews\CheckBoxCellViewBackend.cs,Convert,The following switch statement is missing a default case: switch (svalue) {  			case CheckBoxState.On:  				return true;  			case CheckBoxState.Off:  				return false;  			}
Missing Default,Xwt.WPFBackend,AlertDialogBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\AlertDialogBackend.cs,ConvertButtons,The following switch statement is missing a default case: switch (buttons.Count){  			case 1:  					if (buttons.Contains (Command.Ok)) {  						result = MessageBoxButton.OK;  						return true;  					}  					break;  			case 2:  				if (buttons.Contains (Command.Ok) && buttons.Contains (Command.Cancel)) {  					result = MessageBoxButton.OKCancel;  					return true;  				} else if (buttons.Contains (Command.Yes) && buttons.Contains (Command.No)) {  					result = MessageBoxButton.YesNo;  					return true;  				}  				break;  			case 3:  				if (buttons.Contains (Command.Yes) && buttons.Contains (Command.No) && buttons.Contains (Command.Cancel)) {  					result = MessageBoxButton.YesNoCancel;  					return true;  				}  				break;  			}
Missing Default,Xwt.WPFBackend,ButtonBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ButtonBackend.cs,SetButtonStyle,The following switch statement is missing a default case: switch (style)  			{  				case ButtonStyle.Normal:  					Button.ClearValue (SWC.Control.BackgroundProperty);  					Button.ClearValue (SWC.Control.BorderThicknessProperty);  					Button.ClearValue (SWC.Control.BorderBrushProperty);  					break;  				case ButtonStyle.Flat:  					Button.Background = Brushes.Transparent;  					Button.BorderBrush = Brushes.Transparent;  					break;  				case ButtonStyle.Borderless:  					Button.ClearValue (SWC.Control.BackgroundProperty);  					Button.BorderThickness = new Thickness (0);  					Button.BorderBrush = Brushes.Transparent;  					break;  			}
Missing Default,Xwt.WPFBackend,ButtonBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ButtonBackend.cs,SetButtonType,The following switch statement is missing a default case: switch (type) {  			case ButtonType.Normal:  				Button.Style = null;  				break;    			case ButtonType.DropDown:  				Button.Style = (Style) ButtonResources ["NormalDropDown"];  				break;  			}
Missing Default,Xwt.WPFBackend,ButtonBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ButtonBackend.cs,EnableEvent,The following switch statement is missing a default case: switch ((ButtonEvent)eventId)  				{  					case ButtonEvent.Clicked: Button.Click += HandleWidgetClicked; break;  				}
Missing Default,Xwt.WPFBackend,ButtonBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ButtonBackend.cs,DisableEvent,The following switch statement is missing a default case: switch ((ButtonEvent)eventId)  				{  					case ButtonEvent.Clicked: Button.Click -= HandleWidgetClicked; break;  				}
Missing Default,Xwt.WPFBackend,CheckBoxBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\CheckBoxBackend.cs,EnableEvent,The following switch statement is missing a default case: switch ((CheckBoxEvent)eventId) {  				case CheckBoxEvent.Clicked:  					CheckBox.Click += OnClicked;  					break;    				case CheckBoxEvent.Toggled:  					CheckBox.Checked += OnChecked;  					CheckBox.Unchecked += OnChecked;  					break;  				}
Missing Default,Xwt.WPFBackend,CheckBoxBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\CheckBoxBackend.cs,DisableEvent,The following switch statement is missing a default case: switch ((CheckBoxEvent)eventId) {  				case CheckBoxEvent.Clicked:  					CheckBox.Click -= OnClicked;  					break;    				case CheckBoxEvent.Toggled:  					CheckBox.Checked -= OnChecked;  					CheckBox.Unchecked -= OnChecked;  					break;  				}
Missing Default,Xwt.WPFBackend,ComboBoxBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ComboBoxBackend.cs,EnableEvent,The following switch statement is missing a default case: switch ((ComboBoxEvent)eventId) {  					case ComboBoxEvent.SelectionChanged:  						ComboBox.SelectionChanged += OnSelectionChanged;  					break;  				}
Missing Default,Xwt.WPFBackend,ComboBoxBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ComboBoxBackend.cs,DisableEvent,The following switch statement is missing a default case: switch ((ComboBoxEvent)eventId) {  					case ComboBoxEvent.SelectionChanged:  						ComboBox.SelectionChanged -= OnSelectionChanged;  					break;  				}
Missing Default,Xwt.WPFBackend,ComboBoxTextEntryBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ComboBoxTextEntryBackend.cs,EnableEvent,The following switch statement is missing a default case: switch ((TextEntryEvent)eventId) { 				case TextEntryEvent.Changed: 					this.combobox.TextChanged += OnTextChanged; 					break; 				case TextEntryEvent.SelectionChanged: 					combobox.TextSelectionChanged += OnSelectionChanged;  					break; 				}
Missing Default,Xwt.WPFBackend,ComboBoxTextEntryBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ComboBoxTextEntryBackend.cs,DisableEvent,The following switch statement is missing a default case: switch ((TextEntryEvent)eventId) { 				case TextEntryEvent.Changed: 					this.combobox.TextChanged -= OnTextChanged; 					break; 				case TextEntryEvent.SelectionChanged: 					combobox.TextSelectionChanged -= OnSelectionChanged; 					break; 				}
Missing Default,Xwt.WPFBackend,PasswordEntryBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\PasswordEntryBackend.cs,EnableEvent,The following switch statement is missing a default case: switch ((PasswordEntryEvent) eventId)   				{  					case PasswordEntryEvent.Changed:  						PasswordBox.PasswordChanged += OnPasswordChanged;  						break;  					case PasswordEntryEvent.Activated:  						PasswordBox.KeyDown += OnActivated;  						break;  				}
Missing Default,Xwt.WPFBackend,PasswordEntryBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\PasswordEntryBackend.cs,DisableEvent,The following switch statement is missing a default case: switch ((PasswordEntryEvent)eventId)  				{  					case PasswordEntryEvent.Changed:  						PasswordBox.PasswordChanged -= OnPasswordChanged;  						break;  					case PasswordEntryEvent.Activated:  						PasswordBox.KeyDown -= OnActivated;  						break;  				}
Missing Default,Xwt.WPFBackend,PlaceholderTextAdorner,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\PlaceholderTextAdorner.cs,OnRender,The following switch statement is missing a default case: switch (alignment) {  			case TextAlignment.Center:  				xpos = (RenderSize.Width - text.Width) * 0.5;  				break;  			case TextAlignment.Right:  				xpos = (RenderSize.Width - text.Width) - 6;  				break;  			}
Missing Default,Xwt.WPFBackend,SpinButtonBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\SpinButtonBackend.cs,EnableEvent,The following switch statement is missing a default case: switch ((SpinButtonEvent)eventId)                  {                      case SpinButtonEvent.ValueChanged:                          SpinButton.OnValueChanged += SpinButton_OnValueChanged;                          break;                  }
Missing Default,Xwt.WPFBackend,SpinButtonBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\SpinButtonBackend.cs,DisableEvent,The following switch statement is missing a default case: switch ((SpinButtonEvent)eventId)                  {                      case SpinButtonEvent.ValueChanged:                          SpinButton.OnValueChanged -= SpinButton_OnValueChanged;                          break;                  }
Missing Default,Xwt.WPFBackend,RadioButtonBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\RadioButtonBackend.cs,EnableEvent,The following switch statement is missing a default case: switch ((RadioButtonEvent)eventId)  				{  					case RadioButtonEvent.Clicked:  						RadioButton.Click += OnClicked;  						break;  					case RadioButtonEvent.ActiveChanged:  						RadioButton.Checked += OnChecked;  						RadioButton.Unchecked += OnChecked;  						break;  				}
Missing Default,Xwt.WPFBackend,RadioButtonBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\RadioButtonBackend.cs,DisableEvent,The following switch statement is missing a default case: switch ((RadioButtonEvent)eventId)  				{  					case RadioButtonEvent.Clicked:  						RadioButton.Click -= OnClicked;  						break;  					case RadioButtonEvent.ActiveChanged:  						RadioButton.Checked -= OnChecked;  						RadioButton.Unchecked -= OnChecked;  						break;  				}
Missing Default,Xwt.WPFBackend,LinkLabelBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\LinkLabelBackend.cs,EnableEvent,The following switch statement is missing a default case: switch ((LinkLabelEvent) eventId) {  				case LinkLabelEvent.NavigateToUrl:  					Widget.Hyperlink.Click += HandleClicked;  					break;  				}
Missing Default,Xwt.WPFBackend,LinkLabelBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\LinkLabelBackend.cs,DisableEvent,The following switch statement is missing a default case: switch ((LinkLabelEvent) eventId) {  				case LinkLabelEvent.NavigateToUrl:  					Widget.Hyperlink.Click -= HandleClicked;  					break;  				}
Missing Default,Xwt.WPFBackend,KeyboardUtil,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\KeyboardUtil.cs,TranslateToXwtKey,The following switch statement is missing a default case: switch (key) {  				case WpfKey.Cancel: return Key.Cancel;  				case WpfKey.Back: return Key.BackSpace;  				case WpfKey.Tab: return Key.Tab;  				case WpfKey.LineFeed: return Key.LineFeed;  				case WpfKey.Clear: return Key.Clear;  				case WpfKey.Return: return Key.Return;  				case WpfKey.Pause: return Key.Pause;  				case WpfKey.CapsLock: return Key.CapsLock;  				case WpfKey.Space: return Key.Space;  				case WpfKey.Escape: return Key.Escape;  				case WpfKey.PageDown: return Key.PageDown;  				case WpfKey.PageUp: return Key.PageUp;  				case WpfKey.End: return Key.End;  				case WpfKey.Home: return Key.Home;  				case WpfKey.Left: return Key.Left;  				case WpfKey.Up: return Key.Up;  				case WpfKey.Right: return Key.Right;  				case WpfKey.Down: return Key.Down;  				case WpfKey.Select: return Key.Select;  				case WpfKey.Print: return Key.Print;  				case WpfKey.Execute: return Key.Execute;  				case WpfKey.Delete: return Key.Delete;  				case WpfKey.Help: return Key.Help;  				case WpfKey.Insert: return Key.Insert;  				case WpfKey.Scroll: return Key.ScrollLock;  				case WpfKey.NumLock: return Key.NumLock;  				case WpfKey.LeftShift: return Key.ShiftLeft;  				case WpfKey.RightShift: return Key.ShiftRight;  				case WpfKey.LeftCtrl: return Key.ControlLeft;  				case WpfKey.RightCtrl: return Key.ControlRight;  				case WpfKey.LeftAlt: return Key.AltLeft;  				case WpfKey.RightAlt: return Key.AltRight;  				case WpfKey.Multiply: return Key.Asterisk;  				case WpfKey.Add: return Key.Plus;  				case WpfKey.OemComma: return isShiftToggled ? Key.Semicolon : Key.Comma;  				case WpfKey.Subtract: return Key.Minus;  				case WpfKey.Divide: return Key.Slash;  				case WpfKey.OemPeriod: return isShiftToggled ? Key.Colon : Key.Period;  				case WpfKey.Oem5: return Key.Caret;  			}
Missing Default,Xwt.WPFBackend,ListBoxBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ListBoxBackend.cs,SetSelectionMode,The following switch statement is missing a default case: switch (mode) {  			case SelectionMode.Single:  				ListBox.SelectionMode = System.Windows.Controls.SelectionMode.Single;  				break;  			case SelectionMode.Multiple:  				ListBox.SelectionMode = System.Windows.Controls.SelectionMode.Extended;  				break;  			}
Missing Default,Xwt.WPFBackend,ListBoxBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ListBoxBackend.cs,EnableEvent,The following switch statement is missing a default case: switch ((TableViewEvent)eventId) {  				case TableViewEvent.SelectionChanged:  					ListBox.SelectionChanged += OnSelectionChanged;  					break;  				}
Missing Default,Xwt.WPFBackend,ListBoxBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ListBoxBackend.cs,EnableEvent,The following switch statement is missing a default case: switch ((ListViewEvent)eventId) {  				case ListViewEvent.RowActivated:  					ListBox.MouseDoubleClick += OnMouseDoubleClick;  					break;  				}
Missing Default,Xwt.WPFBackend,ListBoxBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ListBoxBackend.cs,DisableEvent,The following switch statement is missing a default case: switch ((TableViewEvent)eventId) {  				case TableViewEvent.SelectionChanged:  					ListBox.SelectionChanged -= OnSelectionChanged;  					break;  				}
Missing Default,Xwt.WPFBackend,ListBoxBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ListBoxBackend.cs,DisableEvent,The following switch statement is missing a default case: switch ((ListViewEvent)eventId) {  				case ListViewEvent.RowActivated:  					ListBox.MouseDoubleClick -= OnMouseDoubleClick;  					break;  				}
Missing Default,Xwt.WPFBackend,ListViewBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ListViewBackend.cs,SetSelectionMode,The following switch statement is missing a default case: switch (mode) {  			case SelectionMode.Single:  				ListView.SelectionMode = SWC.SelectionMode.Single;  				break;    			case SelectionMode.Multiple:  				ListView.SelectionMode = SWC.SelectionMode.Extended;  				break;  			}
Missing Default,Xwt.WPFBackend,ListViewBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ListViewBackend.cs,EnableEvent,The following switch statement is missing a default case: switch ((TableViewEvent)eventId) {  				case TableViewEvent.SelectionChanged:  					ListView.SelectionChanged += OnSelectionChanged;  					break;  				}
Missing Default,Xwt.WPFBackend,ListViewBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ListViewBackend.cs,EnableEvent,The following switch statement is missing a default case: switch ((ListViewEvent)eventId) {  				case ListViewEvent.RowActivated:  					ListView.MouseDoubleClick += OnMouseDoubleClick;  					break;  				}
Missing Default,Xwt.WPFBackend,ListViewBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ListViewBackend.cs,DisableEvent,The following switch statement is missing a default case: switch ((TableViewEvent)eventId) {  				case TableViewEvent.SelectionChanged:  					ListView.SelectionChanged -= OnSelectionChanged;  					break;  				}
Missing Default,Xwt.WPFBackend,ListViewBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ListViewBackend.cs,DisableEvent,The following switch statement is missing a default case: switch ((ListViewEvent)eventId) {  				case ListViewEvent.RowActivated:  					ListView.MouseDoubleClick -= OnMouseDoubleClick;  					break;  				}
Missing Default,Xwt.WPFBackend,MenuButtonBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\MenuButtonBackend.cs,SetButtonType,The following switch statement is missing a default case: switch (type) {  			case ButtonType.Normal:  				DropDownButton.Style = null;  				break;    			case ButtonType.DropDown:  				DropDownButton.Style = (Style) ButtonResources["MenuDropDown"];  				break;  			}
Missing Default,Xwt.WPFBackend,MenuItemBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\MenuItemBackend.cs,SetType,The following switch statement is missing a default case: switch (type) {  				case MenuItemType.RadioButton:  				case MenuItemType.CheckBox:  					this.menuItem.IsCheckable = true;  					break;  				case MenuItemType.Normal:  					this.menuItem.IsCheckable = false;  					break;  			}
Missing Default,Xwt.WPFBackend,MenuItemBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\MenuItemBackend.cs,EnableEvent,The following switch statement is missing a default case: switch ((MenuItemEvent)eventId) {  					case MenuItemEvent.Clicked:  						this.menuItem.Click += MenuItemClickHandler;  						break;  				}
Missing Default,Xwt.WPFBackend,MenuItemBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\MenuItemBackend.cs,DisableEvent,The following switch statement is missing a default case: switch ((MenuItemEvent)eventId) {  					case MenuItemEvent.Clicked:  						this.menuItem.Click -= MenuItemClickHandler;  						break;  				}
Missing Default,Xwt.WPFBackend,PanedBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\PanedBackend.cs,EnableEvent,The following switch statement is missing a default case: switch ((PanedEvent)eventId) {  				case PanedEvent.PositionChanged:  					this.reportPositionChanged = true;  					break;  				}
Missing Default,Xwt.WPFBackend,PanedBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\PanedBackend.cs,DisableEvent,The following switch statement is missing a default case: switch ((PanedEvent)eventId) {  				case PanedEvent.PositionChanged:  					this.reportPositionChanged = false;  					break;  				}
Missing Default,Xwt.WPFBackend,ScrollViewBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ScrollViewBackend.cs,EnableEvent,The following switch statement is missing a default case: switch ((ScrollViewEvent)eventId) {  					case ScrollViewEvent.VisibleRectChanged:  						break;  				}
Missing Default,Xwt.WPFBackend,ScrollViewBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ScrollViewBackend.cs,DisableEvent,The following switch statement is missing a default case: switch ((ScrollViewEvent)eventId) {  					case ScrollViewEvent.VisibleRectChanged:  						break;  				}
Missing Default,Xwt.WPFBackend,TextEntryBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\TextEntryBackend.cs,EnableEvent,The following switch statement is missing a default case: switch ((TextEntryEvent)eventId)  				{  					// TODO: Should we ignore this for placeholder changes?  					case TextEntryEvent.Changed:  						TextBox.TextChanged += OnTextChanged;  						break;  					case TextEntryEvent.Activated:  						TextBox.KeyDown += OnActivated;  						break;  					case TextEntryEvent.SelectionChanged:  						TextBox.SelectionChanged += OnSelectionChanged;  						break;  				}
Missing Default,Xwt.WPFBackend,TextEntryBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\TextEntryBackend.cs,DisableEvent,The following switch statement is missing a default case: switch ((TextEntryEvent)eventId)  				{  					case TextEntryEvent.Changed:  						TextBox.TextChanged -= OnTextChanged;  						break;  					case TextEntryEvent.Activated:  						TextBox.KeyDown -= OnActivated;  						break;  					case TextEntryEvent.SelectionChanged:  						TextBox.SelectionChanged -= OnSelectionChanged;  						break;  				}
Missing Default,Xwt.WPFBackend,ToggleButtonBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ToggleButtonBackend.cs,EnableEvent,The following switch statement is missing a default case: switch ((ToggleButtonEvent)eventId)  				{  					case ToggleButtonEvent.Toggled:  						ToggleButton.Checked += OnButtonToggled;  						ToggleButton.Unchecked += OnButtonToggled;  						break;  				}
Missing Default,Xwt.WPFBackend,ToggleButtonBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\ToggleButtonBackend.cs,DisableEvent,The following switch statement is missing a default case: switch ((ToggleButtonEvent)eventId)  				{  					case ToggleButtonEvent.Toggled:  						ToggleButton.Checked -= OnButtonToggled;  						ToggleButton.Unchecked -= OnButtonToggled;  						break;  				}
Missing Default,Xwt.WPFBackend,TreeViewBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\TreeViewBackend.cs,UpdateColumn,The following switch statement is missing a default case: switch (change) { 			case ListViewColumnChange.Title: 				col.Header = column.Title; 				break;  			case ListViewColumnChange.Cells:                 var cellTemplate = CellUtil.CreateBoundColumnTemplate(Context' this' column.Views);  				col.CellTemplate = new DataTemplate { VisualTree = cellTemplate };  				int index = Tree.View.Columns.IndexOf (col); 				if (index == 0) { 					var dockFactory = CreateExpanderDock (); 					dockFactory.AppendChild (cellTemplate);  					col.CellTemplate.VisualTree = dockFactory; 				}  				MapColumn (column' col);  				break; 			case ListViewColumnChange.Alignment: 				var style = new Style(typeof(GridViewColumnHeader)); 				style.Setters.Add(new Setter(Control.HorizontalContentAlignmentProperty' Util.ToWpfHorizontalAlignment(column.Alignment))); 				col.HeaderContainerStyle = style; 				break; 			}
Missing Default,Xwt.WPFBackend,TreeViewBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\TreeViewBackend.cs,EnableEvent,The following switch statement is missing a default case: switch ((TableViewEvent)eventId) { 				case TableViewEvent.SelectionChanged: 					Tree.SelectedItemsChanged += OnSelectedItemsChanged; 					break; 				}
Missing Default,Xwt.WPFBackend,TreeViewBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\TreeViewBackend.cs,EnableEvent,The following switch statement is missing a default case: switch ((TreeViewEvent)eventId)  				{  					case TreeViewEvent.RowActivated:  						RowActivatedEventEnabled = true;  						break; 				}
Missing Default,Xwt.WPFBackend,TreeViewBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\TreeViewBackend.cs,DisableEvent,The following switch statement is missing a default case: switch ((TableViewEvent)eventId) { 				case TableViewEvent.SelectionChanged: 					Tree.SelectedItemsChanged -= OnSelectedItemsChanged; 					break; 				}
Missing Default,Xwt.WPFBackend,TreeViewBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\TreeViewBackend.cs,DisableEvent,The following switch statement is missing a default case: switch ((TreeViewEvent)eventId) 				{ 					case TreeViewEvent.RowActivated: 						RowActivatedEventEnabled = false; 						break; 				}
Missing Default,Xwt.WPFBackend,TreeViewDropAdorner,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\TreeViewDropAdorner.cs,TreeViewDropAdorner,The following switch statement is missing a default case: switch (position) {  				case RowDropPosition.Into:  					this.shape.Height = item.ActualHeight;  					this.shape.Margin = new Thickness (indent' 0' 0' 0);  					this.shape.StrokeDashArray = new DoubleCollection { 1' 0' 1 };  				break;    				case RowDropPosition.Before:  					this.shape.Height = 1;  					this.shape.Margin = new Thickness (indent' 0' 0' 0);  				break;    				case RowDropPosition.After:  					this.shape.Height = 1;  					this.shape.Margin = new Thickness (indent' item.ActualHeight' 0' 0);  				break;  			}
Missing Default,Xwt.WPFBackend,Util,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\Util.cs,ToWpfHorizontalAlignment,The following switch statement is missing a default case: switch (alignment) {  			case Alignment.Start:  				return HorizontalAlignment.Left;  			case Alignment.Center:  				return HorizontalAlignment.Center;  			case Alignment.End:  				return HorizontalAlignment.Right;  			}
Missing Default,Xwt.WPFBackend,WidgetBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WidgetBackend.cs,SetChildPlacement,The following switch statement is missing a default case: switch (w.Frontend.HorizontalPlacement) {  				case WidgetPlacement.Start: w.Widget.HorizontalAlignment = HorizontalAlignment.Left; break;  				case WidgetPlacement.Center: w.Widget.HorizontalAlignment = HorizontalAlignment.Center; break;  				case WidgetPlacement.End: w.Widget.HorizontalAlignment = HorizontalAlignment.Right; break;  				case WidgetPlacement.Fill: w.Widget.HorizontalAlignment = HorizontalAlignment.Stretch; break;  			}
Missing Default,Xwt.WPFBackend,WidgetBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WidgetBackend.cs,SetChildPlacement,The following switch statement is missing a default case: switch (w.Frontend.VerticalPlacement) {  				case WidgetPlacement.Start: w.Widget.VerticalAlignment = VerticalAlignment.Top; break;  				case WidgetPlacement.Center: w.Widget.VerticalAlignment = VerticalAlignment.Center; break;  				case WidgetPlacement.End: w.Widget.VerticalAlignment = VerticalAlignment.Bottom; break;  				case WidgetPlacement.Fill: w.Widget.VerticalAlignment = VerticalAlignment.Stretch; break;  			}
Missing Default,Xwt.WPFBackend,WidgetBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WidgetBackend.cs,EnableEvent,The following switch statement is missing a default case: switch (ev) {  					case WidgetEvent.KeyPressed:  						Widget.PreviewKeyDown += WidgetKeyDownHandler;  						break;  					case WidgetEvent.KeyReleased:  						Widget.PreviewKeyUp += WidgetKeyUpHandler;  						break;  					case WidgetEvent.TextInput:  						TextCompositionManager.AddPreviewTextInputHandler(Widget' WidgetPreviewTextInputHandler);  						break;  					case WidgetEvent.ButtonPressed:  						Widget.MouseDown += WidgetMouseDownHandler;  						break;  					case WidgetEvent.ButtonReleased:  						Widget.MouseUp += WidgetMouseUpHandler;  						break;  					case WidgetEvent.GotFocus:  						Widget.GotFocus += WidgetGotFocusHandler;  						break;  					case WidgetEvent.LostFocus:  						Widget.LostFocus += WidgetLostFocusHandler;  						break;  					case WidgetEvent.MouseEntered:  						Widget.MouseEnter += WidgetMouseEnteredHandler;  						break;  					case WidgetEvent.MouseExited:  						Widget.MouseLeave += WidgetMouseExitedHandler;  						break;  					case WidgetEvent.MouseMoved:  						Widget.MouseMove += WidgetMouseMoveHandler;  						break;  					case WidgetEvent.BoundsChanged:  						Widget.SizeChanged += WidgetOnSizeChanged;  						break;  					case WidgetEvent.MouseScrolled:  						Widget.MouseWheel += WidgetMouseWheelHandler;  						break;  				}
Missing Default,Xwt.WPFBackend,WidgetBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WidgetBackend.cs,DisableEvent,The following switch statement is missing a default case: switch (ev) {  					case WidgetEvent.KeyPressed:  						Widget.PreviewKeyDown -= WidgetKeyDownHandler;  						break;  					case WidgetEvent.KeyReleased:  						Widget.PreviewKeyUp -= WidgetKeyUpHandler;  						break;  					case WidgetEvent.TextInput:  						TextCompositionManager.RemovePreviewTextInputHandler(Widget' WidgetPreviewTextInputHandler);  						break;  					case WidgetEvent.ButtonPressed:  						Widget.MouseDown -= WidgetMouseDownHandler;  						break;  					case WidgetEvent.ButtonReleased:  						Widget.MouseUp -= WidgetMouseUpHandler;  						break;  					case WidgetEvent.MouseEntered:  						Widget.MouseEnter -= WidgetMouseEnteredHandler;  						break;  					case WidgetEvent.MouseExited:  						Widget.MouseLeave -= WidgetMouseExitedHandler;  						break;  					case WidgetEvent.MouseMoved:  						Widget.MouseMove -= WidgetMouseMoveHandler;  						break;  					case WidgetEvent.BoundsChanged:  						Widget.SizeChanged -= WidgetOnSizeChanged;  						break;  					case WidgetEvent.MouseScrolled:  						Widget.MouseWheel -= WidgetMouseWheelHandler;  						break;  				}
Missing Default,Xwt.WPFBackend,WindowFrameBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WindowFrameBackend.cs,EnableEvent,The following switch statement is missing a default case: switch ((WindowFrameEvent)eventId) {  					case WindowFrameEvent.BoundsChanged:  						window.LocationChanged += BoundsChangedHandler;  						window.SizeChanged += BoundsChangedHandler;  						break;  					case WindowFrameEvent.Shown:  						window.IsVisibleChanged += ShownHandler;  						break;  					case WindowFrameEvent.Hidden:  						window.IsVisibleChanged += HiddenHandler;  						break;  					case WindowFrameEvent.CloseRequested:  						window.Closing += ClosingHandler;  						break;  					case WindowFrameEvent.Closed:  						window.Closed += ClosedHandler;  						break;  				}
Missing Default,Xwt.WPFBackend,WindowFrameBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WindowFrameBackend.cs,DisableEvent,The following switch statement is missing a default case: switch ((WindowFrameEvent)eventId) {  					case WindowFrameEvent.BoundsChanged:  						window.LocationChanged -= BoundsChangedHandler;  						window.SizeChanged -= BoundsChangedHandler;  						break;  					case WindowFrameEvent.Shown:  						window.IsVisibleChanged -= ShownHandler;  						break;  					case WindowFrameEvent.Hidden:  						window.IsVisibleChanged -= HiddenHandler;  						break;  					case WindowFrameEvent.CloseRequested:  						window.Closing -= ClosingHandler;  						break;  					case WindowFrameEvent.Closed:  						window.Closing -= ClosedHandler;  						break;  				}
Missing Default,Xwt.WPFBackend,NotebookBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\NotebookBackend.cs,EnableEvent,The following switch statement is missing a default case: switch ((NotebookEvent)eventId) {  				case NotebookEvent.CurrentTabChanged:  					TabControl.SelectionChanged += OnCurrentTabChanged;  					break;  				}
Missing Default,Xwt.WPFBackend,NotebookBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\NotebookBackend.cs,DisableEvent,The following switch statement is missing a default case: switch ((NotebookEvent)eventId) {  				case NotebookEvent.CurrentTabChanged:  					TabControl.SelectionChanged -= OnCurrentTabChanged;  					break;  				}
Missing Default,Xwt.WPFBackend,RichTextViewBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\RichTextViewBackend.cs,EnableEvent,The following switch statement is missing a default case: switch ((RichTextViewEvent) eventId) {  				case RichTextViewEvent.NavigateToUrl:  						Widget.AddHandler (Hyperlink.RequestNavigateEvent' new RequestNavigateEventHandler (HyperlinkNavigated)' true);  						break;  				}
Missing Default,Xwt.WPFBackend,RichTextViewBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\RichTextViewBackend.cs,DisableEvent,The following switch statement is missing a default case: switch ((RichTextViewEvent) eventId) {  				case RichTextViewEvent.NavigateToUrl:  						Widget.RemoveHandler (Hyperlink.RequestNavigateEvent' new RequestNavigateEventHandler (HyperlinkNavigated));  						break;  				}
Missing Default,Xwt.WPFBackend,WebViewBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WebViewBackend.cs,EnableEvent,The following switch statement is missing a default case: switch ((WebViewEvent)eventId) { 				case WebViewEvent.NavigateToUrl: 					enableNavigatingEvent = true; 					break; 				case WebViewEvent.Loading: 					enableLoadingEvent = true; 					break; 				case WebViewEvent.Loaded: 					enableLoadedEvent = true; 					break; 				case WebViewEvent.TitleChanged: 					enableTitleChangedEvent = true; 					break; 				}
Missing Default,Xwt.WPFBackend,WebViewBackend,C:\repos\mono_xwt\Xwt.WPF\Xwt.WPFBackend\WebViewBackend.cs,DisableEvent,The following switch statement is missing a default case: switch ((WebViewEvent)eventId) { 				case WebViewEvent.NavigateToUrl: 					enableNavigatingEvent = false; 					break; 				case WebViewEvent.Loading: 					enableLoadingEvent = false; 					break; 				case WebViewEvent.Loaded: 					enableLoadedEvent = false; 					break; 				case WebViewEvent.TitleChanged: 					enableTitleChangedEvent = false; 					break; 				}
