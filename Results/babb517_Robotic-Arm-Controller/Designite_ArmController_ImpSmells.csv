Implementation smell,Namespace,Class,File,Method,Description
Long Method,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The method has 132 lines of code.
Complex Method,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,Cyclomatic complexity of the method is 16
Complex Method,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,Cyclomatic complexity of the method is 21
Complex Method,ArmController.Kinect_Module,PositionalTracker,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Kinect Module\PositionalTracker.cs,ProcessSkeletalData,Cyclomatic complexity of the method is 24
Long Statement,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The length of the statement  "	// local flag to store if robot arm is enabled.  We never READ this from the robot' but use it to control our toggle before sending to the robot arm module (via the bus). " is 170.
Long Statement,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The length of the statement  "	// Flags to store if we're currently in a gesture' so we don't repeatedly tell the bus a gesture is occurring' but rather only on change. " is 137.
Long Statement,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The length of the statement  "	// flag meaning that we should keep collecting data.  Set to false by OnFinalize()' which is called when the program is to shut down. " is 133.
Long Statement,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The length of the statement  "                    */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)' " is 138.
Long Statement,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The length of the statement  "			// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18 " is 120.
Long Statement,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The length of the statement  "				// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately. " is 120.
Long Statement,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The length of the statement  "	// Since we've subscribed to the POSITION_TICK' the 'value' parameter has no meaning' we should get the value directly from the bus. " is 132.
Long Statement,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The length of the statement  "				//Debug.WriteLine("forearm: " + (forearm.Roll * 180) / Math.PI + " / " + (forearm.Pitch * 180) / Math.PI + " / " + (forearm.Yaw * 180) / Math.PI); " is 146.
Long Statement,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The length of the statement  "				finalForearmPosition = 1500 + (int)(((forearm.Pitch - ELBOW_PITCH_MIN_DEG * RAD_PER_DEG) / ((ELBOW_PITCH_MAX_DEG - ELBOW_PITCH_MIN_DEG) * RAD_PER_DEG)) * 700); " is 159.
Long Statement,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The length of the statement  "					finalShoulderPosition = 1500 - (int)(((arm.Yaw / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITC_MIN_DEG_PHYSICAL))) " is 172.
Long Statement,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The length of the statement  "					finalShoulderPosition = 1500 + (int)(((Math.Abs (arm.Yaw) / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITCH_MIN_DEG_PHYSICAL))) " is 184.
Long Statement,ArmController.Integration,VirtualBus,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Integration\VirtualBus.cs,Get,The length of the statement  "		throw new ArgumentException ("Cannot get a value of type " + typeof(T).Name + " from node " + node + ". The type must be serializeable."); " is 138.
Long Statement,ArmController.Integration,VirtualBus,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Integration\VirtualBus.cs,Publish,The length of the statement  "		throw new ArgumentException ("Cannot publish a value of type " + typeof(T).Name + " to node " + node + ". The type must be serializeable."); " is 140.
Long Statement,ArmController.Integration,VirtualBus,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Integration\VirtualBus.cs,Publish,The length of the statement  "		throw new ArgumentException ("Cannot publish a value of type " + typeof(T).Name + " to a node " + node + " of type " + entry.Node.NodeType.Name + ". The types are not compatible."); " is 181.
Long Statement,ArmController.Integration,VirtualBus,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Integration\VirtualBus.cs,Unsubscribe,The length of the statement  "			throw new ArgumentException ("Unable to unsubscribe from node " + node + " as the delegate wasn't subscribed properly."); " is 121.
Long Statement,ArmController.Kinect_Module,PositionalTracker,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Kinect Module\PositionalTracker.cs,ProcessSkeletalData,The length of the statement  "		//Debug.WriteLine((_playerOne.BoneOrientations[JointType.ElbowRight].HierarchicalRotation.Matrix.M12 * inv_cos_roll).ToString("F3") + " " + (_playerOne.BoneOrientations[JointType.ElbowRight].HierarchicalRotation.Matrix.M23 * inv_cos_roll).ToString("F3")); " is 255.
Long Statement,ArmController.Kinect_Module,PositionFeedback,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Kinect Module\PositionFeedback.cs,OrientationToString,The length of the statement  "	return (or.Roll * (180 / Math.PI)).ToString ("F2") + " / " + (or.Pitch * (180 / Math.PI)).ToString ("F2") + " / " + (or.Yaw * (180 / Math.PI)).ToString ("F2"); " is 159.
Long Statement,ArmController.Kinect_Module,SkeletonRenderer,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Kinect Module\SkeletonRenderer.cs,RenderClippedEdges,The length of the statement  "		context.DrawRectangle (Brushes.Red' null' new Rect (0' RenderHeight - ClipBoundsThickness' RenderWidth' ClipBoundsThickness)); " is 126.
Long Statement,ArmController.Kinect_Module,SkeletonRenderer,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Kinect Module\SkeletonRenderer.cs,RenderClippedEdges,The length of the statement  "		context.DrawRectangle (Brushes.Red' null' new Rect (RenderWidth - ClipBoundsThickness' 0' ClipBoundsThickness' RenderHeight)); " is 126.
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,OnInitialize,The following statement contains a magic number: sp = new SerialPort ("COM1"' 115200' Parity.None' 8' StopBits.One);  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,OnInitialize,The following statement contains a magic number: sp = new SerialPort ("COM1"' 115200' Parity.None' 8' StopBits.One);  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: while (running) {  	//sp.Write("G");  // tell glove to start streaming  	sp.Write ("g");  	// request a single sample from the CyberGlove  	try {  		Debug.WriteLine ("Reading from CyberGlove...");  		msg = sp.ReadLine ();  		Debug.WriteLine ("Yay!");  		/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  		// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  		// sensors on the glove.  See the manual for their names.  		string[] sensors = Regex.Split (msg' "\\s+");  		if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  		 {  			// Note that values are same for both right and left hand gloves.  			int pinky = Convert.ToInt32 (sensors [14]);  			// get flex of pinky's first joint  			int ring = Convert.ToInt32 (sensors [11]);  			// get flex of ring finger's first joint  			int middle = Convert.ToInt32 (sensors [8]);  			// get flex of middle finger's first joint  			indexFinger = Convert.ToInt32 (sensors [5]);  			// get flex of index finger's first joint  			wrist = Convert.ToInt32 (sensors [17]);  			// get flex/extension of wrist  			// Detect "Starting Postion" gesture  			// Currently we do NOT publish this gesture to the bus  			if (pinky >= 120) {  				if (!pinkyGesture) {  					//Console.WriteLine("Moving to starting position");  					pinkyGesture = true;  					// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  				}  			}  			else {  				if (pinkyGesture)  					pinkyGesture = false;  			}  			// Detect start/stop (robot arm) gesture  			if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  			 {  				if (!movingGesture)// If we're not already in the "moving" gesture...  				 {  					if (moving == true)// If the robot arm is moving' stop it.  					 {  						moving = false;  						Console.WriteLine ("Telling robot arm to stop");  						Bus.Publish (BusNode.ROBOT_ACTIVE' false);  					}  					else// If the robot arm is not moving' enable it.  					 {  						moving = true;  						Console.WriteLine ("Telling robot arm to begin tracking");  						Bus.Publish (BusNode.ROBOT_ACTIVE' true);  					}  					movingGesture = true;  					// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  				}  			}  			else// If we're not in the moving gesture...  			 {  				if (movingGesture)  					// ... and we were' record the change' so we can re-enter the gesture later.  					movingGesture = false;  			}  			/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  			index_percent = ((indexFinger - 125) / 55) * 100;  			if (index_percent < 0)  				index_percent = 0;  			else if (index_percent > 100)  				index_percent = 100;  			/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  			// Craig centered (hand straight): 170 (180 degrees)  			// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  			// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  			if (wrist >= 170)  				wrist_percent = (wrist - 170) / 45 * 50 + 50;  			else  				wrist_percent = (wrist - 75) / 95 * 50;  			if (wrist_percent < 0)  				wrist_percent = 0;  			else if (wrist_percent > 100)  				wrist_percent = 100;  			/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  			//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  			//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  			Debug.WriteLine ("Moving gesture? " + movingGesture);  			Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  			Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  		}  	}  	catch (TimeoutException) {  		Debug.WriteLine ("Timed out waiting for CyberGlove data!");  	}  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: while (running) {  	//sp.Write("G");  // tell glove to start streaming  	sp.Write ("g");  	// request a single sample from the CyberGlove  	try {  		Debug.WriteLine ("Reading from CyberGlove...");  		msg = sp.ReadLine ();  		Debug.WriteLine ("Yay!");  		/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  		// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  		// sensors on the glove.  See the manual for their names.  		string[] sensors = Regex.Split (msg' "\\s+");  		if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  		 {  			// Note that values are same for both right and left hand gloves.  			int pinky = Convert.ToInt32 (sensors [14]);  			// get flex of pinky's first joint  			int ring = Convert.ToInt32 (sensors [11]);  			// get flex of ring finger's first joint  			int middle = Convert.ToInt32 (sensors [8]);  			// get flex of middle finger's first joint  			indexFinger = Convert.ToInt32 (sensors [5]);  			// get flex of index finger's first joint  			wrist = Convert.ToInt32 (sensors [17]);  			// get flex/extension of wrist  			// Detect "Starting Postion" gesture  			// Currently we do NOT publish this gesture to the bus  			if (pinky >= 120) {  				if (!pinkyGesture) {  					//Console.WriteLine("Moving to starting position");  					pinkyGesture = true;  					// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  				}  			}  			else {  				if (pinkyGesture)  					pinkyGesture = false;  			}  			// Detect start/stop (robot arm) gesture  			if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  			 {  				if (!movingGesture)// If we're not already in the "moving" gesture...  				 {  					if (moving == true)// If the robot arm is moving' stop it.  					 {  						moving = false;  						Console.WriteLine ("Telling robot arm to stop");  						Bus.Publish (BusNode.ROBOT_ACTIVE' false);  					}  					else// If the robot arm is not moving' enable it.  					 {  						moving = true;  						Console.WriteLine ("Telling robot arm to begin tracking");  						Bus.Publish (BusNode.ROBOT_ACTIVE' true);  					}  					movingGesture = true;  					// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  				}  			}  			else// If we're not in the moving gesture...  			 {  				if (movingGesture)  					// ... and we were' record the change' so we can re-enter the gesture later.  					movingGesture = false;  			}  			/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  			index_percent = ((indexFinger - 125) / 55) * 100;  			if (index_percent < 0)  				index_percent = 0;  			else if (index_percent > 100)  				index_percent = 100;  			/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  			// Craig centered (hand straight): 170 (180 degrees)  			// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  			// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  			if (wrist >= 170)  				wrist_percent = (wrist - 170) / 45 * 50 + 50;  			else  				wrist_percent = (wrist - 75) / 95 * 50;  			if (wrist_percent < 0)  				wrist_percent = 0;  			else if (wrist_percent > 100)  				wrist_percent = 100;  			/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  			//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  			//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  			Debug.WriteLine ("Moving gesture? " + movingGesture);  			Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  			Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  		}  	}  	catch (TimeoutException) {  		Debug.WriteLine ("Timed out waiting for CyberGlove data!");  	}  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: while (running) {  	//sp.Write("G");  // tell glove to start streaming  	sp.Write ("g");  	// request a single sample from the CyberGlove  	try {  		Debug.WriteLine ("Reading from CyberGlove...");  		msg = sp.ReadLine ();  		Debug.WriteLine ("Yay!");  		/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  		// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  		// sensors on the glove.  See the manual for their names.  		string[] sensors = Regex.Split (msg' "\\s+");  		if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  		 {  			// Note that values are same for both right and left hand gloves.  			int pinky = Convert.ToInt32 (sensors [14]);  			// get flex of pinky's first joint  			int ring = Convert.ToInt32 (sensors [11]);  			// get flex of ring finger's first joint  			int middle = Convert.ToInt32 (sensors [8]);  			// get flex of middle finger's first joint  			indexFinger = Convert.ToInt32 (sensors [5]);  			// get flex of index finger's first joint  			wrist = Convert.ToInt32 (sensors [17]);  			// get flex/extension of wrist  			// Detect "Starting Postion" gesture  			// Currently we do NOT publish this gesture to the bus  			if (pinky >= 120) {  				if (!pinkyGesture) {  					//Console.WriteLine("Moving to starting position");  					pinkyGesture = true;  					// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  				}  			}  			else {  				if (pinkyGesture)  					pinkyGesture = false;  			}  			// Detect start/stop (robot arm) gesture  			if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  			 {  				if (!movingGesture)// If we're not already in the "moving" gesture...  				 {  					if (moving == true)// If the robot arm is moving' stop it.  					 {  						moving = false;  						Console.WriteLine ("Telling robot arm to stop");  						Bus.Publish (BusNode.ROBOT_ACTIVE' false);  					}  					else// If the robot arm is not moving' enable it.  					 {  						moving = true;  						Console.WriteLine ("Telling robot arm to begin tracking");  						Bus.Publish (BusNode.ROBOT_ACTIVE' true);  					}  					movingGesture = true;  					// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  				}  			}  			else// If we're not in the moving gesture...  			 {  				if (movingGesture)  					// ... and we were' record the change' so we can re-enter the gesture later.  					movingGesture = false;  			}  			/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  			index_percent = ((indexFinger - 125) / 55) * 100;  			if (index_percent < 0)  				index_percent = 0;  			else if (index_percent > 100)  				index_percent = 100;  			/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  			// Craig centered (hand straight): 170 (180 degrees)  			// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  			// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  			if (wrist >= 170)  				wrist_percent = (wrist - 170) / 45 * 50 + 50;  			else  				wrist_percent = (wrist - 75) / 95 * 50;  			if (wrist_percent < 0)  				wrist_percent = 0;  			else if (wrist_percent > 100)  				wrist_percent = 100;  			/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  			//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  			//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  			Debug.WriteLine ("Moving gesture? " + movingGesture);  			Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  			Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  		}  	}  	catch (TimeoutException) {  		Debug.WriteLine ("Timed out waiting for CyberGlove data!");  	}  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: while (running) {  	//sp.Write("G");  // tell glove to start streaming  	sp.Write ("g");  	// request a single sample from the CyberGlove  	try {  		Debug.WriteLine ("Reading from CyberGlove...");  		msg = sp.ReadLine ();  		Debug.WriteLine ("Yay!");  		/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  		// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  		// sensors on the glove.  See the manual for their names.  		string[] sensors = Regex.Split (msg' "\\s+");  		if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  		 {  			// Note that values are same for both right and left hand gloves.  			int pinky = Convert.ToInt32 (sensors [14]);  			// get flex of pinky's first joint  			int ring = Convert.ToInt32 (sensors [11]);  			// get flex of ring finger's first joint  			int middle = Convert.ToInt32 (sensors [8]);  			// get flex of middle finger's first joint  			indexFinger = Convert.ToInt32 (sensors [5]);  			// get flex of index finger's first joint  			wrist = Convert.ToInt32 (sensors [17]);  			// get flex/extension of wrist  			// Detect "Starting Postion" gesture  			// Currently we do NOT publish this gesture to the bus  			if (pinky >= 120) {  				if (!pinkyGesture) {  					//Console.WriteLine("Moving to starting position");  					pinkyGesture = true;  					// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  				}  			}  			else {  				if (pinkyGesture)  					pinkyGesture = false;  			}  			// Detect start/stop (robot arm) gesture  			if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  			 {  				if (!movingGesture)// If we're not already in the "moving" gesture...  				 {  					if (moving == true)// If the robot arm is moving' stop it.  					 {  						moving = false;  						Console.WriteLine ("Telling robot arm to stop");  						Bus.Publish (BusNode.ROBOT_ACTIVE' false);  					}  					else// If the robot arm is not moving' enable it.  					 {  						moving = true;  						Console.WriteLine ("Telling robot arm to begin tracking");  						Bus.Publish (BusNode.ROBOT_ACTIVE' true);  					}  					movingGesture = true;  					// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  				}  			}  			else// If we're not in the moving gesture...  			 {  				if (movingGesture)  					// ... and we were' record the change' so we can re-enter the gesture later.  					movingGesture = false;  			}  			/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  			index_percent = ((indexFinger - 125) / 55) * 100;  			if (index_percent < 0)  				index_percent = 0;  			else if (index_percent > 100)  				index_percent = 100;  			/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  			// Craig centered (hand straight): 170 (180 degrees)  			// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  			// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  			if (wrist >= 170)  				wrist_percent = (wrist - 170) / 45 * 50 + 50;  			else  				wrist_percent = (wrist - 75) / 95 * 50;  			if (wrist_percent < 0)  				wrist_percent = 0;  			else if (wrist_percent > 100)  				wrist_percent = 100;  			/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  			//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  			//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  			Debug.WriteLine ("Moving gesture? " + movingGesture);  			Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  			Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  		}  	}  	catch (TimeoutException) {  		Debug.WriteLine ("Timed out waiting for CyberGlove data!");  	}  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: while (running) {  	//sp.Write("G");  // tell glove to start streaming  	sp.Write ("g");  	// request a single sample from the CyberGlove  	try {  		Debug.WriteLine ("Reading from CyberGlove...");  		msg = sp.ReadLine ();  		Debug.WriteLine ("Yay!");  		/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  		// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  		// sensors on the glove.  See the manual for their names.  		string[] sensors = Regex.Split (msg' "\\s+");  		if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  		 {  			// Note that values are same for both right and left hand gloves.  			int pinky = Convert.ToInt32 (sensors [14]);  			// get flex of pinky's first joint  			int ring = Convert.ToInt32 (sensors [11]);  			// get flex of ring finger's first joint  			int middle = Convert.ToInt32 (sensors [8]);  			// get flex of middle finger's first joint  			indexFinger = Convert.ToInt32 (sensors [5]);  			// get flex of index finger's first joint  			wrist = Convert.ToInt32 (sensors [17]);  			// get flex/extension of wrist  			// Detect "Starting Postion" gesture  			// Currently we do NOT publish this gesture to the bus  			if (pinky >= 120) {  				if (!pinkyGesture) {  					//Console.WriteLine("Moving to starting position");  					pinkyGesture = true;  					// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  				}  			}  			else {  				if (pinkyGesture)  					pinkyGesture = false;  			}  			// Detect start/stop (robot arm) gesture  			if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  			 {  				if (!movingGesture)// If we're not already in the "moving" gesture...  				 {  					if (moving == true)// If the robot arm is moving' stop it.  					 {  						moving = false;  						Console.WriteLine ("Telling robot arm to stop");  						Bus.Publish (BusNode.ROBOT_ACTIVE' false);  					}  					else// If the robot arm is not moving' enable it.  					 {  						moving = true;  						Console.WriteLine ("Telling robot arm to begin tracking");  						Bus.Publish (BusNode.ROBOT_ACTIVE' true);  					}  					movingGesture = true;  					// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  				}  			}  			else// If we're not in the moving gesture...  			 {  				if (movingGesture)  					// ... and we were' record the change' so we can re-enter the gesture later.  					movingGesture = false;  			}  			/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  			index_percent = ((indexFinger - 125) / 55) * 100;  			if (index_percent < 0)  				index_percent = 0;  			else if (index_percent > 100)  				index_percent = 100;  			/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  			// Craig centered (hand straight): 170 (180 degrees)  			// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  			// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  			if (wrist >= 170)  				wrist_percent = (wrist - 170) / 45 * 50 + 50;  			else  				wrist_percent = (wrist - 75) / 95 * 50;  			if (wrist_percent < 0)  				wrist_percent = 0;  			else if (wrist_percent > 100)  				wrist_percent = 100;  			/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  			//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  			//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  			Debug.WriteLine ("Moving gesture? " + movingGesture);  			Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  			Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  		}  	}  	catch (TimeoutException) {  		Debug.WriteLine ("Timed out waiting for CyberGlove data!");  	}  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: while (running) {  	//sp.Write("G");  // tell glove to start streaming  	sp.Write ("g");  	// request a single sample from the CyberGlove  	try {  		Debug.WriteLine ("Reading from CyberGlove...");  		msg = sp.ReadLine ();  		Debug.WriteLine ("Yay!");  		/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  		// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  		// sensors on the glove.  See the manual for their names.  		string[] sensors = Regex.Split (msg' "\\s+");  		if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  		 {  			// Note that values are same for both right and left hand gloves.  			int pinky = Convert.ToInt32 (sensors [14]);  			// get flex of pinky's first joint  			int ring = Convert.ToInt32 (sensors [11]);  			// get flex of ring finger's first joint  			int middle = Convert.ToInt32 (sensors [8]);  			// get flex of middle finger's first joint  			indexFinger = Convert.ToInt32 (sensors [5]);  			// get flex of index finger's first joint  			wrist = Convert.ToInt32 (sensors [17]);  			// get flex/extension of wrist  			// Detect "Starting Postion" gesture  			// Currently we do NOT publish this gesture to the bus  			if (pinky >= 120) {  				if (!pinkyGesture) {  					//Console.WriteLine("Moving to starting position");  					pinkyGesture = true;  					// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  				}  			}  			else {  				if (pinkyGesture)  					pinkyGesture = false;  			}  			// Detect start/stop (robot arm) gesture  			if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  			 {  				if (!movingGesture)// If we're not already in the "moving" gesture...  				 {  					if (moving == true)// If the robot arm is moving' stop it.  					 {  						moving = false;  						Console.WriteLine ("Telling robot arm to stop");  						Bus.Publish (BusNode.ROBOT_ACTIVE' false);  					}  					else// If the robot arm is not moving' enable it.  					 {  						moving = true;  						Console.WriteLine ("Telling robot arm to begin tracking");  						Bus.Publish (BusNode.ROBOT_ACTIVE' true);  					}  					movingGesture = true;  					// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  				}  			}  			else// If we're not in the moving gesture...  			 {  				if (movingGesture)  					// ... and we were' record the change' so we can re-enter the gesture later.  					movingGesture = false;  			}  			/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  			index_percent = ((indexFinger - 125) / 55) * 100;  			if (index_percent < 0)  				index_percent = 0;  			else if (index_percent > 100)  				index_percent = 100;  			/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  			// Craig centered (hand straight): 170 (180 degrees)  			// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  			// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  			if (wrist >= 170)  				wrist_percent = (wrist - 170) / 45 * 50 + 50;  			else  				wrist_percent = (wrist - 75) / 95 * 50;  			if (wrist_percent < 0)  				wrist_percent = 0;  			else if (wrist_percent > 100)  				wrist_percent = 100;  			/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  			//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  			//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  			Debug.WriteLine ("Moving gesture? " + movingGesture);  			Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  			Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  		}  	}  	catch (TimeoutException) {  		Debug.WriteLine ("Timed out waiting for CyberGlove data!");  	}  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: while (running) {  	//sp.Write("G");  // tell glove to start streaming  	sp.Write ("g");  	// request a single sample from the CyberGlove  	try {  		Debug.WriteLine ("Reading from CyberGlove...");  		msg = sp.ReadLine ();  		Debug.WriteLine ("Yay!");  		/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  		// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  		// sensors on the glove.  See the manual for their names.  		string[] sensors = Regex.Split (msg' "\\s+");  		if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  		 {  			// Note that values are same for both right and left hand gloves.  			int pinky = Convert.ToInt32 (sensors [14]);  			// get flex of pinky's first joint  			int ring = Convert.ToInt32 (sensors [11]);  			// get flex of ring finger's first joint  			int middle = Convert.ToInt32 (sensors [8]);  			// get flex of middle finger's first joint  			indexFinger = Convert.ToInt32 (sensors [5]);  			// get flex of index finger's first joint  			wrist = Convert.ToInt32 (sensors [17]);  			// get flex/extension of wrist  			// Detect "Starting Postion" gesture  			// Currently we do NOT publish this gesture to the bus  			if (pinky >= 120) {  				if (!pinkyGesture) {  					//Console.WriteLine("Moving to starting position");  					pinkyGesture = true;  					// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  				}  			}  			else {  				if (pinkyGesture)  					pinkyGesture = false;  			}  			// Detect start/stop (robot arm) gesture  			if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  			 {  				if (!movingGesture)// If we're not already in the "moving" gesture...  				 {  					if (moving == true)// If the robot arm is moving' stop it.  					 {  						moving = false;  						Console.WriteLine ("Telling robot arm to stop");  						Bus.Publish (BusNode.ROBOT_ACTIVE' false);  					}  					else// If the robot arm is not moving' enable it.  					 {  						moving = true;  						Console.WriteLine ("Telling robot arm to begin tracking");  						Bus.Publish (BusNode.ROBOT_ACTIVE' true);  					}  					movingGesture = true;  					// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  				}  			}  			else// If we're not in the moving gesture...  			 {  				if (movingGesture)  					// ... and we were' record the change' so we can re-enter the gesture later.  					movingGesture = false;  			}  			/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  			index_percent = ((indexFinger - 125) / 55) * 100;  			if (index_percent < 0)  				index_percent = 0;  			else if (index_percent > 100)  				index_percent = 100;  			/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  			// Craig centered (hand straight): 170 (180 degrees)  			// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  			// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  			if (wrist >= 170)  				wrist_percent = (wrist - 170) / 45 * 50 + 50;  			else  				wrist_percent = (wrist - 75) / 95 * 50;  			if (wrist_percent < 0)  				wrist_percent = 0;  			else if (wrist_percent > 100)  				wrist_percent = 100;  			/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  			//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  			//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  			Debug.WriteLine ("Moving gesture? " + movingGesture);  			Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  			Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  		}  	}  	catch (TimeoutException) {  		Debug.WriteLine ("Timed out waiting for CyberGlove data!");  	}  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: while (running) {  	//sp.Write("G");  // tell glove to start streaming  	sp.Write ("g");  	// request a single sample from the CyberGlove  	try {  		Debug.WriteLine ("Reading from CyberGlove...");  		msg = sp.ReadLine ();  		Debug.WriteLine ("Yay!");  		/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  		// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  		// sensors on the glove.  See the manual for their names.  		string[] sensors = Regex.Split (msg' "\\s+");  		if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  		 {  			// Note that values are same for both right and left hand gloves.  			int pinky = Convert.ToInt32 (sensors [14]);  			// get flex of pinky's first joint  			int ring = Convert.ToInt32 (sensors [11]);  			// get flex of ring finger's first joint  			int middle = Convert.ToInt32 (sensors [8]);  			// get flex of middle finger's first joint  			indexFinger = Convert.ToInt32 (sensors [5]);  			// get flex of index finger's first joint  			wrist = Convert.ToInt32 (sensors [17]);  			// get flex/extension of wrist  			// Detect "Starting Postion" gesture  			// Currently we do NOT publish this gesture to the bus  			if (pinky >= 120) {  				if (!pinkyGesture) {  					//Console.WriteLine("Moving to starting position");  					pinkyGesture = true;  					// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  				}  			}  			else {  				if (pinkyGesture)  					pinkyGesture = false;  			}  			// Detect start/stop (robot arm) gesture  			if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  			 {  				if (!movingGesture)// If we're not already in the "moving" gesture...  				 {  					if (moving == true)// If the robot arm is moving' stop it.  					 {  						moving = false;  						Console.WriteLine ("Telling robot arm to stop");  						Bus.Publish (BusNode.ROBOT_ACTIVE' false);  					}  					else// If the robot arm is not moving' enable it.  					 {  						moving = true;  						Console.WriteLine ("Telling robot arm to begin tracking");  						Bus.Publish (BusNode.ROBOT_ACTIVE' true);  					}  					movingGesture = true;  					// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  				}  			}  			else// If we're not in the moving gesture...  			 {  				if (movingGesture)  					// ... and we were' record the change' so we can re-enter the gesture later.  					movingGesture = false;  			}  			/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  			index_percent = ((indexFinger - 125) / 55) * 100;  			if (index_percent < 0)  				index_percent = 0;  			else if (index_percent > 100)  				index_percent = 100;  			/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  			// Craig centered (hand straight): 170 (180 degrees)  			// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  			// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  			if (wrist >= 170)  				wrist_percent = (wrist - 170) / 45 * 50 + 50;  			else  				wrist_percent = (wrist - 75) / 95 * 50;  			if (wrist_percent < 0)  				wrist_percent = 0;  			else if (wrist_percent > 100)  				wrist_percent = 100;  			/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  			//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  			//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  			Debug.WriteLine ("Moving gesture? " + movingGesture);  			Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  			Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  		}  	}  	catch (TimeoutException) {  		Debug.WriteLine ("Timed out waiting for CyberGlove data!");  	}  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: while (running) {  	//sp.Write("G");  // tell glove to start streaming  	sp.Write ("g");  	// request a single sample from the CyberGlove  	try {  		Debug.WriteLine ("Reading from CyberGlove...");  		msg = sp.ReadLine ();  		Debug.WriteLine ("Yay!");  		/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  		// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  		// sensors on the glove.  See the manual for their names.  		string[] sensors = Regex.Split (msg' "\\s+");  		if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  		 {  			// Note that values are same for both right and left hand gloves.  			int pinky = Convert.ToInt32 (sensors [14]);  			// get flex of pinky's first joint  			int ring = Convert.ToInt32 (sensors [11]);  			// get flex of ring finger's first joint  			int middle = Convert.ToInt32 (sensors [8]);  			// get flex of middle finger's first joint  			indexFinger = Convert.ToInt32 (sensors [5]);  			// get flex of index finger's first joint  			wrist = Convert.ToInt32 (sensors [17]);  			// get flex/extension of wrist  			// Detect "Starting Postion" gesture  			// Currently we do NOT publish this gesture to the bus  			if (pinky >= 120) {  				if (!pinkyGesture) {  					//Console.WriteLine("Moving to starting position");  					pinkyGesture = true;  					// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  				}  			}  			else {  				if (pinkyGesture)  					pinkyGesture = false;  			}  			// Detect start/stop (robot arm) gesture  			if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  			 {  				if (!movingGesture)// If we're not already in the "moving" gesture...  				 {  					if (moving == true)// If the robot arm is moving' stop it.  					 {  						moving = false;  						Console.WriteLine ("Telling robot arm to stop");  						Bus.Publish (BusNode.ROBOT_ACTIVE' false);  					}  					else// If the robot arm is not moving' enable it.  					 {  						moving = true;  						Console.WriteLine ("Telling robot arm to begin tracking");  						Bus.Publish (BusNode.ROBOT_ACTIVE' true);  					}  					movingGesture = true;  					// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  				}  			}  			else// If we're not in the moving gesture...  			 {  				if (movingGesture)  					// ... and we were' record the change' so we can re-enter the gesture later.  					movingGesture = false;  			}  			/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  			index_percent = ((indexFinger - 125) / 55) * 100;  			if (index_percent < 0)  				index_percent = 0;  			else if (index_percent > 100)  				index_percent = 100;  			/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  			// Craig centered (hand straight): 170 (180 degrees)  			// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  			// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  			if (wrist >= 170)  				wrist_percent = (wrist - 170) / 45 * 50 + 50;  			else  				wrist_percent = (wrist - 75) / 95 * 50;  			if (wrist_percent < 0)  				wrist_percent = 0;  			else if (wrist_percent > 100)  				wrist_percent = 100;  			/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  			//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  			//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  			Debug.WriteLine ("Moving gesture? " + movingGesture);  			Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  			Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  		}  	}  	catch (TimeoutException) {  		Debug.WriteLine ("Timed out waiting for CyberGlove data!");  	}  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: while (running) {  	//sp.Write("G");  // tell glove to start streaming  	sp.Write ("g");  	// request a single sample from the CyberGlove  	try {  		Debug.WriteLine ("Reading from CyberGlove...");  		msg = sp.ReadLine ();  		Debug.WriteLine ("Yay!");  		/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  		// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  		// sensors on the glove.  See the manual for their names.  		string[] sensors = Regex.Split (msg' "\\s+");  		if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  		 {  			// Note that values are same for both right and left hand gloves.  			int pinky = Convert.ToInt32 (sensors [14]);  			// get flex of pinky's first joint  			int ring = Convert.ToInt32 (sensors [11]);  			// get flex of ring finger's first joint  			int middle = Convert.ToInt32 (sensors [8]);  			// get flex of middle finger's first joint  			indexFinger = Convert.ToInt32 (sensors [5]);  			// get flex of index finger's first joint  			wrist = Convert.ToInt32 (sensors [17]);  			// get flex/extension of wrist  			// Detect "Starting Postion" gesture  			// Currently we do NOT publish this gesture to the bus  			if (pinky >= 120) {  				if (!pinkyGesture) {  					//Console.WriteLine("Moving to starting position");  					pinkyGesture = true;  					// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  				}  			}  			else {  				if (pinkyGesture)  					pinkyGesture = false;  			}  			// Detect start/stop (robot arm) gesture  			if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  			 {  				if (!movingGesture)// If we're not already in the "moving" gesture...  				 {  					if (moving == true)// If the robot arm is moving' stop it.  					 {  						moving = false;  						Console.WriteLine ("Telling robot arm to stop");  						Bus.Publish (BusNode.ROBOT_ACTIVE' false);  					}  					else// If the robot arm is not moving' enable it.  					 {  						moving = true;  						Console.WriteLine ("Telling robot arm to begin tracking");  						Bus.Publish (BusNode.ROBOT_ACTIVE' true);  					}  					movingGesture = true;  					// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  				}  			}  			else// If we're not in the moving gesture...  			 {  				if (movingGesture)  					// ... and we were' record the change' so we can re-enter the gesture later.  					movingGesture = false;  			}  			/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  			index_percent = ((indexFinger - 125) / 55) * 100;  			if (index_percent < 0)  				index_percent = 0;  			else if (index_percent > 100)  				index_percent = 100;  			/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  			// Craig centered (hand straight): 170 (180 degrees)  			// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  			// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  			if (wrist >= 170)  				wrist_percent = (wrist - 170) / 45 * 50 + 50;  			else  				wrist_percent = (wrist - 75) / 95 * 50;  			if (wrist_percent < 0)  				wrist_percent = 0;  			else if (wrist_percent > 100)  				wrist_percent = 100;  			/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  			//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  			//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  			Debug.WriteLine ("Moving gesture? " + movingGesture);  			Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  			Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  		}  	}  	catch (TimeoutException) {  		Debug.WriteLine ("Timed out waiting for CyberGlove data!");  	}  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: while (running) {  	//sp.Write("G");  // tell glove to start streaming  	sp.Write ("g");  	// request a single sample from the CyberGlove  	try {  		Debug.WriteLine ("Reading from CyberGlove...");  		msg = sp.ReadLine ();  		Debug.WriteLine ("Yay!");  		/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  		// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  		// sensors on the glove.  See the manual for their names.  		string[] sensors = Regex.Split (msg' "\\s+");  		if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  		 {  			// Note that values are same for both right and left hand gloves.  			int pinky = Convert.ToInt32 (sensors [14]);  			// get flex of pinky's first joint  			int ring = Convert.ToInt32 (sensors [11]);  			// get flex of ring finger's first joint  			int middle = Convert.ToInt32 (sensors [8]);  			// get flex of middle finger's first joint  			indexFinger = Convert.ToInt32 (sensors [5]);  			// get flex of index finger's first joint  			wrist = Convert.ToInt32 (sensors [17]);  			// get flex/extension of wrist  			// Detect "Starting Postion" gesture  			// Currently we do NOT publish this gesture to the bus  			if (pinky >= 120) {  				if (!pinkyGesture) {  					//Console.WriteLine("Moving to starting position");  					pinkyGesture = true;  					// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  				}  			}  			else {  				if (pinkyGesture)  					pinkyGesture = false;  			}  			// Detect start/stop (robot arm) gesture  			if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  			 {  				if (!movingGesture)// If we're not already in the "moving" gesture...  				 {  					if (moving == true)// If the robot arm is moving' stop it.  					 {  						moving = false;  						Console.WriteLine ("Telling robot arm to stop");  						Bus.Publish (BusNode.ROBOT_ACTIVE' false);  					}  					else// If the robot arm is not moving' enable it.  					 {  						moving = true;  						Console.WriteLine ("Telling robot arm to begin tracking");  						Bus.Publish (BusNode.ROBOT_ACTIVE' true);  					}  					movingGesture = true;  					// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  				}  			}  			else// If we're not in the moving gesture...  			 {  				if (movingGesture)  					// ... and we were' record the change' so we can re-enter the gesture later.  					movingGesture = false;  			}  			/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  			index_percent = ((indexFinger - 125) / 55) * 100;  			if (index_percent < 0)  				index_percent = 0;  			else if (index_percent > 100)  				index_percent = 100;  			/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  			// Craig centered (hand straight): 170 (180 degrees)  			// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  			// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  			if (wrist >= 170)  				wrist_percent = (wrist - 170) / 45 * 50 + 50;  			else  				wrist_percent = (wrist - 75) / 95 * 50;  			if (wrist_percent < 0)  				wrist_percent = 0;  			else if (wrist_percent > 100)  				wrist_percent = 100;  			/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  			//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  			//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  			Debug.WriteLine ("Moving gesture? " + movingGesture);  			Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  			Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  		}  	}  	catch (TimeoutException) {  		Debug.WriteLine ("Timed out waiting for CyberGlove data!");  	}  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: while (running) {  	//sp.Write("G");  // tell glove to start streaming  	sp.Write ("g");  	// request a single sample from the CyberGlove  	try {  		Debug.WriteLine ("Reading from CyberGlove...");  		msg = sp.ReadLine ();  		Debug.WriteLine ("Yay!");  		/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  		// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  		// sensors on the glove.  See the manual for their names.  		string[] sensors = Regex.Split (msg' "\\s+");  		if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  		 {  			// Note that values are same for both right and left hand gloves.  			int pinky = Convert.ToInt32 (sensors [14]);  			// get flex of pinky's first joint  			int ring = Convert.ToInt32 (sensors [11]);  			// get flex of ring finger's first joint  			int middle = Convert.ToInt32 (sensors [8]);  			// get flex of middle finger's first joint  			indexFinger = Convert.ToInt32 (sensors [5]);  			// get flex of index finger's first joint  			wrist = Convert.ToInt32 (sensors [17]);  			// get flex/extension of wrist  			// Detect "Starting Postion" gesture  			// Currently we do NOT publish this gesture to the bus  			if (pinky >= 120) {  				if (!pinkyGesture) {  					//Console.WriteLine("Moving to starting position");  					pinkyGesture = true;  					// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  				}  			}  			else {  				if (pinkyGesture)  					pinkyGesture = false;  			}  			// Detect start/stop (robot arm) gesture  			if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  			 {  				if (!movingGesture)// If we're not already in the "moving" gesture...  				 {  					if (moving == true)// If the robot arm is moving' stop it.  					 {  						moving = false;  						Console.WriteLine ("Telling robot arm to stop");  						Bus.Publish (BusNode.ROBOT_ACTIVE' false);  					}  					else// If the robot arm is not moving' enable it.  					 {  						moving = true;  						Console.WriteLine ("Telling robot arm to begin tracking");  						Bus.Publish (BusNode.ROBOT_ACTIVE' true);  					}  					movingGesture = true;  					// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  				}  			}  			else// If we're not in the moving gesture...  			 {  				if (movingGesture)  					// ... and we were' record the change' so we can re-enter the gesture later.  					movingGesture = false;  			}  			/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  			index_percent = ((indexFinger - 125) / 55) * 100;  			if (index_percent < 0)  				index_percent = 0;  			else if (index_percent > 100)  				index_percent = 100;  			/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  			// Craig centered (hand straight): 170 (180 degrees)  			// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  			// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  			if (wrist >= 170)  				wrist_percent = (wrist - 170) / 45 * 50 + 50;  			else  				wrist_percent = (wrist - 75) / 95 * 50;  			if (wrist_percent < 0)  				wrist_percent = 0;  			else if (wrist_percent > 100)  				wrist_percent = 100;  			/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  			//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  			//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  			Debug.WriteLine ("Moving gesture? " + movingGesture);  			Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  			Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  		}  	}  	catch (TimeoutException) {  		Debug.WriteLine ("Timed out waiting for CyberGlove data!");  	}  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: while (running) {  	//sp.Write("G");  // tell glove to start streaming  	sp.Write ("g");  	// request a single sample from the CyberGlove  	try {  		Debug.WriteLine ("Reading from CyberGlove...");  		msg = sp.ReadLine ();  		Debug.WriteLine ("Yay!");  		/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  		// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  		// sensors on the glove.  See the manual for their names.  		string[] sensors = Regex.Split (msg' "\\s+");  		if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  		 {  			// Note that values are same for both right and left hand gloves.  			int pinky = Convert.ToInt32 (sensors [14]);  			// get flex of pinky's first joint  			int ring = Convert.ToInt32 (sensors [11]);  			// get flex of ring finger's first joint  			int middle = Convert.ToInt32 (sensors [8]);  			// get flex of middle finger's first joint  			indexFinger = Convert.ToInt32 (sensors [5]);  			// get flex of index finger's first joint  			wrist = Convert.ToInt32 (sensors [17]);  			// get flex/extension of wrist  			// Detect "Starting Postion" gesture  			// Currently we do NOT publish this gesture to the bus  			if (pinky >= 120) {  				if (!pinkyGesture) {  					//Console.WriteLine("Moving to starting position");  					pinkyGesture = true;  					// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  				}  			}  			else {  				if (pinkyGesture)  					pinkyGesture = false;  			}  			// Detect start/stop (robot arm) gesture  			if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  			 {  				if (!movingGesture)// If we're not already in the "moving" gesture...  				 {  					if (moving == true)// If the robot arm is moving' stop it.  					 {  						moving = false;  						Console.WriteLine ("Telling robot arm to stop");  						Bus.Publish (BusNode.ROBOT_ACTIVE' false);  					}  					else// If the robot arm is not moving' enable it.  					 {  						moving = true;  						Console.WriteLine ("Telling robot arm to begin tracking");  						Bus.Publish (BusNode.ROBOT_ACTIVE' true);  					}  					movingGesture = true;  					// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  				}  			}  			else// If we're not in the moving gesture...  			 {  				if (movingGesture)  					// ... and we were' record the change' so we can re-enter the gesture later.  					movingGesture = false;  			}  			/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  			index_percent = ((indexFinger - 125) / 55) * 100;  			if (index_percent < 0)  				index_percent = 0;  			else if (index_percent > 100)  				index_percent = 100;  			/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  			// Craig centered (hand straight): 170 (180 degrees)  			// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  			// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  			if (wrist >= 170)  				wrist_percent = (wrist - 170) / 45 * 50 + 50;  			else  				wrist_percent = (wrist - 75) / 95 * 50;  			if (wrist_percent < 0)  				wrist_percent = 0;  			else if (wrist_percent > 100)  				wrist_percent = 100;  			/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  			//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  			//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  			Debug.WriteLine ("Moving gesture? " + movingGesture);  			Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  			Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  		}  	}  	catch (TimeoutException) {  		Debug.WriteLine ("Timed out waiting for CyberGlove data!");  	}  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: while (running) {  	//sp.Write("G");  // tell glove to start streaming  	sp.Write ("g");  	// request a single sample from the CyberGlove  	try {  		Debug.WriteLine ("Reading from CyberGlove...");  		msg = sp.ReadLine ();  		Debug.WriteLine ("Yay!");  		/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  		// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  		// sensors on the glove.  See the manual for their names.  		string[] sensors = Regex.Split (msg' "\\s+");  		if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  		 {  			// Note that values are same for both right and left hand gloves.  			int pinky = Convert.ToInt32 (sensors [14]);  			// get flex of pinky's first joint  			int ring = Convert.ToInt32 (sensors [11]);  			// get flex of ring finger's first joint  			int middle = Convert.ToInt32 (sensors [8]);  			// get flex of middle finger's first joint  			indexFinger = Convert.ToInt32 (sensors [5]);  			// get flex of index finger's first joint  			wrist = Convert.ToInt32 (sensors [17]);  			// get flex/extension of wrist  			// Detect "Starting Postion" gesture  			// Currently we do NOT publish this gesture to the bus  			if (pinky >= 120) {  				if (!pinkyGesture) {  					//Console.WriteLine("Moving to starting position");  					pinkyGesture = true;  					// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  				}  			}  			else {  				if (pinkyGesture)  					pinkyGesture = false;  			}  			// Detect start/stop (robot arm) gesture  			if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  			 {  				if (!movingGesture)// If we're not already in the "moving" gesture...  				 {  					if (moving == true)// If the robot arm is moving' stop it.  					 {  						moving = false;  						Console.WriteLine ("Telling robot arm to stop");  						Bus.Publish (BusNode.ROBOT_ACTIVE' false);  					}  					else// If the robot arm is not moving' enable it.  					 {  						moving = true;  						Console.WriteLine ("Telling robot arm to begin tracking");  						Bus.Publish (BusNode.ROBOT_ACTIVE' true);  					}  					movingGesture = true;  					// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  				}  			}  			else// If we're not in the moving gesture...  			 {  				if (movingGesture)  					// ... and we were' record the change' so we can re-enter the gesture later.  					movingGesture = false;  			}  			/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  			index_percent = ((indexFinger - 125) / 55) * 100;  			if (index_percent < 0)  				index_percent = 0;  			else if (index_percent > 100)  				index_percent = 100;  			/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  			// Craig centered (hand straight): 170 (180 degrees)  			// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  			// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  			if (wrist >= 170)  				wrist_percent = (wrist - 170) / 45 * 50 + 50;  			else  				wrist_percent = (wrist - 75) / 95 * 50;  			if (wrist_percent < 0)  				wrist_percent = 0;  			else if (wrist_percent > 100)  				wrist_percent = 100;  			/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  			//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  			//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  			Debug.WriteLine ("Moving gesture? " + movingGesture);  			Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  			Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  		}  	}  	catch (TimeoutException) {  		Debug.WriteLine ("Timed out waiting for CyberGlove data!");  	}  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: while (running) {  	//sp.Write("G");  // tell glove to start streaming  	sp.Write ("g");  	// request a single sample from the CyberGlove  	try {  		Debug.WriteLine ("Reading from CyberGlove...");  		msg = sp.ReadLine ();  		Debug.WriteLine ("Yay!");  		/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  		// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  		// sensors on the glove.  See the manual for their names.  		string[] sensors = Regex.Split (msg' "\\s+");  		if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  		 {  			// Note that values are same for both right and left hand gloves.  			int pinky = Convert.ToInt32 (sensors [14]);  			// get flex of pinky's first joint  			int ring = Convert.ToInt32 (sensors [11]);  			// get flex of ring finger's first joint  			int middle = Convert.ToInt32 (sensors [8]);  			// get flex of middle finger's first joint  			indexFinger = Convert.ToInt32 (sensors [5]);  			// get flex of index finger's first joint  			wrist = Convert.ToInt32 (sensors [17]);  			// get flex/extension of wrist  			// Detect "Starting Postion" gesture  			// Currently we do NOT publish this gesture to the bus  			if (pinky >= 120) {  				if (!pinkyGesture) {  					//Console.WriteLine("Moving to starting position");  					pinkyGesture = true;  					// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  				}  			}  			else {  				if (pinkyGesture)  					pinkyGesture = false;  			}  			// Detect start/stop (robot arm) gesture  			if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  			 {  				if (!movingGesture)// If we're not already in the "moving" gesture...  				 {  					if (moving == true)// If the robot arm is moving' stop it.  					 {  						moving = false;  						Console.WriteLine ("Telling robot arm to stop");  						Bus.Publish (BusNode.ROBOT_ACTIVE' false);  					}  					else// If the robot arm is not moving' enable it.  					 {  						moving = true;  						Console.WriteLine ("Telling robot arm to begin tracking");  						Bus.Publish (BusNode.ROBOT_ACTIVE' true);  					}  					movingGesture = true;  					// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  				}  			}  			else// If we're not in the moving gesture...  			 {  				if (movingGesture)  					// ... and we were' record the change' so we can re-enter the gesture later.  					movingGesture = false;  			}  			/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  			index_percent = ((indexFinger - 125) / 55) * 100;  			if (index_percent < 0)  				index_percent = 0;  			else if (index_percent > 100)  				index_percent = 100;  			/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  			// Craig centered (hand straight): 170 (180 degrees)  			// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  			// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  			if (wrist >= 170)  				wrist_percent = (wrist - 170) / 45 * 50 + 50;  			else  				wrist_percent = (wrist - 75) / 95 * 50;  			if (wrist_percent < 0)  				wrist_percent = 0;  			else if (wrist_percent > 100)  				wrist_percent = 100;  			/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  			//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  			//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  			Debug.WriteLine ("Moving gesture? " + movingGesture);  			Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  			Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  		}  	}  	catch (TimeoutException) {  		Debug.WriteLine ("Timed out waiting for CyberGlove data!");  	}  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: while (running) {  	//sp.Write("G");  // tell glove to start streaming  	sp.Write ("g");  	// request a single sample from the CyberGlove  	try {  		Debug.WriteLine ("Reading from CyberGlove...");  		msg = sp.ReadLine ();  		Debug.WriteLine ("Yay!");  		/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  		// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  		// sensors on the glove.  See the manual for their names.  		string[] sensors = Regex.Split (msg' "\\s+");  		if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  		 {  			// Note that values are same for both right and left hand gloves.  			int pinky = Convert.ToInt32 (sensors [14]);  			// get flex of pinky's first joint  			int ring = Convert.ToInt32 (sensors [11]);  			// get flex of ring finger's first joint  			int middle = Convert.ToInt32 (sensors [8]);  			// get flex of middle finger's first joint  			indexFinger = Convert.ToInt32 (sensors [5]);  			// get flex of index finger's first joint  			wrist = Convert.ToInt32 (sensors [17]);  			// get flex/extension of wrist  			// Detect "Starting Postion" gesture  			// Currently we do NOT publish this gesture to the bus  			if (pinky >= 120) {  				if (!pinkyGesture) {  					//Console.WriteLine("Moving to starting position");  					pinkyGesture = true;  					// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  				}  			}  			else {  				if (pinkyGesture)  					pinkyGesture = false;  			}  			// Detect start/stop (robot arm) gesture  			if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  			 {  				if (!movingGesture)// If we're not already in the "moving" gesture...  				 {  					if (moving == true)// If the robot arm is moving' stop it.  					 {  						moving = false;  						Console.WriteLine ("Telling robot arm to stop");  						Bus.Publish (BusNode.ROBOT_ACTIVE' false);  					}  					else// If the robot arm is not moving' enable it.  					 {  						moving = true;  						Console.WriteLine ("Telling robot arm to begin tracking");  						Bus.Publish (BusNode.ROBOT_ACTIVE' true);  					}  					movingGesture = true;  					// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  				}  			}  			else// If we're not in the moving gesture...  			 {  				if (movingGesture)  					// ... and we were' record the change' so we can re-enter the gesture later.  					movingGesture = false;  			}  			/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  			index_percent = ((indexFinger - 125) / 55) * 100;  			if (index_percent < 0)  				index_percent = 0;  			else if (index_percent > 100)  				index_percent = 100;  			/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  			// Craig centered (hand straight): 170 (180 degrees)  			// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  			// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  			if (wrist >= 170)  				wrist_percent = (wrist - 170) / 45 * 50 + 50;  			else  				wrist_percent = (wrist - 75) / 95 * 50;  			if (wrist_percent < 0)  				wrist_percent = 0;  			else if (wrist_percent > 100)  				wrist_percent = 100;  			/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  			//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  			//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  			Debug.WriteLine ("Moving gesture? " + movingGesture);  			Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  			Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  		}  	}  	catch (TimeoutException) {  		Debug.WriteLine ("Timed out waiting for CyberGlove data!");  	}  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: while (running) {  	//sp.Write("G");  // tell glove to start streaming  	sp.Write ("g");  	// request a single sample from the CyberGlove  	try {  		Debug.WriteLine ("Reading from CyberGlove...");  		msg = sp.ReadLine ();  		Debug.WriteLine ("Yay!");  		/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  		// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  		// sensors on the glove.  See the manual for their names.  		string[] sensors = Regex.Split (msg' "\\s+");  		if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  		 {  			// Note that values are same for both right and left hand gloves.  			int pinky = Convert.ToInt32 (sensors [14]);  			// get flex of pinky's first joint  			int ring = Convert.ToInt32 (sensors [11]);  			// get flex of ring finger's first joint  			int middle = Convert.ToInt32 (sensors [8]);  			// get flex of middle finger's first joint  			indexFinger = Convert.ToInt32 (sensors [5]);  			// get flex of index finger's first joint  			wrist = Convert.ToInt32 (sensors [17]);  			// get flex/extension of wrist  			// Detect "Starting Postion" gesture  			// Currently we do NOT publish this gesture to the bus  			if (pinky >= 120) {  				if (!pinkyGesture) {  					//Console.WriteLine("Moving to starting position");  					pinkyGesture = true;  					// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  				}  			}  			else {  				if (pinkyGesture)  					pinkyGesture = false;  			}  			// Detect start/stop (robot arm) gesture  			if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  			 {  				if (!movingGesture)// If we're not already in the "moving" gesture...  				 {  					if (moving == true)// If the robot arm is moving' stop it.  					 {  						moving = false;  						Console.WriteLine ("Telling robot arm to stop");  						Bus.Publish (BusNode.ROBOT_ACTIVE' false);  					}  					else// If the robot arm is not moving' enable it.  					 {  						moving = true;  						Console.WriteLine ("Telling robot arm to begin tracking");  						Bus.Publish (BusNode.ROBOT_ACTIVE' true);  					}  					movingGesture = true;  					// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  				}  			}  			else// If we're not in the moving gesture...  			 {  				if (movingGesture)  					// ... and we were' record the change' so we can re-enter the gesture later.  					movingGesture = false;  			}  			/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  			index_percent = ((indexFinger - 125) / 55) * 100;  			if (index_percent < 0)  				index_percent = 0;  			else if (index_percent > 100)  				index_percent = 100;  			/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  			// Craig centered (hand straight): 170 (180 degrees)  			// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  			// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  			if (wrist >= 170)  				wrist_percent = (wrist - 170) / 45 * 50 + 50;  			else  				wrist_percent = (wrist - 75) / 95 * 50;  			if (wrist_percent < 0)  				wrist_percent = 0;  			else if (wrist_percent > 100)  				wrist_percent = 100;  			/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  			//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  			//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  			Debug.WriteLine ("Moving gesture? " + movingGesture);  			Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  			Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  		}  	}  	catch (TimeoutException) {  		Debug.WriteLine ("Timed out waiting for CyberGlove data!");  	}  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: while (running) {  	//sp.Write("G");  // tell glove to start streaming  	sp.Write ("g");  	// request a single sample from the CyberGlove  	try {  		Debug.WriteLine ("Reading from CyberGlove...");  		msg = sp.ReadLine ();  		Debug.WriteLine ("Yay!");  		/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  		// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  		// sensors on the glove.  See the manual for their names.  		string[] sensors = Regex.Split (msg' "\\s+");  		if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  		 {  			// Note that values are same for both right and left hand gloves.  			int pinky = Convert.ToInt32 (sensors [14]);  			// get flex of pinky's first joint  			int ring = Convert.ToInt32 (sensors [11]);  			// get flex of ring finger's first joint  			int middle = Convert.ToInt32 (sensors [8]);  			// get flex of middle finger's first joint  			indexFinger = Convert.ToInt32 (sensors [5]);  			// get flex of index finger's first joint  			wrist = Convert.ToInt32 (sensors [17]);  			// get flex/extension of wrist  			// Detect "Starting Postion" gesture  			// Currently we do NOT publish this gesture to the bus  			if (pinky >= 120) {  				if (!pinkyGesture) {  					//Console.WriteLine("Moving to starting position");  					pinkyGesture = true;  					// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  				}  			}  			else {  				if (pinkyGesture)  					pinkyGesture = false;  			}  			// Detect start/stop (robot arm) gesture  			if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  			 {  				if (!movingGesture)// If we're not already in the "moving" gesture...  				 {  					if (moving == true)// If the robot arm is moving' stop it.  					 {  						moving = false;  						Console.WriteLine ("Telling robot arm to stop");  						Bus.Publish (BusNode.ROBOT_ACTIVE' false);  					}  					else// If the robot arm is not moving' enable it.  					 {  						moving = true;  						Console.WriteLine ("Telling robot arm to begin tracking");  						Bus.Publish (BusNode.ROBOT_ACTIVE' true);  					}  					movingGesture = true;  					// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  				}  			}  			else// If we're not in the moving gesture...  			 {  				if (movingGesture)  					// ... and we were' record the change' so we can re-enter the gesture later.  					movingGesture = false;  			}  			/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  			index_percent = ((indexFinger - 125) / 55) * 100;  			if (index_percent < 0)  				index_percent = 0;  			else if (index_percent > 100)  				index_percent = 100;  			/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  			// Craig centered (hand straight): 170 (180 degrees)  			// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  			// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  			if (wrist >= 170)  				wrist_percent = (wrist - 170) / 45 * 50 + 50;  			else  				wrist_percent = (wrist - 75) / 95 * 50;  			if (wrist_percent < 0)  				wrist_percent = 0;  			else if (wrist_percent > 100)  				wrist_percent = 100;  			/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  			//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  			//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  			Debug.WriteLine ("Moving gesture? " + movingGesture);  			Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  			Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  		}  	}  	catch (TimeoutException) {  		Debug.WriteLine ("Timed out waiting for CyberGlove data!");  	}  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: while (running) {  	//sp.Write("G");  // tell glove to start streaming  	sp.Write ("g");  	// request a single sample from the CyberGlove  	try {  		Debug.WriteLine ("Reading from CyberGlove...");  		msg = sp.ReadLine ();  		Debug.WriteLine ("Yay!");  		/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  		// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  		// sensors on the glove.  See the manual for their names.  		string[] sensors = Regex.Split (msg' "\\s+");  		if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  		 {  			// Note that values are same for both right and left hand gloves.  			int pinky = Convert.ToInt32 (sensors [14]);  			// get flex of pinky's first joint  			int ring = Convert.ToInt32 (sensors [11]);  			// get flex of ring finger's first joint  			int middle = Convert.ToInt32 (sensors [8]);  			// get flex of middle finger's first joint  			indexFinger = Convert.ToInt32 (sensors [5]);  			// get flex of index finger's first joint  			wrist = Convert.ToInt32 (sensors [17]);  			// get flex/extension of wrist  			// Detect "Starting Postion" gesture  			// Currently we do NOT publish this gesture to the bus  			if (pinky >= 120) {  				if (!pinkyGesture) {  					//Console.WriteLine("Moving to starting position");  					pinkyGesture = true;  					// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  				}  			}  			else {  				if (pinkyGesture)  					pinkyGesture = false;  			}  			// Detect start/stop (robot arm) gesture  			if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  			 {  				if (!movingGesture)// If we're not already in the "moving" gesture...  				 {  					if (moving == true)// If the robot arm is moving' stop it.  					 {  						moving = false;  						Console.WriteLine ("Telling robot arm to stop");  						Bus.Publish (BusNode.ROBOT_ACTIVE' false);  					}  					else// If the robot arm is not moving' enable it.  					 {  						moving = true;  						Console.WriteLine ("Telling robot arm to begin tracking");  						Bus.Publish (BusNode.ROBOT_ACTIVE' true);  					}  					movingGesture = true;  					// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  				}  			}  			else// If we're not in the moving gesture...  			 {  				if (movingGesture)  					// ... and we were' record the change' so we can re-enter the gesture later.  					movingGesture = false;  			}  			/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  			index_percent = ((indexFinger - 125) / 55) * 100;  			if (index_percent < 0)  				index_percent = 0;  			else if (index_percent > 100)  				index_percent = 100;  			/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  			// Craig centered (hand straight): 170 (180 degrees)  			// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  			// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  			if (wrist >= 170)  				wrist_percent = (wrist - 170) / 45 * 50 + 50;  			else  				wrist_percent = (wrist - 75) / 95 * 50;  			if (wrist_percent < 0)  				wrist_percent = 0;  			else if (wrist_percent > 100)  				wrist_percent = 100;  			/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  			//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  			//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  			Debug.WriteLine ("Moving gesture? " + movingGesture);  			Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  			Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  		}  	}  	catch (TimeoutException) {  		Debug.WriteLine ("Timed out waiting for CyberGlove data!");  	}  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: while (running) {  	//sp.Write("G");  // tell glove to start streaming  	sp.Write ("g");  	// request a single sample from the CyberGlove  	try {  		Debug.WriteLine ("Reading from CyberGlove...");  		msg = sp.ReadLine ();  		Debug.WriteLine ("Yay!");  		/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  		// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  		// sensors on the glove.  See the manual for their names.  		string[] sensors = Regex.Split (msg' "\\s+");  		if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  		 {  			// Note that values are same for both right and left hand gloves.  			int pinky = Convert.ToInt32 (sensors [14]);  			// get flex of pinky's first joint  			int ring = Convert.ToInt32 (sensors [11]);  			// get flex of ring finger's first joint  			int middle = Convert.ToInt32 (sensors [8]);  			// get flex of middle finger's first joint  			indexFinger = Convert.ToInt32 (sensors [5]);  			// get flex of index finger's first joint  			wrist = Convert.ToInt32 (sensors [17]);  			// get flex/extension of wrist  			// Detect "Starting Postion" gesture  			// Currently we do NOT publish this gesture to the bus  			if (pinky >= 120) {  				if (!pinkyGesture) {  					//Console.WriteLine("Moving to starting position");  					pinkyGesture = true;  					// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  				}  			}  			else {  				if (pinkyGesture)  					pinkyGesture = false;  			}  			// Detect start/stop (robot arm) gesture  			if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  			 {  				if (!movingGesture)// If we're not already in the "moving" gesture...  				 {  					if (moving == true)// If the robot arm is moving' stop it.  					 {  						moving = false;  						Console.WriteLine ("Telling robot arm to stop");  						Bus.Publish (BusNode.ROBOT_ACTIVE' false);  					}  					else// If the robot arm is not moving' enable it.  					 {  						moving = true;  						Console.WriteLine ("Telling robot arm to begin tracking");  						Bus.Publish (BusNode.ROBOT_ACTIVE' true);  					}  					movingGesture = true;  					// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  				}  			}  			else// If we're not in the moving gesture...  			 {  				if (movingGesture)  					// ... and we were' record the change' so we can re-enter the gesture later.  					movingGesture = false;  			}  			/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  			index_percent = ((indexFinger - 125) / 55) * 100;  			if (index_percent < 0)  				index_percent = 0;  			else if (index_percent > 100)  				index_percent = 100;  			/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  			// Craig centered (hand straight): 170 (180 degrees)  			// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  			// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  			if (wrist >= 170)  				wrist_percent = (wrist - 170) / 45 * 50 + 50;  			else  				wrist_percent = (wrist - 75) / 95 * 50;  			if (wrist_percent < 0)  				wrist_percent = 0;  			else if (wrist_percent > 100)  				wrist_percent = 100;  			/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  			//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  			//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  			Debug.WriteLine ("Moving gesture? " + movingGesture);  			Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  			Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  		}  	}  	catch (TimeoutException) {  		Debug.WriteLine ("Timed out waiting for CyberGlove data!");  	}  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: while (running) {  	//sp.Write("G");  // tell glove to start streaming  	sp.Write ("g");  	// request a single sample from the CyberGlove  	try {  		Debug.WriteLine ("Reading from CyberGlove...");  		msg = sp.ReadLine ();  		Debug.WriteLine ("Yay!");  		/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  		// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  		// sensors on the glove.  See the manual for their names.  		string[] sensors = Regex.Split (msg' "\\s+");  		if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  		 {  			// Note that values are same for both right and left hand gloves.  			int pinky = Convert.ToInt32 (sensors [14]);  			// get flex of pinky's first joint  			int ring = Convert.ToInt32 (sensors [11]);  			// get flex of ring finger's first joint  			int middle = Convert.ToInt32 (sensors [8]);  			// get flex of middle finger's first joint  			indexFinger = Convert.ToInt32 (sensors [5]);  			// get flex of index finger's first joint  			wrist = Convert.ToInt32 (sensors [17]);  			// get flex/extension of wrist  			// Detect "Starting Postion" gesture  			// Currently we do NOT publish this gesture to the bus  			if (pinky >= 120) {  				if (!pinkyGesture) {  					//Console.WriteLine("Moving to starting position");  					pinkyGesture = true;  					// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  				}  			}  			else {  				if (pinkyGesture)  					pinkyGesture = false;  			}  			// Detect start/stop (robot arm) gesture  			if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  			 {  				if (!movingGesture)// If we're not already in the "moving" gesture...  				 {  					if (moving == true)// If the robot arm is moving' stop it.  					 {  						moving = false;  						Console.WriteLine ("Telling robot arm to stop");  						Bus.Publish (BusNode.ROBOT_ACTIVE' false);  					}  					else// If the robot arm is not moving' enable it.  					 {  						moving = true;  						Console.WriteLine ("Telling robot arm to begin tracking");  						Bus.Publish (BusNode.ROBOT_ACTIVE' true);  					}  					movingGesture = true;  					// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  				}  			}  			else// If we're not in the moving gesture...  			 {  				if (movingGesture)  					// ... and we were' record the change' so we can re-enter the gesture later.  					movingGesture = false;  			}  			/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  			index_percent = ((indexFinger - 125) / 55) * 100;  			if (index_percent < 0)  				index_percent = 0;  			else if (index_percent > 100)  				index_percent = 100;  			/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  			// Craig centered (hand straight): 170 (180 degrees)  			// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  			// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  			if (wrist >= 170)  				wrist_percent = (wrist - 170) / 45 * 50 + 50;  			else  				wrist_percent = (wrist - 75) / 95 * 50;  			if (wrist_percent < 0)  				wrist_percent = 0;  			else if (wrist_percent > 100)  				wrist_percent = 100;  			/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  			//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  			//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  			Debug.WriteLine ("Moving gesture? " + movingGesture);  			Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  			Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  		}  	}  	catch (TimeoutException) {  		Debug.WriteLine ("Timed out waiting for CyberGlove data!");  	}  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: while (running) {  	//sp.Write("G");  // tell glove to start streaming  	sp.Write ("g");  	// request a single sample from the CyberGlove  	try {  		Debug.WriteLine ("Reading from CyberGlove...");  		msg = sp.ReadLine ();  		Debug.WriteLine ("Yay!");  		/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  		// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  		// sensors on the glove.  See the manual for their names.  		string[] sensors = Regex.Split (msg' "\\s+");  		if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  		 {  			// Note that values are same for both right and left hand gloves.  			int pinky = Convert.ToInt32 (sensors [14]);  			// get flex of pinky's first joint  			int ring = Convert.ToInt32 (sensors [11]);  			// get flex of ring finger's first joint  			int middle = Convert.ToInt32 (sensors [8]);  			// get flex of middle finger's first joint  			indexFinger = Convert.ToInt32 (sensors [5]);  			// get flex of index finger's first joint  			wrist = Convert.ToInt32 (sensors [17]);  			// get flex/extension of wrist  			// Detect "Starting Postion" gesture  			// Currently we do NOT publish this gesture to the bus  			if (pinky >= 120) {  				if (!pinkyGesture) {  					//Console.WriteLine("Moving to starting position");  					pinkyGesture = true;  					// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  				}  			}  			else {  				if (pinkyGesture)  					pinkyGesture = false;  			}  			// Detect start/stop (robot arm) gesture  			if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  			 {  				if (!movingGesture)// If we're not already in the "moving" gesture...  				 {  					if (moving == true)// If the robot arm is moving' stop it.  					 {  						moving = false;  						Console.WriteLine ("Telling robot arm to stop");  						Bus.Publish (BusNode.ROBOT_ACTIVE' false);  					}  					else// If the robot arm is not moving' enable it.  					 {  						moving = true;  						Console.WriteLine ("Telling robot arm to begin tracking");  						Bus.Publish (BusNode.ROBOT_ACTIVE' true);  					}  					movingGesture = true;  					// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  				}  			}  			else// If we're not in the moving gesture...  			 {  				if (movingGesture)  					// ... and we were' record the change' so we can re-enter the gesture later.  					movingGesture = false;  			}  			/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  			index_percent = ((indexFinger - 125) / 55) * 100;  			if (index_percent < 0)  				index_percent = 0;  			else if (index_percent > 100)  				index_percent = 100;  			/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  			// Craig centered (hand straight): 170 (180 degrees)  			// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  			// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  			if (wrist >= 170)  				wrist_percent = (wrist - 170) / 45 * 50 + 50;  			else  				wrist_percent = (wrist - 75) / 95 * 50;  			if (wrist_percent < 0)  				wrist_percent = 0;  			else if (wrist_percent > 100)  				wrist_percent = 100;  			/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  			//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  			//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  			Debug.WriteLine ("Moving gesture? " + movingGesture);  			Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  			Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  		}  	}  	catch (TimeoutException) {  		Debug.WriteLine ("Timed out waiting for CyberGlove data!");  	}  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: while (running) {  	//sp.Write("G");  // tell glove to start streaming  	sp.Write ("g");  	// request a single sample from the CyberGlove  	try {  		Debug.WriteLine ("Reading from CyberGlove...");  		msg = sp.ReadLine ();  		Debug.WriteLine ("Yay!");  		/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  		// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  		// sensors on the glove.  See the manual for their names.  		string[] sensors = Regex.Split (msg' "\\s+");  		if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  		 {  			// Note that values are same for both right and left hand gloves.  			int pinky = Convert.ToInt32 (sensors [14]);  			// get flex of pinky's first joint  			int ring = Convert.ToInt32 (sensors [11]);  			// get flex of ring finger's first joint  			int middle = Convert.ToInt32 (sensors [8]);  			// get flex of middle finger's first joint  			indexFinger = Convert.ToInt32 (sensors [5]);  			// get flex of index finger's first joint  			wrist = Convert.ToInt32 (sensors [17]);  			// get flex/extension of wrist  			// Detect "Starting Postion" gesture  			// Currently we do NOT publish this gesture to the bus  			if (pinky >= 120) {  				if (!pinkyGesture) {  					//Console.WriteLine("Moving to starting position");  					pinkyGesture = true;  					// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  				}  			}  			else {  				if (pinkyGesture)  					pinkyGesture = false;  			}  			// Detect start/stop (robot arm) gesture  			if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  			 {  				if (!movingGesture)// If we're not already in the "moving" gesture...  				 {  					if (moving == true)// If the robot arm is moving' stop it.  					 {  						moving = false;  						Console.WriteLine ("Telling robot arm to stop");  						Bus.Publish (BusNode.ROBOT_ACTIVE' false);  					}  					else// If the robot arm is not moving' enable it.  					 {  						moving = true;  						Console.WriteLine ("Telling robot arm to begin tracking");  						Bus.Publish (BusNode.ROBOT_ACTIVE' true);  					}  					movingGesture = true;  					// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  				}  			}  			else// If we're not in the moving gesture...  			 {  				if (movingGesture)  					// ... and we were' record the change' so we can re-enter the gesture later.  					movingGesture = false;  			}  			/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  			index_percent = ((indexFinger - 125) / 55) * 100;  			if (index_percent < 0)  				index_percent = 0;  			else if (index_percent > 100)  				index_percent = 100;  			/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  			// Craig centered (hand straight): 170 (180 degrees)  			// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  			// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  			if (wrist >= 170)  				wrist_percent = (wrist - 170) / 45 * 50 + 50;  			else  				wrist_percent = (wrist - 75) / 95 * 50;  			if (wrist_percent < 0)  				wrist_percent = 0;  			else if (wrist_percent > 100)  				wrist_percent = 100;  			/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  			//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  			//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  			Debug.WriteLine ("Moving gesture? " + movingGesture);  			Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  			Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  		}  	}  	catch (TimeoutException) {  		Debug.WriteLine ("Timed out waiting for CyberGlove data!");  	}  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: while (running) {  	//sp.Write("G");  // tell glove to start streaming  	sp.Write ("g");  	// request a single sample from the CyberGlove  	try {  		Debug.WriteLine ("Reading from CyberGlove...");  		msg = sp.ReadLine ();  		Debug.WriteLine ("Yay!");  		/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  		// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  		// sensors on the glove.  See the manual for their names.  		string[] sensors = Regex.Split (msg' "\\s+");  		if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  		 {  			// Note that values are same for both right and left hand gloves.  			int pinky = Convert.ToInt32 (sensors [14]);  			// get flex of pinky's first joint  			int ring = Convert.ToInt32 (sensors [11]);  			// get flex of ring finger's first joint  			int middle = Convert.ToInt32 (sensors [8]);  			// get flex of middle finger's first joint  			indexFinger = Convert.ToInt32 (sensors [5]);  			// get flex of index finger's first joint  			wrist = Convert.ToInt32 (sensors [17]);  			// get flex/extension of wrist  			// Detect "Starting Postion" gesture  			// Currently we do NOT publish this gesture to the bus  			if (pinky >= 120) {  				if (!pinkyGesture) {  					//Console.WriteLine("Moving to starting position");  					pinkyGesture = true;  					// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  				}  			}  			else {  				if (pinkyGesture)  					pinkyGesture = false;  			}  			// Detect start/stop (robot arm) gesture  			if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  			 {  				if (!movingGesture)// If we're not already in the "moving" gesture...  				 {  					if (moving == true)// If the robot arm is moving' stop it.  					 {  						moving = false;  						Console.WriteLine ("Telling robot arm to stop");  						Bus.Publish (BusNode.ROBOT_ACTIVE' false);  					}  					else// If the robot arm is not moving' enable it.  					 {  						moving = true;  						Console.WriteLine ("Telling robot arm to begin tracking");  						Bus.Publish (BusNode.ROBOT_ACTIVE' true);  					}  					movingGesture = true;  					// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  				}  			}  			else// If we're not in the moving gesture...  			 {  				if (movingGesture)  					// ... and we were' record the change' so we can re-enter the gesture later.  					movingGesture = false;  			}  			/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  			index_percent = ((indexFinger - 125) / 55) * 100;  			if (index_percent < 0)  				index_percent = 0;  			else if (index_percent > 100)  				index_percent = 100;  			/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  			// Craig centered (hand straight): 170 (180 degrees)  			// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  			// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  			if (wrist >= 170)  				wrist_percent = (wrist - 170) / 45 * 50 + 50;  			else  				wrist_percent = (wrist - 75) / 95 * 50;  			if (wrist_percent < 0)  				wrist_percent = 0;  			else if (wrist_percent > 100)  				wrist_percent = 100;  			/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  			//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  			//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  			Debug.WriteLine ("Moving gesture? " + movingGesture);  			Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  			Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  		}  	}  	catch (TimeoutException) {  		Debug.WriteLine ("Timed out waiting for CyberGlove data!");  	}  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: while (running) {  	//sp.Write("G");  // tell glove to start streaming  	sp.Write ("g");  	// request a single sample from the CyberGlove  	try {  		Debug.WriteLine ("Reading from CyberGlove...");  		msg = sp.ReadLine ();  		Debug.WriteLine ("Yay!");  		/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  		// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  		// sensors on the glove.  See the manual for their names.  		string[] sensors = Regex.Split (msg' "\\s+");  		if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  		 {  			// Note that values are same for both right and left hand gloves.  			int pinky = Convert.ToInt32 (sensors [14]);  			// get flex of pinky's first joint  			int ring = Convert.ToInt32 (sensors [11]);  			// get flex of ring finger's first joint  			int middle = Convert.ToInt32 (sensors [8]);  			// get flex of middle finger's first joint  			indexFinger = Convert.ToInt32 (sensors [5]);  			// get flex of index finger's first joint  			wrist = Convert.ToInt32 (sensors [17]);  			// get flex/extension of wrist  			// Detect "Starting Postion" gesture  			// Currently we do NOT publish this gesture to the bus  			if (pinky >= 120) {  				if (!pinkyGesture) {  					//Console.WriteLine("Moving to starting position");  					pinkyGesture = true;  					// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  				}  			}  			else {  				if (pinkyGesture)  					pinkyGesture = false;  			}  			// Detect start/stop (robot arm) gesture  			if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  			 {  				if (!movingGesture)// If we're not already in the "moving" gesture...  				 {  					if (moving == true)// If the robot arm is moving' stop it.  					 {  						moving = false;  						Console.WriteLine ("Telling robot arm to stop");  						Bus.Publish (BusNode.ROBOT_ACTIVE' false);  					}  					else// If the robot arm is not moving' enable it.  					 {  						moving = true;  						Console.WriteLine ("Telling robot arm to begin tracking");  						Bus.Publish (BusNode.ROBOT_ACTIVE' true);  					}  					movingGesture = true;  					// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  				}  			}  			else// If we're not in the moving gesture...  			 {  				if (movingGesture)  					// ... and we were' record the change' so we can re-enter the gesture later.  					movingGesture = false;  			}  			/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  			index_percent = ((indexFinger - 125) / 55) * 100;  			if (index_percent < 0)  				index_percent = 0;  			else if (index_percent > 100)  				index_percent = 100;  			/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  			// Craig centered (hand straight): 170 (180 degrees)  			// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  			// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  			if (wrist >= 170)  				wrist_percent = (wrist - 170) / 45 * 50 + 50;  			else  				wrist_percent = (wrist - 75) / 95 * 50;  			if (wrist_percent < 0)  				wrist_percent = 0;  			else if (wrist_percent > 100)  				wrist_percent = 100;  			/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  			//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  			//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  			Debug.WriteLine ("Moving gesture? " + movingGesture);  			Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  			Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  		}  	}  	catch (TimeoutException) {  		Debug.WriteLine ("Timed out waiting for CyberGlove data!");  	}  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: try {  	Debug.WriteLine ("Reading from CyberGlove...");  	msg = sp.ReadLine ();  	Debug.WriteLine ("Yay!");  	/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  	// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  	// sensors on the glove.  See the manual for their names.  	string[] sensors = Regex.Split (msg' "\\s+");  	if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  	 {  		// Note that values are same for both right and left hand gloves.  		int pinky = Convert.ToInt32 (sensors [14]);  		// get flex of pinky's first joint  		int ring = Convert.ToInt32 (sensors [11]);  		// get flex of ring finger's first joint  		int middle = Convert.ToInt32 (sensors [8]);  		// get flex of middle finger's first joint  		indexFinger = Convert.ToInt32 (sensors [5]);  		// get flex of index finger's first joint  		wrist = Convert.ToInt32 (sensors [17]);  		// get flex/extension of wrist  		// Detect "Starting Postion" gesture  		// Currently we do NOT publish this gesture to the bus  		if (pinky >= 120) {  			if (!pinkyGesture) {  				//Console.WriteLine("Moving to starting position");  				pinkyGesture = true;  				// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  			}  		}  		else {  			if (pinkyGesture)  				pinkyGesture = false;  		}  		// Detect start/stop (robot arm) gesture  		if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  		 {  			if (!movingGesture)// If we're not already in the "moving" gesture...  			 {  				if (moving == true)// If the robot arm is moving' stop it.  				 {  					moving = false;  					Console.WriteLine ("Telling robot arm to stop");  					Bus.Publish (BusNode.ROBOT_ACTIVE' false);  				}  				else// If the robot arm is not moving' enable it.  				 {  					moving = true;  					Console.WriteLine ("Telling robot arm to begin tracking");  					Bus.Publish (BusNode.ROBOT_ACTIVE' true);  				}  				movingGesture = true;  				// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  			}  		}  		else// If we're not in the moving gesture...  		 {  			if (movingGesture)  				// ... and we were' record the change' so we can re-enter the gesture later.  				movingGesture = false;  		}  		/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  		index_percent = ((indexFinger - 125) / 55) * 100;  		if (index_percent < 0)  			index_percent = 0;  		else if (index_percent > 100)  			index_percent = 100;  		/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  		// Craig centered (hand straight): 170 (180 degrees)  		// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  		// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  		if (wrist >= 170)  			wrist_percent = (wrist - 170) / 45 * 50 + 50;  		else  			wrist_percent = (wrist - 75) / 95 * 50;  		if (wrist_percent < 0)  			wrist_percent = 0;  		else if (wrist_percent > 100)  			wrist_percent = 100;  		/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  		//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  		//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  		Debug.WriteLine ("Moving gesture? " + movingGesture);  		Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  		Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  	}  }  catch (TimeoutException) {  	Debug.WriteLine ("Timed out waiting for CyberGlove data!");  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: try {  	Debug.WriteLine ("Reading from CyberGlove...");  	msg = sp.ReadLine ();  	Debug.WriteLine ("Yay!");  	/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  	// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  	// sensors on the glove.  See the manual for their names.  	string[] sensors = Regex.Split (msg' "\\s+");  	if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  	 {  		// Note that values are same for both right and left hand gloves.  		int pinky = Convert.ToInt32 (sensors [14]);  		// get flex of pinky's first joint  		int ring = Convert.ToInt32 (sensors [11]);  		// get flex of ring finger's first joint  		int middle = Convert.ToInt32 (sensors [8]);  		// get flex of middle finger's first joint  		indexFinger = Convert.ToInt32 (sensors [5]);  		// get flex of index finger's first joint  		wrist = Convert.ToInt32 (sensors [17]);  		// get flex/extension of wrist  		// Detect "Starting Postion" gesture  		// Currently we do NOT publish this gesture to the bus  		if (pinky >= 120) {  			if (!pinkyGesture) {  				//Console.WriteLine("Moving to starting position");  				pinkyGesture = true;  				// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  			}  		}  		else {  			if (pinkyGesture)  				pinkyGesture = false;  		}  		// Detect start/stop (robot arm) gesture  		if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  		 {  			if (!movingGesture)// If we're not already in the "moving" gesture...  			 {  				if (moving == true)// If the robot arm is moving' stop it.  				 {  					moving = false;  					Console.WriteLine ("Telling robot arm to stop");  					Bus.Publish (BusNode.ROBOT_ACTIVE' false);  				}  				else// If the robot arm is not moving' enable it.  				 {  					moving = true;  					Console.WriteLine ("Telling robot arm to begin tracking");  					Bus.Publish (BusNode.ROBOT_ACTIVE' true);  				}  				movingGesture = true;  				// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  			}  		}  		else// If we're not in the moving gesture...  		 {  			if (movingGesture)  				// ... and we were' record the change' so we can re-enter the gesture later.  				movingGesture = false;  		}  		/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  		index_percent = ((indexFinger - 125) / 55) * 100;  		if (index_percent < 0)  			index_percent = 0;  		else if (index_percent > 100)  			index_percent = 100;  		/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  		// Craig centered (hand straight): 170 (180 degrees)  		// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  		// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  		if (wrist >= 170)  			wrist_percent = (wrist - 170) / 45 * 50 + 50;  		else  			wrist_percent = (wrist - 75) / 95 * 50;  		if (wrist_percent < 0)  			wrist_percent = 0;  		else if (wrist_percent > 100)  			wrist_percent = 100;  		/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  		//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  		//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  		Debug.WriteLine ("Moving gesture? " + movingGesture);  		Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  		Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  	}  }  catch (TimeoutException) {  	Debug.WriteLine ("Timed out waiting for CyberGlove data!");  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: try {  	Debug.WriteLine ("Reading from CyberGlove...");  	msg = sp.ReadLine ();  	Debug.WriteLine ("Yay!");  	/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  	// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  	// sensors on the glove.  See the manual for their names.  	string[] sensors = Regex.Split (msg' "\\s+");  	if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  	 {  		// Note that values are same for both right and left hand gloves.  		int pinky = Convert.ToInt32 (sensors [14]);  		// get flex of pinky's first joint  		int ring = Convert.ToInt32 (sensors [11]);  		// get flex of ring finger's first joint  		int middle = Convert.ToInt32 (sensors [8]);  		// get flex of middle finger's first joint  		indexFinger = Convert.ToInt32 (sensors [5]);  		// get flex of index finger's first joint  		wrist = Convert.ToInt32 (sensors [17]);  		// get flex/extension of wrist  		// Detect "Starting Postion" gesture  		// Currently we do NOT publish this gesture to the bus  		if (pinky >= 120) {  			if (!pinkyGesture) {  				//Console.WriteLine("Moving to starting position");  				pinkyGesture = true;  				// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  			}  		}  		else {  			if (pinkyGesture)  				pinkyGesture = false;  		}  		// Detect start/stop (robot arm) gesture  		if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  		 {  			if (!movingGesture)// If we're not already in the "moving" gesture...  			 {  				if (moving == true)// If the robot arm is moving' stop it.  				 {  					moving = false;  					Console.WriteLine ("Telling robot arm to stop");  					Bus.Publish (BusNode.ROBOT_ACTIVE' false);  				}  				else// If the robot arm is not moving' enable it.  				 {  					moving = true;  					Console.WriteLine ("Telling robot arm to begin tracking");  					Bus.Publish (BusNode.ROBOT_ACTIVE' true);  				}  				movingGesture = true;  				// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  			}  		}  		else// If we're not in the moving gesture...  		 {  			if (movingGesture)  				// ... and we were' record the change' so we can re-enter the gesture later.  				movingGesture = false;  		}  		/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  		index_percent = ((indexFinger - 125) / 55) * 100;  		if (index_percent < 0)  			index_percent = 0;  		else if (index_percent > 100)  			index_percent = 100;  		/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  		// Craig centered (hand straight): 170 (180 degrees)  		// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  		// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  		if (wrist >= 170)  			wrist_percent = (wrist - 170) / 45 * 50 + 50;  		else  			wrist_percent = (wrist - 75) / 95 * 50;  		if (wrist_percent < 0)  			wrist_percent = 0;  		else if (wrist_percent > 100)  			wrist_percent = 100;  		/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  		//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  		//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  		Debug.WriteLine ("Moving gesture? " + movingGesture);  		Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  		Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  	}  }  catch (TimeoutException) {  	Debug.WriteLine ("Timed out waiting for CyberGlove data!");  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: try {  	Debug.WriteLine ("Reading from CyberGlove...");  	msg = sp.ReadLine ();  	Debug.WriteLine ("Yay!");  	/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  	// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  	// sensors on the glove.  See the manual for their names.  	string[] sensors = Regex.Split (msg' "\\s+");  	if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  	 {  		// Note that values are same for both right and left hand gloves.  		int pinky = Convert.ToInt32 (sensors [14]);  		// get flex of pinky's first joint  		int ring = Convert.ToInt32 (sensors [11]);  		// get flex of ring finger's first joint  		int middle = Convert.ToInt32 (sensors [8]);  		// get flex of middle finger's first joint  		indexFinger = Convert.ToInt32 (sensors [5]);  		// get flex of index finger's first joint  		wrist = Convert.ToInt32 (sensors [17]);  		// get flex/extension of wrist  		// Detect "Starting Postion" gesture  		// Currently we do NOT publish this gesture to the bus  		if (pinky >= 120) {  			if (!pinkyGesture) {  				//Console.WriteLine("Moving to starting position");  				pinkyGesture = true;  				// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  			}  		}  		else {  			if (pinkyGesture)  				pinkyGesture = false;  		}  		// Detect start/stop (robot arm) gesture  		if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  		 {  			if (!movingGesture)// If we're not already in the "moving" gesture...  			 {  				if (moving == true)// If the robot arm is moving' stop it.  				 {  					moving = false;  					Console.WriteLine ("Telling robot arm to stop");  					Bus.Publish (BusNode.ROBOT_ACTIVE' false);  				}  				else// If the robot arm is not moving' enable it.  				 {  					moving = true;  					Console.WriteLine ("Telling robot arm to begin tracking");  					Bus.Publish (BusNode.ROBOT_ACTIVE' true);  				}  				movingGesture = true;  				// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  			}  		}  		else// If we're not in the moving gesture...  		 {  			if (movingGesture)  				// ... and we were' record the change' so we can re-enter the gesture later.  				movingGesture = false;  		}  		/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  		index_percent = ((indexFinger - 125) / 55) * 100;  		if (index_percent < 0)  			index_percent = 0;  		else if (index_percent > 100)  			index_percent = 100;  		/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  		// Craig centered (hand straight): 170 (180 degrees)  		// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  		// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  		if (wrist >= 170)  			wrist_percent = (wrist - 170) / 45 * 50 + 50;  		else  			wrist_percent = (wrist - 75) / 95 * 50;  		if (wrist_percent < 0)  			wrist_percent = 0;  		else if (wrist_percent > 100)  			wrist_percent = 100;  		/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  		//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  		//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  		Debug.WriteLine ("Moving gesture? " + movingGesture);  		Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  		Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  	}  }  catch (TimeoutException) {  	Debug.WriteLine ("Timed out waiting for CyberGlove data!");  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: try {  	Debug.WriteLine ("Reading from CyberGlove...");  	msg = sp.ReadLine ();  	Debug.WriteLine ("Yay!");  	/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  	// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  	// sensors on the glove.  See the manual for their names.  	string[] sensors = Regex.Split (msg' "\\s+");  	if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  	 {  		// Note that values are same for both right and left hand gloves.  		int pinky = Convert.ToInt32 (sensors [14]);  		// get flex of pinky's first joint  		int ring = Convert.ToInt32 (sensors [11]);  		// get flex of ring finger's first joint  		int middle = Convert.ToInt32 (sensors [8]);  		// get flex of middle finger's first joint  		indexFinger = Convert.ToInt32 (sensors [5]);  		// get flex of index finger's first joint  		wrist = Convert.ToInt32 (sensors [17]);  		// get flex/extension of wrist  		// Detect "Starting Postion" gesture  		// Currently we do NOT publish this gesture to the bus  		if (pinky >= 120) {  			if (!pinkyGesture) {  				//Console.WriteLine("Moving to starting position");  				pinkyGesture = true;  				// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  			}  		}  		else {  			if (pinkyGesture)  				pinkyGesture = false;  		}  		// Detect start/stop (robot arm) gesture  		if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  		 {  			if (!movingGesture)// If we're not already in the "moving" gesture...  			 {  				if (moving == true)// If the robot arm is moving' stop it.  				 {  					moving = false;  					Console.WriteLine ("Telling robot arm to stop");  					Bus.Publish (BusNode.ROBOT_ACTIVE' false);  				}  				else// If the robot arm is not moving' enable it.  				 {  					moving = true;  					Console.WriteLine ("Telling robot arm to begin tracking");  					Bus.Publish (BusNode.ROBOT_ACTIVE' true);  				}  				movingGesture = true;  				// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  			}  		}  		else// If we're not in the moving gesture...  		 {  			if (movingGesture)  				// ... and we were' record the change' so we can re-enter the gesture later.  				movingGesture = false;  		}  		/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  		index_percent = ((indexFinger - 125) / 55) * 100;  		if (index_percent < 0)  			index_percent = 0;  		else if (index_percent > 100)  			index_percent = 100;  		/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  		// Craig centered (hand straight): 170 (180 degrees)  		// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  		// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  		if (wrist >= 170)  			wrist_percent = (wrist - 170) / 45 * 50 + 50;  		else  			wrist_percent = (wrist - 75) / 95 * 50;  		if (wrist_percent < 0)  			wrist_percent = 0;  		else if (wrist_percent > 100)  			wrist_percent = 100;  		/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  		//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  		//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  		Debug.WriteLine ("Moving gesture? " + movingGesture);  		Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  		Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  	}  }  catch (TimeoutException) {  	Debug.WriteLine ("Timed out waiting for CyberGlove data!");  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: try {  	Debug.WriteLine ("Reading from CyberGlove...");  	msg = sp.ReadLine ();  	Debug.WriteLine ("Yay!");  	/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  	// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  	// sensors on the glove.  See the manual for their names.  	string[] sensors = Regex.Split (msg' "\\s+");  	if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  	 {  		// Note that values are same for both right and left hand gloves.  		int pinky = Convert.ToInt32 (sensors [14]);  		// get flex of pinky's first joint  		int ring = Convert.ToInt32 (sensors [11]);  		// get flex of ring finger's first joint  		int middle = Convert.ToInt32 (sensors [8]);  		// get flex of middle finger's first joint  		indexFinger = Convert.ToInt32 (sensors [5]);  		// get flex of index finger's first joint  		wrist = Convert.ToInt32 (sensors [17]);  		// get flex/extension of wrist  		// Detect "Starting Postion" gesture  		// Currently we do NOT publish this gesture to the bus  		if (pinky >= 120) {  			if (!pinkyGesture) {  				//Console.WriteLine("Moving to starting position");  				pinkyGesture = true;  				// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  			}  		}  		else {  			if (pinkyGesture)  				pinkyGesture = false;  		}  		// Detect start/stop (robot arm) gesture  		if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  		 {  			if (!movingGesture)// If we're not already in the "moving" gesture...  			 {  				if (moving == true)// If the robot arm is moving' stop it.  				 {  					moving = false;  					Console.WriteLine ("Telling robot arm to stop");  					Bus.Publish (BusNode.ROBOT_ACTIVE' false);  				}  				else// If the robot arm is not moving' enable it.  				 {  					moving = true;  					Console.WriteLine ("Telling robot arm to begin tracking");  					Bus.Publish (BusNode.ROBOT_ACTIVE' true);  				}  				movingGesture = true;  				// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  			}  		}  		else// If we're not in the moving gesture...  		 {  			if (movingGesture)  				// ... and we were' record the change' so we can re-enter the gesture later.  				movingGesture = false;  		}  		/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  		index_percent = ((indexFinger - 125) / 55) * 100;  		if (index_percent < 0)  			index_percent = 0;  		else if (index_percent > 100)  			index_percent = 100;  		/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  		// Craig centered (hand straight): 170 (180 degrees)  		// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  		// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  		if (wrist >= 170)  			wrist_percent = (wrist - 170) / 45 * 50 + 50;  		else  			wrist_percent = (wrist - 75) / 95 * 50;  		if (wrist_percent < 0)  			wrist_percent = 0;  		else if (wrist_percent > 100)  			wrist_percent = 100;  		/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  		//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  		//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  		Debug.WriteLine ("Moving gesture? " + movingGesture);  		Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  		Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  	}  }  catch (TimeoutException) {  	Debug.WriteLine ("Timed out waiting for CyberGlove data!");  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: try {  	Debug.WriteLine ("Reading from CyberGlove...");  	msg = sp.ReadLine ();  	Debug.WriteLine ("Yay!");  	/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  	// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  	// sensors on the glove.  See the manual for their names.  	string[] sensors = Regex.Split (msg' "\\s+");  	if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  	 {  		// Note that values are same for both right and left hand gloves.  		int pinky = Convert.ToInt32 (sensors [14]);  		// get flex of pinky's first joint  		int ring = Convert.ToInt32 (sensors [11]);  		// get flex of ring finger's first joint  		int middle = Convert.ToInt32 (sensors [8]);  		// get flex of middle finger's first joint  		indexFinger = Convert.ToInt32 (sensors [5]);  		// get flex of index finger's first joint  		wrist = Convert.ToInt32 (sensors [17]);  		// get flex/extension of wrist  		// Detect "Starting Postion" gesture  		// Currently we do NOT publish this gesture to the bus  		if (pinky >= 120) {  			if (!pinkyGesture) {  				//Console.WriteLine("Moving to starting position");  				pinkyGesture = true;  				// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  			}  		}  		else {  			if (pinkyGesture)  				pinkyGesture = false;  		}  		// Detect start/stop (robot arm) gesture  		if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  		 {  			if (!movingGesture)// If we're not already in the "moving" gesture...  			 {  				if (moving == true)// If the robot arm is moving' stop it.  				 {  					moving = false;  					Console.WriteLine ("Telling robot arm to stop");  					Bus.Publish (BusNode.ROBOT_ACTIVE' false);  				}  				else// If the robot arm is not moving' enable it.  				 {  					moving = true;  					Console.WriteLine ("Telling robot arm to begin tracking");  					Bus.Publish (BusNode.ROBOT_ACTIVE' true);  				}  				movingGesture = true;  				// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  			}  		}  		else// If we're not in the moving gesture...  		 {  			if (movingGesture)  				// ... and we were' record the change' so we can re-enter the gesture later.  				movingGesture = false;  		}  		/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  		index_percent = ((indexFinger - 125) / 55) * 100;  		if (index_percent < 0)  			index_percent = 0;  		else if (index_percent > 100)  			index_percent = 100;  		/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  		// Craig centered (hand straight): 170 (180 degrees)  		// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  		// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  		if (wrist >= 170)  			wrist_percent = (wrist - 170) / 45 * 50 + 50;  		else  			wrist_percent = (wrist - 75) / 95 * 50;  		if (wrist_percent < 0)  			wrist_percent = 0;  		else if (wrist_percent > 100)  			wrist_percent = 100;  		/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  		//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  		//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  		Debug.WriteLine ("Moving gesture? " + movingGesture);  		Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  		Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  	}  }  catch (TimeoutException) {  	Debug.WriteLine ("Timed out waiting for CyberGlove data!");  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: try {  	Debug.WriteLine ("Reading from CyberGlove...");  	msg = sp.ReadLine ();  	Debug.WriteLine ("Yay!");  	/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  	// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  	// sensors on the glove.  See the manual for their names.  	string[] sensors = Regex.Split (msg' "\\s+");  	if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  	 {  		// Note that values are same for both right and left hand gloves.  		int pinky = Convert.ToInt32 (sensors [14]);  		// get flex of pinky's first joint  		int ring = Convert.ToInt32 (sensors [11]);  		// get flex of ring finger's first joint  		int middle = Convert.ToInt32 (sensors [8]);  		// get flex of middle finger's first joint  		indexFinger = Convert.ToInt32 (sensors [5]);  		// get flex of index finger's first joint  		wrist = Convert.ToInt32 (sensors [17]);  		// get flex/extension of wrist  		// Detect "Starting Postion" gesture  		// Currently we do NOT publish this gesture to the bus  		if (pinky >= 120) {  			if (!pinkyGesture) {  				//Console.WriteLine("Moving to starting position");  				pinkyGesture = true;  				// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  			}  		}  		else {  			if (pinkyGesture)  				pinkyGesture = false;  		}  		// Detect start/stop (robot arm) gesture  		if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  		 {  			if (!movingGesture)// If we're not already in the "moving" gesture...  			 {  				if (moving == true)// If the robot arm is moving' stop it.  				 {  					moving = false;  					Console.WriteLine ("Telling robot arm to stop");  					Bus.Publish (BusNode.ROBOT_ACTIVE' false);  				}  				else// If the robot arm is not moving' enable it.  				 {  					moving = true;  					Console.WriteLine ("Telling robot arm to begin tracking");  					Bus.Publish (BusNode.ROBOT_ACTIVE' true);  				}  				movingGesture = true;  				// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  			}  		}  		else// If we're not in the moving gesture...  		 {  			if (movingGesture)  				// ... and we were' record the change' so we can re-enter the gesture later.  				movingGesture = false;  		}  		/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  		index_percent = ((indexFinger - 125) / 55) * 100;  		if (index_percent < 0)  			index_percent = 0;  		else if (index_percent > 100)  			index_percent = 100;  		/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  		// Craig centered (hand straight): 170 (180 degrees)  		// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  		// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  		if (wrist >= 170)  			wrist_percent = (wrist - 170) / 45 * 50 + 50;  		else  			wrist_percent = (wrist - 75) / 95 * 50;  		if (wrist_percent < 0)  			wrist_percent = 0;  		else if (wrist_percent > 100)  			wrist_percent = 100;  		/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  		//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  		//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  		Debug.WriteLine ("Moving gesture? " + movingGesture);  		Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  		Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  	}  }  catch (TimeoutException) {  	Debug.WriteLine ("Timed out waiting for CyberGlove data!");  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: try {  	Debug.WriteLine ("Reading from CyberGlove...");  	msg = sp.ReadLine ();  	Debug.WriteLine ("Yay!");  	/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  	// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  	// sensors on the glove.  See the manual for their names.  	string[] sensors = Regex.Split (msg' "\\s+");  	if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  	 {  		// Note that values are same for both right and left hand gloves.  		int pinky = Convert.ToInt32 (sensors [14]);  		// get flex of pinky's first joint  		int ring = Convert.ToInt32 (sensors [11]);  		// get flex of ring finger's first joint  		int middle = Convert.ToInt32 (sensors [8]);  		// get flex of middle finger's first joint  		indexFinger = Convert.ToInt32 (sensors [5]);  		// get flex of index finger's first joint  		wrist = Convert.ToInt32 (sensors [17]);  		// get flex/extension of wrist  		// Detect "Starting Postion" gesture  		// Currently we do NOT publish this gesture to the bus  		if (pinky >= 120) {  			if (!pinkyGesture) {  				//Console.WriteLine("Moving to starting position");  				pinkyGesture = true;  				// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  			}  		}  		else {  			if (pinkyGesture)  				pinkyGesture = false;  		}  		// Detect start/stop (robot arm) gesture  		if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  		 {  			if (!movingGesture)// If we're not already in the "moving" gesture...  			 {  				if (moving == true)// If the robot arm is moving' stop it.  				 {  					moving = false;  					Console.WriteLine ("Telling robot arm to stop");  					Bus.Publish (BusNode.ROBOT_ACTIVE' false);  				}  				else// If the robot arm is not moving' enable it.  				 {  					moving = true;  					Console.WriteLine ("Telling robot arm to begin tracking");  					Bus.Publish (BusNode.ROBOT_ACTIVE' true);  				}  				movingGesture = true;  				// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  			}  		}  		else// If we're not in the moving gesture...  		 {  			if (movingGesture)  				// ... and we were' record the change' so we can re-enter the gesture later.  				movingGesture = false;  		}  		/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  		index_percent = ((indexFinger - 125) / 55) * 100;  		if (index_percent < 0)  			index_percent = 0;  		else if (index_percent > 100)  			index_percent = 100;  		/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  		// Craig centered (hand straight): 170 (180 degrees)  		// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  		// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  		if (wrist >= 170)  			wrist_percent = (wrist - 170) / 45 * 50 + 50;  		else  			wrist_percent = (wrist - 75) / 95 * 50;  		if (wrist_percent < 0)  			wrist_percent = 0;  		else if (wrist_percent > 100)  			wrist_percent = 100;  		/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  		//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  		//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  		Debug.WriteLine ("Moving gesture? " + movingGesture);  		Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  		Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  	}  }  catch (TimeoutException) {  	Debug.WriteLine ("Timed out waiting for CyberGlove data!");  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: try {  	Debug.WriteLine ("Reading from CyberGlove...");  	msg = sp.ReadLine ();  	Debug.WriteLine ("Yay!");  	/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  	// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  	// sensors on the glove.  See the manual for their names.  	string[] sensors = Regex.Split (msg' "\\s+");  	if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  	 {  		// Note that values are same for both right and left hand gloves.  		int pinky = Convert.ToInt32 (sensors [14]);  		// get flex of pinky's first joint  		int ring = Convert.ToInt32 (sensors [11]);  		// get flex of ring finger's first joint  		int middle = Convert.ToInt32 (sensors [8]);  		// get flex of middle finger's first joint  		indexFinger = Convert.ToInt32 (sensors [5]);  		// get flex of index finger's first joint  		wrist = Convert.ToInt32 (sensors [17]);  		// get flex/extension of wrist  		// Detect "Starting Postion" gesture  		// Currently we do NOT publish this gesture to the bus  		if (pinky >= 120) {  			if (!pinkyGesture) {  				//Console.WriteLine("Moving to starting position");  				pinkyGesture = true;  				// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  			}  		}  		else {  			if (pinkyGesture)  				pinkyGesture = false;  		}  		// Detect start/stop (robot arm) gesture  		if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  		 {  			if (!movingGesture)// If we're not already in the "moving" gesture...  			 {  				if (moving == true)// If the robot arm is moving' stop it.  				 {  					moving = false;  					Console.WriteLine ("Telling robot arm to stop");  					Bus.Publish (BusNode.ROBOT_ACTIVE' false);  				}  				else// If the robot arm is not moving' enable it.  				 {  					moving = true;  					Console.WriteLine ("Telling robot arm to begin tracking");  					Bus.Publish (BusNode.ROBOT_ACTIVE' true);  				}  				movingGesture = true;  				// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  			}  		}  		else// If we're not in the moving gesture...  		 {  			if (movingGesture)  				// ... and we were' record the change' so we can re-enter the gesture later.  				movingGesture = false;  		}  		/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  		index_percent = ((indexFinger - 125) / 55) * 100;  		if (index_percent < 0)  			index_percent = 0;  		else if (index_percent > 100)  			index_percent = 100;  		/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  		// Craig centered (hand straight): 170 (180 degrees)  		// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  		// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  		if (wrist >= 170)  			wrist_percent = (wrist - 170) / 45 * 50 + 50;  		else  			wrist_percent = (wrist - 75) / 95 * 50;  		if (wrist_percent < 0)  			wrist_percent = 0;  		else if (wrist_percent > 100)  			wrist_percent = 100;  		/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  		//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  		//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  		Debug.WriteLine ("Moving gesture? " + movingGesture);  		Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  		Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  	}  }  catch (TimeoutException) {  	Debug.WriteLine ("Timed out waiting for CyberGlove data!");  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: try {  	Debug.WriteLine ("Reading from CyberGlove...");  	msg = sp.ReadLine ();  	Debug.WriteLine ("Yay!");  	/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  	// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  	// sensors on the glove.  See the manual for their names.  	string[] sensors = Regex.Split (msg' "\\s+");  	if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  	 {  		// Note that values are same for both right and left hand gloves.  		int pinky = Convert.ToInt32 (sensors [14]);  		// get flex of pinky's first joint  		int ring = Convert.ToInt32 (sensors [11]);  		// get flex of ring finger's first joint  		int middle = Convert.ToInt32 (sensors [8]);  		// get flex of middle finger's first joint  		indexFinger = Convert.ToInt32 (sensors [5]);  		// get flex of index finger's first joint  		wrist = Convert.ToInt32 (sensors [17]);  		// get flex/extension of wrist  		// Detect "Starting Postion" gesture  		// Currently we do NOT publish this gesture to the bus  		if (pinky >= 120) {  			if (!pinkyGesture) {  				//Console.WriteLine("Moving to starting position");  				pinkyGesture = true;  				// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  			}  		}  		else {  			if (pinkyGesture)  				pinkyGesture = false;  		}  		// Detect start/stop (robot arm) gesture  		if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  		 {  			if (!movingGesture)// If we're not already in the "moving" gesture...  			 {  				if (moving == true)// If the robot arm is moving' stop it.  				 {  					moving = false;  					Console.WriteLine ("Telling robot arm to stop");  					Bus.Publish (BusNode.ROBOT_ACTIVE' false);  				}  				else// If the robot arm is not moving' enable it.  				 {  					moving = true;  					Console.WriteLine ("Telling robot arm to begin tracking");  					Bus.Publish (BusNode.ROBOT_ACTIVE' true);  				}  				movingGesture = true;  				// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  			}  		}  		else// If we're not in the moving gesture...  		 {  			if (movingGesture)  				// ... and we were' record the change' so we can re-enter the gesture later.  				movingGesture = false;  		}  		/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  		index_percent = ((indexFinger - 125) / 55) * 100;  		if (index_percent < 0)  			index_percent = 0;  		else if (index_percent > 100)  			index_percent = 100;  		/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  		// Craig centered (hand straight): 170 (180 degrees)  		// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  		// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  		if (wrist >= 170)  			wrist_percent = (wrist - 170) / 45 * 50 + 50;  		else  			wrist_percent = (wrist - 75) / 95 * 50;  		if (wrist_percent < 0)  			wrist_percent = 0;  		else if (wrist_percent > 100)  			wrist_percent = 100;  		/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  		//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  		//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  		Debug.WriteLine ("Moving gesture? " + movingGesture);  		Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  		Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  	}  }  catch (TimeoutException) {  	Debug.WriteLine ("Timed out waiting for CyberGlove data!");  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: try {  	Debug.WriteLine ("Reading from CyberGlove...");  	msg = sp.ReadLine ();  	Debug.WriteLine ("Yay!");  	/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  	// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  	// sensors on the glove.  See the manual for their names.  	string[] sensors = Regex.Split (msg' "\\s+");  	if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  	 {  		// Note that values are same for both right and left hand gloves.  		int pinky = Convert.ToInt32 (sensors [14]);  		// get flex of pinky's first joint  		int ring = Convert.ToInt32 (sensors [11]);  		// get flex of ring finger's first joint  		int middle = Convert.ToInt32 (sensors [8]);  		// get flex of middle finger's first joint  		indexFinger = Convert.ToInt32 (sensors [5]);  		// get flex of index finger's first joint  		wrist = Convert.ToInt32 (sensors [17]);  		// get flex/extension of wrist  		// Detect "Starting Postion" gesture  		// Currently we do NOT publish this gesture to the bus  		if (pinky >= 120) {  			if (!pinkyGesture) {  				//Console.WriteLine("Moving to starting position");  				pinkyGesture = true;  				// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  			}  		}  		else {  			if (pinkyGesture)  				pinkyGesture = false;  		}  		// Detect start/stop (robot arm) gesture  		if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  		 {  			if (!movingGesture)// If we're not already in the "moving" gesture...  			 {  				if (moving == true)// If the robot arm is moving' stop it.  				 {  					moving = false;  					Console.WriteLine ("Telling robot arm to stop");  					Bus.Publish (BusNode.ROBOT_ACTIVE' false);  				}  				else// If the robot arm is not moving' enable it.  				 {  					moving = true;  					Console.WriteLine ("Telling robot arm to begin tracking");  					Bus.Publish (BusNode.ROBOT_ACTIVE' true);  				}  				movingGesture = true;  				// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  			}  		}  		else// If we're not in the moving gesture...  		 {  			if (movingGesture)  				// ... and we were' record the change' so we can re-enter the gesture later.  				movingGesture = false;  		}  		/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  		index_percent = ((indexFinger - 125) / 55) * 100;  		if (index_percent < 0)  			index_percent = 0;  		else if (index_percent > 100)  			index_percent = 100;  		/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  		// Craig centered (hand straight): 170 (180 degrees)  		// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  		// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  		if (wrist >= 170)  			wrist_percent = (wrist - 170) / 45 * 50 + 50;  		else  			wrist_percent = (wrist - 75) / 95 * 50;  		if (wrist_percent < 0)  			wrist_percent = 0;  		else if (wrist_percent > 100)  			wrist_percent = 100;  		/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  		//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  		//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  		Debug.WriteLine ("Moving gesture? " + movingGesture);  		Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  		Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  	}  }  catch (TimeoutException) {  	Debug.WriteLine ("Timed out waiting for CyberGlove data!");  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: try {  	Debug.WriteLine ("Reading from CyberGlove...");  	msg = sp.ReadLine ();  	Debug.WriteLine ("Yay!");  	/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  	// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  	// sensors on the glove.  See the manual for their names.  	string[] sensors = Regex.Split (msg' "\\s+");  	if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  	 {  		// Note that values are same for both right and left hand gloves.  		int pinky = Convert.ToInt32 (sensors [14]);  		// get flex of pinky's first joint  		int ring = Convert.ToInt32 (sensors [11]);  		// get flex of ring finger's first joint  		int middle = Convert.ToInt32 (sensors [8]);  		// get flex of middle finger's first joint  		indexFinger = Convert.ToInt32 (sensors [5]);  		// get flex of index finger's first joint  		wrist = Convert.ToInt32 (sensors [17]);  		// get flex/extension of wrist  		// Detect "Starting Postion" gesture  		// Currently we do NOT publish this gesture to the bus  		if (pinky >= 120) {  			if (!pinkyGesture) {  				//Console.WriteLine("Moving to starting position");  				pinkyGesture = true;  				// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  			}  		}  		else {  			if (pinkyGesture)  				pinkyGesture = false;  		}  		// Detect start/stop (robot arm) gesture  		if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  		 {  			if (!movingGesture)// If we're not already in the "moving" gesture...  			 {  				if (moving == true)// If the robot arm is moving' stop it.  				 {  					moving = false;  					Console.WriteLine ("Telling robot arm to stop");  					Bus.Publish (BusNode.ROBOT_ACTIVE' false);  				}  				else// If the robot arm is not moving' enable it.  				 {  					moving = true;  					Console.WriteLine ("Telling robot arm to begin tracking");  					Bus.Publish (BusNode.ROBOT_ACTIVE' true);  				}  				movingGesture = true;  				// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  			}  		}  		else// If we're not in the moving gesture...  		 {  			if (movingGesture)  				// ... and we were' record the change' so we can re-enter the gesture later.  				movingGesture = false;  		}  		/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  		index_percent = ((indexFinger - 125) / 55) * 100;  		if (index_percent < 0)  			index_percent = 0;  		else if (index_percent > 100)  			index_percent = 100;  		/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  		// Craig centered (hand straight): 170 (180 degrees)  		// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  		// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  		if (wrist >= 170)  			wrist_percent = (wrist - 170) / 45 * 50 + 50;  		else  			wrist_percent = (wrist - 75) / 95 * 50;  		if (wrist_percent < 0)  			wrist_percent = 0;  		else if (wrist_percent > 100)  			wrist_percent = 100;  		/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  		//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  		//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  		Debug.WriteLine ("Moving gesture? " + movingGesture);  		Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  		Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  	}  }  catch (TimeoutException) {  	Debug.WriteLine ("Timed out waiting for CyberGlove data!");  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: try {  	Debug.WriteLine ("Reading from CyberGlove...");  	msg = sp.ReadLine ();  	Debug.WriteLine ("Yay!");  	/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  	// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  	// sensors on the glove.  See the manual for their names.  	string[] sensors = Regex.Split (msg' "\\s+");  	if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  	 {  		// Note that values are same for both right and left hand gloves.  		int pinky = Convert.ToInt32 (sensors [14]);  		// get flex of pinky's first joint  		int ring = Convert.ToInt32 (sensors [11]);  		// get flex of ring finger's first joint  		int middle = Convert.ToInt32 (sensors [8]);  		// get flex of middle finger's first joint  		indexFinger = Convert.ToInt32 (sensors [5]);  		// get flex of index finger's first joint  		wrist = Convert.ToInt32 (sensors [17]);  		// get flex/extension of wrist  		// Detect "Starting Postion" gesture  		// Currently we do NOT publish this gesture to the bus  		if (pinky >= 120) {  			if (!pinkyGesture) {  				//Console.WriteLine("Moving to starting position");  				pinkyGesture = true;  				// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  			}  		}  		else {  			if (pinkyGesture)  				pinkyGesture = false;  		}  		// Detect start/stop (robot arm) gesture  		if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  		 {  			if (!movingGesture)// If we're not already in the "moving" gesture...  			 {  				if (moving == true)// If the robot arm is moving' stop it.  				 {  					moving = false;  					Console.WriteLine ("Telling robot arm to stop");  					Bus.Publish (BusNode.ROBOT_ACTIVE' false);  				}  				else// If the robot arm is not moving' enable it.  				 {  					moving = true;  					Console.WriteLine ("Telling robot arm to begin tracking");  					Bus.Publish (BusNode.ROBOT_ACTIVE' true);  				}  				movingGesture = true;  				// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  			}  		}  		else// If we're not in the moving gesture...  		 {  			if (movingGesture)  				// ... and we were' record the change' so we can re-enter the gesture later.  				movingGesture = false;  		}  		/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  		index_percent = ((indexFinger - 125) / 55) * 100;  		if (index_percent < 0)  			index_percent = 0;  		else if (index_percent > 100)  			index_percent = 100;  		/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  		// Craig centered (hand straight): 170 (180 degrees)  		// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  		// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  		if (wrist >= 170)  			wrist_percent = (wrist - 170) / 45 * 50 + 50;  		else  			wrist_percent = (wrist - 75) / 95 * 50;  		if (wrist_percent < 0)  			wrist_percent = 0;  		else if (wrist_percent > 100)  			wrist_percent = 100;  		/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  		//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  		//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  		Debug.WriteLine ("Moving gesture? " + movingGesture);  		Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  		Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  	}  }  catch (TimeoutException) {  	Debug.WriteLine ("Timed out waiting for CyberGlove data!");  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: try {  	Debug.WriteLine ("Reading from CyberGlove...");  	msg = sp.ReadLine ();  	Debug.WriteLine ("Yay!");  	/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  	// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  	// sensors on the glove.  See the manual for their names.  	string[] sensors = Regex.Split (msg' "\\s+");  	if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  	 {  		// Note that values are same for both right and left hand gloves.  		int pinky = Convert.ToInt32 (sensors [14]);  		// get flex of pinky's first joint  		int ring = Convert.ToInt32 (sensors [11]);  		// get flex of ring finger's first joint  		int middle = Convert.ToInt32 (sensors [8]);  		// get flex of middle finger's first joint  		indexFinger = Convert.ToInt32 (sensors [5]);  		// get flex of index finger's first joint  		wrist = Convert.ToInt32 (sensors [17]);  		// get flex/extension of wrist  		// Detect "Starting Postion" gesture  		// Currently we do NOT publish this gesture to the bus  		if (pinky >= 120) {  			if (!pinkyGesture) {  				//Console.WriteLine("Moving to starting position");  				pinkyGesture = true;  				// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  			}  		}  		else {  			if (pinkyGesture)  				pinkyGesture = false;  		}  		// Detect start/stop (robot arm) gesture  		if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  		 {  			if (!movingGesture)// If we're not already in the "moving" gesture...  			 {  				if (moving == true)// If the robot arm is moving' stop it.  				 {  					moving = false;  					Console.WriteLine ("Telling robot arm to stop");  					Bus.Publish (BusNode.ROBOT_ACTIVE' false);  				}  				else// If the robot arm is not moving' enable it.  				 {  					moving = true;  					Console.WriteLine ("Telling robot arm to begin tracking");  					Bus.Publish (BusNode.ROBOT_ACTIVE' true);  				}  				movingGesture = true;  				// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  			}  		}  		else// If we're not in the moving gesture...  		 {  			if (movingGesture)  				// ... and we were' record the change' so we can re-enter the gesture later.  				movingGesture = false;  		}  		/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  		index_percent = ((indexFinger - 125) / 55) * 100;  		if (index_percent < 0)  			index_percent = 0;  		else if (index_percent > 100)  			index_percent = 100;  		/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  		// Craig centered (hand straight): 170 (180 degrees)  		// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  		// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  		if (wrist >= 170)  			wrist_percent = (wrist - 170) / 45 * 50 + 50;  		else  			wrist_percent = (wrist - 75) / 95 * 50;  		if (wrist_percent < 0)  			wrist_percent = 0;  		else if (wrist_percent > 100)  			wrist_percent = 100;  		/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  		//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  		//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  		Debug.WriteLine ("Moving gesture? " + movingGesture);  		Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  		Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  	}  }  catch (TimeoutException) {  	Debug.WriteLine ("Timed out waiting for CyberGlove data!");  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: try {  	Debug.WriteLine ("Reading from CyberGlove...");  	msg = sp.ReadLine ();  	Debug.WriteLine ("Yay!");  	/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  	// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  	// sensors on the glove.  See the manual for their names.  	string[] sensors = Regex.Split (msg' "\\s+");  	if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  	 {  		// Note that values are same for both right and left hand gloves.  		int pinky = Convert.ToInt32 (sensors [14]);  		// get flex of pinky's first joint  		int ring = Convert.ToInt32 (sensors [11]);  		// get flex of ring finger's first joint  		int middle = Convert.ToInt32 (sensors [8]);  		// get flex of middle finger's first joint  		indexFinger = Convert.ToInt32 (sensors [5]);  		// get flex of index finger's first joint  		wrist = Convert.ToInt32 (sensors [17]);  		// get flex/extension of wrist  		// Detect "Starting Postion" gesture  		// Currently we do NOT publish this gesture to the bus  		if (pinky >= 120) {  			if (!pinkyGesture) {  				//Console.WriteLine("Moving to starting position");  				pinkyGesture = true;  				// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  			}  		}  		else {  			if (pinkyGesture)  				pinkyGesture = false;  		}  		// Detect start/stop (robot arm) gesture  		if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  		 {  			if (!movingGesture)// If we're not already in the "moving" gesture...  			 {  				if (moving == true)// If the robot arm is moving' stop it.  				 {  					moving = false;  					Console.WriteLine ("Telling robot arm to stop");  					Bus.Publish (BusNode.ROBOT_ACTIVE' false);  				}  				else// If the robot arm is not moving' enable it.  				 {  					moving = true;  					Console.WriteLine ("Telling robot arm to begin tracking");  					Bus.Publish (BusNode.ROBOT_ACTIVE' true);  				}  				movingGesture = true;  				// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  			}  		}  		else// If we're not in the moving gesture...  		 {  			if (movingGesture)  				// ... and we were' record the change' so we can re-enter the gesture later.  				movingGesture = false;  		}  		/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  		index_percent = ((indexFinger - 125) / 55) * 100;  		if (index_percent < 0)  			index_percent = 0;  		else if (index_percent > 100)  			index_percent = 100;  		/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  		// Craig centered (hand straight): 170 (180 degrees)  		// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  		// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  		if (wrist >= 170)  			wrist_percent = (wrist - 170) / 45 * 50 + 50;  		else  			wrist_percent = (wrist - 75) / 95 * 50;  		if (wrist_percent < 0)  			wrist_percent = 0;  		else if (wrist_percent > 100)  			wrist_percent = 100;  		/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  		//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  		//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  		Debug.WriteLine ("Moving gesture? " + movingGesture);  		Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  		Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  	}  }  catch (TimeoutException) {  	Debug.WriteLine ("Timed out waiting for CyberGlove data!");  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: try {  	Debug.WriteLine ("Reading from CyberGlove...");  	msg = sp.ReadLine ();  	Debug.WriteLine ("Yay!");  	/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  	// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  	// sensors on the glove.  See the manual for their names.  	string[] sensors = Regex.Split (msg' "\\s+");  	if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  	 {  		// Note that values are same for both right and left hand gloves.  		int pinky = Convert.ToInt32 (sensors [14]);  		// get flex of pinky's first joint  		int ring = Convert.ToInt32 (sensors [11]);  		// get flex of ring finger's first joint  		int middle = Convert.ToInt32 (sensors [8]);  		// get flex of middle finger's first joint  		indexFinger = Convert.ToInt32 (sensors [5]);  		// get flex of index finger's first joint  		wrist = Convert.ToInt32 (sensors [17]);  		// get flex/extension of wrist  		// Detect "Starting Postion" gesture  		// Currently we do NOT publish this gesture to the bus  		if (pinky >= 120) {  			if (!pinkyGesture) {  				//Console.WriteLine("Moving to starting position");  				pinkyGesture = true;  				// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  			}  		}  		else {  			if (pinkyGesture)  				pinkyGesture = false;  		}  		// Detect start/stop (robot arm) gesture  		if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  		 {  			if (!movingGesture)// If we're not already in the "moving" gesture...  			 {  				if (moving == true)// If the robot arm is moving' stop it.  				 {  					moving = false;  					Console.WriteLine ("Telling robot arm to stop");  					Bus.Publish (BusNode.ROBOT_ACTIVE' false);  				}  				else// If the robot arm is not moving' enable it.  				 {  					moving = true;  					Console.WriteLine ("Telling robot arm to begin tracking");  					Bus.Publish (BusNode.ROBOT_ACTIVE' true);  				}  				movingGesture = true;  				// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  			}  		}  		else// If we're not in the moving gesture...  		 {  			if (movingGesture)  				// ... and we were' record the change' so we can re-enter the gesture later.  				movingGesture = false;  		}  		/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  		index_percent = ((indexFinger - 125) / 55) * 100;  		if (index_percent < 0)  			index_percent = 0;  		else if (index_percent > 100)  			index_percent = 100;  		/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  		// Craig centered (hand straight): 170 (180 degrees)  		// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  		// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  		if (wrist >= 170)  			wrist_percent = (wrist - 170) / 45 * 50 + 50;  		else  			wrist_percent = (wrist - 75) / 95 * 50;  		if (wrist_percent < 0)  			wrist_percent = 0;  		else if (wrist_percent > 100)  			wrist_percent = 100;  		/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  		//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  		//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  		Debug.WriteLine ("Moving gesture? " + movingGesture);  		Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  		Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  	}  }  catch (TimeoutException) {  	Debug.WriteLine ("Timed out waiting for CyberGlove data!");  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: try {  	Debug.WriteLine ("Reading from CyberGlove...");  	msg = sp.ReadLine ();  	Debug.WriteLine ("Yay!");  	/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  	// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  	// sensors on the glove.  See the manual for their names.  	string[] sensors = Regex.Split (msg' "\\s+");  	if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  	 {  		// Note that values are same for both right and left hand gloves.  		int pinky = Convert.ToInt32 (sensors [14]);  		// get flex of pinky's first joint  		int ring = Convert.ToInt32 (sensors [11]);  		// get flex of ring finger's first joint  		int middle = Convert.ToInt32 (sensors [8]);  		// get flex of middle finger's first joint  		indexFinger = Convert.ToInt32 (sensors [5]);  		// get flex of index finger's first joint  		wrist = Convert.ToInt32 (sensors [17]);  		// get flex/extension of wrist  		// Detect "Starting Postion" gesture  		// Currently we do NOT publish this gesture to the bus  		if (pinky >= 120) {  			if (!pinkyGesture) {  				//Console.WriteLine("Moving to starting position");  				pinkyGesture = true;  				// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  			}  		}  		else {  			if (pinkyGesture)  				pinkyGesture = false;  		}  		// Detect start/stop (robot arm) gesture  		if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  		 {  			if (!movingGesture)// If we're not already in the "moving" gesture...  			 {  				if (moving == true)// If the robot arm is moving' stop it.  				 {  					moving = false;  					Console.WriteLine ("Telling robot arm to stop");  					Bus.Publish (BusNode.ROBOT_ACTIVE' false);  				}  				else// If the robot arm is not moving' enable it.  				 {  					moving = true;  					Console.WriteLine ("Telling robot arm to begin tracking");  					Bus.Publish (BusNode.ROBOT_ACTIVE' true);  				}  				movingGesture = true;  				// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  			}  		}  		else// If we're not in the moving gesture...  		 {  			if (movingGesture)  				// ... and we were' record the change' so we can re-enter the gesture later.  				movingGesture = false;  		}  		/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  		index_percent = ((indexFinger - 125) / 55) * 100;  		if (index_percent < 0)  			index_percent = 0;  		else if (index_percent > 100)  			index_percent = 100;  		/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  		// Craig centered (hand straight): 170 (180 degrees)  		// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  		// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  		if (wrist >= 170)  			wrist_percent = (wrist - 170) / 45 * 50 + 50;  		else  			wrist_percent = (wrist - 75) / 95 * 50;  		if (wrist_percent < 0)  			wrist_percent = 0;  		else if (wrist_percent > 100)  			wrist_percent = 100;  		/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  		//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  		//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  		Debug.WriteLine ("Moving gesture? " + movingGesture);  		Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  		Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  	}  }  catch (TimeoutException) {  	Debug.WriteLine ("Timed out waiting for CyberGlove data!");  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: try {  	Debug.WriteLine ("Reading from CyberGlove...");  	msg = sp.ReadLine ();  	Debug.WriteLine ("Yay!");  	/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  	// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  	// sensors on the glove.  See the manual for their names.  	string[] sensors = Regex.Split (msg' "\\s+");  	if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  	 {  		// Note that values are same for both right and left hand gloves.  		int pinky = Convert.ToInt32 (sensors [14]);  		// get flex of pinky's first joint  		int ring = Convert.ToInt32 (sensors [11]);  		// get flex of ring finger's first joint  		int middle = Convert.ToInt32 (sensors [8]);  		// get flex of middle finger's first joint  		indexFinger = Convert.ToInt32 (sensors [5]);  		// get flex of index finger's first joint  		wrist = Convert.ToInt32 (sensors [17]);  		// get flex/extension of wrist  		// Detect "Starting Postion" gesture  		// Currently we do NOT publish this gesture to the bus  		if (pinky >= 120) {  			if (!pinkyGesture) {  				//Console.WriteLine("Moving to starting position");  				pinkyGesture = true;  				// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  			}  		}  		else {  			if (pinkyGesture)  				pinkyGesture = false;  		}  		// Detect start/stop (robot arm) gesture  		if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  		 {  			if (!movingGesture)// If we're not already in the "moving" gesture...  			 {  				if (moving == true)// If the robot arm is moving' stop it.  				 {  					moving = false;  					Console.WriteLine ("Telling robot arm to stop");  					Bus.Publish (BusNode.ROBOT_ACTIVE' false);  				}  				else// If the robot arm is not moving' enable it.  				 {  					moving = true;  					Console.WriteLine ("Telling robot arm to begin tracking");  					Bus.Publish (BusNode.ROBOT_ACTIVE' true);  				}  				movingGesture = true;  				// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  			}  		}  		else// If we're not in the moving gesture...  		 {  			if (movingGesture)  				// ... and we were' record the change' so we can re-enter the gesture later.  				movingGesture = false;  		}  		/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  		index_percent = ((indexFinger - 125) / 55) * 100;  		if (index_percent < 0)  			index_percent = 0;  		else if (index_percent > 100)  			index_percent = 100;  		/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  		// Craig centered (hand straight): 170 (180 degrees)  		// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  		// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  		if (wrist >= 170)  			wrist_percent = (wrist - 170) / 45 * 50 + 50;  		else  			wrist_percent = (wrist - 75) / 95 * 50;  		if (wrist_percent < 0)  			wrist_percent = 0;  		else if (wrist_percent > 100)  			wrist_percent = 100;  		/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  		//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  		//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  		Debug.WriteLine ("Moving gesture? " + movingGesture);  		Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  		Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  	}  }  catch (TimeoutException) {  	Debug.WriteLine ("Timed out waiting for CyberGlove data!");  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: try {  	Debug.WriteLine ("Reading from CyberGlove...");  	msg = sp.ReadLine ();  	Debug.WriteLine ("Yay!");  	/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  	// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  	// sensors on the glove.  See the manual for their names.  	string[] sensors = Regex.Split (msg' "\\s+");  	if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  	 {  		// Note that values are same for both right and left hand gloves.  		int pinky = Convert.ToInt32 (sensors [14]);  		// get flex of pinky's first joint  		int ring = Convert.ToInt32 (sensors [11]);  		// get flex of ring finger's first joint  		int middle = Convert.ToInt32 (sensors [8]);  		// get flex of middle finger's first joint  		indexFinger = Convert.ToInt32 (sensors [5]);  		// get flex of index finger's first joint  		wrist = Convert.ToInt32 (sensors [17]);  		// get flex/extension of wrist  		// Detect "Starting Postion" gesture  		// Currently we do NOT publish this gesture to the bus  		if (pinky >= 120) {  			if (!pinkyGesture) {  				//Console.WriteLine("Moving to starting position");  				pinkyGesture = true;  				// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  			}  		}  		else {  			if (pinkyGesture)  				pinkyGesture = false;  		}  		// Detect start/stop (robot arm) gesture  		if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  		 {  			if (!movingGesture)// If we're not already in the "moving" gesture...  			 {  				if (moving == true)// If the robot arm is moving' stop it.  				 {  					moving = false;  					Console.WriteLine ("Telling robot arm to stop");  					Bus.Publish (BusNode.ROBOT_ACTIVE' false);  				}  				else// If the robot arm is not moving' enable it.  				 {  					moving = true;  					Console.WriteLine ("Telling robot arm to begin tracking");  					Bus.Publish (BusNode.ROBOT_ACTIVE' true);  				}  				movingGesture = true;  				// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  			}  		}  		else// If we're not in the moving gesture...  		 {  			if (movingGesture)  				// ... and we were' record the change' so we can re-enter the gesture later.  				movingGesture = false;  		}  		/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  		index_percent = ((indexFinger - 125) / 55) * 100;  		if (index_percent < 0)  			index_percent = 0;  		else if (index_percent > 100)  			index_percent = 100;  		/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  		// Craig centered (hand straight): 170 (180 degrees)  		// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  		// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  		if (wrist >= 170)  			wrist_percent = (wrist - 170) / 45 * 50 + 50;  		else  			wrist_percent = (wrist - 75) / 95 * 50;  		if (wrist_percent < 0)  			wrist_percent = 0;  		else if (wrist_percent > 100)  			wrist_percent = 100;  		/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  		//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  		//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  		Debug.WriteLine ("Moving gesture? " + movingGesture);  		Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  		Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  	}  }  catch (TimeoutException) {  	Debug.WriteLine ("Timed out waiting for CyberGlove data!");  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: try {  	Debug.WriteLine ("Reading from CyberGlove...");  	msg = sp.ReadLine ();  	Debug.WriteLine ("Yay!");  	/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  	// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  	// sensors on the glove.  See the manual for their names.  	string[] sensors = Regex.Split (msg' "\\s+");  	if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  	 {  		// Note that values are same for both right and left hand gloves.  		int pinky = Convert.ToInt32 (sensors [14]);  		// get flex of pinky's first joint  		int ring = Convert.ToInt32 (sensors [11]);  		// get flex of ring finger's first joint  		int middle = Convert.ToInt32 (sensors [8]);  		// get flex of middle finger's first joint  		indexFinger = Convert.ToInt32 (sensors [5]);  		// get flex of index finger's first joint  		wrist = Convert.ToInt32 (sensors [17]);  		// get flex/extension of wrist  		// Detect "Starting Postion" gesture  		// Currently we do NOT publish this gesture to the bus  		if (pinky >= 120) {  			if (!pinkyGesture) {  				//Console.WriteLine("Moving to starting position");  				pinkyGesture = true;  				// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  			}  		}  		else {  			if (pinkyGesture)  				pinkyGesture = false;  		}  		// Detect start/stop (robot arm) gesture  		if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  		 {  			if (!movingGesture)// If we're not already in the "moving" gesture...  			 {  				if (moving == true)// If the robot arm is moving' stop it.  				 {  					moving = false;  					Console.WriteLine ("Telling robot arm to stop");  					Bus.Publish (BusNode.ROBOT_ACTIVE' false);  				}  				else// If the robot arm is not moving' enable it.  				 {  					moving = true;  					Console.WriteLine ("Telling robot arm to begin tracking");  					Bus.Publish (BusNode.ROBOT_ACTIVE' true);  				}  				movingGesture = true;  				// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  			}  		}  		else// If we're not in the moving gesture...  		 {  			if (movingGesture)  				// ... and we were' record the change' so we can re-enter the gesture later.  				movingGesture = false;  		}  		/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  		index_percent = ((indexFinger - 125) / 55) * 100;  		if (index_percent < 0)  			index_percent = 0;  		else if (index_percent > 100)  			index_percent = 100;  		/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  		// Craig centered (hand straight): 170 (180 degrees)  		// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  		// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  		if (wrist >= 170)  			wrist_percent = (wrist - 170) / 45 * 50 + 50;  		else  			wrist_percent = (wrist - 75) / 95 * 50;  		if (wrist_percent < 0)  			wrist_percent = 0;  		else if (wrist_percent > 100)  			wrist_percent = 100;  		/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  		//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  		//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  		Debug.WriteLine ("Moving gesture? " + movingGesture);  		Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  		Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  	}  }  catch (TimeoutException) {  	Debug.WriteLine ("Timed out waiting for CyberGlove data!");  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: try {  	Debug.WriteLine ("Reading from CyberGlove...");  	msg = sp.ReadLine ();  	Debug.WriteLine ("Yay!");  	/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  	// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  	// sensors on the glove.  See the manual for their names.  	string[] sensors = Regex.Split (msg' "\\s+");  	if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  	 {  		// Note that values are same for both right and left hand gloves.  		int pinky = Convert.ToInt32 (sensors [14]);  		// get flex of pinky's first joint  		int ring = Convert.ToInt32 (sensors [11]);  		// get flex of ring finger's first joint  		int middle = Convert.ToInt32 (sensors [8]);  		// get flex of middle finger's first joint  		indexFinger = Convert.ToInt32 (sensors [5]);  		// get flex of index finger's first joint  		wrist = Convert.ToInt32 (sensors [17]);  		// get flex/extension of wrist  		// Detect "Starting Postion" gesture  		// Currently we do NOT publish this gesture to the bus  		if (pinky >= 120) {  			if (!pinkyGesture) {  				//Console.WriteLine("Moving to starting position");  				pinkyGesture = true;  				// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  			}  		}  		else {  			if (pinkyGesture)  				pinkyGesture = false;  		}  		// Detect start/stop (robot arm) gesture  		if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  		 {  			if (!movingGesture)// If we're not already in the "moving" gesture...  			 {  				if (moving == true)// If the robot arm is moving' stop it.  				 {  					moving = false;  					Console.WriteLine ("Telling robot arm to stop");  					Bus.Publish (BusNode.ROBOT_ACTIVE' false);  				}  				else// If the robot arm is not moving' enable it.  				 {  					moving = true;  					Console.WriteLine ("Telling robot arm to begin tracking");  					Bus.Publish (BusNode.ROBOT_ACTIVE' true);  				}  				movingGesture = true;  				// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  			}  		}  		else// If we're not in the moving gesture...  		 {  			if (movingGesture)  				// ... and we were' record the change' so we can re-enter the gesture later.  				movingGesture = false;  		}  		/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  		index_percent = ((indexFinger - 125) / 55) * 100;  		if (index_percent < 0)  			index_percent = 0;  		else if (index_percent > 100)  			index_percent = 100;  		/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  		// Craig centered (hand straight): 170 (180 degrees)  		// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  		// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  		if (wrist >= 170)  			wrist_percent = (wrist - 170) / 45 * 50 + 50;  		else  			wrist_percent = (wrist - 75) / 95 * 50;  		if (wrist_percent < 0)  			wrist_percent = 0;  		else if (wrist_percent > 100)  			wrist_percent = 100;  		/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  		//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  		//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  		Debug.WriteLine ("Moving gesture? " + movingGesture);  		Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  		Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  	}  }  catch (TimeoutException) {  	Debug.WriteLine ("Timed out waiting for CyberGlove data!");  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: try {  	Debug.WriteLine ("Reading from CyberGlove...");  	msg = sp.ReadLine ();  	Debug.WriteLine ("Yay!");  	/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  	// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  	// sensors on the glove.  See the manual for their names.  	string[] sensors = Regex.Split (msg' "\\s+");  	if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  	 {  		// Note that values are same for both right and left hand gloves.  		int pinky = Convert.ToInt32 (sensors [14]);  		// get flex of pinky's first joint  		int ring = Convert.ToInt32 (sensors [11]);  		// get flex of ring finger's first joint  		int middle = Convert.ToInt32 (sensors [8]);  		// get flex of middle finger's first joint  		indexFinger = Convert.ToInt32 (sensors [5]);  		// get flex of index finger's first joint  		wrist = Convert.ToInt32 (sensors [17]);  		// get flex/extension of wrist  		// Detect "Starting Postion" gesture  		// Currently we do NOT publish this gesture to the bus  		if (pinky >= 120) {  			if (!pinkyGesture) {  				//Console.WriteLine("Moving to starting position");  				pinkyGesture = true;  				// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  			}  		}  		else {  			if (pinkyGesture)  				pinkyGesture = false;  		}  		// Detect start/stop (robot arm) gesture  		if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  		 {  			if (!movingGesture)// If we're not already in the "moving" gesture...  			 {  				if (moving == true)// If the robot arm is moving' stop it.  				 {  					moving = false;  					Console.WriteLine ("Telling robot arm to stop");  					Bus.Publish (BusNode.ROBOT_ACTIVE' false);  				}  				else// If the robot arm is not moving' enable it.  				 {  					moving = true;  					Console.WriteLine ("Telling robot arm to begin tracking");  					Bus.Publish (BusNode.ROBOT_ACTIVE' true);  				}  				movingGesture = true;  				// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  			}  		}  		else// If we're not in the moving gesture...  		 {  			if (movingGesture)  				// ... and we were' record the change' so we can re-enter the gesture later.  				movingGesture = false;  		}  		/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  		index_percent = ((indexFinger - 125) / 55) * 100;  		if (index_percent < 0)  			index_percent = 0;  		else if (index_percent > 100)  			index_percent = 100;  		/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  		// Craig centered (hand straight): 170 (180 degrees)  		// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  		// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  		if (wrist >= 170)  			wrist_percent = (wrist - 170) / 45 * 50 + 50;  		else  			wrist_percent = (wrist - 75) / 95 * 50;  		if (wrist_percent < 0)  			wrist_percent = 0;  		else if (wrist_percent > 100)  			wrist_percent = 100;  		/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  		//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  		//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  		Debug.WriteLine ("Moving gesture? " + movingGesture);  		Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  		Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  	}  }  catch (TimeoutException) {  	Debug.WriteLine ("Timed out waiting for CyberGlove data!");  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: try {  	Debug.WriteLine ("Reading from CyberGlove...");  	msg = sp.ReadLine ();  	Debug.WriteLine ("Yay!");  	/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  	// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  	// sensors on the glove.  See the manual for their names.  	string[] sensors = Regex.Split (msg' "\\s+");  	if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  	 {  		// Note that values are same for both right and left hand gloves.  		int pinky = Convert.ToInt32 (sensors [14]);  		// get flex of pinky's first joint  		int ring = Convert.ToInt32 (sensors [11]);  		// get flex of ring finger's first joint  		int middle = Convert.ToInt32 (sensors [8]);  		// get flex of middle finger's first joint  		indexFinger = Convert.ToInt32 (sensors [5]);  		// get flex of index finger's first joint  		wrist = Convert.ToInt32 (sensors [17]);  		// get flex/extension of wrist  		// Detect "Starting Postion" gesture  		// Currently we do NOT publish this gesture to the bus  		if (pinky >= 120) {  			if (!pinkyGesture) {  				//Console.WriteLine("Moving to starting position");  				pinkyGesture = true;  				// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  			}  		}  		else {  			if (pinkyGesture)  				pinkyGesture = false;  		}  		// Detect start/stop (robot arm) gesture  		if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  		 {  			if (!movingGesture)// If we're not already in the "moving" gesture...  			 {  				if (moving == true)// If the robot arm is moving' stop it.  				 {  					moving = false;  					Console.WriteLine ("Telling robot arm to stop");  					Bus.Publish (BusNode.ROBOT_ACTIVE' false);  				}  				else// If the robot arm is not moving' enable it.  				 {  					moving = true;  					Console.WriteLine ("Telling robot arm to begin tracking");  					Bus.Publish (BusNode.ROBOT_ACTIVE' true);  				}  				movingGesture = true;  				// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  			}  		}  		else// If we're not in the moving gesture...  		 {  			if (movingGesture)  				// ... and we were' record the change' so we can re-enter the gesture later.  				movingGesture = false;  		}  		/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  		index_percent = ((indexFinger - 125) / 55) * 100;  		if (index_percent < 0)  			index_percent = 0;  		else if (index_percent > 100)  			index_percent = 100;  		/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  		// Craig centered (hand straight): 170 (180 degrees)  		// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  		// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  		if (wrist >= 170)  			wrist_percent = (wrist - 170) / 45 * 50 + 50;  		else  			wrist_percent = (wrist - 75) / 95 * 50;  		if (wrist_percent < 0)  			wrist_percent = 0;  		else if (wrist_percent > 100)  			wrist_percent = 100;  		/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  		//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  		//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  		Debug.WriteLine ("Moving gesture? " + movingGesture);  		Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  		Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  	}  }  catch (TimeoutException) {  	Debug.WriteLine ("Timed out waiting for CyberGlove data!");  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: try {  	Debug.WriteLine ("Reading from CyberGlove...");  	msg = sp.ReadLine ();  	Debug.WriteLine ("Yay!");  	/* Calibration ranges:                      *                       * Sensor 5 - Index MPJ - byte 4 in manual - clamp control                      *  125 (open) to 180 (closed) (craig)                      *  125 (open) to 175 (closed) (Michael)                        Sensors 8 & 11 - Middle and Ring first joint - (byte indices 9 and 13)                         >145 bent for 8 & 11 (Craig)                         >145 (Michael)                         Sensor 14 - Pinkie first joint - Pinkie PIJ (Byte index 17 in manual)                         >145 consider bent (Craig)                      *  >120 bent (Michael)                      */// Tokenize the line read from the CyberGlove on whitespace.  Using defaults' it should be 'g' (the character sent to request the data)'  	// followed by a space and then 18 numeric values (followed by spaces or a null for the last).  The 18 values are the 18  	// sensors on the glove.  See the manual for their names.  	string[] sensors = Regex.Split (msg' "\\s+");  	if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)  	 {  		// Note that values are same for both right and left hand gloves.  		int pinky = Convert.ToInt32 (sensors [14]);  		// get flex of pinky's first joint  		int ring = Convert.ToInt32 (sensors [11]);  		// get flex of ring finger's first joint  		int middle = Convert.ToInt32 (sensors [8]);  		// get flex of middle finger's first joint  		indexFinger = Convert.ToInt32 (sensors [5]);  		// get flex of index finger's first joint  		wrist = Convert.ToInt32 (sensors [17]);  		// get flex/extension of wrist  		// Detect "Starting Postion" gesture  		// Currently we do NOT publish this gesture to the bus  		if (pinky >= 120) {  			if (!pinkyGesture) {  				//Console.WriteLine("Moving to starting position");  				pinkyGesture = true;  				// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  			}  		}  		else {  			if (pinkyGesture)  				pinkyGesture = false;  		}  		// Detect start/stop (robot arm) gesture  		if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  		 {  			if (!movingGesture)// If we're not already in the "moving" gesture...  			 {  				if (moving == true)// If the robot arm is moving' stop it.  				 {  					moving = false;  					Console.WriteLine ("Telling robot arm to stop");  					Bus.Publish (BusNode.ROBOT_ACTIVE' false);  				}  				else// If the robot arm is not moving' enable it.  				 {  					moving = true;  					Console.WriteLine ("Telling robot arm to begin tracking");  					Bus.Publish (BusNode.ROBOT_ACTIVE' true);  				}  				movingGesture = true;  				// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  			}  		}  		else// If we're not in the moving gesture...  		 {  			if (movingGesture)  				// ... and we were' record the change' so we can re-enter the gesture later.  				movingGesture = false;  		}  		/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  		index_percent = ((indexFinger - 125) / 55) * 100;  		if (index_percent < 0)  			index_percent = 0;  		else if (index_percent > 100)  			index_percent = 100;  		/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  		// Craig centered (hand straight): 170 (180 degrees)  		// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  		// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  		if (wrist >= 170)  			wrist_percent = (wrist - 170) / 45 * 50 + 50;  		else  			wrist_percent = (wrist - 75) / 95 * 50;  		if (wrist_percent < 0)  			wrist_percent = 0;  		else if (wrist_percent > 100)  			wrist_percent = 100;  		/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  		//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  		//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  		Debug.WriteLine ("Moving gesture? " + movingGesture);  		Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  		Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  	}  }  catch (TimeoutException) {  	Debug.WriteLine ("Timed out waiting for CyberGlove data!");  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)   {  	// Note that values are same for both right and left hand gloves.  	int pinky = Convert.ToInt32 (sensors [14]);  	// get flex of pinky's first joint  	int ring = Convert.ToInt32 (sensors [11]);  	// get flex of ring finger's first joint  	int middle = Convert.ToInt32 (sensors [8]);  	// get flex of middle finger's first joint  	indexFinger = Convert.ToInt32 (sensors [5]);  	// get flex of index finger's first joint  	wrist = Convert.ToInt32 (sensors [17]);  	// get flex/extension of wrist  	// Detect "Starting Postion" gesture  	// Currently we do NOT publish this gesture to the bus  	if (pinky >= 120) {  		if (!pinkyGesture) {  			//Console.WriteLine("Moving to starting position");  			pinkyGesture = true;  			// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  		}  	}  	else {  		if (pinkyGesture)  			pinkyGesture = false;  	}  	// Detect start/stop (robot arm) gesture  	if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  	 {  		if (!movingGesture)// If we're not already in the "moving" gesture...  		 {  			if (moving == true)// If the robot arm is moving' stop it.  			 {  				moving = false;  				Console.WriteLine ("Telling robot arm to stop");  				Bus.Publish (BusNode.ROBOT_ACTIVE' false);  			}  			else// If the robot arm is not moving' enable it.  			 {  				moving = true;  				Console.WriteLine ("Telling robot arm to begin tracking");  				Bus.Publish (BusNode.ROBOT_ACTIVE' true);  			}  			movingGesture = true;  			// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  		}  	}  	else// If we're not in the moving gesture...  	 {  		if (movingGesture)  			// ... and we were' record the change' so we can re-enter the gesture later.  			movingGesture = false;  	}  	/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  	index_percent = ((indexFinger - 125) / 55) * 100;  	if (index_percent < 0)  		index_percent = 0;  	else if (index_percent > 100)  		index_percent = 100;  	/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  	// Craig centered (hand straight): 170 (180 degrees)  	// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  	// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  	if (wrist >= 170)  		wrist_percent = (wrist - 170) / 45 * 50 + 50;  	else  		wrist_percent = (wrist - 75) / 95 * 50;  	if (wrist_percent < 0)  		wrist_percent = 0;  	else if (wrist_percent > 100)  		wrist_percent = 100;  	/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  	//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  	//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  	Debug.WriteLine ("Moving gesture? " + movingGesture);  	Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  	Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)   {  	// Note that values are same for both right and left hand gloves.  	int pinky = Convert.ToInt32 (sensors [14]);  	// get flex of pinky's first joint  	int ring = Convert.ToInt32 (sensors [11]);  	// get flex of ring finger's first joint  	int middle = Convert.ToInt32 (sensors [8]);  	// get flex of middle finger's first joint  	indexFinger = Convert.ToInt32 (sensors [5]);  	// get flex of index finger's first joint  	wrist = Convert.ToInt32 (sensors [17]);  	// get flex/extension of wrist  	// Detect "Starting Postion" gesture  	// Currently we do NOT publish this gesture to the bus  	if (pinky >= 120) {  		if (!pinkyGesture) {  			//Console.WriteLine("Moving to starting position");  			pinkyGesture = true;  			// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  		}  	}  	else {  		if (pinkyGesture)  			pinkyGesture = false;  	}  	// Detect start/stop (robot arm) gesture  	if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  	 {  		if (!movingGesture)// If we're not already in the "moving" gesture...  		 {  			if (moving == true)// If the robot arm is moving' stop it.  			 {  				moving = false;  				Console.WriteLine ("Telling robot arm to stop");  				Bus.Publish (BusNode.ROBOT_ACTIVE' false);  			}  			else// If the robot arm is not moving' enable it.  			 {  				moving = true;  				Console.WriteLine ("Telling robot arm to begin tracking");  				Bus.Publish (BusNode.ROBOT_ACTIVE' true);  			}  			movingGesture = true;  			// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  		}  	}  	else// If we're not in the moving gesture...  	 {  		if (movingGesture)  			// ... and we were' record the change' so we can re-enter the gesture later.  			movingGesture = false;  	}  	/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  	index_percent = ((indexFinger - 125) / 55) * 100;  	if (index_percent < 0)  		index_percent = 0;  	else if (index_percent > 100)  		index_percent = 100;  	/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  	// Craig centered (hand straight): 170 (180 degrees)  	// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  	// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  	if (wrist >= 170)  		wrist_percent = (wrist - 170) / 45 * 50 + 50;  	else  		wrist_percent = (wrist - 75) / 95 * 50;  	if (wrist_percent < 0)  		wrist_percent = 0;  	else if (wrist_percent > 100)  		wrist_percent = 100;  	/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  	//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  	//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  	Debug.WriteLine ("Moving gesture? " + movingGesture);  	Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  	Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)   {  	// Note that values are same for both right and left hand gloves.  	int pinky = Convert.ToInt32 (sensors [14]);  	// get flex of pinky's first joint  	int ring = Convert.ToInt32 (sensors [11]);  	// get flex of ring finger's first joint  	int middle = Convert.ToInt32 (sensors [8]);  	// get flex of middle finger's first joint  	indexFinger = Convert.ToInt32 (sensors [5]);  	// get flex of index finger's first joint  	wrist = Convert.ToInt32 (sensors [17]);  	// get flex/extension of wrist  	// Detect "Starting Postion" gesture  	// Currently we do NOT publish this gesture to the bus  	if (pinky >= 120) {  		if (!pinkyGesture) {  			//Console.WriteLine("Moving to starting position");  			pinkyGesture = true;  			// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  		}  	}  	else {  		if (pinkyGesture)  			pinkyGesture = false;  	}  	// Detect start/stop (robot arm) gesture  	if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  	 {  		if (!movingGesture)// If we're not already in the "moving" gesture...  		 {  			if (moving == true)// If the robot arm is moving' stop it.  			 {  				moving = false;  				Console.WriteLine ("Telling robot arm to stop");  				Bus.Publish (BusNode.ROBOT_ACTIVE' false);  			}  			else// If the robot arm is not moving' enable it.  			 {  				moving = true;  				Console.WriteLine ("Telling robot arm to begin tracking");  				Bus.Publish (BusNode.ROBOT_ACTIVE' true);  			}  			movingGesture = true;  			// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  		}  	}  	else// If we're not in the moving gesture...  	 {  		if (movingGesture)  			// ... and we were' record the change' so we can re-enter the gesture later.  			movingGesture = false;  	}  	/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  	index_percent = ((indexFinger - 125) / 55) * 100;  	if (index_percent < 0)  		index_percent = 0;  	else if (index_percent > 100)  		index_percent = 100;  	/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  	// Craig centered (hand straight): 170 (180 degrees)  	// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  	// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  	if (wrist >= 170)  		wrist_percent = (wrist - 170) / 45 * 50 + 50;  	else  		wrist_percent = (wrist - 75) / 95 * 50;  	if (wrist_percent < 0)  		wrist_percent = 0;  	else if (wrist_percent > 100)  		wrist_percent = 100;  	/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  	//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  	//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  	Debug.WriteLine ("Moving gesture? " + movingGesture);  	Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  	Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)   {  	// Note that values are same for both right and left hand gloves.  	int pinky = Convert.ToInt32 (sensors [14]);  	// get flex of pinky's first joint  	int ring = Convert.ToInt32 (sensors [11]);  	// get flex of ring finger's first joint  	int middle = Convert.ToInt32 (sensors [8]);  	// get flex of middle finger's first joint  	indexFinger = Convert.ToInt32 (sensors [5]);  	// get flex of index finger's first joint  	wrist = Convert.ToInt32 (sensors [17]);  	// get flex/extension of wrist  	// Detect "Starting Postion" gesture  	// Currently we do NOT publish this gesture to the bus  	if (pinky >= 120) {  		if (!pinkyGesture) {  			//Console.WriteLine("Moving to starting position");  			pinkyGesture = true;  			// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  		}  	}  	else {  		if (pinkyGesture)  			pinkyGesture = false;  	}  	// Detect start/stop (robot arm) gesture  	if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  	 {  		if (!movingGesture)// If we're not already in the "moving" gesture...  		 {  			if (moving == true)// If the robot arm is moving' stop it.  			 {  				moving = false;  				Console.WriteLine ("Telling robot arm to stop");  				Bus.Publish (BusNode.ROBOT_ACTIVE' false);  			}  			else// If the robot arm is not moving' enable it.  			 {  				moving = true;  				Console.WriteLine ("Telling robot arm to begin tracking");  				Bus.Publish (BusNode.ROBOT_ACTIVE' true);  			}  			movingGesture = true;  			// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  		}  	}  	else// If we're not in the moving gesture...  	 {  		if (movingGesture)  			// ... and we were' record the change' so we can re-enter the gesture later.  			movingGesture = false;  	}  	/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  	index_percent = ((indexFinger - 125) / 55) * 100;  	if (index_percent < 0)  		index_percent = 0;  	else if (index_percent > 100)  		index_percent = 100;  	/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  	// Craig centered (hand straight): 170 (180 degrees)  	// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  	// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  	if (wrist >= 170)  		wrist_percent = (wrist - 170) / 45 * 50 + 50;  	else  		wrist_percent = (wrist - 75) / 95 * 50;  	if (wrist_percent < 0)  		wrist_percent = 0;  	else if (wrist_percent > 100)  		wrist_percent = 100;  	/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  	//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  	//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  	Debug.WriteLine ("Moving gesture? " + movingGesture);  	Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  	Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)   {  	// Note that values are same for both right and left hand gloves.  	int pinky = Convert.ToInt32 (sensors [14]);  	// get flex of pinky's first joint  	int ring = Convert.ToInt32 (sensors [11]);  	// get flex of ring finger's first joint  	int middle = Convert.ToInt32 (sensors [8]);  	// get flex of middle finger's first joint  	indexFinger = Convert.ToInt32 (sensors [5]);  	// get flex of index finger's first joint  	wrist = Convert.ToInt32 (sensors [17]);  	// get flex/extension of wrist  	// Detect "Starting Postion" gesture  	// Currently we do NOT publish this gesture to the bus  	if (pinky >= 120) {  		if (!pinkyGesture) {  			//Console.WriteLine("Moving to starting position");  			pinkyGesture = true;  			// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  		}  	}  	else {  		if (pinkyGesture)  			pinkyGesture = false;  	}  	// Detect start/stop (robot arm) gesture  	if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  	 {  		if (!movingGesture)// If we're not already in the "moving" gesture...  		 {  			if (moving == true)// If the robot arm is moving' stop it.  			 {  				moving = false;  				Console.WriteLine ("Telling robot arm to stop");  				Bus.Publish (BusNode.ROBOT_ACTIVE' false);  			}  			else// If the robot arm is not moving' enable it.  			 {  				moving = true;  				Console.WriteLine ("Telling robot arm to begin tracking");  				Bus.Publish (BusNode.ROBOT_ACTIVE' true);  			}  			movingGesture = true;  			// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  		}  	}  	else// If we're not in the moving gesture...  	 {  		if (movingGesture)  			// ... and we were' record the change' so we can re-enter the gesture later.  			movingGesture = false;  	}  	/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  	index_percent = ((indexFinger - 125) / 55) * 100;  	if (index_percent < 0)  		index_percent = 0;  	else if (index_percent > 100)  		index_percent = 100;  	/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  	// Craig centered (hand straight): 170 (180 degrees)  	// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  	// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  	if (wrist >= 170)  		wrist_percent = (wrist - 170) / 45 * 50 + 50;  	else  		wrist_percent = (wrist - 75) / 95 * 50;  	if (wrist_percent < 0)  		wrist_percent = 0;  	else if (wrist_percent > 100)  		wrist_percent = 100;  	/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  	//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  	//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  	Debug.WriteLine ("Moving gesture? " + movingGesture);  	Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  	Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)   {  	// Note that values are same for both right and left hand gloves.  	int pinky = Convert.ToInt32 (sensors [14]);  	// get flex of pinky's first joint  	int ring = Convert.ToInt32 (sensors [11]);  	// get flex of ring finger's first joint  	int middle = Convert.ToInt32 (sensors [8]);  	// get flex of middle finger's first joint  	indexFinger = Convert.ToInt32 (sensors [5]);  	// get flex of index finger's first joint  	wrist = Convert.ToInt32 (sensors [17]);  	// get flex/extension of wrist  	// Detect "Starting Postion" gesture  	// Currently we do NOT publish this gesture to the bus  	if (pinky >= 120) {  		if (!pinkyGesture) {  			//Console.WriteLine("Moving to starting position");  			pinkyGesture = true;  			// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  		}  	}  	else {  		if (pinkyGesture)  			pinkyGesture = false;  	}  	// Detect start/stop (robot arm) gesture  	if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  	 {  		if (!movingGesture)// If we're not already in the "moving" gesture...  		 {  			if (moving == true)// If the robot arm is moving' stop it.  			 {  				moving = false;  				Console.WriteLine ("Telling robot arm to stop");  				Bus.Publish (BusNode.ROBOT_ACTIVE' false);  			}  			else// If the robot arm is not moving' enable it.  			 {  				moving = true;  				Console.WriteLine ("Telling robot arm to begin tracking");  				Bus.Publish (BusNode.ROBOT_ACTIVE' true);  			}  			movingGesture = true;  			// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  		}  	}  	else// If we're not in the moving gesture...  	 {  		if (movingGesture)  			// ... and we were' record the change' so we can re-enter the gesture later.  			movingGesture = false;  	}  	/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  	index_percent = ((indexFinger - 125) / 55) * 100;  	if (index_percent < 0)  		index_percent = 0;  	else if (index_percent > 100)  		index_percent = 100;  	/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  	// Craig centered (hand straight): 170 (180 degrees)  	// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  	// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  	if (wrist >= 170)  		wrist_percent = (wrist - 170) / 45 * 50 + 50;  	else  		wrist_percent = (wrist - 75) / 95 * 50;  	if (wrist_percent < 0)  		wrist_percent = 0;  	else if (wrist_percent > 100)  		wrist_percent = 100;  	/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  	//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  	//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  	Debug.WriteLine ("Moving gesture? " + movingGesture);  	Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  	Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)   {  	// Note that values are same for both right and left hand gloves.  	int pinky = Convert.ToInt32 (sensors [14]);  	// get flex of pinky's first joint  	int ring = Convert.ToInt32 (sensors [11]);  	// get flex of ring finger's first joint  	int middle = Convert.ToInt32 (sensors [8]);  	// get flex of middle finger's first joint  	indexFinger = Convert.ToInt32 (sensors [5]);  	// get flex of index finger's first joint  	wrist = Convert.ToInt32 (sensors [17]);  	// get flex/extension of wrist  	// Detect "Starting Postion" gesture  	// Currently we do NOT publish this gesture to the bus  	if (pinky >= 120) {  		if (!pinkyGesture) {  			//Console.WriteLine("Moving to starting position");  			pinkyGesture = true;  			// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  		}  	}  	else {  		if (pinkyGesture)  			pinkyGesture = false;  	}  	// Detect start/stop (robot arm) gesture  	if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  	 {  		if (!movingGesture)// If we're not already in the "moving" gesture...  		 {  			if (moving == true)// If the robot arm is moving' stop it.  			 {  				moving = false;  				Console.WriteLine ("Telling robot arm to stop");  				Bus.Publish (BusNode.ROBOT_ACTIVE' false);  			}  			else// If the robot arm is not moving' enable it.  			 {  				moving = true;  				Console.WriteLine ("Telling robot arm to begin tracking");  				Bus.Publish (BusNode.ROBOT_ACTIVE' true);  			}  			movingGesture = true;  			// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  		}  	}  	else// If we're not in the moving gesture...  	 {  		if (movingGesture)  			// ... and we were' record the change' so we can re-enter the gesture later.  			movingGesture = false;  	}  	/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  	index_percent = ((indexFinger - 125) / 55) * 100;  	if (index_percent < 0)  		index_percent = 0;  	else if (index_percent > 100)  		index_percent = 100;  	/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  	// Craig centered (hand straight): 170 (180 degrees)  	// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  	// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  	if (wrist >= 170)  		wrist_percent = (wrist - 170) / 45 * 50 + 50;  	else  		wrist_percent = (wrist - 75) / 95 * 50;  	if (wrist_percent < 0)  		wrist_percent = 0;  	else if (wrist_percent > 100)  		wrist_percent = 100;  	/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  	//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  	//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  	Debug.WriteLine ("Moving gesture? " + movingGesture);  	Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  	Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)   {  	// Note that values are same for both right and left hand gloves.  	int pinky = Convert.ToInt32 (sensors [14]);  	// get flex of pinky's first joint  	int ring = Convert.ToInt32 (sensors [11]);  	// get flex of ring finger's first joint  	int middle = Convert.ToInt32 (sensors [8]);  	// get flex of middle finger's first joint  	indexFinger = Convert.ToInt32 (sensors [5]);  	// get flex of index finger's first joint  	wrist = Convert.ToInt32 (sensors [17]);  	// get flex/extension of wrist  	// Detect "Starting Postion" gesture  	// Currently we do NOT publish this gesture to the bus  	if (pinky >= 120) {  		if (!pinkyGesture) {  			//Console.WriteLine("Moving to starting position");  			pinkyGesture = true;  			// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  		}  	}  	else {  		if (pinkyGesture)  			pinkyGesture = false;  	}  	// Detect start/stop (robot arm) gesture  	if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  	 {  		if (!movingGesture)// If we're not already in the "moving" gesture...  		 {  			if (moving == true)// If the robot arm is moving' stop it.  			 {  				moving = false;  				Console.WriteLine ("Telling robot arm to stop");  				Bus.Publish (BusNode.ROBOT_ACTIVE' false);  			}  			else// If the robot arm is not moving' enable it.  			 {  				moving = true;  				Console.WriteLine ("Telling robot arm to begin tracking");  				Bus.Publish (BusNode.ROBOT_ACTIVE' true);  			}  			movingGesture = true;  			// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  		}  	}  	else// If we're not in the moving gesture...  	 {  		if (movingGesture)  			// ... and we were' record the change' so we can re-enter the gesture later.  			movingGesture = false;  	}  	/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  	index_percent = ((indexFinger - 125) / 55) * 100;  	if (index_percent < 0)  		index_percent = 0;  	else if (index_percent > 100)  		index_percent = 100;  	/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  	// Craig centered (hand straight): 170 (180 degrees)  	// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  	// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  	if (wrist >= 170)  		wrist_percent = (wrist - 170) / 45 * 50 + 50;  	else  		wrist_percent = (wrist - 75) / 95 * 50;  	if (wrist_percent < 0)  		wrist_percent = 0;  	else if (wrist_percent > 100)  		wrist_percent = 100;  	/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  	//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  	//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  	Debug.WriteLine ("Moving gesture? " + movingGesture);  	Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  	Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)   {  	// Note that values are same for both right and left hand gloves.  	int pinky = Convert.ToInt32 (sensors [14]);  	// get flex of pinky's first joint  	int ring = Convert.ToInt32 (sensors [11]);  	// get flex of ring finger's first joint  	int middle = Convert.ToInt32 (sensors [8]);  	// get flex of middle finger's first joint  	indexFinger = Convert.ToInt32 (sensors [5]);  	// get flex of index finger's first joint  	wrist = Convert.ToInt32 (sensors [17]);  	// get flex/extension of wrist  	// Detect "Starting Postion" gesture  	// Currently we do NOT publish this gesture to the bus  	if (pinky >= 120) {  		if (!pinkyGesture) {  			//Console.WriteLine("Moving to starting position");  			pinkyGesture = true;  			// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  		}  	}  	else {  		if (pinkyGesture)  			pinkyGesture = false;  	}  	// Detect start/stop (robot arm) gesture  	if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  	 {  		if (!movingGesture)// If we're not already in the "moving" gesture...  		 {  			if (moving == true)// If the robot arm is moving' stop it.  			 {  				moving = false;  				Console.WriteLine ("Telling robot arm to stop");  				Bus.Publish (BusNode.ROBOT_ACTIVE' false);  			}  			else// If the robot arm is not moving' enable it.  			 {  				moving = true;  				Console.WriteLine ("Telling robot arm to begin tracking");  				Bus.Publish (BusNode.ROBOT_ACTIVE' true);  			}  			movingGesture = true;  			// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  		}  	}  	else// If we're not in the moving gesture...  	 {  		if (movingGesture)  			// ... and we were' record the change' so we can re-enter the gesture later.  			movingGesture = false;  	}  	/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  	index_percent = ((indexFinger - 125) / 55) * 100;  	if (index_percent < 0)  		index_percent = 0;  	else if (index_percent > 100)  		index_percent = 100;  	/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  	// Craig centered (hand straight): 170 (180 degrees)  	// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  	// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  	if (wrist >= 170)  		wrist_percent = (wrist - 170) / 45 * 50 + 50;  	else  		wrist_percent = (wrist - 75) / 95 * 50;  	if (wrist_percent < 0)  		wrist_percent = 0;  	else if (wrist_percent > 100)  		wrist_percent = 100;  	/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  	//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  	//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  	Debug.WriteLine ("Moving gesture? " + movingGesture);  	Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  	Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)   {  	// Note that values are same for both right and left hand gloves.  	int pinky = Convert.ToInt32 (sensors [14]);  	// get flex of pinky's first joint  	int ring = Convert.ToInt32 (sensors [11]);  	// get flex of ring finger's first joint  	int middle = Convert.ToInt32 (sensors [8]);  	// get flex of middle finger's first joint  	indexFinger = Convert.ToInt32 (sensors [5]);  	// get flex of index finger's first joint  	wrist = Convert.ToInt32 (sensors [17]);  	// get flex/extension of wrist  	// Detect "Starting Postion" gesture  	// Currently we do NOT publish this gesture to the bus  	if (pinky >= 120) {  		if (!pinkyGesture) {  			//Console.WriteLine("Moving to starting position");  			pinkyGesture = true;  			// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  		}  	}  	else {  		if (pinkyGesture)  			pinkyGesture = false;  	}  	// Detect start/stop (robot arm) gesture  	if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  	 {  		if (!movingGesture)// If we're not already in the "moving" gesture...  		 {  			if (moving == true)// If the robot arm is moving' stop it.  			 {  				moving = false;  				Console.WriteLine ("Telling robot arm to stop");  				Bus.Publish (BusNode.ROBOT_ACTIVE' false);  			}  			else// If the robot arm is not moving' enable it.  			 {  				moving = true;  				Console.WriteLine ("Telling robot arm to begin tracking");  				Bus.Publish (BusNode.ROBOT_ACTIVE' true);  			}  			movingGesture = true;  			// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  		}  	}  	else// If we're not in the moving gesture...  	 {  		if (movingGesture)  			// ... and we were' record the change' so we can re-enter the gesture later.  			movingGesture = false;  	}  	/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  	index_percent = ((indexFinger - 125) / 55) * 100;  	if (index_percent < 0)  		index_percent = 0;  	else if (index_percent > 100)  		index_percent = 100;  	/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  	// Craig centered (hand straight): 170 (180 degrees)  	// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  	// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  	if (wrist >= 170)  		wrist_percent = (wrist - 170) / 45 * 50 + 50;  	else  		wrist_percent = (wrist - 75) / 95 * 50;  	if (wrist_percent < 0)  		wrist_percent = 0;  	else if (wrist_percent > 100)  		wrist_percent = 100;  	/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  	//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  	//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  	Debug.WriteLine ("Moving gesture? " + movingGesture);  	Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  	Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)   {  	// Note that values are same for both right and left hand gloves.  	int pinky = Convert.ToInt32 (sensors [14]);  	// get flex of pinky's first joint  	int ring = Convert.ToInt32 (sensors [11]);  	// get flex of ring finger's first joint  	int middle = Convert.ToInt32 (sensors [8]);  	// get flex of middle finger's first joint  	indexFinger = Convert.ToInt32 (sensors [5]);  	// get flex of index finger's first joint  	wrist = Convert.ToInt32 (sensors [17]);  	// get flex/extension of wrist  	// Detect "Starting Postion" gesture  	// Currently we do NOT publish this gesture to the bus  	if (pinky >= 120) {  		if (!pinkyGesture) {  			//Console.WriteLine("Moving to starting position");  			pinkyGesture = true;  			// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  		}  	}  	else {  		if (pinkyGesture)  			pinkyGesture = false;  	}  	// Detect start/stop (robot arm) gesture  	if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  	 {  		if (!movingGesture)// If we're not already in the "moving" gesture...  		 {  			if (moving == true)// If the robot arm is moving' stop it.  			 {  				moving = false;  				Console.WriteLine ("Telling robot arm to stop");  				Bus.Publish (BusNode.ROBOT_ACTIVE' false);  			}  			else// If the robot arm is not moving' enable it.  			 {  				moving = true;  				Console.WriteLine ("Telling robot arm to begin tracking");  				Bus.Publish (BusNode.ROBOT_ACTIVE' true);  			}  			movingGesture = true;  			// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  		}  	}  	else// If we're not in the moving gesture...  	 {  		if (movingGesture)  			// ... and we were' record the change' so we can re-enter the gesture later.  			movingGesture = false;  	}  	/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  	index_percent = ((indexFinger - 125) / 55) * 100;  	if (index_percent < 0)  		index_percent = 0;  	else if (index_percent > 100)  		index_percent = 100;  	/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  	// Craig centered (hand straight): 170 (180 degrees)  	// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  	// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  	if (wrist >= 170)  		wrist_percent = (wrist - 170) / 45 * 50 + 50;  	else  		wrist_percent = (wrist - 75) / 95 * 50;  	if (wrist_percent < 0)  		wrist_percent = 0;  	else if (wrist_percent > 100)  		wrist_percent = 100;  	/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  	//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  	//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  	Debug.WriteLine ("Moving gesture? " + movingGesture);  	Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  	Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)   {  	// Note that values are same for both right and left hand gloves.  	int pinky = Convert.ToInt32 (sensors [14]);  	// get flex of pinky's first joint  	int ring = Convert.ToInt32 (sensors [11]);  	// get flex of ring finger's first joint  	int middle = Convert.ToInt32 (sensors [8]);  	// get flex of middle finger's first joint  	indexFinger = Convert.ToInt32 (sensors [5]);  	// get flex of index finger's first joint  	wrist = Convert.ToInt32 (sensors [17]);  	// get flex/extension of wrist  	// Detect "Starting Postion" gesture  	// Currently we do NOT publish this gesture to the bus  	if (pinky >= 120) {  		if (!pinkyGesture) {  			//Console.WriteLine("Moving to starting position");  			pinkyGesture = true;  			// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  		}  	}  	else {  		if (pinkyGesture)  			pinkyGesture = false;  	}  	// Detect start/stop (robot arm) gesture  	if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  	 {  		if (!movingGesture)// If we're not already in the "moving" gesture...  		 {  			if (moving == true)// If the robot arm is moving' stop it.  			 {  				moving = false;  				Console.WriteLine ("Telling robot arm to stop");  				Bus.Publish (BusNode.ROBOT_ACTIVE' false);  			}  			else// If the robot arm is not moving' enable it.  			 {  				moving = true;  				Console.WriteLine ("Telling robot arm to begin tracking");  				Bus.Publish (BusNode.ROBOT_ACTIVE' true);  			}  			movingGesture = true;  			// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  		}  	}  	else// If we're not in the moving gesture...  	 {  		if (movingGesture)  			// ... and we were' record the change' so we can re-enter the gesture later.  			movingGesture = false;  	}  	/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  	index_percent = ((indexFinger - 125) / 55) * 100;  	if (index_percent < 0)  		index_percent = 0;  	else if (index_percent > 100)  		index_percent = 100;  	/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  	// Craig centered (hand straight): 170 (180 degrees)  	// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  	// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  	if (wrist >= 170)  		wrist_percent = (wrist - 170) / 45 * 50 + 50;  	else  		wrist_percent = (wrist - 75) / 95 * 50;  	if (wrist_percent < 0)  		wrist_percent = 0;  	else if (wrist_percent > 100)  		wrist_percent = 100;  	/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  	//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  	//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  	Debug.WriteLine ("Moving gesture? " + movingGesture);  	Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  	Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)   {  	// Note that values are same for both right and left hand gloves.  	int pinky = Convert.ToInt32 (sensors [14]);  	// get flex of pinky's first joint  	int ring = Convert.ToInt32 (sensors [11]);  	// get flex of ring finger's first joint  	int middle = Convert.ToInt32 (sensors [8]);  	// get flex of middle finger's first joint  	indexFinger = Convert.ToInt32 (sensors [5]);  	// get flex of index finger's first joint  	wrist = Convert.ToInt32 (sensors [17]);  	// get flex/extension of wrist  	// Detect "Starting Postion" gesture  	// Currently we do NOT publish this gesture to the bus  	if (pinky >= 120) {  		if (!pinkyGesture) {  			//Console.WriteLine("Moving to starting position");  			pinkyGesture = true;  			// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  		}  	}  	else {  		if (pinkyGesture)  			pinkyGesture = false;  	}  	// Detect start/stop (robot arm) gesture  	if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  	 {  		if (!movingGesture)// If we're not already in the "moving" gesture...  		 {  			if (moving == true)// If the robot arm is moving' stop it.  			 {  				moving = false;  				Console.WriteLine ("Telling robot arm to stop");  				Bus.Publish (BusNode.ROBOT_ACTIVE' false);  			}  			else// If the robot arm is not moving' enable it.  			 {  				moving = true;  				Console.WriteLine ("Telling robot arm to begin tracking");  				Bus.Publish (BusNode.ROBOT_ACTIVE' true);  			}  			movingGesture = true;  			// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  		}  	}  	else// If we're not in the moving gesture...  	 {  		if (movingGesture)  			// ... and we were' record the change' so we can re-enter the gesture later.  			movingGesture = false;  	}  	/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  	index_percent = ((indexFinger - 125) / 55) * 100;  	if (index_percent < 0)  		index_percent = 0;  	else if (index_percent > 100)  		index_percent = 100;  	/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  	// Craig centered (hand straight): 170 (180 degrees)  	// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  	// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  	if (wrist >= 170)  		wrist_percent = (wrist - 170) / 45 * 50 + 50;  	else  		wrist_percent = (wrist - 75) / 95 * 50;  	if (wrist_percent < 0)  		wrist_percent = 0;  	else if (wrist_percent > 100)  		wrist_percent = 100;  	/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  	//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  	//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  	Debug.WriteLine ("Moving gesture? " + movingGesture);  	Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  	Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)   {  	// Note that values are same for both right and left hand gloves.  	int pinky = Convert.ToInt32 (sensors [14]);  	// get flex of pinky's first joint  	int ring = Convert.ToInt32 (sensors [11]);  	// get flex of ring finger's first joint  	int middle = Convert.ToInt32 (sensors [8]);  	// get flex of middle finger's first joint  	indexFinger = Convert.ToInt32 (sensors [5]);  	// get flex of index finger's first joint  	wrist = Convert.ToInt32 (sensors [17]);  	// get flex/extension of wrist  	// Detect "Starting Postion" gesture  	// Currently we do NOT publish this gesture to the bus  	if (pinky >= 120) {  		if (!pinkyGesture) {  			//Console.WriteLine("Moving to starting position");  			pinkyGesture = true;  			// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  		}  	}  	else {  		if (pinkyGesture)  			pinkyGesture = false;  	}  	// Detect start/stop (robot arm) gesture  	if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  	 {  		if (!movingGesture)// If we're not already in the "moving" gesture...  		 {  			if (moving == true)// If the robot arm is moving' stop it.  			 {  				moving = false;  				Console.WriteLine ("Telling robot arm to stop");  				Bus.Publish (BusNode.ROBOT_ACTIVE' false);  			}  			else// If the robot arm is not moving' enable it.  			 {  				moving = true;  				Console.WriteLine ("Telling robot arm to begin tracking");  				Bus.Publish (BusNode.ROBOT_ACTIVE' true);  			}  			movingGesture = true;  			// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  		}  	}  	else// If we're not in the moving gesture...  	 {  		if (movingGesture)  			// ... and we were' record the change' so we can re-enter the gesture later.  			movingGesture = false;  	}  	/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  	index_percent = ((indexFinger - 125) / 55) * 100;  	if (index_percent < 0)  		index_percent = 0;  	else if (index_percent > 100)  		index_percent = 100;  	/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  	// Craig centered (hand straight): 170 (180 degrees)  	// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  	// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  	if (wrist >= 170)  		wrist_percent = (wrist - 170) / 45 * 50 + 50;  	else  		wrist_percent = (wrist - 75) / 95 * 50;  	if (wrist_percent < 0)  		wrist_percent = 0;  	else if (wrist_percent > 100)  		wrist_percent = 100;  	/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  	//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  	//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  	Debug.WriteLine ("Moving gesture? " + movingGesture);  	Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  	Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)   {  	// Note that values are same for both right and left hand gloves.  	int pinky = Convert.ToInt32 (sensors [14]);  	// get flex of pinky's first joint  	int ring = Convert.ToInt32 (sensors [11]);  	// get flex of ring finger's first joint  	int middle = Convert.ToInt32 (sensors [8]);  	// get flex of middle finger's first joint  	indexFinger = Convert.ToInt32 (sensors [5]);  	// get flex of index finger's first joint  	wrist = Convert.ToInt32 (sensors [17]);  	// get flex/extension of wrist  	// Detect "Starting Postion" gesture  	// Currently we do NOT publish this gesture to the bus  	if (pinky >= 120) {  		if (!pinkyGesture) {  			//Console.WriteLine("Moving to starting position");  			pinkyGesture = true;  			// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  		}  	}  	else {  		if (pinkyGesture)  			pinkyGesture = false;  	}  	// Detect start/stop (robot arm) gesture  	if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  	 {  		if (!movingGesture)// If we're not already in the "moving" gesture...  		 {  			if (moving == true)// If the robot arm is moving' stop it.  			 {  				moving = false;  				Console.WriteLine ("Telling robot arm to stop");  				Bus.Publish (BusNode.ROBOT_ACTIVE' false);  			}  			else// If the robot arm is not moving' enable it.  			 {  				moving = true;  				Console.WriteLine ("Telling robot arm to begin tracking");  				Bus.Publish (BusNode.ROBOT_ACTIVE' true);  			}  			movingGesture = true;  			// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  		}  	}  	else// If we're not in the moving gesture...  	 {  		if (movingGesture)  			// ... and we were' record the change' so we can re-enter the gesture later.  			movingGesture = false;  	}  	/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  	index_percent = ((indexFinger - 125) / 55) * 100;  	if (index_percent < 0)  		index_percent = 0;  	else if (index_percent > 100)  		index_percent = 100;  	/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  	// Craig centered (hand straight): 170 (180 degrees)  	// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  	// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  	if (wrist >= 170)  		wrist_percent = (wrist - 170) / 45 * 50 + 50;  	else  		wrist_percent = (wrist - 75) / 95 * 50;  	if (wrist_percent < 0)  		wrist_percent = 0;  	else if (wrist_percent > 100)  		wrist_percent = 100;  	/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  	//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  	//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  	Debug.WriteLine ("Moving gesture? " + movingGesture);  	Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  	Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)   {  	// Note that values are same for both right and left hand gloves.  	int pinky = Convert.ToInt32 (sensors [14]);  	// get flex of pinky's first joint  	int ring = Convert.ToInt32 (sensors [11]);  	// get flex of ring finger's first joint  	int middle = Convert.ToInt32 (sensors [8]);  	// get flex of middle finger's first joint  	indexFinger = Convert.ToInt32 (sensors [5]);  	// get flex of index finger's first joint  	wrist = Convert.ToInt32 (sensors [17]);  	// get flex/extension of wrist  	// Detect "Starting Postion" gesture  	// Currently we do NOT publish this gesture to the bus  	if (pinky >= 120) {  		if (!pinkyGesture) {  			//Console.WriteLine("Moving to starting position");  			pinkyGesture = true;  			// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  		}  	}  	else {  		if (pinkyGesture)  			pinkyGesture = false;  	}  	// Detect start/stop (robot arm) gesture  	if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  	 {  		if (!movingGesture)// If we're not already in the "moving" gesture...  		 {  			if (moving == true)// If the robot arm is moving' stop it.  			 {  				moving = false;  				Console.WriteLine ("Telling robot arm to stop");  				Bus.Publish (BusNode.ROBOT_ACTIVE' false);  			}  			else// If the robot arm is not moving' enable it.  			 {  				moving = true;  				Console.WriteLine ("Telling robot arm to begin tracking");  				Bus.Publish (BusNode.ROBOT_ACTIVE' true);  			}  			movingGesture = true;  			// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  		}  	}  	else// If we're not in the moving gesture...  	 {  		if (movingGesture)  			// ... and we were' record the change' so we can re-enter the gesture later.  			movingGesture = false;  	}  	/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  	index_percent = ((indexFinger - 125) / 55) * 100;  	if (index_percent < 0)  		index_percent = 0;  	else if (index_percent > 100)  		index_percent = 100;  	/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  	// Craig centered (hand straight): 170 (180 degrees)  	// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  	// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  	if (wrist >= 170)  		wrist_percent = (wrist - 170) / 45 * 50 + 50;  	else  		wrist_percent = (wrist - 75) / 95 * 50;  	if (wrist_percent < 0)  		wrist_percent = 0;  	else if (wrist_percent > 100)  		wrist_percent = 100;  	/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  	//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  	//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  	Debug.WriteLine ("Moving gesture? " + movingGesture);  	Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  	Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)   {  	// Note that values are same for both right and left hand gloves.  	int pinky = Convert.ToInt32 (sensors [14]);  	// get flex of pinky's first joint  	int ring = Convert.ToInt32 (sensors [11]);  	// get flex of ring finger's first joint  	int middle = Convert.ToInt32 (sensors [8]);  	// get flex of middle finger's first joint  	indexFinger = Convert.ToInt32 (sensors [5]);  	// get flex of index finger's first joint  	wrist = Convert.ToInt32 (sensors [17]);  	// get flex/extension of wrist  	// Detect "Starting Postion" gesture  	// Currently we do NOT publish this gesture to the bus  	if (pinky >= 120) {  		if (!pinkyGesture) {  			//Console.WriteLine("Moving to starting position");  			pinkyGesture = true;  			// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  		}  	}  	else {  		if (pinkyGesture)  			pinkyGesture = false;  	}  	// Detect start/stop (robot arm) gesture  	if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  	 {  		if (!movingGesture)// If we're not already in the "moving" gesture...  		 {  			if (moving == true)// If the robot arm is moving' stop it.  			 {  				moving = false;  				Console.WriteLine ("Telling robot arm to stop");  				Bus.Publish (BusNode.ROBOT_ACTIVE' false);  			}  			else// If the robot arm is not moving' enable it.  			 {  				moving = true;  				Console.WriteLine ("Telling robot arm to begin tracking");  				Bus.Publish (BusNode.ROBOT_ACTIVE' true);  			}  			movingGesture = true;  			// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  		}  	}  	else// If we're not in the moving gesture...  	 {  		if (movingGesture)  			// ... and we were' record the change' so we can re-enter the gesture later.  			movingGesture = false;  	}  	/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  	index_percent = ((indexFinger - 125) / 55) * 100;  	if (index_percent < 0)  		index_percent = 0;  	else if (index_percent > 100)  		index_percent = 100;  	/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  	// Craig centered (hand straight): 170 (180 degrees)  	// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  	// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  	if (wrist >= 170)  		wrist_percent = (wrist - 170) / 45 * 50 + 50;  	else  		wrist_percent = (wrist - 75) / 95 * 50;  	if (wrist_percent < 0)  		wrist_percent = 0;  	else if (wrist_percent > 100)  		wrist_percent = 100;  	/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  	//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  	//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  	Debug.WriteLine ("Moving gesture? " + movingGesture);  	Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  	Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)   {  	// Note that values are same for both right and left hand gloves.  	int pinky = Convert.ToInt32 (sensors [14]);  	// get flex of pinky's first joint  	int ring = Convert.ToInt32 (sensors [11]);  	// get flex of ring finger's first joint  	int middle = Convert.ToInt32 (sensors [8]);  	// get flex of middle finger's first joint  	indexFinger = Convert.ToInt32 (sensors [5]);  	// get flex of index finger's first joint  	wrist = Convert.ToInt32 (sensors [17]);  	// get flex/extension of wrist  	// Detect "Starting Postion" gesture  	// Currently we do NOT publish this gesture to the bus  	if (pinky >= 120) {  		if (!pinkyGesture) {  			//Console.WriteLine("Moving to starting position");  			pinkyGesture = true;  			// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  		}  	}  	else {  		if (pinkyGesture)  			pinkyGesture = false;  	}  	// Detect start/stop (robot arm) gesture  	if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  	 {  		if (!movingGesture)// If we're not already in the "moving" gesture...  		 {  			if (moving == true)// If the robot arm is moving' stop it.  			 {  				moving = false;  				Console.WriteLine ("Telling robot arm to stop");  				Bus.Publish (BusNode.ROBOT_ACTIVE' false);  			}  			else// If the robot arm is not moving' enable it.  			 {  				moving = true;  				Console.WriteLine ("Telling robot arm to begin tracking");  				Bus.Publish (BusNode.ROBOT_ACTIVE' true);  			}  			movingGesture = true;  			// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  		}  	}  	else// If we're not in the moving gesture...  	 {  		if (movingGesture)  			// ... and we were' record the change' so we can re-enter the gesture later.  			movingGesture = false;  	}  	/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  	index_percent = ((indexFinger - 125) / 55) * 100;  	if (index_percent < 0)  		index_percent = 0;  	else if (index_percent > 100)  		index_percent = 100;  	/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  	// Craig centered (hand straight): 170 (180 degrees)  	// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  	// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  	if (wrist >= 170)  		wrist_percent = (wrist - 170) / 45 * 50 + 50;  	else  		wrist_percent = (wrist - 75) / 95 * 50;  	if (wrist_percent < 0)  		wrist_percent = 0;  	else if (wrist_percent > 100)  		wrist_percent = 100;  	/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  	//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  	//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  	Debug.WriteLine ("Moving gesture? " + movingGesture);  	Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  	Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)   {  	// Note that values are same for both right and left hand gloves.  	int pinky = Convert.ToInt32 (sensors [14]);  	// get flex of pinky's first joint  	int ring = Convert.ToInt32 (sensors [11]);  	// get flex of ring finger's first joint  	int middle = Convert.ToInt32 (sensors [8]);  	// get flex of middle finger's first joint  	indexFinger = Convert.ToInt32 (sensors [5]);  	// get flex of index finger's first joint  	wrist = Convert.ToInt32 (sensors [17]);  	// get flex/extension of wrist  	// Detect "Starting Postion" gesture  	// Currently we do NOT publish this gesture to the bus  	if (pinky >= 120) {  		if (!pinkyGesture) {  			//Console.WriteLine("Moving to starting position");  			pinkyGesture = true;  			// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  		}  	}  	else {  		if (pinkyGesture)  			pinkyGesture = false;  	}  	// Detect start/stop (robot arm) gesture  	if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  	 {  		if (!movingGesture)// If we're not already in the "moving" gesture...  		 {  			if (moving == true)// If the robot arm is moving' stop it.  			 {  				moving = false;  				Console.WriteLine ("Telling robot arm to stop");  				Bus.Publish (BusNode.ROBOT_ACTIVE' false);  			}  			else// If the robot arm is not moving' enable it.  			 {  				moving = true;  				Console.WriteLine ("Telling robot arm to begin tracking");  				Bus.Publish (BusNode.ROBOT_ACTIVE' true);  			}  			movingGesture = true;  			// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  		}  	}  	else// If we're not in the moving gesture...  	 {  		if (movingGesture)  			// ... and we were' record the change' so we can re-enter the gesture later.  			movingGesture = false;  	}  	/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  	index_percent = ((indexFinger - 125) / 55) * 100;  	if (index_percent < 0)  		index_percent = 0;  	else if (index_percent > 100)  		index_percent = 100;  	/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  	// Craig centered (hand straight): 170 (180 degrees)  	// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  	// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  	if (wrist >= 170)  		wrist_percent = (wrist - 170) / 45 * 50 + 50;  	else  		wrist_percent = (wrist - 75) / 95 * 50;  	if (wrist_percent < 0)  		wrist_percent = 0;  	else if (wrist_percent > 100)  		wrist_percent = 100;  	/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  	//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  	//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  	Debug.WriteLine ("Moving gesture? " + movingGesture);  	Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  	Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)   {  	// Note that values are same for both right and left hand gloves.  	int pinky = Convert.ToInt32 (sensors [14]);  	// get flex of pinky's first joint  	int ring = Convert.ToInt32 (sensors [11]);  	// get flex of ring finger's first joint  	int middle = Convert.ToInt32 (sensors [8]);  	// get flex of middle finger's first joint  	indexFinger = Convert.ToInt32 (sensors [5]);  	// get flex of index finger's first joint  	wrist = Convert.ToInt32 (sensors [17]);  	// get flex/extension of wrist  	// Detect "Starting Postion" gesture  	// Currently we do NOT publish this gesture to the bus  	if (pinky >= 120) {  		if (!pinkyGesture) {  			//Console.WriteLine("Moving to starting position");  			pinkyGesture = true;  			// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  		}  	}  	else {  		if (pinkyGesture)  			pinkyGesture = false;  	}  	// Detect start/stop (robot arm) gesture  	if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  	 {  		if (!movingGesture)// If we're not already in the "moving" gesture...  		 {  			if (moving == true)// If the robot arm is moving' stop it.  			 {  				moving = false;  				Console.WriteLine ("Telling robot arm to stop");  				Bus.Publish (BusNode.ROBOT_ACTIVE' false);  			}  			else// If the robot arm is not moving' enable it.  			 {  				moving = true;  				Console.WriteLine ("Telling robot arm to begin tracking");  				Bus.Publish (BusNode.ROBOT_ACTIVE' true);  			}  			movingGesture = true;  			// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  		}  	}  	else// If we're not in the moving gesture...  	 {  		if (movingGesture)  			// ... and we were' record the change' so we can re-enter the gesture later.  			movingGesture = false;  	}  	/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  	index_percent = ((indexFinger - 125) / 55) * 100;  	if (index_percent < 0)  		index_percent = 0;  	else if (index_percent > 100)  		index_percent = 100;  	/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  	// Craig centered (hand straight): 170 (180 degrees)  	// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  	// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  	if (wrist >= 170)  		wrist_percent = (wrist - 170) / 45 * 50 + 50;  	else  		wrist_percent = (wrist - 75) / 95 * 50;  	if (wrist_percent < 0)  		wrist_percent = 0;  	else if (wrist_percent > 100)  		wrist_percent = 100;  	/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  	//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  	//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  	Debug.WriteLine ("Moving gesture? " + movingGesture);  	Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  	Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)   {  	// Note that values are same for both right and left hand gloves.  	int pinky = Convert.ToInt32 (sensors [14]);  	// get flex of pinky's first joint  	int ring = Convert.ToInt32 (sensors [11]);  	// get flex of ring finger's first joint  	int middle = Convert.ToInt32 (sensors [8]);  	// get flex of middle finger's first joint  	indexFinger = Convert.ToInt32 (sensors [5]);  	// get flex of index finger's first joint  	wrist = Convert.ToInt32 (sensors [17]);  	// get flex/extension of wrist  	// Detect "Starting Postion" gesture  	// Currently we do NOT publish this gesture to the bus  	if (pinky >= 120) {  		if (!pinkyGesture) {  			//Console.WriteLine("Moving to starting position");  			pinkyGesture = true;  			// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  		}  	}  	else {  		if (pinkyGesture)  			pinkyGesture = false;  	}  	// Detect start/stop (robot arm) gesture  	if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  	 {  		if (!movingGesture)// If we're not already in the "moving" gesture...  		 {  			if (moving == true)// If the robot arm is moving' stop it.  			 {  				moving = false;  				Console.WriteLine ("Telling robot arm to stop");  				Bus.Publish (BusNode.ROBOT_ACTIVE' false);  			}  			else// If the robot arm is not moving' enable it.  			 {  				moving = true;  				Console.WriteLine ("Telling robot arm to begin tracking");  				Bus.Publish (BusNode.ROBOT_ACTIVE' true);  			}  			movingGesture = true;  			// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  		}  	}  	else// If we're not in the moving gesture...  	 {  		if (movingGesture)  			// ... and we were' record the change' so we can re-enter the gesture later.  			movingGesture = false;  	}  	/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  	index_percent = ((indexFinger - 125) / 55) * 100;  	if (index_percent < 0)  		index_percent = 0;  	else if (index_percent > 100)  		index_percent = 100;  	/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  	// Craig centered (hand straight): 170 (180 degrees)  	// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  	// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  	if (wrist >= 170)  		wrist_percent = (wrist - 170) / 45 * 50 + 50;  	else  		wrist_percent = (wrist - 75) / 95 * 50;  	if (wrist_percent < 0)  		wrist_percent = 0;  	else if (wrist_percent > 100)  		wrist_percent = 100;  	/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  	//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  	//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  	Debug.WriteLine ("Moving gesture? " + movingGesture);  	Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  	Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)   {  	// Note that values are same for both right and left hand gloves.  	int pinky = Convert.ToInt32 (sensors [14]);  	// get flex of pinky's first joint  	int ring = Convert.ToInt32 (sensors [11]);  	// get flex of ring finger's first joint  	int middle = Convert.ToInt32 (sensors [8]);  	// get flex of middle finger's first joint  	indexFinger = Convert.ToInt32 (sensors [5]);  	// get flex of index finger's first joint  	wrist = Convert.ToInt32 (sensors [17]);  	// get flex/extension of wrist  	// Detect "Starting Postion" gesture  	// Currently we do NOT publish this gesture to the bus  	if (pinky >= 120) {  		if (!pinkyGesture) {  			//Console.WriteLine("Moving to starting position");  			pinkyGesture = true;  			// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  		}  	}  	else {  		if (pinkyGesture)  			pinkyGesture = false;  	}  	// Detect start/stop (robot arm) gesture  	if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  	 {  		if (!movingGesture)// If we're not already in the "moving" gesture...  		 {  			if (moving == true)// If the robot arm is moving' stop it.  			 {  				moving = false;  				Console.WriteLine ("Telling robot arm to stop");  				Bus.Publish (BusNode.ROBOT_ACTIVE' false);  			}  			else// If the robot arm is not moving' enable it.  			 {  				moving = true;  				Console.WriteLine ("Telling robot arm to begin tracking");  				Bus.Publish (BusNode.ROBOT_ACTIVE' true);  			}  			movingGesture = true;  			// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  		}  	}  	else// If we're not in the moving gesture...  	 {  		if (movingGesture)  			// ... and we were' record the change' so we can re-enter the gesture later.  			movingGesture = false;  	}  	/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  	index_percent = ((indexFinger - 125) / 55) * 100;  	if (index_percent < 0)  		index_percent = 0;  	else if (index_percent > 100)  		index_percent = 100;  	/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  	// Craig centered (hand straight): 170 (180 degrees)  	// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  	// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  	if (wrist >= 170)  		wrist_percent = (wrist - 170) / 45 * 50 + 50;  	else  		wrist_percent = (wrist - 75) / 95 * 50;  	if (wrist_percent < 0)  		wrist_percent = 0;  	else if (wrist_percent > 100)  		wrist_percent = 100;  	/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  	//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  	//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  	Debug.WriteLine ("Moving gesture? " + movingGesture);  	Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  	Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)   {  	// Note that values are same for both right and left hand gloves.  	int pinky = Convert.ToInt32 (sensors [14]);  	// get flex of pinky's first joint  	int ring = Convert.ToInt32 (sensors [11]);  	// get flex of ring finger's first joint  	int middle = Convert.ToInt32 (sensors [8]);  	// get flex of middle finger's first joint  	indexFinger = Convert.ToInt32 (sensors [5]);  	// get flex of index finger's first joint  	wrist = Convert.ToInt32 (sensors [17]);  	// get flex/extension of wrist  	// Detect "Starting Postion" gesture  	// Currently we do NOT publish this gesture to the bus  	if (pinky >= 120) {  		if (!pinkyGesture) {  			//Console.WriteLine("Moving to starting position");  			pinkyGesture = true;  			// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  		}  	}  	else {  		if (pinkyGesture)  			pinkyGesture = false;  	}  	// Detect start/stop (robot arm) gesture  	if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  	 {  		if (!movingGesture)// If we're not already in the "moving" gesture...  		 {  			if (moving == true)// If the robot arm is moving' stop it.  			 {  				moving = false;  				Console.WriteLine ("Telling robot arm to stop");  				Bus.Publish (BusNode.ROBOT_ACTIVE' false);  			}  			else// If the robot arm is not moving' enable it.  			 {  				moving = true;  				Console.WriteLine ("Telling robot arm to begin tracking");  				Bus.Publish (BusNode.ROBOT_ACTIVE' true);  			}  			movingGesture = true;  			// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  		}  	}  	else// If we're not in the moving gesture...  	 {  		if (movingGesture)  			// ... and we were' record the change' so we can re-enter the gesture later.  			movingGesture = false;  	}  	/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  	index_percent = ((indexFinger - 125) / 55) * 100;  	if (index_percent < 0)  		index_percent = 0;  	else if (index_percent > 100)  		index_percent = 100;  	/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  	// Craig centered (hand straight): 170 (180 degrees)  	// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  	// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  	if (wrist >= 170)  		wrist_percent = (wrist - 170) / 45 * 50 + 50;  	else  		wrist_percent = (wrist - 75) / 95 * 50;  	if (wrist_percent < 0)  		wrist_percent = 0;  	else if (wrist_percent > 100)  		wrist_percent = 100;  	/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  	//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  	//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  	Debug.WriteLine ("Moving gesture? " + movingGesture);  	Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  	Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)   {  	// Note that values are same for both right and left hand gloves.  	int pinky = Convert.ToInt32 (sensors [14]);  	// get flex of pinky's first joint  	int ring = Convert.ToInt32 (sensors [11]);  	// get flex of ring finger's first joint  	int middle = Convert.ToInt32 (sensors [8]);  	// get flex of middle finger's first joint  	indexFinger = Convert.ToInt32 (sensors [5]);  	// get flex of index finger's first joint  	wrist = Convert.ToInt32 (sensors [17]);  	// get flex/extension of wrist  	// Detect "Starting Postion" gesture  	// Currently we do NOT publish this gesture to the bus  	if (pinky >= 120) {  		if (!pinkyGesture) {  			//Console.WriteLine("Moving to starting position");  			pinkyGesture = true;  			// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  		}  	}  	else {  		if (pinkyGesture)  			pinkyGesture = false;  	}  	// Detect start/stop (robot arm) gesture  	if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  	 {  		if (!movingGesture)// If we're not already in the "moving" gesture...  		 {  			if (moving == true)// If the robot arm is moving' stop it.  			 {  				moving = false;  				Console.WriteLine ("Telling robot arm to stop");  				Bus.Publish (BusNode.ROBOT_ACTIVE' false);  			}  			else// If the robot arm is not moving' enable it.  			 {  				moving = true;  				Console.WriteLine ("Telling robot arm to begin tracking");  				Bus.Publish (BusNode.ROBOT_ACTIVE' true);  			}  			movingGesture = true;  			// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  		}  	}  	else// If we're not in the moving gesture...  	 {  		if (movingGesture)  			// ... and we were' record the change' so we can re-enter the gesture later.  			movingGesture = false;  	}  	/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  	index_percent = ((indexFinger - 125) / 55) * 100;  	if (index_percent < 0)  		index_percent = 0;  	else if (index_percent > 100)  		index_percent = 100;  	/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  	// Craig centered (hand straight): 170 (180 degrees)  	// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  	// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  	if (wrist >= 170)  		wrist_percent = (wrist - 170) / 45 * 50 + 50;  	else  		wrist_percent = (wrist - 75) / 95 * 50;  	if (wrist_percent < 0)  		wrist_percent = 0;  	else if (wrist_percent > 100)  		wrist_percent = 100;  	/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  	//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  	//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  	Debug.WriteLine ("Moving gesture? " + movingGesture);  	Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  	Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (sensors.Length >= 18)// If we got at least 18 tokens (we should get 19)   {  	// Note that values are same for both right and left hand gloves.  	int pinky = Convert.ToInt32 (sensors [14]);  	// get flex of pinky's first joint  	int ring = Convert.ToInt32 (sensors [11]);  	// get flex of ring finger's first joint  	int middle = Convert.ToInt32 (sensors [8]);  	// get flex of middle finger's first joint  	indexFinger = Convert.ToInt32 (sensors [5]);  	// get flex of index finger's first joint  	wrist = Convert.ToInt32 (sensors [17]);  	// get flex/extension of wrist  	// Detect "Starting Postion" gesture  	// Currently we do NOT publish this gesture to the bus  	if (pinky >= 120) {  		if (!pinkyGesture) {  			//Console.WriteLine("Moving to starting position");  			pinkyGesture = true;  			// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  		}  	}  	else {  		if (pinkyGesture)  			pinkyGesture = false;  	}  	// Detect start/stop (robot arm) gesture  	if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...  	 {  		if (!movingGesture)// If we're not already in the "moving" gesture...  		 {  			if (moving == true)// If the robot arm is moving' stop it.  			 {  				moving = false;  				Console.WriteLine ("Telling robot arm to stop");  				Bus.Publish (BusNode.ROBOT_ACTIVE' false);  			}  			else// If the robot arm is not moving' enable it.  			 {  				moving = true;  				Console.WriteLine ("Telling robot arm to begin tracking");  				Bus.Publish (BusNode.ROBOT_ACTIVE' true);  			}  			movingGesture = true;  			// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  		}  	}  	else// If we're not in the moving gesture...  	 {  		if (movingGesture)  			// ... and we were' record the change' so we can re-enter the gesture later.  			movingGesture = false;  	}  	/*                          * Calculate Claw openness based on index finger's first joint                          * range is 125 to 180                          *///Debug.WriteLine("The index finger is at " + indexFinger);  	index_percent = ((indexFinger - 125) / 55) * 100;  	if (index_percent < 0)  		index_percent = 0;  	else if (index_percent > 100)  		index_percent = 100;  	/*                          * Wrist flexion/extension calculations                          */// Craig: extension (hand up): 75 (roughly 100 deg from top of arm)  	// Craig centered (hand straight): 170 (180 degrees)  	// Craig flexion (hand down): 215 (roughly 120 deg from bottom of arm)  	// Calculation is piecewise so centered one hand is actually centered on gripper' but we can scale each half separately.  	if (wrist >= 170)  		wrist_percent = (wrist - 170) / 45 * 50 + 50;  	else  		wrist_percent = (wrist - 75) / 95 * 50;  	if (wrist_percent < 0)  		wrist_percent = 0;  	else if (wrist_percent > 100)  		wrist_percent = 100;  	/*                          * Send data to robot arm (publish our data to the bus)                          *///Console.WriteLine("The claw is open " + percent + " percent");  	//Debug.WriteLine("The index finger is at " + (100 - (int)index_percent));  	//Debug.WriteLine("Raw wrist: " + wrist + "' percent: " + (int)wrist_percent);  	Debug.WriteLine ("Moving gesture? " + movingGesture);  	Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  	Bus.Publish (BusNode.WRIST_PERCENT' (int)wrist_percent);  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: indexFinger = Convert.ToInt32 (sensors [5]);  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: wrist = Convert.ToInt32 (sensors [17]);  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (pinky >= 120) {  	if (!pinkyGesture) {  		//Console.WriteLine("Moving to starting position");  		pinkyGesture = true;  		// Bus.Publish(BusNode.ROBOT_RESET' (object)null);  	}  }  else {  	if (pinkyGesture)  		pinkyGesture = false;  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...   {  	if (!movingGesture)// If we're not already in the "moving" gesture...  	 {  		if (moving == true)// If the robot arm is moving' stop it.  		 {  			moving = false;  			Console.WriteLine ("Telling robot arm to stop");  			Bus.Publish (BusNode.ROBOT_ACTIVE' false);  		}  		else// If the robot arm is not moving' enable it.  		 {  			moving = true;  			Console.WriteLine ("Telling robot arm to begin tracking");  			Bus.Publish (BusNode.ROBOT_ACTIVE' true);  		}  		movingGesture = true;  		// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  	}  }  else// If we're not in the moving gesture...   {  	if (movingGesture)  		// ... and we were' record the change' so we can re-enter the gesture later.  		movingGesture = false;  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (middle >= 145 && ring >= 145)// If both middle and ring fingers are significantly flexed...   {  	if (!movingGesture)// If we're not already in the "moving" gesture...  	 {  		if (moving == true)// If the robot arm is moving' stop it.  		 {  			moving = false;  			Console.WriteLine ("Telling robot arm to stop");  			Bus.Publish (BusNode.ROBOT_ACTIVE' false);  		}  		else// If the robot arm is not moving' enable it.  		 {  			moving = true;  			Console.WriteLine ("Telling robot arm to begin tracking");  			Bus.Publish (BusNode.ROBOT_ACTIVE' true);  		}  		movingGesture = true;  		// Record that we're in the gesture' so that we only update the bus if we re-enter the gesture.  	}  }  else// If we're not in the moving gesture...   {  	if (movingGesture)  		// ... and we were' record the change' so we can re-enter the gesture later.  		movingGesture = false;  }  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: index_percent = ((indexFinger - 125) / 55) * 100;  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: index_percent = ((indexFinger - 125) / 55) * 100;  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: index_percent = ((indexFinger - 125) / 55) * 100;  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (index_percent < 0)  	index_percent = 0;  else if (index_percent > 100)  	index_percent = 100;  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (index_percent < 0)  	index_percent = 0;  else if (index_percent > 100)  	index_percent = 100;  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (index_percent > 100)  	index_percent = 100;  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (index_percent > 100)  	index_percent = 100;  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: index_percent = 100;  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (wrist >= 170)  	wrist_percent = (wrist - 170) / 45 * 50 + 50;  else  	wrist_percent = (wrist - 75) / 95 * 50;  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (wrist >= 170)  	wrist_percent = (wrist - 170) / 45 * 50 + 50;  else  	wrist_percent = (wrist - 75) / 95 * 50;  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (wrist >= 170)  	wrist_percent = (wrist - 170) / 45 * 50 + 50;  else  	wrist_percent = (wrist - 75) / 95 * 50;  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (wrist >= 170)  	wrist_percent = (wrist - 170) / 45 * 50 + 50;  else  	wrist_percent = (wrist - 75) / 95 * 50;  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (wrist >= 170)  	wrist_percent = (wrist - 170) / 45 * 50 + 50;  else  	wrist_percent = (wrist - 75) / 95 * 50;  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (wrist >= 170)  	wrist_percent = (wrist - 170) / 45 * 50 + 50;  else  	wrist_percent = (wrist - 75) / 95 * 50;  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (wrist >= 170)  	wrist_percent = (wrist - 170) / 45 * 50 + 50;  else  	wrist_percent = (wrist - 75) / 95 * 50;  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (wrist >= 170)  	wrist_percent = (wrist - 170) / 45 * 50 + 50;  else  	wrist_percent = (wrist - 75) / 95 * 50;  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: wrist_percent = (wrist - 170) / 45 * 50 + 50;  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: wrist_percent = (wrist - 170) / 45 * 50 + 50;  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: wrist_percent = (wrist - 170) / 45 * 50 + 50;  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: wrist_percent = (wrist - 170) / 45 * 50 + 50;  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: wrist_percent = (wrist - 75) / 95 * 50;  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: wrist_percent = (wrist - 75) / 95 * 50;  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: wrist_percent = (wrist - 75) / 95 * 50;  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (wrist_percent < 0)  	wrist_percent = 0;  else if (wrist_percent > 100)  	wrist_percent = 100;  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (wrist_percent < 0)  	wrist_percent = 0;  else if (wrist_percent > 100)  	wrist_percent = 100;  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (wrist_percent > 100)  	wrist_percent = 100;  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: if (wrist_percent > 100)  	wrist_percent = 100;  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: wrist_percent = 100;  
Magic Number,ArmController.CyberGloveLibrary,GloveModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\CyberGlove Module\CyberGloveModule.cs,readGlove,The following statement contains a magic number: Bus.Publish (BusNode.CLAW_OPEN_PERCENT' 100 - (int)index_percent);  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnInitialize,The following statement contains a magic number: _serialPort = new SerialPort ("COM3"' 115200' Parity.None' 8' StopBits.One);  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnInitialize,The following statement contains a magic number: _serialPort = new SerialPort ("COM3"' 115200' Parity.None' 8' StopBits.One);  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnInitialize,The following statement contains a magic number: _serialPort.ReadTimeout = 500;  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnInitialize,The following statement contains a magic number: _serialPort.WriteTimeout = 500;  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnInitialize,The following statement contains a magic number: move (SHOULDER_PITCH' 1500' 100);  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnInitialize,The following statement contains a magic number: move (SHOULDER_PITCH' 1500' 100);  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnInitialize,The following statement contains a magic number: move (SHOULDER_YAW' 1500' 100);  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnInitialize,The following statement contains a magic number: move (SHOULDER_YAW' 1500' 100);  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnInitialize,The following statement contains a magic number: move (ELBOW_JOINT' 1500' 100);  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnInitialize,The following statement contains a magic number: move (ELBOW_JOINT' 1500' 100);  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnInitialize,The following statement contains a magic number: move (WRIST_JOINT' 1500' 100);  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnInitialize,The following statement contains a magic number: move (WRIST_JOINT' 1500' 100);  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnInitialize,The following statement contains a magic number: move (FINGERS' 1500' 100);  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnInitialize,The following statement contains a magic number: move (FINGERS' 1500' 100);  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (armMoving) {  	if (node == BusNode.POSITION_TICK) {  		// TODO: All the other joints  		if (forearm != null) {  			//Debug.WriteLine("forearm: " + (forearm.Roll * 180) / Math.PI + " / " + (forearm.Pitch * 180) / Math.PI + " / " + (forearm.Yaw * 180) / Math.PI);  			if (forearm.Pitch > ELBOW_PITCH_MAX_DEG * RAD_PER_DEG)  				forearm.Pitch = (float)(ELBOW_PITCH_MAX_DEG * RAD_PER_DEG);  			if (forearm.Pitch < ELBOW_PITCH_MIN_DEG * RAD_PER_DEG)  				forearm.Pitch = (float)(ELBOW_PITCH_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (1500 - 2200)  			finalForearmPosition = 1500 + (int)(((forearm.Pitch - ELBOW_PITCH_MIN_DEG * RAD_PER_DEG) / ((ELBOW_PITCH_MAX_DEG - ELBOW_PITCH_MIN_DEG) * RAD_PER_DEG)) * 700);  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalForearmPosition - currentForearmPosition) >= positionDeltaThreshold) {  				currentForearmPosition = finalForearmPosition;  				move (ELBOW_JOINT' currentForearmPosition' 200);  				Debug.WriteLine ("Got " + currentForearmPosition);  			}  		}  		if (arm != null) {  			if (arm.Pitch > SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG)  				arm.Pitch = (float)(SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG);  			if (arm.Pitch < SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG)  				arm.Pitch = (float)(SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (800 - 2200)  			if (arm.Pitch > 0) {  				finalArmPosition = 1500 - (int)(((arm.Pitch / (SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG))) * 700);  			}  			else {  				finalArmPosition = 1500 + (int)(((Math.Abs (arm.Pitch) / (Math.Abs (SHOULDER_PITCH_MIN_DEG) * RAD_PER_DEG))) * 700);  			}  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalArmPosition - currentForearmPosition) >= positionDeltaThreshold) {  				currentArmPosition = finalArmPosition;  				//move(SHOULDER_PITCH' currentArmPosition' 200);  			}  		}  		if (arm != null) {  			if (arm.Yaw > SHOULDER_YAW_MAX_DEG * RAD_PER_DEG)  				arm.Yaw = (float)(SHOULDER_YAW_MAX_DEG * RAD_PER_DEG);  			if (arm.Yaw < SHOULDER_YAW_MIN_DEG * RAD_PER_DEG)  				arm.Yaw = (float)(SHOULDER_YAW_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (800 - 2200)  			if (arm.Yaw > 0) {  				finalShoulderPosition = 1500 - (int)(((arm.Yaw / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITC_MIN_DEG_PHYSICAL)))  				) * 700);  			}  			else {  				finalShoulderPosition = 1500 + (int)(((Math.Abs (arm.Yaw) / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITCH_MIN_DEG_PHYSICAL)))  				) * 700);  			}  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalShoulderPosition - currentShoulderPosition) >= positionDeltaThreshold) {  				currentShoulderPosition = finalShoulderPosition;  				//move(SHOULDER_YAW' finalShoulderPosition' 200);  			}  		}  	}  	if (node == BusNode.CLAW_OPEN_PERCENT) {  		// scale to the valid range (1000 - 2000)  		finalHandPosition = 1500 + ((-hand + 50) * 10);  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalHandPosition - currentHandPosition) >= positionDeltaThreshold) {  			currentHandPosition = finalHandPosition;  			move (FINGERS' currentHandPosition' 400);  		}  	}  	if (node == BusNode.WRIST_PERCENT) {  		finalWristPosition = 1380 + (int)((-wrist_hand + 50) * 12.4f);  		if (Math.Abs (finalWristPosition - currentWristPosition) >= positionDeltaThreshold) {  			currentWristPosition = finalWristPosition;  			move (WRIST_JOINT' currentWristPosition' 300);  		}  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (armMoving) {  	if (node == BusNode.POSITION_TICK) {  		// TODO: All the other joints  		if (forearm != null) {  			//Debug.WriteLine("forearm: " + (forearm.Roll * 180) / Math.PI + " / " + (forearm.Pitch * 180) / Math.PI + " / " + (forearm.Yaw * 180) / Math.PI);  			if (forearm.Pitch > ELBOW_PITCH_MAX_DEG * RAD_PER_DEG)  				forearm.Pitch = (float)(ELBOW_PITCH_MAX_DEG * RAD_PER_DEG);  			if (forearm.Pitch < ELBOW_PITCH_MIN_DEG * RAD_PER_DEG)  				forearm.Pitch = (float)(ELBOW_PITCH_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (1500 - 2200)  			finalForearmPosition = 1500 + (int)(((forearm.Pitch - ELBOW_PITCH_MIN_DEG * RAD_PER_DEG) / ((ELBOW_PITCH_MAX_DEG - ELBOW_PITCH_MIN_DEG) * RAD_PER_DEG)) * 700);  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalForearmPosition - currentForearmPosition) >= positionDeltaThreshold) {  				currentForearmPosition = finalForearmPosition;  				move (ELBOW_JOINT' currentForearmPosition' 200);  				Debug.WriteLine ("Got " + currentForearmPosition);  			}  		}  		if (arm != null) {  			if (arm.Pitch > SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG)  				arm.Pitch = (float)(SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG);  			if (arm.Pitch < SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG)  				arm.Pitch = (float)(SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (800 - 2200)  			if (arm.Pitch > 0) {  				finalArmPosition = 1500 - (int)(((arm.Pitch / (SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG))) * 700);  			}  			else {  				finalArmPosition = 1500 + (int)(((Math.Abs (arm.Pitch) / (Math.Abs (SHOULDER_PITCH_MIN_DEG) * RAD_PER_DEG))) * 700);  			}  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalArmPosition - currentForearmPosition) >= positionDeltaThreshold) {  				currentArmPosition = finalArmPosition;  				//move(SHOULDER_PITCH' currentArmPosition' 200);  			}  		}  		if (arm != null) {  			if (arm.Yaw > SHOULDER_YAW_MAX_DEG * RAD_PER_DEG)  				arm.Yaw = (float)(SHOULDER_YAW_MAX_DEG * RAD_PER_DEG);  			if (arm.Yaw < SHOULDER_YAW_MIN_DEG * RAD_PER_DEG)  				arm.Yaw = (float)(SHOULDER_YAW_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (800 - 2200)  			if (arm.Yaw > 0) {  				finalShoulderPosition = 1500 - (int)(((arm.Yaw / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITC_MIN_DEG_PHYSICAL)))  				) * 700);  			}  			else {  				finalShoulderPosition = 1500 + (int)(((Math.Abs (arm.Yaw) / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITCH_MIN_DEG_PHYSICAL)))  				) * 700);  			}  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalShoulderPosition - currentShoulderPosition) >= positionDeltaThreshold) {  				currentShoulderPosition = finalShoulderPosition;  				//move(SHOULDER_YAW' finalShoulderPosition' 200);  			}  		}  	}  	if (node == BusNode.CLAW_OPEN_PERCENT) {  		// scale to the valid range (1000 - 2000)  		finalHandPosition = 1500 + ((-hand + 50) * 10);  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalHandPosition - currentHandPosition) >= positionDeltaThreshold) {  			currentHandPosition = finalHandPosition;  			move (FINGERS' currentHandPosition' 400);  		}  	}  	if (node == BusNode.WRIST_PERCENT) {  		finalWristPosition = 1380 + (int)((-wrist_hand + 50) * 12.4f);  		if (Math.Abs (finalWristPosition - currentWristPosition) >= positionDeltaThreshold) {  			currentWristPosition = finalWristPosition;  			move (WRIST_JOINT' currentWristPosition' 300);  		}  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (armMoving) {  	if (node == BusNode.POSITION_TICK) {  		// TODO: All the other joints  		if (forearm != null) {  			//Debug.WriteLine("forearm: " + (forearm.Roll * 180) / Math.PI + " / " + (forearm.Pitch * 180) / Math.PI + " / " + (forearm.Yaw * 180) / Math.PI);  			if (forearm.Pitch > ELBOW_PITCH_MAX_DEG * RAD_PER_DEG)  				forearm.Pitch = (float)(ELBOW_PITCH_MAX_DEG * RAD_PER_DEG);  			if (forearm.Pitch < ELBOW_PITCH_MIN_DEG * RAD_PER_DEG)  				forearm.Pitch = (float)(ELBOW_PITCH_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (1500 - 2200)  			finalForearmPosition = 1500 + (int)(((forearm.Pitch - ELBOW_PITCH_MIN_DEG * RAD_PER_DEG) / ((ELBOW_PITCH_MAX_DEG - ELBOW_PITCH_MIN_DEG) * RAD_PER_DEG)) * 700);  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalForearmPosition - currentForearmPosition) >= positionDeltaThreshold) {  				currentForearmPosition = finalForearmPosition;  				move (ELBOW_JOINT' currentForearmPosition' 200);  				Debug.WriteLine ("Got " + currentForearmPosition);  			}  		}  		if (arm != null) {  			if (arm.Pitch > SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG)  				arm.Pitch = (float)(SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG);  			if (arm.Pitch < SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG)  				arm.Pitch = (float)(SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (800 - 2200)  			if (arm.Pitch > 0) {  				finalArmPosition = 1500 - (int)(((arm.Pitch / (SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG))) * 700);  			}  			else {  				finalArmPosition = 1500 + (int)(((Math.Abs (arm.Pitch) / (Math.Abs (SHOULDER_PITCH_MIN_DEG) * RAD_PER_DEG))) * 700);  			}  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalArmPosition - currentForearmPosition) >= positionDeltaThreshold) {  				currentArmPosition = finalArmPosition;  				//move(SHOULDER_PITCH' currentArmPosition' 200);  			}  		}  		if (arm != null) {  			if (arm.Yaw > SHOULDER_YAW_MAX_DEG * RAD_PER_DEG)  				arm.Yaw = (float)(SHOULDER_YAW_MAX_DEG * RAD_PER_DEG);  			if (arm.Yaw < SHOULDER_YAW_MIN_DEG * RAD_PER_DEG)  				arm.Yaw = (float)(SHOULDER_YAW_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (800 - 2200)  			if (arm.Yaw > 0) {  				finalShoulderPosition = 1500 - (int)(((arm.Yaw / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITC_MIN_DEG_PHYSICAL)))  				) * 700);  			}  			else {  				finalShoulderPosition = 1500 + (int)(((Math.Abs (arm.Yaw) / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITCH_MIN_DEG_PHYSICAL)))  				) * 700);  			}  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalShoulderPosition - currentShoulderPosition) >= positionDeltaThreshold) {  				currentShoulderPosition = finalShoulderPosition;  				//move(SHOULDER_YAW' finalShoulderPosition' 200);  			}  		}  	}  	if (node == BusNode.CLAW_OPEN_PERCENT) {  		// scale to the valid range (1000 - 2000)  		finalHandPosition = 1500 + ((-hand + 50) * 10);  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalHandPosition - currentHandPosition) >= positionDeltaThreshold) {  			currentHandPosition = finalHandPosition;  			move (FINGERS' currentHandPosition' 400);  		}  	}  	if (node == BusNode.WRIST_PERCENT) {  		finalWristPosition = 1380 + (int)((-wrist_hand + 50) * 12.4f);  		if (Math.Abs (finalWristPosition - currentWristPosition) >= positionDeltaThreshold) {  			currentWristPosition = finalWristPosition;  			move (WRIST_JOINT' currentWristPosition' 300);  		}  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (armMoving) {  	if (node == BusNode.POSITION_TICK) {  		// TODO: All the other joints  		if (forearm != null) {  			//Debug.WriteLine("forearm: " + (forearm.Roll * 180) / Math.PI + " / " + (forearm.Pitch * 180) / Math.PI + " / " + (forearm.Yaw * 180) / Math.PI);  			if (forearm.Pitch > ELBOW_PITCH_MAX_DEG * RAD_PER_DEG)  				forearm.Pitch = (float)(ELBOW_PITCH_MAX_DEG * RAD_PER_DEG);  			if (forearm.Pitch < ELBOW_PITCH_MIN_DEG * RAD_PER_DEG)  				forearm.Pitch = (float)(ELBOW_PITCH_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (1500 - 2200)  			finalForearmPosition = 1500 + (int)(((forearm.Pitch - ELBOW_PITCH_MIN_DEG * RAD_PER_DEG) / ((ELBOW_PITCH_MAX_DEG - ELBOW_PITCH_MIN_DEG) * RAD_PER_DEG)) * 700);  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalForearmPosition - currentForearmPosition) >= positionDeltaThreshold) {  				currentForearmPosition = finalForearmPosition;  				move (ELBOW_JOINT' currentForearmPosition' 200);  				Debug.WriteLine ("Got " + currentForearmPosition);  			}  		}  		if (arm != null) {  			if (arm.Pitch > SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG)  				arm.Pitch = (float)(SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG);  			if (arm.Pitch < SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG)  				arm.Pitch = (float)(SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (800 - 2200)  			if (arm.Pitch > 0) {  				finalArmPosition = 1500 - (int)(((arm.Pitch / (SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG))) * 700);  			}  			else {  				finalArmPosition = 1500 + (int)(((Math.Abs (arm.Pitch) / (Math.Abs (SHOULDER_PITCH_MIN_DEG) * RAD_PER_DEG))) * 700);  			}  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalArmPosition - currentForearmPosition) >= positionDeltaThreshold) {  				currentArmPosition = finalArmPosition;  				//move(SHOULDER_PITCH' currentArmPosition' 200);  			}  		}  		if (arm != null) {  			if (arm.Yaw > SHOULDER_YAW_MAX_DEG * RAD_PER_DEG)  				arm.Yaw = (float)(SHOULDER_YAW_MAX_DEG * RAD_PER_DEG);  			if (arm.Yaw < SHOULDER_YAW_MIN_DEG * RAD_PER_DEG)  				arm.Yaw = (float)(SHOULDER_YAW_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (800 - 2200)  			if (arm.Yaw > 0) {  				finalShoulderPosition = 1500 - (int)(((arm.Yaw / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITC_MIN_DEG_PHYSICAL)))  				) * 700);  			}  			else {  				finalShoulderPosition = 1500 + (int)(((Math.Abs (arm.Yaw) / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITCH_MIN_DEG_PHYSICAL)))  				) * 700);  			}  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalShoulderPosition - currentShoulderPosition) >= positionDeltaThreshold) {  				currentShoulderPosition = finalShoulderPosition;  				//move(SHOULDER_YAW' finalShoulderPosition' 200);  			}  		}  	}  	if (node == BusNode.CLAW_OPEN_PERCENT) {  		// scale to the valid range (1000 - 2000)  		finalHandPosition = 1500 + ((-hand + 50) * 10);  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalHandPosition - currentHandPosition) >= positionDeltaThreshold) {  			currentHandPosition = finalHandPosition;  			move (FINGERS' currentHandPosition' 400);  		}  	}  	if (node == BusNode.WRIST_PERCENT) {  		finalWristPosition = 1380 + (int)((-wrist_hand + 50) * 12.4f);  		if (Math.Abs (finalWristPosition - currentWristPosition) >= positionDeltaThreshold) {  			currentWristPosition = finalWristPosition;  			move (WRIST_JOINT' currentWristPosition' 300);  		}  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (armMoving) {  	if (node == BusNode.POSITION_TICK) {  		// TODO: All the other joints  		if (forearm != null) {  			//Debug.WriteLine("forearm: " + (forearm.Roll * 180) / Math.PI + " / " + (forearm.Pitch * 180) / Math.PI + " / " + (forearm.Yaw * 180) / Math.PI);  			if (forearm.Pitch > ELBOW_PITCH_MAX_DEG * RAD_PER_DEG)  				forearm.Pitch = (float)(ELBOW_PITCH_MAX_DEG * RAD_PER_DEG);  			if (forearm.Pitch < ELBOW_PITCH_MIN_DEG * RAD_PER_DEG)  				forearm.Pitch = (float)(ELBOW_PITCH_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (1500 - 2200)  			finalForearmPosition = 1500 + (int)(((forearm.Pitch - ELBOW_PITCH_MIN_DEG * RAD_PER_DEG) / ((ELBOW_PITCH_MAX_DEG - ELBOW_PITCH_MIN_DEG) * RAD_PER_DEG)) * 700);  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalForearmPosition - currentForearmPosition) >= positionDeltaThreshold) {  				currentForearmPosition = finalForearmPosition;  				move (ELBOW_JOINT' currentForearmPosition' 200);  				Debug.WriteLine ("Got " + currentForearmPosition);  			}  		}  		if (arm != null) {  			if (arm.Pitch > SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG)  				arm.Pitch = (float)(SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG);  			if (arm.Pitch < SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG)  				arm.Pitch = (float)(SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (800 - 2200)  			if (arm.Pitch > 0) {  				finalArmPosition = 1500 - (int)(((arm.Pitch / (SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG))) * 700);  			}  			else {  				finalArmPosition = 1500 + (int)(((Math.Abs (arm.Pitch) / (Math.Abs (SHOULDER_PITCH_MIN_DEG) * RAD_PER_DEG))) * 700);  			}  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalArmPosition - currentForearmPosition) >= positionDeltaThreshold) {  				currentArmPosition = finalArmPosition;  				//move(SHOULDER_PITCH' currentArmPosition' 200);  			}  		}  		if (arm != null) {  			if (arm.Yaw > SHOULDER_YAW_MAX_DEG * RAD_PER_DEG)  				arm.Yaw = (float)(SHOULDER_YAW_MAX_DEG * RAD_PER_DEG);  			if (arm.Yaw < SHOULDER_YAW_MIN_DEG * RAD_PER_DEG)  				arm.Yaw = (float)(SHOULDER_YAW_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (800 - 2200)  			if (arm.Yaw > 0) {  				finalShoulderPosition = 1500 - (int)(((arm.Yaw / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITC_MIN_DEG_PHYSICAL)))  				) * 700);  			}  			else {  				finalShoulderPosition = 1500 + (int)(((Math.Abs (arm.Yaw) / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITCH_MIN_DEG_PHYSICAL)))  				) * 700);  			}  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalShoulderPosition - currentShoulderPosition) >= positionDeltaThreshold) {  				currentShoulderPosition = finalShoulderPosition;  				//move(SHOULDER_YAW' finalShoulderPosition' 200);  			}  		}  	}  	if (node == BusNode.CLAW_OPEN_PERCENT) {  		// scale to the valid range (1000 - 2000)  		finalHandPosition = 1500 + ((-hand + 50) * 10);  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalHandPosition - currentHandPosition) >= positionDeltaThreshold) {  			currentHandPosition = finalHandPosition;  			move (FINGERS' currentHandPosition' 400);  		}  	}  	if (node == BusNode.WRIST_PERCENT) {  		finalWristPosition = 1380 + (int)((-wrist_hand + 50) * 12.4f);  		if (Math.Abs (finalWristPosition - currentWristPosition) >= positionDeltaThreshold) {  			currentWristPosition = finalWristPosition;  			move (WRIST_JOINT' currentWristPosition' 300);  		}  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (armMoving) {  	if (node == BusNode.POSITION_TICK) {  		// TODO: All the other joints  		if (forearm != null) {  			//Debug.WriteLine("forearm: " + (forearm.Roll * 180) / Math.PI + " / " + (forearm.Pitch * 180) / Math.PI + " / " + (forearm.Yaw * 180) / Math.PI);  			if (forearm.Pitch > ELBOW_PITCH_MAX_DEG * RAD_PER_DEG)  				forearm.Pitch = (float)(ELBOW_PITCH_MAX_DEG * RAD_PER_DEG);  			if (forearm.Pitch < ELBOW_PITCH_MIN_DEG * RAD_PER_DEG)  				forearm.Pitch = (float)(ELBOW_PITCH_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (1500 - 2200)  			finalForearmPosition = 1500 + (int)(((forearm.Pitch - ELBOW_PITCH_MIN_DEG * RAD_PER_DEG) / ((ELBOW_PITCH_MAX_DEG - ELBOW_PITCH_MIN_DEG) * RAD_PER_DEG)) * 700);  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalForearmPosition - currentForearmPosition) >= positionDeltaThreshold) {  				currentForearmPosition = finalForearmPosition;  				move (ELBOW_JOINT' currentForearmPosition' 200);  				Debug.WriteLine ("Got " + currentForearmPosition);  			}  		}  		if (arm != null) {  			if (arm.Pitch > SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG)  				arm.Pitch = (float)(SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG);  			if (arm.Pitch < SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG)  				arm.Pitch = (float)(SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (800 - 2200)  			if (arm.Pitch > 0) {  				finalArmPosition = 1500 - (int)(((arm.Pitch / (SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG))) * 700);  			}  			else {  				finalArmPosition = 1500 + (int)(((Math.Abs (arm.Pitch) / (Math.Abs (SHOULDER_PITCH_MIN_DEG) * RAD_PER_DEG))) * 700);  			}  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalArmPosition - currentForearmPosition) >= positionDeltaThreshold) {  				currentArmPosition = finalArmPosition;  				//move(SHOULDER_PITCH' currentArmPosition' 200);  			}  		}  		if (arm != null) {  			if (arm.Yaw > SHOULDER_YAW_MAX_DEG * RAD_PER_DEG)  				arm.Yaw = (float)(SHOULDER_YAW_MAX_DEG * RAD_PER_DEG);  			if (arm.Yaw < SHOULDER_YAW_MIN_DEG * RAD_PER_DEG)  				arm.Yaw = (float)(SHOULDER_YAW_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (800 - 2200)  			if (arm.Yaw > 0) {  				finalShoulderPosition = 1500 - (int)(((arm.Yaw / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITC_MIN_DEG_PHYSICAL)))  				) * 700);  			}  			else {  				finalShoulderPosition = 1500 + (int)(((Math.Abs (arm.Yaw) / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITCH_MIN_DEG_PHYSICAL)))  				) * 700);  			}  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalShoulderPosition - currentShoulderPosition) >= positionDeltaThreshold) {  				currentShoulderPosition = finalShoulderPosition;  				//move(SHOULDER_YAW' finalShoulderPosition' 200);  			}  		}  	}  	if (node == BusNode.CLAW_OPEN_PERCENT) {  		// scale to the valid range (1000 - 2000)  		finalHandPosition = 1500 + ((-hand + 50) * 10);  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalHandPosition - currentHandPosition) >= positionDeltaThreshold) {  			currentHandPosition = finalHandPosition;  			move (FINGERS' currentHandPosition' 400);  		}  	}  	if (node == BusNode.WRIST_PERCENT) {  		finalWristPosition = 1380 + (int)((-wrist_hand + 50) * 12.4f);  		if (Math.Abs (finalWristPosition - currentWristPosition) >= positionDeltaThreshold) {  			currentWristPosition = finalWristPosition;  			move (WRIST_JOINT' currentWristPosition' 300);  		}  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (armMoving) {  	if (node == BusNode.POSITION_TICK) {  		// TODO: All the other joints  		if (forearm != null) {  			//Debug.WriteLine("forearm: " + (forearm.Roll * 180) / Math.PI + " / " + (forearm.Pitch * 180) / Math.PI + " / " + (forearm.Yaw * 180) / Math.PI);  			if (forearm.Pitch > ELBOW_PITCH_MAX_DEG * RAD_PER_DEG)  				forearm.Pitch = (float)(ELBOW_PITCH_MAX_DEG * RAD_PER_DEG);  			if (forearm.Pitch < ELBOW_PITCH_MIN_DEG * RAD_PER_DEG)  				forearm.Pitch = (float)(ELBOW_PITCH_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (1500 - 2200)  			finalForearmPosition = 1500 + (int)(((forearm.Pitch - ELBOW_PITCH_MIN_DEG * RAD_PER_DEG) / ((ELBOW_PITCH_MAX_DEG - ELBOW_PITCH_MIN_DEG) * RAD_PER_DEG)) * 700);  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalForearmPosition - currentForearmPosition) >= positionDeltaThreshold) {  				currentForearmPosition = finalForearmPosition;  				move (ELBOW_JOINT' currentForearmPosition' 200);  				Debug.WriteLine ("Got " + currentForearmPosition);  			}  		}  		if (arm != null) {  			if (arm.Pitch > SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG)  				arm.Pitch = (float)(SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG);  			if (arm.Pitch < SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG)  				arm.Pitch = (float)(SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (800 - 2200)  			if (arm.Pitch > 0) {  				finalArmPosition = 1500 - (int)(((arm.Pitch / (SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG))) * 700);  			}  			else {  				finalArmPosition = 1500 + (int)(((Math.Abs (arm.Pitch) / (Math.Abs (SHOULDER_PITCH_MIN_DEG) * RAD_PER_DEG))) * 700);  			}  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalArmPosition - currentForearmPosition) >= positionDeltaThreshold) {  				currentArmPosition = finalArmPosition;  				//move(SHOULDER_PITCH' currentArmPosition' 200);  			}  		}  		if (arm != null) {  			if (arm.Yaw > SHOULDER_YAW_MAX_DEG * RAD_PER_DEG)  				arm.Yaw = (float)(SHOULDER_YAW_MAX_DEG * RAD_PER_DEG);  			if (arm.Yaw < SHOULDER_YAW_MIN_DEG * RAD_PER_DEG)  				arm.Yaw = (float)(SHOULDER_YAW_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (800 - 2200)  			if (arm.Yaw > 0) {  				finalShoulderPosition = 1500 - (int)(((arm.Yaw / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITC_MIN_DEG_PHYSICAL)))  				) * 700);  			}  			else {  				finalShoulderPosition = 1500 + (int)(((Math.Abs (arm.Yaw) / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITCH_MIN_DEG_PHYSICAL)))  				) * 700);  			}  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalShoulderPosition - currentShoulderPosition) >= positionDeltaThreshold) {  				currentShoulderPosition = finalShoulderPosition;  				//move(SHOULDER_YAW' finalShoulderPosition' 200);  			}  		}  	}  	if (node == BusNode.CLAW_OPEN_PERCENT) {  		// scale to the valid range (1000 - 2000)  		finalHandPosition = 1500 + ((-hand + 50) * 10);  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalHandPosition - currentHandPosition) >= positionDeltaThreshold) {  			currentHandPosition = finalHandPosition;  			move (FINGERS' currentHandPosition' 400);  		}  	}  	if (node == BusNode.WRIST_PERCENT) {  		finalWristPosition = 1380 + (int)((-wrist_hand + 50) * 12.4f);  		if (Math.Abs (finalWristPosition - currentWristPosition) >= positionDeltaThreshold) {  			currentWristPosition = finalWristPosition;  			move (WRIST_JOINT' currentWristPosition' 300);  		}  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (armMoving) {  	if (node == BusNode.POSITION_TICK) {  		// TODO: All the other joints  		if (forearm != null) {  			//Debug.WriteLine("forearm: " + (forearm.Roll * 180) / Math.PI + " / " + (forearm.Pitch * 180) / Math.PI + " / " + (forearm.Yaw * 180) / Math.PI);  			if (forearm.Pitch > ELBOW_PITCH_MAX_DEG * RAD_PER_DEG)  				forearm.Pitch = (float)(ELBOW_PITCH_MAX_DEG * RAD_PER_DEG);  			if (forearm.Pitch < ELBOW_PITCH_MIN_DEG * RAD_PER_DEG)  				forearm.Pitch = (float)(ELBOW_PITCH_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (1500 - 2200)  			finalForearmPosition = 1500 + (int)(((forearm.Pitch - ELBOW_PITCH_MIN_DEG * RAD_PER_DEG) / ((ELBOW_PITCH_MAX_DEG - ELBOW_PITCH_MIN_DEG) * RAD_PER_DEG)) * 700);  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalForearmPosition - currentForearmPosition) >= positionDeltaThreshold) {  				currentForearmPosition = finalForearmPosition;  				move (ELBOW_JOINT' currentForearmPosition' 200);  				Debug.WriteLine ("Got " + currentForearmPosition);  			}  		}  		if (arm != null) {  			if (arm.Pitch > SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG)  				arm.Pitch = (float)(SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG);  			if (arm.Pitch < SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG)  				arm.Pitch = (float)(SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (800 - 2200)  			if (arm.Pitch > 0) {  				finalArmPosition = 1500 - (int)(((arm.Pitch / (SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG))) * 700);  			}  			else {  				finalArmPosition = 1500 + (int)(((Math.Abs (arm.Pitch) / (Math.Abs (SHOULDER_PITCH_MIN_DEG) * RAD_PER_DEG))) * 700);  			}  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalArmPosition - currentForearmPosition) >= positionDeltaThreshold) {  				currentArmPosition = finalArmPosition;  				//move(SHOULDER_PITCH' currentArmPosition' 200);  			}  		}  		if (arm != null) {  			if (arm.Yaw > SHOULDER_YAW_MAX_DEG * RAD_PER_DEG)  				arm.Yaw = (float)(SHOULDER_YAW_MAX_DEG * RAD_PER_DEG);  			if (arm.Yaw < SHOULDER_YAW_MIN_DEG * RAD_PER_DEG)  				arm.Yaw = (float)(SHOULDER_YAW_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (800 - 2200)  			if (arm.Yaw > 0) {  				finalShoulderPosition = 1500 - (int)(((arm.Yaw / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITC_MIN_DEG_PHYSICAL)))  				) * 700);  			}  			else {  				finalShoulderPosition = 1500 + (int)(((Math.Abs (arm.Yaw) / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITCH_MIN_DEG_PHYSICAL)))  				) * 700);  			}  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalShoulderPosition - currentShoulderPosition) >= positionDeltaThreshold) {  				currentShoulderPosition = finalShoulderPosition;  				//move(SHOULDER_YAW' finalShoulderPosition' 200);  			}  		}  	}  	if (node == BusNode.CLAW_OPEN_PERCENT) {  		// scale to the valid range (1000 - 2000)  		finalHandPosition = 1500 + ((-hand + 50) * 10);  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalHandPosition - currentHandPosition) >= positionDeltaThreshold) {  			currentHandPosition = finalHandPosition;  			move (FINGERS' currentHandPosition' 400);  		}  	}  	if (node == BusNode.WRIST_PERCENT) {  		finalWristPosition = 1380 + (int)((-wrist_hand + 50) * 12.4f);  		if (Math.Abs (finalWristPosition - currentWristPosition) >= positionDeltaThreshold) {  			currentWristPosition = finalWristPosition;  			move (WRIST_JOINT' currentWristPosition' 300);  		}  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (armMoving) {  	if (node == BusNode.POSITION_TICK) {  		// TODO: All the other joints  		if (forearm != null) {  			//Debug.WriteLine("forearm: " + (forearm.Roll * 180) / Math.PI + " / " + (forearm.Pitch * 180) / Math.PI + " / " + (forearm.Yaw * 180) / Math.PI);  			if (forearm.Pitch > ELBOW_PITCH_MAX_DEG * RAD_PER_DEG)  				forearm.Pitch = (float)(ELBOW_PITCH_MAX_DEG * RAD_PER_DEG);  			if (forearm.Pitch < ELBOW_PITCH_MIN_DEG * RAD_PER_DEG)  				forearm.Pitch = (float)(ELBOW_PITCH_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (1500 - 2200)  			finalForearmPosition = 1500 + (int)(((forearm.Pitch - ELBOW_PITCH_MIN_DEG * RAD_PER_DEG) / ((ELBOW_PITCH_MAX_DEG - ELBOW_PITCH_MIN_DEG) * RAD_PER_DEG)) * 700);  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalForearmPosition - currentForearmPosition) >= positionDeltaThreshold) {  				currentForearmPosition = finalForearmPosition;  				move (ELBOW_JOINT' currentForearmPosition' 200);  				Debug.WriteLine ("Got " + currentForearmPosition);  			}  		}  		if (arm != null) {  			if (arm.Pitch > SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG)  				arm.Pitch = (float)(SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG);  			if (arm.Pitch < SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG)  				arm.Pitch = (float)(SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (800 - 2200)  			if (arm.Pitch > 0) {  				finalArmPosition = 1500 - (int)(((arm.Pitch / (SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG))) * 700);  			}  			else {  				finalArmPosition = 1500 + (int)(((Math.Abs (arm.Pitch) / (Math.Abs (SHOULDER_PITCH_MIN_DEG) * RAD_PER_DEG))) * 700);  			}  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalArmPosition - currentForearmPosition) >= positionDeltaThreshold) {  				currentArmPosition = finalArmPosition;  				//move(SHOULDER_PITCH' currentArmPosition' 200);  			}  		}  		if (arm != null) {  			if (arm.Yaw > SHOULDER_YAW_MAX_DEG * RAD_PER_DEG)  				arm.Yaw = (float)(SHOULDER_YAW_MAX_DEG * RAD_PER_DEG);  			if (arm.Yaw < SHOULDER_YAW_MIN_DEG * RAD_PER_DEG)  				arm.Yaw = (float)(SHOULDER_YAW_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (800 - 2200)  			if (arm.Yaw > 0) {  				finalShoulderPosition = 1500 - (int)(((arm.Yaw / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITC_MIN_DEG_PHYSICAL)))  				) * 700);  			}  			else {  				finalShoulderPosition = 1500 + (int)(((Math.Abs (arm.Yaw) / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITCH_MIN_DEG_PHYSICAL)))  				) * 700);  			}  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalShoulderPosition - currentShoulderPosition) >= positionDeltaThreshold) {  				currentShoulderPosition = finalShoulderPosition;  				//move(SHOULDER_YAW' finalShoulderPosition' 200);  			}  		}  	}  	if (node == BusNode.CLAW_OPEN_PERCENT) {  		// scale to the valid range (1000 - 2000)  		finalHandPosition = 1500 + ((-hand + 50) * 10);  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalHandPosition - currentHandPosition) >= positionDeltaThreshold) {  			currentHandPosition = finalHandPosition;  			move (FINGERS' currentHandPosition' 400);  		}  	}  	if (node == BusNode.WRIST_PERCENT) {  		finalWristPosition = 1380 + (int)((-wrist_hand + 50) * 12.4f);  		if (Math.Abs (finalWristPosition - currentWristPosition) >= positionDeltaThreshold) {  			currentWristPosition = finalWristPosition;  			move (WRIST_JOINT' currentWristPosition' 300);  		}  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (armMoving) {  	if (node == BusNode.POSITION_TICK) {  		// TODO: All the other joints  		if (forearm != null) {  			//Debug.WriteLine("forearm: " + (forearm.Roll * 180) / Math.PI + " / " + (forearm.Pitch * 180) / Math.PI + " / " + (forearm.Yaw * 180) / Math.PI);  			if (forearm.Pitch > ELBOW_PITCH_MAX_DEG * RAD_PER_DEG)  				forearm.Pitch = (float)(ELBOW_PITCH_MAX_DEG * RAD_PER_DEG);  			if (forearm.Pitch < ELBOW_PITCH_MIN_DEG * RAD_PER_DEG)  				forearm.Pitch = (float)(ELBOW_PITCH_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (1500 - 2200)  			finalForearmPosition = 1500 + (int)(((forearm.Pitch - ELBOW_PITCH_MIN_DEG * RAD_PER_DEG) / ((ELBOW_PITCH_MAX_DEG - ELBOW_PITCH_MIN_DEG) * RAD_PER_DEG)) * 700);  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalForearmPosition - currentForearmPosition) >= positionDeltaThreshold) {  				currentForearmPosition = finalForearmPosition;  				move (ELBOW_JOINT' currentForearmPosition' 200);  				Debug.WriteLine ("Got " + currentForearmPosition);  			}  		}  		if (arm != null) {  			if (arm.Pitch > SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG)  				arm.Pitch = (float)(SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG);  			if (arm.Pitch < SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG)  				arm.Pitch = (float)(SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (800 - 2200)  			if (arm.Pitch > 0) {  				finalArmPosition = 1500 - (int)(((arm.Pitch / (SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG))) * 700);  			}  			else {  				finalArmPosition = 1500 + (int)(((Math.Abs (arm.Pitch) / (Math.Abs (SHOULDER_PITCH_MIN_DEG) * RAD_PER_DEG))) * 700);  			}  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalArmPosition - currentForearmPosition) >= positionDeltaThreshold) {  				currentArmPosition = finalArmPosition;  				//move(SHOULDER_PITCH' currentArmPosition' 200);  			}  		}  		if (arm != null) {  			if (arm.Yaw > SHOULDER_YAW_MAX_DEG * RAD_PER_DEG)  				arm.Yaw = (float)(SHOULDER_YAW_MAX_DEG * RAD_PER_DEG);  			if (arm.Yaw < SHOULDER_YAW_MIN_DEG * RAD_PER_DEG)  				arm.Yaw = (float)(SHOULDER_YAW_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (800 - 2200)  			if (arm.Yaw > 0) {  				finalShoulderPosition = 1500 - (int)(((arm.Yaw / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITC_MIN_DEG_PHYSICAL)))  				) * 700);  			}  			else {  				finalShoulderPosition = 1500 + (int)(((Math.Abs (arm.Yaw) / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITCH_MIN_DEG_PHYSICAL)))  				) * 700);  			}  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalShoulderPosition - currentShoulderPosition) >= positionDeltaThreshold) {  				currentShoulderPosition = finalShoulderPosition;  				//move(SHOULDER_YAW' finalShoulderPosition' 200);  			}  		}  	}  	if (node == BusNode.CLAW_OPEN_PERCENT) {  		// scale to the valid range (1000 - 2000)  		finalHandPosition = 1500 + ((-hand + 50) * 10);  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalHandPosition - currentHandPosition) >= positionDeltaThreshold) {  			currentHandPosition = finalHandPosition;  			move (FINGERS' currentHandPosition' 400);  		}  	}  	if (node == BusNode.WRIST_PERCENT) {  		finalWristPosition = 1380 + (int)((-wrist_hand + 50) * 12.4f);  		if (Math.Abs (finalWristPosition - currentWristPosition) >= positionDeltaThreshold) {  			currentWristPosition = finalWristPosition;  			move (WRIST_JOINT' currentWristPosition' 300);  		}  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (armMoving) {  	if (node == BusNode.POSITION_TICK) {  		// TODO: All the other joints  		if (forearm != null) {  			//Debug.WriteLine("forearm: " + (forearm.Roll * 180) / Math.PI + " / " + (forearm.Pitch * 180) / Math.PI + " / " + (forearm.Yaw * 180) / Math.PI);  			if (forearm.Pitch > ELBOW_PITCH_MAX_DEG * RAD_PER_DEG)  				forearm.Pitch = (float)(ELBOW_PITCH_MAX_DEG * RAD_PER_DEG);  			if (forearm.Pitch < ELBOW_PITCH_MIN_DEG * RAD_PER_DEG)  				forearm.Pitch = (float)(ELBOW_PITCH_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (1500 - 2200)  			finalForearmPosition = 1500 + (int)(((forearm.Pitch - ELBOW_PITCH_MIN_DEG * RAD_PER_DEG) / ((ELBOW_PITCH_MAX_DEG - ELBOW_PITCH_MIN_DEG) * RAD_PER_DEG)) * 700);  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalForearmPosition - currentForearmPosition) >= positionDeltaThreshold) {  				currentForearmPosition = finalForearmPosition;  				move (ELBOW_JOINT' currentForearmPosition' 200);  				Debug.WriteLine ("Got " + currentForearmPosition);  			}  		}  		if (arm != null) {  			if (arm.Pitch > SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG)  				arm.Pitch = (float)(SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG);  			if (arm.Pitch < SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG)  				arm.Pitch = (float)(SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (800 - 2200)  			if (arm.Pitch > 0) {  				finalArmPosition = 1500 - (int)(((arm.Pitch / (SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG))) * 700);  			}  			else {  				finalArmPosition = 1500 + (int)(((Math.Abs (arm.Pitch) / (Math.Abs (SHOULDER_PITCH_MIN_DEG) * RAD_PER_DEG))) * 700);  			}  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalArmPosition - currentForearmPosition) >= positionDeltaThreshold) {  				currentArmPosition = finalArmPosition;  				//move(SHOULDER_PITCH' currentArmPosition' 200);  			}  		}  		if (arm != null) {  			if (arm.Yaw > SHOULDER_YAW_MAX_DEG * RAD_PER_DEG)  				arm.Yaw = (float)(SHOULDER_YAW_MAX_DEG * RAD_PER_DEG);  			if (arm.Yaw < SHOULDER_YAW_MIN_DEG * RAD_PER_DEG)  				arm.Yaw = (float)(SHOULDER_YAW_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (800 - 2200)  			if (arm.Yaw > 0) {  				finalShoulderPosition = 1500 - (int)(((arm.Yaw / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITC_MIN_DEG_PHYSICAL)))  				) * 700);  			}  			else {  				finalShoulderPosition = 1500 + (int)(((Math.Abs (arm.Yaw) / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITCH_MIN_DEG_PHYSICAL)))  				) * 700);  			}  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalShoulderPosition - currentShoulderPosition) >= positionDeltaThreshold) {  				currentShoulderPosition = finalShoulderPosition;  				//move(SHOULDER_YAW' finalShoulderPosition' 200);  			}  		}  	}  	if (node == BusNode.CLAW_OPEN_PERCENT) {  		// scale to the valid range (1000 - 2000)  		finalHandPosition = 1500 + ((-hand + 50) * 10);  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalHandPosition - currentHandPosition) >= positionDeltaThreshold) {  			currentHandPosition = finalHandPosition;  			move (FINGERS' currentHandPosition' 400);  		}  	}  	if (node == BusNode.WRIST_PERCENT) {  		finalWristPosition = 1380 + (int)((-wrist_hand + 50) * 12.4f);  		if (Math.Abs (finalWristPosition - currentWristPosition) >= positionDeltaThreshold) {  			currentWristPosition = finalWristPosition;  			move (WRIST_JOINT' currentWristPosition' 300);  		}  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (armMoving) {  	if (node == BusNode.POSITION_TICK) {  		// TODO: All the other joints  		if (forearm != null) {  			//Debug.WriteLine("forearm: " + (forearm.Roll * 180) / Math.PI + " / " + (forearm.Pitch * 180) / Math.PI + " / " + (forearm.Yaw * 180) / Math.PI);  			if (forearm.Pitch > ELBOW_PITCH_MAX_DEG * RAD_PER_DEG)  				forearm.Pitch = (float)(ELBOW_PITCH_MAX_DEG * RAD_PER_DEG);  			if (forearm.Pitch < ELBOW_PITCH_MIN_DEG * RAD_PER_DEG)  				forearm.Pitch = (float)(ELBOW_PITCH_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (1500 - 2200)  			finalForearmPosition = 1500 + (int)(((forearm.Pitch - ELBOW_PITCH_MIN_DEG * RAD_PER_DEG) / ((ELBOW_PITCH_MAX_DEG - ELBOW_PITCH_MIN_DEG) * RAD_PER_DEG)) * 700);  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalForearmPosition - currentForearmPosition) >= positionDeltaThreshold) {  				currentForearmPosition = finalForearmPosition;  				move (ELBOW_JOINT' currentForearmPosition' 200);  				Debug.WriteLine ("Got " + currentForearmPosition);  			}  		}  		if (arm != null) {  			if (arm.Pitch > SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG)  				arm.Pitch = (float)(SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG);  			if (arm.Pitch < SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG)  				arm.Pitch = (float)(SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (800 - 2200)  			if (arm.Pitch > 0) {  				finalArmPosition = 1500 - (int)(((arm.Pitch / (SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG))) * 700);  			}  			else {  				finalArmPosition = 1500 + (int)(((Math.Abs (arm.Pitch) / (Math.Abs (SHOULDER_PITCH_MIN_DEG) * RAD_PER_DEG))) * 700);  			}  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalArmPosition - currentForearmPosition) >= positionDeltaThreshold) {  				currentArmPosition = finalArmPosition;  				//move(SHOULDER_PITCH' currentArmPosition' 200);  			}  		}  		if (arm != null) {  			if (arm.Yaw > SHOULDER_YAW_MAX_DEG * RAD_PER_DEG)  				arm.Yaw = (float)(SHOULDER_YAW_MAX_DEG * RAD_PER_DEG);  			if (arm.Yaw < SHOULDER_YAW_MIN_DEG * RAD_PER_DEG)  				arm.Yaw = (float)(SHOULDER_YAW_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (800 - 2200)  			if (arm.Yaw > 0) {  				finalShoulderPosition = 1500 - (int)(((arm.Yaw / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITC_MIN_DEG_PHYSICAL)))  				) * 700);  			}  			else {  				finalShoulderPosition = 1500 + (int)(((Math.Abs (arm.Yaw) / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITCH_MIN_DEG_PHYSICAL)))  				) * 700);  			}  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalShoulderPosition - currentShoulderPosition) >= positionDeltaThreshold) {  				currentShoulderPosition = finalShoulderPosition;  				//move(SHOULDER_YAW' finalShoulderPosition' 200);  			}  		}  	}  	if (node == BusNode.CLAW_OPEN_PERCENT) {  		// scale to the valid range (1000 - 2000)  		finalHandPosition = 1500 + ((-hand + 50) * 10);  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalHandPosition - currentHandPosition) >= positionDeltaThreshold) {  			currentHandPosition = finalHandPosition;  			move (FINGERS' currentHandPosition' 400);  		}  	}  	if (node == BusNode.WRIST_PERCENT) {  		finalWristPosition = 1380 + (int)((-wrist_hand + 50) * 12.4f);  		if (Math.Abs (finalWristPosition - currentWristPosition) >= positionDeltaThreshold) {  			currentWristPosition = finalWristPosition;  			move (WRIST_JOINT' currentWristPosition' 300);  		}  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (armMoving) {  	if (node == BusNode.POSITION_TICK) {  		// TODO: All the other joints  		if (forearm != null) {  			//Debug.WriteLine("forearm: " + (forearm.Roll * 180) / Math.PI + " / " + (forearm.Pitch * 180) / Math.PI + " / " + (forearm.Yaw * 180) / Math.PI);  			if (forearm.Pitch > ELBOW_PITCH_MAX_DEG * RAD_PER_DEG)  				forearm.Pitch = (float)(ELBOW_PITCH_MAX_DEG * RAD_PER_DEG);  			if (forearm.Pitch < ELBOW_PITCH_MIN_DEG * RAD_PER_DEG)  				forearm.Pitch = (float)(ELBOW_PITCH_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (1500 - 2200)  			finalForearmPosition = 1500 + (int)(((forearm.Pitch - ELBOW_PITCH_MIN_DEG * RAD_PER_DEG) / ((ELBOW_PITCH_MAX_DEG - ELBOW_PITCH_MIN_DEG) * RAD_PER_DEG)) * 700);  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalForearmPosition - currentForearmPosition) >= positionDeltaThreshold) {  				currentForearmPosition = finalForearmPosition;  				move (ELBOW_JOINT' currentForearmPosition' 200);  				Debug.WriteLine ("Got " + currentForearmPosition);  			}  		}  		if (arm != null) {  			if (arm.Pitch > SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG)  				arm.Pitch = (float)(SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG);  			if (arm.Pitch < SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG)  				arm.Pitch = (float)(SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (800 - 2200)  			if (arm.Pitch > 0) {  				finalArmPosition = 1500 - (int)(((arm.Pitch / (SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG))) * 700);  			}  			else {  				finalArmPosition = 1500 + (int)(((Math.Abs (arm.Pitch) / (Math.Abs (SHOULDER_PITCH_MIN_DEG) * RAD_PER_DEG))) * 700);  			}  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalArmPosition - currentForearmPosition) >= positionDeltaThreshold) {  				currentArmPosition = finalArmPosition;  				//move(SHOULDER_PITCH' currentArmPosition' 200);  			}  		}  		if (arm != null) {  			if (arm.Yaw > SHOULDER_YAW_MAX_DEG * RAD_PER_DEG)  				arm.Yaw = (float)(SHOULDER_YAW_MAX_DEG * RAD_PER_DEG);  			if (arm.Yaw < SHOULDER_YAW_MIN_DEG * RAD_PER_DEG)  				arm.Yaw = (float)(SHOULDER_YAW_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (800 - 2200)  			if (arm.Yaw > 0) {  				finalShoulderPosition = 1500 - (int)(((arm.Yaw / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITC_MIN_DEG_PHYSICAL)))  				) * 700);  			}  			else {  				finalShoulderPosition = 1500 + (int)(((Math.Abs (arm.Yaw) / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITCH_MIN_DEG_PHYSICAL)))  				) * 700);  			}  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalShoulderPosition - currentShoulderPosition) >= positionDeltaThreshold) {  				currentShoulderPosition = finalShoulderPosition;  				//move(SHOULDER_YAW' finalShoulderPosition' 200);  			}  		}  	}  	if (node == BusNode.CLAW_OPEN_PERCENT) {  		// scale to the valid range (1000 - 2000)  		finalHandPosition = 1500 + ((-hand + 50) * 10);  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalHandPosition - currentHandPosition) >= positionDeltaThreshold) {  			currentHandPosition = finalHandPosition;  			move (FINGERS' currentHandPosition' 400);  		}  	}  	if (node == BusNode.WRIST_PERCENT) {  		finalWristPosition = 1380 + (int)((-wrist_hand + 50) * 12.4f);  		if (Math.Abs (finalWristPosition - currentWristPosition) >= positionDeltaThreshold) {  			currentWristPosition = finalWristPosition;  			move (WRIST_JOINT' currentWristPosition' 300);  		}  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (armMoving) {  	if (node == BusNode.POSITION_TICK) {  		// TODO: All the other joints  		if (forearm != null) {  			//Debug.WriteLine("forearm: " + (forearm.Roll * 180) / Math.PI + " / " + (forearm.Pitch * 180) / Math.PI + " / " + (forearm.Yaw * 180) / Math.PI);  			if (forearm.Pitch > ELBOW_PITCH_MAX_DEG * RAD_PER_DEG)  				forearm.Pitch = (float)(ELBOW_PITCH_MAX_DEG * RAD_PER_DEG);  			if (forearm.Pitch < ELBOW_PITCH_MIN_DEG * RAD_PER_DEG)  				forearm.Pitch = (float)(ELBOW_PITCH_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (1500 - 2200)  			finalForearmPosition = 1500 + (int)(((forearm.Pitch - ELBOW_PITCH_MIN_DEG * RAD_PER_DEG) / ((ELBOW_PITCH_MAX_DEG - ELBOW_PITCH_MIN_DEG) * RAD_PER_DEG)) * 700);  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalForearmPosition - currentForearmPosition) >= positionDeltaThreshold) {  				currentForearmPosition = finalForearmPosition;  				move (ELBOW_JOINT' currentForearmPosition' 200);  				Debug.WriteLine ("Got " + currentForearmPosition);  			}  		}  		if (arm != null) {  			if (arm.Pitch > SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG)  				arm.Pitch = (float)(SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG);  			if (arm.Pitch < SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG)  				arm.Pitch = (float)(SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (800 - 2200)  			if (arm.Pitch > 0) {  				finalArmPosition = 1500 - (int)(((arm.Pitch / (SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG))) * 700);  			}  			else {  				finalArmPosition = 1500 + (int)(((Math.Abs (arm.Pitch) / (Math.Abs (SHOULDER_PITCH_MIN_DEG) * RAD_PER_DEG))) * 700);  			}  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalArmPosition - currentForearmPosition) >= positionDeltaThreshold) {  				currentArmPosition = finalArmPosition;  				//move(SHOULDER_PITCH' currentArmPosition' 200);  			}  		}  		if (arm != null) {  			if (arm.Yaw > SHOULDER_YAW_MAX_DEG * RAD_PER_DEG)  				arm.Yaw = (float)(SHOULDER_YAW_MAX_DEG * RAD_PER_DEG);  			if (arm.Yaw < SHOULDER_YAW_MIN_DEG * RAD_PER_DEG)  				arm.Yaw = (float)(SHOULDER_YAW_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (800 - 2200)  			if (arm.Yaw > 0) {  				finalShoulderPosition = 1500 - (int)(((arm.Yaw / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITC_MIN_DEG_PHYSICAL)))  				) * 700);  			}  			else {  				finalShoulderPosition = 1500 + (int)(((Math.Abs (arm.Yaw) / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITCH_MIN_DEG_PHYSICAL)))  				) * 700);  			}  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalShoulderPosition - currentShoulderPosition) >= positionDeltaThreshold) {  				currentShoulderPosition = finalShoulderPosition;  				//move(SHOULDER_YAW' finalShoulderPosition' 200);  			}  		}  	}  	if (node == BusNode.CLAW_OPEN_PERCENT) {  		// scale to the valid range (1000 - 2000)  		finalHandPosition = 1500 + ((-hand + 50) * 10);  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalHandPosition - currentHandPosition) >= positionDeltaThreshold) {  			currentHandPosition = finalHandPosition;  			move (FINGERS' currentHandPosition' 400);  		}  	}  	if (node == BusNode.WRIST_PERCENT) {  		finalWristPosition = 1380 + (int)((-wrist_hand + 50) * 12.4f);  		if (Math.Abs (finalWristPosition - currentWristPosition) >= positionDeltaThreshold) {  			currentWristPosition = finalWristPosition;  			move (WRIST_JOINT' currentWristPosition' 300);  		}  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (armMoving) {  	if (node == BusNode.POSITION_TICK) {  		// TODO: All the other joints  		if (forearm != null) {  			//Debug.WriteLine("forearm: " + (forearm.Roll * 180) / Math.PI + " / " + (forearm.Pitch * 180) / Math.PI + " / " + (forearm.Yaw * 180) / Math.PI);  			if (forearm.Pitch > ELBOW_PITCH_MAX_DEG * RAD_PER_DEG)  				forearm.Pitch = (float)(ELBOW_PITCH_MAX_DEG * RAD_PER_DEG);  			if (forearm.Pitch < ELBOW_PITCH_MIN_DEG * RAD_PER_DEG)  				forearm.Pitch = (float)(ELBOW_PITCH_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (1500 - 2200)  			finalForearmPosition = 1500 + (int)(((forearm.Pitch - ELBOW_PITCH_MIN_DEG * RAD_PER_DEG) / ((ELBOW_PITCH_MAX_DEG - ELBOW_PITCH_MIN_DEG) * RAD_PER_DEG)) * 700);  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalForearmPosition - currentForearmPosition) >= positionDeltaThreshold) {  				currentForearmPosition = finalForearmPosition;  				move (ELBOW_JOINT' currentForearmPosition' 200);  				Debug.WriteLine ("Got " + currentForearmPosition);  			}  		}  		if (arm != null) {  			if (arm.Pitch > SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG)  				arm.Pitch = (float)(SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG);  			if (arm.Pitch < SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG)  				arm.Pitch = (float)(SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (800 - 2200)  			if (arm.Pitch > 0) {  				finalArmPosition = 1500 - (int)(((arm.Pitch / (SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG))) * 700);  			}  			else {  				finalArmPosition = 1500 + (int)(((Math.Abs (arm.Pitch) / (Math.Abs (SHOULDER_PITCH_MIN_DEG) * RAD_PER_DEG))) * 700);  			}  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalArmPosition - currentForearmPosition) >= positionDeltaThreshold) {  				currentArmPosition = finalArmPosition;  				//move(SHOULDER_PITCH' currentArmPosition' 200);  			}  		}  		if (arm != null) {  			if (arm.Yaw > SHOULDER_YAW_MAX_DEG * RAD_PER_DEG)  				arm.Yaw = (float)(SHOULDER_YAW_MAX_DEG * RAD_PER_DEG);  			if (arm.Yaw < SHOULDER_YAW_MIN_DEG * RAD_PER_DEG)  				arm.Yaw = (float)(SHOULDER_YAW_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (800 - 2200)  			if (arm.Yaw > 0) {  				finalShoulderPosition = 1500 - (int)(((arm.Yaw / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITC_MIN_DEG_PHYSICAL)))  				) * 700);  			}  			else {  				finalShoulderPosition = 1500 + (int)(((Math.Abs (arm.Yaw) / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITCH_MIN_DEG_PHYSICAL)))  				) * 700);  			}  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalShoulderPosition - currentShoulderPosition) >= positionDeltaThreshold) {  				currentShoulderPosition = finalShoulderPosition;  				//move(SHOULDER_YAW' finalShoulderPosition' 200);  			}  		}  	}  	if (node == BusNode.CLAW_OPEN_PERCENT) {  		// scale to the valid range (1000 - 2000)  		finalHandPosition = 1500 + ((-hand + 50) * 10);  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalHandPosition - currentHandPosition) >= positionDeltaThreshold) {  			currentHandPosition = finalHandPosition;  			move (FINGERS' currentHandPosition' 400);  		}  	}  	if (node == BusNode.WRIST_PERCENT) {  		finalWristPosition = 1380 + (int)((-wrist_hand + 50) * 12.4f);  		if (Math.Abs (finalWristPosition - currentWristPosition) >= positionDeltaThreshold) {  			currentWristPosition = finalWristPosition;  			move (WRIST_JOINT' currentWristPosition' 300);  		}  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (armMoving) {  	if (node == BusNode.POSITION_TICK) {  		// TODO: All the other joints  		if (forearm != null) {  			//Debug.WriteLine("forearm: " + (forearm.Roll * 180) / Math.PI + " / " + (forearm.Pitch * 180) / Math.PI + " / " + (forearm.Yaw * 180) / Math.PI);  			if (forearm.Pitch > ELBOW_PITCH_MAX_DEG * RAD_PER_DEG)  				forearm.Pitch = (float)(ELBOW_PITCH_MAX_DEG * RAD_PER_DEG);  			if (forearm.Pitch < ELBOW_PITCH_MIN_DEG * RAD_PER_DEG)  				forearm.Pitch = (float)(ELBOW_PITCH_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (1500 - 2200)  			finalForearmPosition = 1500 + (int)(((forearm.Pitch - ELBOW_PITCH_MIN_DEG * RAD_PER_DEG) / ((ELBOW_PITCH_MAX_DEG - ELBOW_PITCH_MIN_DEG) * RAD_PER_DEG)) * 700);  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalForearmPosition - currentForearmPosition) >= positionDeltaThreshold) {  				currentForearmPosition = finalForearmPosition;  				move (ELBOW_JOINT' currentForearmPosition' 200);  				Debug.WriteLine ("Got " + currentForearmPosition);  			}  		}  		if (arm != null) {  			if (arm.Pitch > SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG)  				arm.Pitch = (float)(SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG);  			if (arm.Pitch < SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG)  				arm.Pitch = (float)(SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (800 - 2200)  			if (arm.Pitch > 0) {  				finalArmPosition = 1500 - (int)(((arm.Pitch / (SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG))) * 700);  			}  			else {  				finalArmPosition = 1500 + (int)(((Math.Abs (arm.Pitch) / (Math.Abs (SHOULDER_PITCH_MIN_DEG) * RAD_PER_DEG))) * 700);  			}  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalArmPosition - currentForearmPosition) >= positionDeltaThreshold) {  				currentArmPosition = finalArmPosition;  				//move(SHOULDER_PITCH' currentArmPosition' 200);  			}  		}  		if (arm != null) {  			if (arm.Yaw > SHOULDER_YAW_MAX_DEG * RAD_PER_DEG)  				arm.Yaw = (float)(SHOULDER_YAW_MAX_DEG * RAD_PER_DEG);  			if (arm.Yaw < SHOULDER_YAW_MIN_DEG * RAD_PER_DEG)  				arm.Yaw = (float)(SHOULDER_YAW_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (800 - 2200)  			if (arm.Yaw > 0) {  				finalShoulderPosition = 1500 - (int)(((arm.Yaw / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITC_MIN_DEG_PHYSICAL)))  				) * 700);  			}  			else {  				finalShoulderPosition = 1500 + (int)(((Math.Abs (arm.Yaw) / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITCH_MIN_DEG_PHYSICAL)))  				) * 700);  			}  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalShoulderPosition - currentShoulderPosition) >= positionDeltaThreshold) {  				currentShoulderPosition = finalShoulderPosition;  				//move(SHOULDER_YAW' finalShoulderPosition' 200);  			}  		}  	}  	if (node == BusNode.CLAW_OPEN_PERCENT) {  		// scale to the valid range (1000 - 2000)  		finalHandPosition = 1500 + ((-hand + 50) * 10);  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalHandPosition - currentHandPosition) >= positionDeltaThreshold) {  			currentHandPosition = finalHandPosition;  			move (FINGERS' currentHandPosition' 400);  		}  	}  	if (node == BusNode.WRIST_PERCENT) {  		finalWristPosition = 1380 + (int)((-wrist_hand + 50) * 12.4f);  		if (Math.Abs (finalWristPosition - currentWristPosition) >= positionDeltaThreshold) {  			currentWristPosition = finalWristPosition;  			move (WRIST_JOINT' currentWristPosition' 300);  		}  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (armMoving) {  	if (node == BusNode.POSITION_TICK) {  		// TODO: All the other joints  		if (forearm != null) {  			//Debug.WriteLine("forearm: " + (forearm.Roll * 180) / Math.PI + " / " + (forearm.Pitch * 180) / Math.PI + " / " + (forearm.Yaw * 180) / Math.PI);  			if (forearm.Pitch > ELBOW_PITCH_MAX_DEG * RAD_PER_DEG)  				forearm.Pitch = (float)(ELBOW_PITCH_MAX_DEG * RAD_PER_DEG);  			if (forearm.Pitch < ELBOW_PITCH_MIN_DEG * RAD_PER_DEG)  				forearm.Pitch = (float)(ELBOW_PITCH_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (1500 - 2200)  			finalForearmPosition = 1500 + (int)(((forearm.Pitch - ELBOW_PITCH_MIN_DEG * RAD_PER_DEG) / ((ELBOW_PITCH_MAX_DEG - ELBOW_PITCH_MIN_DEG) * RAD_PER_DEG)) * 700);  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalForearmPosition - currentForearmPosition) >= positionDeltaThreshold) {  				currentForearmPosition = finalForearmPosition;  				move (ELBOW_JOINT' currentForearmPosition' 200);  				Debug.WriteLine ("Got " + currentForearmPosition);  			}  		}  		if (arm != null) {  			if (arm.Pitch > SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG)  				arm.Pitch = (float)(SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG);  			if (arm.Pitch < SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG)  				arm.Pitch = (float)(SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (800 - 2200)  			if (arm.Pitch > 0) {  				finalArmPosition = 1500 - (int)(((arm.Pitch / (SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG))) * 700);  			}  			else {  				finalArmPosition = 1500 + (int)(((Math.Abs (arm.Pitch) / (Math.Abs (SHOULDER_PITCH_MIN_DEG) * RAD_PER_DEG))) * 700);  			}  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalArmPosition - currentForearmPosition) >= positionDeltaThreshold) {  				currentArmPosition = finalArmPosition;  				//move(SHOULDER_PITCH' currentArmPosition' 200);  			}  		}  		if (arm != null) {  			if (arm.Yaw > SHOULDER_YAW_MAX_DEG * RAD_PER_DEG)  				arm.Yaw = (float)(SHOULDER_YAW_MAX_DEG * RAD_PER_DEG);  			if (arm.Yaw < SHOULDER_YAW_MIN_DEG * RAD_PER_DEG)  				arm.Yaw = (float)(SHOULDER_YAW_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (800 - 2200)  			if (arm.Yaw > 0) {  				finalShoulderPosition = 1500 - (int)(((arm.Yaw / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITC_MIN_DEG_PHYSICAL)))  				) * 700);  			}  			else {  				finalShoulderPosition = 1500 + (int)(((Math.Abs (arm.Yaw) / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITCH_MIN_DEG_PHYSICAL)))  				) * 700);  			}  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalShoulderPosition - currentShoulderPosition) >= positionDeltaThreshold) {  				currentShoulderPosition = finalShoulderPosition;  				//move(SHOULDER_YAW' finalShoulderPosition' 200);  			}  		}  	}  	if (node == BusNode.CLAW_OPEN_PERCENT) {  		// scale to the valid range (1000 - 2000)  		finalHandPosition = 1500 + ((-hand + 50) * 10);  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalHandPosition - currentHandPosition) >= positionDeltaThreshold) {  			currentHandPosition = finalHandPosition;  			move (FINGERS' currentHandPosition' 400);  		}  	}  	if (node == BusNode.WRIST_PERCENT) {  		finalWristPosition = 1380 + (int)((-wrist_hand + 50) * 12.4f);  		if (Math.Abs (finalWristPosition - currentWristPosition) >= positionDeltaThreshold) {  			currentWristPosition = finalWristPosition;  			move (WRIST_JOINT' currentWristPosition' 300);  		}  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (armMoving) {  	if (node == BusNode.POSITION_TICK) {  		// TODO: All the other joints  		if (forearm != null) {  			//Debug.WriteLine("forearm: " + (forearm.Roll * 180) / Math.PI + " / " + (forearm.Pitch * 180) / Math.PI + " / " + (forearm.Yaw * 180) / Math.PI);  			if (forearm.Pitch > ELBOW_PITCH_MAX_DEG * RAD_PER_DEG)  				forearm.Pitch = (float)(ELBOW_PITCH_MAX_DEG * RAD_PER_DEG);  			if (forearm.Pitch < ELBOW_PITCH_MIN_DEG * RAD_PER_DEG)  				forearm.Pitch = (float)(ELBOW_PITCH_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (1500 - 2200)  			finalForearmPosition = 1500 + (int)(((forearm.Pitch - ELBOW_PITCH_MIN_DEG * RAD_PER_DEG) / ((ELBOW_PITCH_MAX_DEG - ELBOW_PITCH_MIN_DEG) * RAD_PER_DEG)) * 700);  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalForearmPosition - currentForearmPosition) >= positionDeltaThreshold) {  				currentForearmPosition = finalForearmPosition;  				move (ELBOW_JOINT' currentForearmPosition' 200);  				Debug.WriteLine ("Got " + currentForearmPosition);  			}  		}  		if (arm != null) {  			if (arm.Pitch > SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG)  				arm.Pitch = (float)(SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG);  			if (arm.Pitch < SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG)  				arm.Pitch = (float)(SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (800 - 2200)  			if (arm.Pitch > 0) {  				finalArmPosition = 1500 - (int)(((arm.Pitch / (SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG))) * 700);  			}  			else {  				finalArmPosition = 1500 + (int)(((Math.Abs (arm.Pitch) / (Math.Abs (SHOULDER_PITCH_MIN_DEG) * RAD_PER_DEG))) * 700);  			}  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalArmPosition - currentForearmPosition) >= positionDeltaThreshold) {  				currentArmPosition = finalArmPosition;  				//move(SHOULDER_PITCH' currentArmPosition' 200);  			}  		}  		if (arm != null) {  			if (arm.Yaw > SHOULDER_YAW_MAX_DEG * RAD_PER_DEG)  				arm.Yaw = (float)(SHOULDER_YAW_MAX_DEG * RAD_PER_DEG);  			if (arm.Yaw < SHOULDER_YAW_MIN_DEG * RAD_PER_DEG)  				arm.Yaw = (float)(SHOULDER_YAW_MIN_DEG * RAD_PER_DEG);  			// scale to the valid range (800 - 2200)  			if (arm.Yaw > 0) {  				finalShoulderPosition = 1500 - (int)(((arm.Yaw / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITC_MIN_DEG_PHYSICAL)))  				) * 700);  			}  			else {  				finalShoulderPosition = 1500 + (int)(((Math.Abs (arm.Yaw) / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITCH_MIN_DEG_PHYSICAL)))  				) * 700);  			}  			// move the stuff!  			// TODO: Do This correctly  			if (Math.Abs (finalShoulderPosition - currentShoulderPosition) >= positionDeltaThreshold) {  				currentShoulderPosition = finalShoulderPosition;  				//move(SHOULDER_YAW' finalShoulderPosition' 200);  			}  		}  	}  	if (node == BusNode.CLAW_OPEN_PERCENT) {  		// scale to the valid range (1000 - 2000)  		finalHandPosition = 1500 + ((-hand + 50) * 10);  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalHandPosition - currentHandPosition) >= positionDeltaThreshold) {  			currentHandPosition = finalHandPosition;  			move (FINGERS' currentHandPosition' 400);  		}  	}  	if (node == BusNode.WRIST_PERCENT) {  		finalWristPosition = 1380 + (int)((-wrist_hand + 50) * 12.4f);  		if (Math.Abs (finalWristPosition - currentWristPosition) >= positionDeltaThreshold) {  			currentWristPosition = finalWristPosition;  			move (WRIST_JOINT' currentWristPosition' 300);  		}  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (node == BusNode.POSITION_TICK) {  	// TODO: All the other joints  	if (forearm != null) {  		//Debug.WriteLine("forearm: " + (forearm.Roll * 180) / Math.PI + " / " + (forearm.Pitch * 180) / Math.PI + " / " + (forearm.Yaw * 180) / Math.PI);  		if (forearm.Pitch > ELBOW_PITCH_MAX_DEG * RAD_PER_DEG)  			forearm.Pitch = (float)(ELBOW_PITCH_MAX_DEG * RAD_PER_DEG);  		if (forearm.Pitch < ELBOW_PITCH_MIN_DEG * RAD_PER_DEG)  			forearm.Pitch = (float)(ELBOW_PITCH_MIN_DEG * RAD_PER_DEG);  		// scale to the valid range (1500 - 2200)  		finalForearmPosition = 1500 + (int)(((forearm.Pitch - ELBOW_PITCH_MIN_DEG * RAD_PER_DEG) / ((ELBOW_PITCH_MAX_DEG - ELBOW_PITCH_MIN_DEG) * RAD_PER_DEG)) * 700);  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalForearmPosition - currentForearmPosition) >= positionDeltaThreshold) {  			currentForearmPosition = finalForearmPosition;  			move (ELBOW_JOINT' currentForearmPosition' 200);  			Debug.WriteLine ("Got " + currentForearmPosition);  		}  	}  	if (arm != null) {  		if (arm.Pitch > SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG)  			arm.Pitch = (float)(SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG);  		if (arm.Pitch < SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG)  			arm.Pitch = (float)(SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG);  		// scale to the valid range (800 - 2200)  		if (arm.Pitch > 0) {  			finalArmPosition = 1500 - (int)(((arm.Pitch / (SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG))) * 700);  		}  		else {  			finalArmPosition = 1500 + (int)(((Math.Abs (arm.Pitch) / (Math.Abs (SHOULDER_PITCH_MIN_DEG) * RAD_PER_DEG))) * 700);  		}  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalArmPosition - currentForearmPosition) >= positionDeltaThreshold) {  			currentArmPosition = finalArmPosition;  			//move(SHOULDER_PITCH' currentArmPosition' 200);  		}  	}  	if (arm != null) {  		if (arm.Yaw > SHOULDER_YAW_MAX_DEG * RAD_PER_DEG)  			arm.Yaw = (float)(SHOULDER_YAW_MAX_DEG * RAD_PER_DEG);  		if (arm.Yaw < SHOULDER_YAW_MIN_DEG * RAD_PER_DEG)  			arm.Yaw = (float)(SHOULDER_YAW_MIN_DEG * RAD_PER_DEG);  		// scale to the valid range (800 - 2200)  		if (arm.Yaw > 0) {  			finalShoulderPosition = 1500 - (int)(((arm.Yaw / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITC_MIN_DEG_PHYSICAL)))  			) * 700);  		}  		else {  			finalShoulderPosition = 1500 + (int)(((Math.Abs (arm.Yaw) / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITCH_MIN_DEG_PHYSICAL)))  			) * 700);  		}  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalShoulderPosition - currentShoulderPosition) >= positionDeltaThreshold) {  			currentShoulderPosition = finalShoulderPosition;  			//move(SHOULDER_YAW' finalShoulderPosition' 200);  		}  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (node == BusNode.POSITION_TICK) {  	// TODO: All the other joints  	if (forearm != null) {  		//Debug.WriteLine("forearm: " + (forearm.Roll * 180) / Math.PI + " / " + (forearm.Pitch * 180) / Math.PI + " / " + (forearm.Yaw * 180) / Math.PI);  		if (forearm.Pitch > ELBOW_PITCH_MAX_DEG * RAD_PER_DEG)  			forearm.Pitch = (float)(ELBOW_PITCH_MAX_DEG * RAD_PER_DEG);  		if (forearm.Pitch < ELBOW_PITCH_MIN_DEG * RAD_PER_DEG)  			forearm.Pitch = (float)(ELBOW_PITCH_MIN_DEG * RAD_PER_DEG);  		// scale to the valid range (1500 - 2200)  		finalForearmPosition = 1500 + (int)(((forearm.Pitch - ELBOW_PITCH_MIN_DEG * RAD_PER_DEG) / ((ELBOW_PITCH_MAX_DEG - ELBOW_PITCH_MIN_DEG) * RAD_PER_DEG)) * 700);  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalForearmPosition - currentForearmPosition) >= positionDeltaThreshold) {  			currentForearmPosition = finalForearmPosition;  			move (ELBOW_JOINT' currentForearmPosition' 200);  			Debug.WriteLine ("Got " + currentForearmPosition);  		}  	}  	if (arm != null) {  		if (arm.Pitch > SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG)  			arm.Pitch = (float)(SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG);  		if (arm.Pitch < SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG)  			arm.Pitch = (float)(SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG);  		// scale to the valid range (800 - 2200)  		if (arm.Pitch > 0) {  			finalArmPosition = 1500 - (int)(((arm.Pitch / (SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG))) * 700);  		}  		else {  			finalArmPosition = 1500 + (int)(((Math.Abs (arm.Pitch) / (Math.Abs (SHOULDER_PITCH_MIN_DEG) * RAD_PER_DEG))) * 700);  		}  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalArmPosition - currentForearmPosition) >= positionDeltaThreshold) {  			currentArmPosition = finalArmPosition;  			//move(SHOULDER_PITCH' currentArmPosition' 200);  		}  	}  	if (arm != null) {  		if (arm.Yaw > SHOULDER_YAW_MAX_DEG * RAD_PER_DEG)  			arm.Yaw = (float)(SHOULDER_YAW_MAX_DEG * RAD_PER_DEG);  		if (arm.Yaw < SHOULDER_YAW_MIN_DEG * RAD_PER_DEG)  			arm.Yaw = (float)(SHOULDER_YAW_MIN_DEG * RAD_PER_DEG);  		// scale to the valid range (800 - 2200)  		if (arm.Yaw > 0) {  			finalShoulderPosition = 1500 - (int)(((arm.Yaw / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITC_MIN_DEG_PHYSICAL)))  			) * 700);  		}  		else {  			finalShoulderPosition = 1500 + (int)(((Math.Abs (arm.Yaw) / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITCH_MIN_DEG_PHYSICAL)))  			) * 700);  		}  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalShoulderPosition - currentShoulderPosition) >= positionDeltaThreshold) {  			currentShoulderPosition = finalShoulderPosition;  			//move(SHOULDER_YAW' finalShoulderPosition' 200);  		}  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (node == BusNode.POSITION_TICK) {  	// TODO: All the other joints  	if (forearm != null) {  		//Debug.WriteLine("forearm: " + (forearm.Roll * 180) / Math.PI + " / " + (forearm.Pitch * 180) / Math.PI + " / " + (forearm.Yaw * 180) / Math.PI);  		if (forearm.Pitch > ELBOW_PITCH_MAX_DEG * RAD_PER_DEG)  			forearm.Pitch = (float)(ELBOW_PITCH_MAX_DEG * RAD_PER_DEG);  		if (forearm.Pitch < ELBOW_PITCH_MIN_DEG * RAD_PER_DEG)  			forearm.Pitch = (float)(ELBOW_PITCH_MIN_DEG * RAD_PER_DEG);  		// scale to the valid range (1500 - 2200)  		finalForearmPosition = 1500 + (int)(((forearm.Pitch - ELBOW_PITCH_MIN_DEG * RAD_PER_DEG) / ((ELBOW_PITCH_MAX_DEG - ELBOW_PITCH_MIN_DEG) * RAD_PER_DEG)) * 700);  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalForearmPosition - currentForearmPosition) >= positionDeltaThreshold) {  			currentForearmPosition = finalForearmPosition;  			move (ELBOW_JOINT' currentForearmPosition' 200);  			Debug.WriteLine ("Got " + currentForearmPosition);  		}  	}  	if (arm != null) {  		if (arm.Pitch > SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG)  			arm.Pitch = (float)(SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG);  		if (arm.Pitch < SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG)  			arm.Pitch = (float)(SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG);  		// scale to the valid range (800 - 2200)  		if (arm.Pitch > 0) {  			finalArmPosition = 1500 - (int)(((arm.Pitch / (SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG))) * 700);  		}  		else {  			finalArmPosition = 1500 + (int)(((Math.Abs (arm.Pitch) / (Math.Abs (SHOULDER_PITCH_MIN_DEG) * RAD_PER_DEG))) * 700);  		}  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalArmPosition - currentForearmPosition) >= positionDeltaThreshold) {  			currentArmPosition = finalArmPosition;  			//move(SHOULDER_PITCH' currentArmPosition' 200);  		}  	}  	if (arm != null) {  		if (arm.Yaw > SHOULDER_YAW_MAX_DEG * RAD_PER_DEG)  			arm.Yaw = (float)(SHOULDER_YAW_MAX_DEG * RAD_PER_DEG);  		if (arm.Yaw < SHOULDER_YAW_MIN_DEG * RAD_PER_DEG)  			arm.Yaw = (float)(SHOULDER_YAW_MIN_DEG * RAD_PER_DEG);  		// scale to the valid range (800 - 2200)  		if (arm.Yaw > 0) {  			finalShoulderPosition = 1500 - (int)(((arm.Yaw / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITC_MIN_DEG_PHYSICAL)))  			) * 700);  		}  		else {  			finalShoulderPosition = 1500 + (int)(((Math.Abs (arm.Yaw) / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITCH_MIN_DEG_PHYSICAL)))  			) * 700);  		}  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalShoulderPosition - currentShoulderPosition) >= positionDeltaThreshold) {  			currentShoulderPosition = finalShoulderPosition;  			//move(SHOULDER_YAW' finalShoulderPosition' 200);  		}  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (node == BusNode.POSITION_TICK) {  	// TODO: All the other joints  	if (forearm != null) {  		//Debug.WriteLine("forearm: " + (forearm.Roll * 180) / Math.PI + " / " + (forearm.Pitch * 180) / Math.PI + " / " + (forearm.Yaw * 180) / Math.PI);  		if (forearm.Pitch > ELBOW_PITCH_MAX_DEG * RAD_PER_DEG)  			forearm.Pitch = (float)(ELBOW_PITCH_MAX_DEG * RAD_PER_DEG);  		if (forearm.Pitch < ELBOW_PITCH_MIN_DEG * RAD_PER_DEG)  			forearm.Pitch = (float)(ELBOW_PITCH_MIN_DEG * RAD_PER_DEG);  		// scale to the valid range (1500 - 2200)  		finalForearmPosition = 1500 + (int)(((forearm.Pitch - ELBOW_PITCH_MIN_DEG * RAD_PER_DEG) / ((ELBOW_PITCH_MAX_DEG - ELBOW_PITCH_MIN_DEG) * RAD_PER_DEG)) * 700);  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalForearmPosition - currentForearmPosition) >= positionDeltaThreshold) {  			currentForearmPosition = finalForearmPosition;  			move (ELBOW_JOINT' currentForearmPosition' 200);  			Debug.WriteLine ("Got " + currentForearmPosition);  		}  	}  	if (arm != null) {  		if (arm.Pitch > SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG)  			arm.Pitch = (float)(SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG);  		if (arm.Pitch < SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG)  			arm.Pitch = (float)(SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG);  		// scale to the valid range (800 - 2200)  		if (arm.Pitch > 0) {  			finalArmPosition = 1500 - (int)(((arm.Pitch / (SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG))) * 700);  		}  		else {  			finalArmPosition = 1500 + (int)(((Math.Abs (arm.Pitch) / (Math.Abs (SHOULDER_PITCH_MIN_DEG) * RAD_PER_DEG))) * 700);  		}  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalArmPosition - currentForearmPosition) >= positionDeltaThreshold) {  			currentArmPosition = finalArmPosition;  			//move(SHOULDER_PITCH' currentArmPosition' 200);  		}  	}  	if (arm != null) {  		if (arm.Yaw > SHOULDER_YAW_MAX_DEG * RAD_PER_DEG)  			arm.Yaw = (float)(SHOULDER_YAW_MAX_DEG * RAD_PER_DEG);  		if (arm.Yaw < SHOULDER_YAW_MIN_DEG * RAD_PER_DEG)  			arm.Yaw = (float)(SHOULDER_YAW_MIN_DEG * RAD_PER_DEG);  		// scale to the valid range (800 - 2200)  		if (arm.Yaw > 0) {  			finalShoulderPosition = 1500 - (int)(((arm.Yaw / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITC_MIN_DEG_PHYSICAL)))  			) * 700);  		}  		else {  			finalShoulderPosition = 1500 + (int)(((Math.Abs (arm.Yaw) / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITCH_MIN_DEG_PHYSICAL)))  			) * 700);  		}  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalShoulderPosition - currentShoulderPosition) >= positionDeltaThreshold) {  			currentShoulderPosition = finalShoulderPosition;  			//move(SHOULDER_YAW' finalShoulderPosition' 200);  		}  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (node == BusNode.POSITION_TICK) {  	// TODO: All the other joints  	if (forearm != null) {  		//Debug.WriteLine("forearm: " + (forearm.Roll * 180) / Math.PI + " / " + (forearm.Pitch * 180) / Math.PI + " / " + (forearm.Yaw * 180) / Math.PI);  		if (forearm.Pitch > ELBOW_PITCH_MAX_DEG * RAD_PER_DEG)  			forearm.Pitch = (float)(ELBOW_PITCH_MAX_DEG * RAD_PER_DEG);  		if (forearm.Pitch < ELBOW_PITCH_MIN_DEG * RAD_PER_DEG)  			forearm.Pitch = (float)(ELBOW_PITCH_MIN_DEG * RAD_PER_DEG);  		// scale to the valid range (1500 - 2200)  		finalForearmPosition = 1500 + (int)(((forearm.Pitch - ELBOW_PITCH_MIN_DEG * RAD_PER_DEG) / ((ELBOW_PITCH_MAX_DEG - ELBOW_PITCH_MIN_DEG) * RAD_PER_DEG)) * 700);  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalForearmPosition - currentForearmPosition) >= positionDeltaThreshold) {  			currentForearmPosition = finalForearmPosition;  			move (ELBOW_JOINT' currentForearmPosition' 200);  			Debug.WriteLine ("Got " + currentForearmPosition);  		}  	}  	if (arm != null) {  		if (arm.Pitch > SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG)  			arm.Pitch = (float)(SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG);  		if (arm.Pitch < SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG)  			arm.Pitch = (float)(SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG);  		// scale to the valid range (800 - 2200)  		if (arm.Pitch > 0) {  			finalArmPosition = 1500 - (int)(((arm.Pitch / (SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG))) * 700);  		}  		else {  			finalArmPosition = 1500 + (int)(((Math.Abs (arm.Pitch) / (Math.Abs (SHOULDER_PITCH_MIN_DEG) * RAD_PER_DEG))) * 700);  		}  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalArmPosition - currentForearmPosition) >= positionDeltaThreshold) {  			currentArmPosition = finalArmPosition;  			//move(SHOULDER_PITCH' currentArmPosition' 200);  		}  	}  	if (arm != null) {  		if (arm.Yaw > SHOULDER_YAW_MAX_DEG * RAD_PER_DEG)  			arm.Yaw = (float)(SHOULDER_YAW_MAX_DEG * RAD_PER_DEG);  		if (arm.Yaw < SHOULDER_YAW_MIN_DEG * RAD_PER_DEG)  			arm.Yaw = (float)(SHOULDER_YAW_MIN_DEG * RAD_PER_DEG);  		// scale to the valid range (800 - 2200)  		if (arm.Yaw > 0) {  			finalShoulderPosition = 1500 - (int)(((arm.Yaw / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITC_MIN_DEG_PHYSICAL)))  			) * 700);  		}  		else {  			finalShoulderPosition = 1500 + (int)(((Math.Abs (arm.Yaw) / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITCH_MIN_DEG_PHYSICAL)))  			) * 700);  		}  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalShoulderPosition - currentShoulderPosition) >= positionDeltaThreshold) {  			currentShoulderPosition = finalShoulderPosition;  			//move(SHOULDER_YAW' finalShoulderPosition' 200);  		}  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (node == BusNode.POSITION_TICK) {  	// TODO: All the other joints  	if (forearm != null) {  		//Debug.WriteLine("forearm: " + (forearm.Roll * 180) / Math.PI + " / " + (forearm.Pitch * 180) / Math.PI + " / " + (forearm.Yaw * 180) / Math.PI);  		if (forearm.Pitch > ELBOW_PITCH_MAX_DEG * RAD_PER_DEG)  			forearm.Pitch = (float)(ELBOW_PITCH_MAX_DEG * RAD_PER_DEG);  		if (forearm.Pitch < ELBOW_PITCH_MIN_DEG * RAD_PER_DEG)  			forearm.Pitch = (float)(ELBOW_PITCH_MIN_DEG * RAD_PER_DEG);  		// scale to the valid range (1500 - 2200)  		finalForearmPosition = 1500 + (int)(((forearm.Pitch - ELBOW_PITCH_MIN_DEG * RAD_PER_DEG) / ((ELBOW_PITCH_MAX_DEG - ELBOW_PITCH_MIN_DEG) * RAD_PER_DEG)) * 700);  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalForearmPosition - currentForearmPosition) >= positionDeltaThreshold) {  			currentForearmPosition = finalForearmPosition;  			move (ELBOW_JOINT' currentForearmPosition' 200);  			Debug.WriteLine ("Got " + currentForearmPosition);  		}  	}  	if (arm != null) {  		if (arm.Pitch > SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG)  			arm.Pitch = (float)(SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG);  		if (arm.Pitch < SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG)  			arm.Pitch = (float)(SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG);  		// scale to the valid range (800 - 2200)  		if (arm.Pitch > 0) {  			finalArmPosition = 1500 - (int)(((arm.Pitch / (SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG))) * 700);  		}  		else {  			finalArmPosition = 1500 + (int)(((Math.Abs (arm.Pitch) / (Math.Abs (SHOULDER_PITCH_MIN_DEG) * RAD_PER_DEG))) * 700);  		}  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalArmPosition - currentForearmPosition) >= positionDeltaThreshold) {  			currentArmPosition = finalArmPosition;  			//move(SHOULDER_PITCH' currentArmPosition' 200);  		}  	}  	if (arm != null) {  		if (arm.Yaw > SHOULDER_YAW_MAX_DEG * RAD_PER_DEG)  			arm.Yaw = (float)(SHOULDER_YAW_MAX_DEG * RAD_PER_DEG);  		if (arm.Yaw < SHOULDER_YAW_MIN_DEG * RAD_PER_DEG)  			arm.Yaw = (float)(SHOULDER_YAW_MIN_DEG * RAD_PER_DEG);  		// scale to the valid range (800 - 2200)  		if (arm.Yaw > 0) {  			finalShoulderPosition = 1500 - (int)(((arm.Yaw / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITC_MIN_DEG_PHYSICAL)))  			) * 700);  		}  		else {  			finalShoulderPosition = 1500 + (int)(((Math.Abs (arm.Yaw) / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITCH_MIN_DEG_PHYSICAL)))  			) * 700);  		}  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalShoulderPosition - currentShoulderPosition) >= positionDeltaThreshold) {  			currentShoulderPosition = finalShoulderPosition;  			//move(SHOULDER_YAW' finalShoulderPosition' 200);  		}  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (node == BusNode.POSITION_TICK) {  	// TODO: All the other joints  	if (forearm != null) {  		//Debug.WriteLine("forearm: " + (forearm.Roll * 180) / Math.PI + " / " + (forearm.Pitch * 180) / Math.PI + " / " + (forearm.Yaw * 180) / Math.PI);  		if (forearm.Pitch > ELBOW_PITCH_MAX_DEG * RAD_PER_DEG)  			forearm.Pitch = (float)(ELBOW_PITCH_MAX_DEG * RAD_PER_DEG);  		if (forearm.Pitch < ELBOW_PITCH_MIN_DEG * RAD_PER_DEG)  			forearm.Pitch = (float)(ELBOW_PITCH_MIN_DEG * RAD_PER_DEG);  		// scale to the valid range (1500 - 2200)  		finalForearmPosition = 1500 + (int)(((forearm.Pitch - ELBOW_PITCH_MIN_DEG * RAD_PER_DEG) / ((ELBOW_PITCH_MAX_DEG - ELBOW_PITCH_MIN_DEG) * RAD_PER_DEG)) * 700);  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalForearmPosition - currentForearmPosition) >= positionDeltaThreshold) {  			currentForearmPosition = finalForearmPosition;  			move (ELBOW_JOINT' currentForearmPosition' 200);  			Debug.WriteLine ("Got " + currentForearmPosition);  		}  	}  	if (arm != null) {  		if (arm.Pitch > SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG)  			arm.Pitch = (float)(SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG);  		if (arm.Pitch < SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG)  			arm.Pitch = (float)(SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG);  		// scale to the valid range (800 - 2200)  		if (arm.Pitch > 0) {  			finalArmPosition = 1500 - (int)(((arm.Pitch / (SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG))) * 700);  		}  		else {  			finalArmPosition = 1500 + (int)(((Math.Abs (arm.Pitch) / (Math.Abs (SHOULDER_PITCH_MIN_DEG) * RAD_PER_DEG))) * 700);  		}  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalArmPosition - currentForearmPosition) >= positionDeltaThreshold) {  			currentArmPosition = finalArmPosition;  			//move(SHOULDER_PITCH' currentArmPosition' 200);  		}  	}  	if (arm != null) {  		if (arm.Yaw > SHOULDER_YAW_MAX_DEG * RAD_PER_DEG)  			arm.Yaw = (float)(SHOULDER_YAW_MAX_DEG * RAD_PER_DEG);  		if (arm.Yaw < SHOULDER_YAW_MIN_DEG * RAD_PER_DEG)  			arm.Yaw = (float)(SHOULDER_YAW_MIN_DEG * RAD_PER_DEG);  		// scale to the valid range (800 - 2200)  		if (arm.Yaw > 0) {  			finalShoulderPosition = 1500 - (int)(((arm.Yaw / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITC_MIN_DEG_PHYSICAL)))  			) * 700);  		}  		else {  			finalShoulderPosition = 1500 + (int)(((Math.Abs (arm.Yaw) / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITCH_MIN_DEG_PHYSICAL)))  			) * 700);  		}  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalShoulderPosition - currentShoulderPosition) >= positionDeltaThreshold) {  			currentShoulderPosition = finalShoulderPosition;  			//move(SHOULDER_YAW' finalShoulderPosition' 200);  		}  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (node == BusNode.POSITION_TICK) {  	// TODO: All the other joints  	if (forearm != null) {  		//Debug.WriteLine("forearm: " + (forearm.Roll * 180) / Math.PI + " / " + (forearm.Pitch * 180) / Math.PI + " / " + (forearm.Yaw * 180) / Math.PI);  		if (forearm.Pitch > ELBOW_PITCH_MAX_DEG * RAD_PER_DEG)  			forearm.Pitch = (float)(ELBOW_PITCH_MAX_DEG * RAD_PER_DEG);  		if (forearm.Pitch < ELBOW_PITCH_MIN_DEG * RAD_PER_DEG)  			forearm.Pitch = (float)(ELBOW_PITCH_MIN_DEG * RAD_PER_DEG);  		// scale to the valid range (1500 - 2200)  		finalForearmPosition = 1500 + (int)(((forearm.Pitch - ELBOW_PITCH_MIN_DEG * RAD_PER_DEG) / ((ELBOW_PITCH_MAX_DEG - ELBOW_PITCH_MIN_DEG) * RAD_PER_DEG)) * 700);  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalForearmPosition - currentForearmPosition) >= positionDeltaThreshold) {  			currentForearmPosition = finalForearmPosition;  			move (ELBOW_JOINT' currentForearmPosition' 200);  			Debug.WriteLine ("Got " + currentForearmPosition);  		}  	}  	if (arm != null) {  		if (arm.Pitch > SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG)  			arm.Pitch = (float)(SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG);  		if (arm.Pitch < SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG)  			arm.Pitch = (float)(SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG);  		// scale to the valid range (800 - 2200)  		if (arm.Pitch > 0) {  			finalArmPosition = 1500 - (int)(((arm.Pitch / (SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG))) * 700);  		}  		else {  			finalArmPosition = 1500 + (int)(((Math.Abs (arm.Pitch) / (Math.Abs (SHOULDER_PITCH_MIN_DEG) * RAD_PER_DEG))) * 700);  		}  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalArmPosition - currentForearmPosition) >= positionDeltaThreshold) {  			currentArmPosition = finalArmPosition;  			//move(SHOULDER_PITCH' currentArmPosition' 200);  		}  	}  	if (arm != null) {  		if (arm.Yaw > SHOULDER_YAW_MAX_DEG * RAD_PER_DEG)  			arm.Yaw = (float)(SHOULDER_YAW_MAX_DEG * RAD_PER_DEG);  		if (arm.Yaw < SHOULDER_YAW_MIN_DEG * RAD_PER_DEG)  			arm.Yaw = (float)(SHOULDER_YAW_MIN_DEG * RAD_PER_DEG);  		// scale to the valid range (800 - 2200)  		if (arm.Yaw > 0) {  			finalShoulderPosition = 1500 - (int)(((arm.Yaw / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITC_MIN_DEG_PHYSICAL)))  			) * 700);  		}  		else {  			finalShoulderPosition = 1500 + (int)(((Math.Abs (arm.Yaw) / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITCH_MIN_DEG_PHYSICAL)))  			) * 700);  		}  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalShoulderPosition - currentShoulderPosition) >= positionDeltaThreshold) {  			currentShoulderPosition = finalShoulderPosition;  			//move(SHOULDER_YAW' finalShoulderPosition' 200);  		}  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (node == BusNode.POSITION_TICK) {  	// TODO: All the other joints  	if (forearm != null) {  		//Debug.WriteLine("forearm: " + (forearm.Roll * 180) / Math.PI + " / " + (forearm.Pitch * 180) / Math.PI + " / " + (forearm.Yaw * 180) / Math.PI);  		if (forearm.Pitch > ELBOW_PITCH_MAX_DEG * RAD_PER_DEG)  			forearm.Pitch = (float)(ELBOW_PITCH_MAX_DEG * RAD_PER_DEG);  		if (forearm.Pitch < ELBOW_PITCH_MIN_DEG * RAD_PER_DEG)  			forearm.Pitch = (float)(ELBOW_PITCH_MIN_DEG * RAD_PER_DEG);  		// scale to the valid range (1500 - 2200)  		finalForearmPosition = 1500 + (int)(((forearm.Pitch - ELBOW_PITCH_MIN_DEG * RAD_PER_DEG) / ((ELBOW_PITCH_MAX_DEG - ELBOW_PITCH_MIN_DEG) * RAD_PER_DEG)) * 700);  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalForearmPosition - currentForearmPosition) >= positionDeltaThreshold) {  			currentForearmPosition = finalForearmPosition;  			move (ELBOW_JOINT' currentForearmPosition' 200);  			Debug.WriteLine ("Got " + currentForearmPosition);  		}  	}  	if (arm != null) {  		if (arm.Pitch > SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG)  			arm.Pitch = (float)(SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG);  		if (arm.Pitch < SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG)  			arm.Pitch = (float)(SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG);  		// scale to the valid range (800 - 2200)  		if (arm.Pitch > 0) {  			finalArmPosition = 1500 - (int)(((arm.Pitch / (SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG))) * 700);  		}  		else {  			finalArmPosition = 1500 + (int)(((Math.Abs (arm.Pitch) / (Math.Abs (SHOULDER_PITCH_MIN_DEG) * RAD_PER_DEG))) * 700);  		}  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalArmPosition - currentForearmPosition) >= positionDeltaThreshold) {  			currentArmPosition = finalArmPosition;  			//move(SHOULDER_PITCH' currentArmPosition' 200);  		}  	}  	if (arm != null) {  		if (arm.Yaw > SHOULDER_YAW_MAX_DEG * RAD_PER_DEG)  			arm.Yaw = (float)(SHOULDER_YAW_MAX_DEG * RAD_PER_DEG);  		if (arm.Yaw < SHOULDER_YAW_MIN_DEG * RAD_PER_DEG)  			arm.Yaw = (float)(SHOULDER_YAW_MIN_DEG * RAD_PER_DEG);  		// scale to the valid range (800 - 2200)  		if (arm.Yaw > 0) {  			finalShoulderPosition = 1500 - (int)(((arm.Yaw / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITC_MIN_DEG_PHYSICAL)))  			) * 700);  		}  		else {  			finalShoulderPosition = 1500 + (int)(((Math.Abs (arm.Yaw) / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITCH_MIN_DEG_PHYSICAL)))  			) * 700);  		}  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalShoulderPosition - currentShoulderPosition) >= positionDeltaThreshold) {  			currentShoulderPosition = finalShoulderPosition;  			//move(SHOULDER_YAW' finalShoulderPosition' 200);  		}  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (node == BusNode.POSITION_TICK) {  	// TODO: All the other joints  	if (forearm != null) {  		//Debug.WriteLine("forearm: " + (forearm.Roll * 180) / Math.PI + " / " + (forearm.Pitch * 180) / Math.PI + " / " + (forearm.Yaw * 180) / Math.PI);  		if (forearm.Pitch > ELBOW_PITCH_MAX_DEG * RAD_PER_DEG)  			forearm.Pitch = (float)(ELBOW_PITCH_MAX_DEG * RAD_PER_DEG);  		if (forearm.Pitch < ELBOW_PITCH_MIN_DEG * RAD_PER_DEG)  			forearm.Pitch = (float)(ELBOW_PITCH_MIN_DEG * RAD_PER_DEG);  		// scale to the valid range (1500 - 2200)  		finalForearmPosition = 1500 + (int)(((forearm.Pitch - ELBOW_PITCH_MIN_DEG * RAD_PER_DEG) / ((ELBOW_PITCH_MAX_DEG - ELBOW_PITCH_MIN_DEG) * RAD_PER_DEG)) * 700);  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalForearmPosition - currentForearmPosition) >= positionDeltaThreshold) {  			currentForearmPosition = finalForearmPosition;  			move (ELBOW_JOINT' currentForearmPosition' 200);  			Debug.WriteLine ("Got " + currentForearmPosition);  		}  	}  	if (arm != null) {  		if (arm.Pitch > SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG)  			arm.Pitch = (float)(SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG);  		if (arm.Pitch < SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG)  			arm.Pitch = (float)(SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG);  		// scale to the valid range (800 - 2200)  		if (arm.Pitch > 0) {  			finalArmPosition = 1500 - (int)(((arm.Pitch / (SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG))) * 700);  		}  		else {  			finalArmPosition = 1500 + (int)(((Math.Abs (arm.Pitch) / (Math.Abs (SHOULDER_PITCH_MIN_DEG) * RAD_PER_DEG))) * 700);  		}  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalArmPosition - currentForearmPosition) >= positionDeltaThreshold) {  			currentArmPosition = finalArmPosition;  			//move(SHOULDER_PITCH' currentArmPosition' 200);  		}  	}  	if (arm != null) {  		if (arm.Yaw > SHOULDER_YAW_MAX_DEG * RAD_PER_DEG)  			arm.Yaw = (float)(SHOULDER_YAW_MAX_DEG * RAD_PER_DEG);  		if (arm.Yaw < SHOULDER_YAW_MIN_DEG * RAD_PER_DEG)  			arm.Yaw = (float)(SHOULDER_YAW_MIN_DEG * RAD_PER_DEG);  		// scale to the valid range (800 - 2200)  		if (arm.Yaw > 0) {  			finalShoulderPosition = 1500 - (int)(((arm.Yaw / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITC_MIN_DEG_PHYSICAL)))  			) * 700);  		}  		else {  			finalShoulderPosition = 1500 + (int)(((Math.Abs (arm.Yaw) / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITCH_MIN_DEG_PHYSICAL)))  			) * 700);  		}  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalShoulderPosition - currentShoulderPosition) >= positionDeltaThreshold) {  			currentShoulderPosition = finalShoulderPosition;  			//move(SHOULDER_YAW' finalShoulderPosition' 200);  		}  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (node == BusNode.POSITION_TICK) {  	// TODO: All the other joints  	if (forearm != null) {  		//Debug.WriteLine("forearm: " + (forearm.Roll * 180) / Math.PI + " / " + (forearm.Pitch * 180) / Math.PI + " / " + (forearm.Yaw * 180) / Math.PI);  		if (forearm.Pitch > ELBOW_PITCH_MAX_DEG * RAD_PER_DEG)  			forearm.Pitch = (float)(ELBOW_PITCH_MAX_DEG * RAD_PER_DEG);  		if (forearm.Pitch < ELBOW_PITCH_MIN_DEG * RAD_PER_DEG)  			forearm.Pitch = (float)(ELBOW_PITCH_MIN_DEG * RAD_PER_DEG);  		// scale to the valid range (1500 - 2200)  		finalForearmPosition = 1500 + (int)(((forearm.Pitch - ELBOW_PITCH_MIN_DEG * RAD_PER_DEG) / ((ELBOW_PITCH_MAX_DEG - ELBOW_PITCH_MIN_DEG) * RAD_PER_DEG)) * 700);  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalForearmPosition - currentForearmPosition) >= positionDeltaThreshold) {  			currentForearmPosition = finalForearmPosition;  			move (ELBOW_JOINT' currentForearmPosition' 200);  			Debug.WriteLine ("Got " + currentForearmPosition);  		}  	}  	if (arm != null) {  		if (arm.Pitch > SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG)  			arm.Pitch = (float)(SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG);  		if (arm.Pitch < SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG)  			arm.Pitch = (float)(SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG);  		// scale to the valid range (800 - 2200)  		if (arm.Pitch > 0) {  			finalArmPosition = 1500 - (int)(((arm.Pitch / (SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG))) * 700);  		}  		else {  			finalArmPosition = 1500 + (int)(((Math.Abs (arm.Pitch) / (Math.Abs (SHOULDER_PITCH_MIN_DEG) * RAD_PER_DEG))) * 700);  		}  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalArmPosition - currentForearmPosition) >= positionDeltaThreshold) {  			currentArmPosition = finalArmPosition;  			//move(SHOULDER_PITCH' currentArmPosition' 200);  		}  	}  	if (arm != null) {  		if (arm.Yaw > SHOULDER_YAW_MAX_DEG * RAD_PER_DEG)  			arm.Yaw = (float)(SHOULDER_YAW_MAX_DEG * RAD_PER_DEG);  		if (arm.Yaw < SHOULDER_YAW_MIN_DEG * RAD_PER_DEG)  			arm.Yaw = (float)(SHOULDER_YAW_MIN_DEG * RAD_PER_DEG);  		// scale to the valid range (800 - 2200)  		if (arm.Yaw > 0) {  			finalShoulderPosition = 1500 - (int)(((arm.Yaw / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITC_MIN_DEG_PHYSICAL)))  			) * 700);  		}  		else {  			finalShoulderPosition = 1500 + (int)(((Math.Abs (arm.Yaw) / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITCH_MIN_DEG_PHYSICAL)))  			) * 700);  		}  		// move the stuff!  		// TODO: Do This correctly  		if (Math.Abs (finalShoulderPosition - currentShoulderPosition) >= positionDeltaThreshold) {  			currentShoulderPosition = finalShoulderPosition;  			//move(SHOULDER_YAW' finalShoulderPosition' 200);  		}  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (forearm != null) {  	//Debug.WriteLine("forearm: " + (forearm.Roll * 180) / Math.PI + " / " + (forearm.Pitch * 180) / Math.PI + " / " + (forearm.Yaw * 180) / Math.PI);  	if (forearm.Pitch > ELBOW_PITCH_MAX_DEG * RAD_PER_DEG)  		forearm.Pitch = (float)(ELBOW_PITCH_MAX_DEG * RAD_PER_DEG);  	if (forearm.Pitch < ELBOW_PITCH_MIN_DEG * RAD_PER_DEG)  		forearm.Pitch = (float)(ELBOW_PITCH_MIN_DEG * RAD_PER_DEG);  	// scale to the valid range (1500 - 2200)  	finalForearmPosition = 1500 + (int)(((forearm.Pitch - ELBOW_PITCH_MIN_DEG * RAD_PER_DEG) / ((ELBOW_PITCH_MAX_DEG - ELBOW_PITCH_MIN_DEG) * RAD_PER_DEG)) * 700);  	// move the stuff!  	// TODO: Do This correctly  	if (Math.Abs (finalForearmPosition - currentForearmPosition) >= positionDeltaThreshold) {  		currentForearmPosition = finalForearmPosition;  		move (ELBOW_JOINT' currentForearmPosition' 200);  		Debug.WriteLine ("Got " + currentForearmPosition);  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (forearm != null) {  	//Debug.WriteLine("forearm: " + (forearm.Roll * 180) / Math.PI + " / " + (forearm.Pitch * 180) / Math.PI + " / " + (forearm.Yaw * 180) / Math.PI);  	if (forearm.Pitch > ELBOW_PITCH_MAX_DEG * RAD_PER_DEG)  		forearm.Pitch = (float)(ELBOW_PITCH_MAX_DEG * RAD_PER_DEG);  	if (forearm.Pitch < ELBOW_PITCH_MIN_DEG * RAD_PER_DEG)  		forearm.Pitch = (float)(ELBOW_PITCH_MIN_DEG * RAD_PER_DEG);  	// scale to the valid range (1500 - 2200)  	finalForearmPosition = 1500 + (int)(((forearm.Pitch - ELBOW_PITCH_MIN_DEG * RAD_PER_DEG) / ((ELBOW_PITCH_MAX_DEG - ELBOW_PITCH_MIN_DEG) * RAD_PER_DEG)) * 700);  	// move the stuff!  	// TODO: Do This correctly  	if (Math.Abs (finalForearmPosition - currentForearmPosition) >= positionDeltaThreshold) {  		currentForearmPosition = finalForearmPosition;  		move (ELBOW_JOINT' currentForearmPosition' 200);  		Debug.WriteLine ("Got " + currentForearmPosition);  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (forearm != null) {  	//Debug.WriteLine("forearm: " + (forearm.Roll * 180) / Math.PI + " / " + (forearm.Pitch * 180) / Math.PI + " / " + (forearm.Yaw * 180) / Math.PI);  	if (forearm.Pitch > ELBOW_PITCH_MAX_DEG * RAD_PER_DEG)  		forearm.Pitch = (float)(ELBOW_PITCH_MAX_DEG * RAD_PER_DEG);  	if (forearm.Pitch < ELBOW_PITCH_MIN_DEG * RAD_PER_DEG)  		forearm.Pitch = (float)(ELBOW_PITCH_MIN_DEG * RAD_PER_DEG);  	// scale to the valid range (1500 - 2200)  	finalForearmPosition = 1500 + (int)(((forearm.Pitch - ELBOW_PITCH_MIN_DEG * RAD_PER_DEG) / ((ELBOW_PITCH_MAX_DEG - ELBOW_PITCH_MIN_DEG) * RAD_PER_DEG)) * 700);  	// move the stuff!  	// TODO: Do This correctly  	if (Math.Abs (finalForearmPosition - currentForearmPosition) >= positionDeltaThreshold) {  		currentForearmPosition = finalForearmPosition;  		move (ELBOW_JOINT' currentForearmPosition' 200);  		Debug.WriteLine ("Got " + currentForearmPosition);  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: finalForearmPosition = 1500 + (int)(((forearm.Pitch - ELBOW_PITCH_MIN_DEG * RAD_PER_DEG) / ((ELBOW_PITCH_MAX_DEG - ELBOW_PITCH_MIN_DEG) * RAD_PER_DEG)) * 700);  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: finalForearmPosition = 1500 + (int)(((forearm.Pitch - ELBOW_PITCH_MIN_DEG * RAD_PER_DEG) / ((ELBOW_PITCH_MAX_DEG - ELBOW_PITCH_MIN_DEG) * RAD_PER_DEG)) * 700);  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (Math.Abs (finalForearmPosition - currentForearmPosition) >= positionDeltaThreshold) {  	currentForearmPosition = finalForearmPosition;  	move (ELBOW_JOINT' currentForearmPosition' 200);  	Debug.WriteLine ("Got " + currentForearmPosition);  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: move (ELBOW_JOINT' currentForearmPosition' 200);  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (arm != null) {  	if (arm.Pitch > SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG)  		arm.Pitch = (float)(SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG);  	if (arm.Pitch < SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG)  		arm.Pitch = (float)(SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG);  	// scale to the valid range (800 - 2200)  	if (arm.Pitch > 0) {  		finalArmPosition = 1500 - (int)(((arm.Pitch / (SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG))) * 700);  	}  	else {  		finalArmPosition = 1500 + (int)(((Math.Abs (arm.Pitch) / (Math.Abs (SHOULDER_PITCH_MIN_DEG) * RAD_PER_DEG))) * 700);  	}  	// move the stuff!  	// TODO: Do This correctly  	if (Math.Abs (finalArmPosition - currentForearmPosition) >= positionDeltaThreshold) {  		currentArmPosition = finalArmPosition;  		//move(SHOULDER_PITCH' currentArmPosition' 200);  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (arm != null) {  	if (arm.Pitch > SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG)  		arm.Pitch = (float)(SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG);  	if (arm.Pitch < SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG)  		arm.Pitch = (float)(SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG);  	// scale to the valid range (800 - 2200)  	if (arm.Pitch > 0) {  		finalArmPosition = 1500 - (int)(((arm.Pitch / (SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG))) * 700);  	}  	else {  		finalArmPosition = 1500 + (int)(((Math.Abs (arm.Pitch) / (Math.Abs (SHOULDER_PITCH_MIN_DEG) * RAD_PER_DEG))) * 700);  	}  	// move the stuff!  	// TODO: Do This correctly  	if (Math.Abs (finalArmPosition - currentForearmPosition) >= positionDeltaThreshold) {  		currentArmPosition = finalArmPosition;  		//move(SHOULDER_PITCH' currentArmPosition' 200);  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (arm != null) {  	if (arm.Pitch > SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG)  		arm.Pitch = (float)(SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG);  	if (arm.Pitch < SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG)  		arm.Pitch = (float)(SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG);  	// scale to the valid range (800 - 2200)  	if (arm.Pitch > 0) {  		finalArmPosition = 1500 - (int)(((arm.Pitch / (SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG))) * 700);  	}  	else {  		finalArmPosition = 1500 + (int)(((Math.Abs (arm.Pitch) / (Math.Abs (SHOULDER_PITCH_MIN_DEG) * RAD_PER_DEG))) * 700);  	}  	// move the stuff!  	// TODO: Do This correctly  	if (Math.Abs (finalArmPosition - currentForearmPosition) >= positionDeltaThreshold) {  		currentArmPosition = finalArmPosition;  		//move(SHOULDER_PITCH' currentArmPosition' 200);  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (arm != null) {  	if (arm.Pitch > SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG)  		arm.Pitch = (float)(SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG);  	if (arm.Pitch < SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG)  		arm.Pitch = (float)(SHOULDER_PITCH_MIN_DEG * RAD_PER_DEG);  	// scale to the valid range (800 - 2200)  	if (arm.Pitch > 0) {  		finalArmPosition = 1500 - (int)(((arm.Pitch / (SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG))) * 700);  	}  	else {  		finalArmPosition = 1500 + (int)(((Math.Abs (arm.Pitch) / (Math.Abs (SHOULDER_PITCH_MIN_DEG) * RAD_PER_DEG))) * 700);  	}  	// move the stuff!  	// TODO: Do This correctly  	if (Math.Abs (finalArmPosition - currentForearmPosition) >= positionDeltaThreshold) {  		currentArmPosition = finalArmPosition;  		//move(SHOULDER_PITCH' currentArmPosition' 200);  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (arm.Pitch > 0) {  	finalArmPosition = 1500 - (int)(((arm.Pitch / (SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG))) * 700);  }  else {  	finalArmPosition = 1500 + (int)(((Math.Abs (arm.Pitch) / (Math.Abs (SHOULDER_PITCH_MIN_DEG) * RAD_PER_DEG))) * 700);  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (arm.Pitch > 0) {  	finalArmPosition = 1500 - (int)(((arm.Pitch / (SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG))) * 700);  }  else {  	finalArmPosition = 1500 + (int)(((Math.Abs (arm.Pitch) / (Math.Abs (SHOULDER_PITCH_MIN_DEG) * RAD_PER_DEG))) * 700);  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (arm.Pitch > 0) {  	finalArmPosition = 1500 - (int)(((arm.Pitch / (SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG))) * 700);  }  else {  	finalArmPosition = 1500 + (int)(((Math.Abs (arm.Pitch) / (Math.Abs (SHOULDER_PITCH_MIN_DEG) * RAD_PER_DEG))) * 700);  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (arm.Pitch > 0) {  	finalArmPosition = 1500 - (int)(((arm.Pitch / (SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG))) * 700);  }  else {  	finalArmPosition = 1500 + (int)(((Math.Abs (arm.Pitch) / (Math.Abs (SHOULDER_PITCH_MIN_DEG) * RAD_PER_DEG))) * 700);  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: finalArmPosition = 1500 - (int)(((arm.Pitch / (SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG))) * 700);  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: finalArmPosition = 1500 - (int)(((arm.Pitch / (SHOULDER_PITCH_MAX_DEG * RAD_PER_DEG))) * 700);  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: finalArmPosition = 1500 + (int)(((Math.Abs (arm.Pitch) / (Math.Abs (SHOULDER_PITCH_MIN_DEG) * RAD_PER_DEG))) * 700);  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: finalArmPosition = 1500 + (int)(((Math.Abs (arm.Pitch) / (Math.Abs (SHOULDER_PITCH_MIN_DEG) * RAD_PER_DEG))) * 700);  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (arm != null) {  	if (arm.Yaw > SHOULDER_YAW_MAX_DEG * RAD_PER_DEG)  		arm.Yaw = (float)(SHOULDER_YAW_MAX_DEG * RAD_PER_DEG);  	if (arm.Yaw < SHOULDER_YAW_MIN_DEG * RAD_PER_DEG)  		arm.Yaw = (float)(SHOULDER_YAW_MIN_DEG * RAD_PER_DEG);  	// scale to the valid range (800 - 2200)  	if (arm.Yaw > 0) {  		finalShoulderPosition = 1500 - (int)(((arm.Yaw / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITC_MIN_DEG_PHYSICAL)))  		) * 700);  	}  	else {  		finalShoulderPosition = 1500 + (int)(((Math.Abs (arm.Yaw) / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITCH_MIN_DEG_PHYSICAL)))  		) * 700);  	}  	// move the stuff!  	// TODO: Do This correctly  	if (Math.Abs (finalShoulderPosition - currentShoulderPosition) >= positionDeltaThreshold) {  		currentShoulderPosition = finalShoulderPosition;  		//move(SHOULDER_YAW' finalShoulderPosition' 200);  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (arm != null) {  	if (arm.Yaw > SHOULDER_YAW_MAX_DEG * RAD_PER_DEG)  		arm.Yaw = (float)(SHOULDER_YAW_MAX_DEG * RAD_PER_DEG);  	if (arm.Yaw < SHOULDER_YAW_MIN_DEG * RAD_PER_DEG)  		arm.Yaw = (float)(SHOULDER_YAW_MIN_DEG * RAD_PER_DEG);  	// scale to the valid range (800 - 2200)  	if (arm.Yaw > 0) {  		finalShoulderPosition = 1500 - (int)(((arm.Yaw / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITC_MIN_DEG_PHYSICAL)))  		) * 700);  	}  	else {  		finalShoulderPosition = 1500 + (int)(((Math.Abs (arm.Yaw) / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITCH_MIN_DEG_PHYSICAL)))  		) * 700);  	}  	// move the stuff!  	// TODO: Do This correctly  	if (Math.Abs (finalShoulderPosition - currentShoulderPosition) >= positionDeltaThreshold) {  		currentShoulderPosition = finalShoulderPosition;  		//move(SHOULDER_YAW' finalShoulderPosition' 200);  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (arm != null) {  	if (arm.Yaw > SHOULDER_YAW_MAX_DEG * RAD_PER_DEG)  		arm.Yaw = (float)(SHOULDER_YAW_MAX_DEG * RAD_PER_DEG);  	if (arm.Yaw < SHOULDER_YAW_MIN_DEG * RAD_PER_DEG)  		arm.Yaw = (float)(SHOULDER_YAW_MIN_DEG * RAD_PER_DEG);  	// scale to the valid range (800 - 2200)  	if (arm.Yaw > 0) {  		finalShoulderPosition = 1500 - (int)(((arm.Yaw / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITC_MIN_DEG_PHYSICAL)))  		) * 700);  	}  	else {  		finalShoulderPosition = 1500 + (int)(((Math.Abs (arm.Yaw) / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITCH_MIN_DEG_PHYSICAL)))  		) * 700);  	}  	// move the stuff!  	// TODO: Do This correctly  	if (Math.Abs (finalShoulderPosition - currentShoulderPosition) >= positionDeltaThreshold) {  		currentShoulderPosition = finalShoulderPosition;  		//move(SHOULDER_YAW' finalShoulderPosition' 200);  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (arm != null) {  	if (arm.Yaw > SHOULDER_YAW_MAX_DEG * RAD_PER_DEG)  		arm.Yaw = (float)(SHOULDER_YAW_MAX_DEG * RAD_PER_DEG);  	if (arm.Yaw < SHOULDER_YAW_MIN_DEG * RAD_PER_DEG)  		arm.Yaw = (float)(SHOULDER_YAW_MIN_DEG * RAD_PER_DEG);  	// scale to the valid range (800 - 2200)  	if (arm.Yaw > 0) {  		finalShoulderPosition = 1500 - (int)(((arm.Yaw / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITC_MIN_DEG_PHYSICAL)))  		) * 700);  	}  	else {  		finalShoulderPosition = 1500 + (int)(((Math.Abs (arm.Yaw) / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITCH_MIN_DEG_PHYSICAL)))  		) * 700);  	}  	// move the stuff!  	// TODO: Do This correctly  	if (Math.Abs (finalShoulderPosition - currentShoulderPosition) >= positionDeltaThreshold) {  		currentShoulderPosition = finalShoulderPosition;  		//move(SHOULDER_YAW' finalShoulderPosition' 200);  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (arm.Yaw > 0) {  	finalShoulderPosition = 1500 - (int)(((arm.Yaw / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITC_MIN_DEG_PHYSICAL)))  	) * 700);  }  else {  	finalShoulderPosition = 1500 + (int)(((Math.Abs (arm.Yaw) / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITCH_MIN_DEG_PHYSICAL)))  	) * 700);  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (arm.Yaw > 0) {  	finalShoulderPosition = 1500 - (int)(((arm.Yaw / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITC_MIN_DEG_PHYSICAL)))  	) * 700);  }  else {  	finalShoulderPosition = 1500 + (int)(((Math.Abs (arm.Yaw) / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITCH_MIN_DEG_PHYSICAL)))  	) * 700);  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (arm.Yaw > 0) {  	finalShoulderPosition = 1500 - (int)(((arm.Yaw / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITC_MIN_DEG_PHYSICAL)))  	) * 700);  }  else {  	finalShoulderPosition = 1500 + (int)(((Math.Abs (arm.Yaw) / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITCH_MIN_DEG_PHYSICAL)))  	) * 700);  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (arm.Yaw > 0) {  	finalShoulderPosition = 1500 - (int)(((arm.Yaw / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITC_MIN_DEG_PHYSICAL)))  	) * 700);  }  else {  	finalShoulderPosition = 1500 + (int)(((Math.Abs (arm.Yaw) / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITCH_MIN_DEG_PHYSICAL)))  	) * 700);  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: finalShoulderPosition = 1500 - (int)(((arm.Yaw / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITC_MIN_DEG_PHYSICAL)))  ) * 700);  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: finalShoulderPosition = 1500 - (int)(((arm.Yaw / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITC_MIN_DEG_PHYSICAL)))  ) * 700);  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: finalShoulderPosition = 1500 + (int)(((Math.Abs (arm.Yaw) / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITCH_MIN_DEG_PHYSICAL)))  ) * 700);  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: finalShoulderPosition = 1500 + (int)(((Math.Abs (arm.Yaw) / ((SHOULDER_YAW_MAX_DEG - SHOULDER_YAW_MIN_DEG) * RAD_PER_DEG))//* (180 / ((float)Math.Abs(SHOULDER_PITCH_MIN_DEG_PHYSICAL)))  ) * 700);  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (node == BusNode.CLAW_OPEN_PERCENT) {  	// scale to the valid range (1000 - 2000)  	finalHandPosition = 1500 + ((-hand + 50) * 10);  	// move the stuff!  	// TODO: Do This correctly  	if (Math.Abs (finalHandPosition - currentHandPosition) >= positionDeltaThreshold) {  		currentHandPosition = finalHandPosition;  		move (FINGERS' currentHandPosition' 400);  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (node == BusNode.CLAW_OPEN_PERCENT) {  	// scale to the valid range (1000 - 2000)  	finalHandPosition = 1500 + ((-hand + 50) * 10);  	// move the stuff!  	// TODO: Do This correctly  	if (Math.Abs (finalHandPosition - currentHandPosition) >= positionDeltaThreshold) {  		currentHandPosition = finalHandPosition;  		move (FINGERS' currentHandPosition' 400);  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (node == BusNode.CLAW_OPEN_PERCENT) {  	// scale to the valid range (1000 - 2000)  	finalHandPosition = 1500 + ((-hand + 50) * 10);  	// move the stuff!  	// TODO: Do This correctly  	if (Math.Abs (finalHandPosition - currentHandPosition) >= positionDeltaThreshold) {  		currentHandPosition = finalHandPosition;  		move (FINGERS' currentHandPosition' 400);  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (node == BusNode.CLAW_OPEN_PERCENT) {  	// scale to the valid range (1000 - 2000)  	finalHandPosition = 1500 + ((-hand + 50) * 10);  	// move the stuff!  	// TODO: Do This correctly  	if (Math.Abs (finalHandPosition - currentHandPosition) >= positionDeltaThreshold) {  		currentHandPosition = finalHandPosition;  		move (FINGERS' currentHandPosition' 400);  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: finalHandPosition = 1500 + ((-hand + 50) * 10);  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: finalHandPosition = 1500 + ((-hand + 50) * 10);  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: finalHandPosition = 1500 + ((-hand + 50) * 10);  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (Math.Abs (finalHandPosition - currentHandPosition) >= positionDeltaThreshold) {  	currentHandPosition = finalHandPosition;  	move (FINGERS' currentHandPosition' 400);  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: move (FINGERS' currentHandPosition' 400);  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (node == BusNode.WRIST_PERCENT) {  	finalWristPosition = 1380 + (int)((-wrist_hand + 50) * 12.4f);  	if (Math.Abs (finalWristPosition - currentWristPosition) >= positionDeltaThreshold) {  		currentWristPosition = finalWristPosition;  		move (WRIST_JOINT' currentWristPosition' 300);  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (node == BusNode.WRIST_PERCENT) {  	finalWristPosition = 1380 + (int)((-wrist_hand + 50) * 12.4f);  	if (Math.Abs (finalWristPosition - currentWristPosition) >= positionDeltaThreshold) {  		currentWristPosition = finalWristPosition;  		move (WRIST_JOINT' currentWristPosition' 300);  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (node == BusNode.WRIST_PERCENT) {  	finalWristPosition = 1380 + (int)((-wrist_hand + 50) * 12.4f);  	if (Math.Abs (finalWristPosition - currentWristPosition) >= positionDeltaThreshold) {  		currentWristPosition = finalWristPosition;  		move (WRIST_JOINT' currentWristPosition' 300);  	}  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: finalWristPosition = 1380 + (int)((-wrist_hand + 50) * 12.4f);  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: finalWristPosition = 1380 + (int)((-wrist_hand + 50) * 12.4f);  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: if (Math.Abs (finalWristPosition - currentWristPosition) >= positionDeltaThreshold) {  	currentWristPosition = finalWristPosition;  	move (WRIST_JOINT' currentWristPosition' 300);  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,OnValuePublished,The following statement contains a magic number: move (WRIST_JOINT' currentWristPosition' 300);  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,move,The following statement contains a magic number: if (pos < 800 || pos > 2200) {  	Debug.WriteLine ("ERROR: servo " + servo + " set to invalid position " + pos);  	pos = (pos < 800) ? 800 : 2200;  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,move,The following statement contains a magic number: if (pos < 800 || pos > 2200) {  	Debug.WriteLine ("ERROR: servo " + servo + " set to invalid position " + pos);  	pos = (pos < 800) ? 800 : 2200;  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,move,The following statement contains a magic number: if (pos < 800 || pos > 2200) {  	Debug.WriteLine ("ERROR: servo " + servo + " set to invalid position " + pos);  	pos = (pos < 800) ? 800 : 2200;  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,move,The following statement contains a magic number: if (pos < 800 || pos > 2200) {  	Debug.WriteLine ("ERROR: servo " + servo + " set to invalid position " + pos);  	pos = (pos < 800) ? 800 : 2200;  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,move,The following statement contains a magic number: if (pos < 800 || pos > 2200) {  	Debug.WriteLine ("ERROR: servo " + servo + " set to invalid position " + pos);  	pos = (pos < 800) ? 800 : 2200;  }  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,move,The following statement contains a magic number: pos = (pos < 800) ? 800 : 2200;  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,move,The following statement contains a magic number: pos = (pos < 800) ? 800 : 2200;  
Magic Number,ArmController.Robot_Arm_Module,RobotArmModule,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Robot Arm Module\RobotArmModule.cs,move,The following statement contains a magic number: pos = (pos < 800) ? 800 : 2200;  
Magic Number,ArmController.Kinect_Module,PositionFeedback,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Kinect Module\PositionFeedback.cs,OrientationToString,The following statement contains a magic number: return (or.Roll * (180 / Math.PI)).ToString ("F2") + " / " + (or.Pitch * (180 / Math.PI)).ToString ("F2") + " / " + (or.Yaw * (180 / Math.PI)).ToString ("F2");  
Magic Number,ArmController.Kinect_Module,PositionFeedback,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Kinect Module\PositionFeedback.cs,OrientationToString,The following statement contains a magic number: return (or.Roll * (180 / Math.PI)).ToString ("F2") + " / " + (or.Pitch * (180 / Math.PI)).ToString ("F2") + " / " + (or.Yaw * (180 / Math.PI)).ToString ("F2");  
Magic Number,ArmController.Kinect_Module,PositionFeedback,C:\repos\babb517_Robotic-Arm-Controller\RobotArmControl\ArmController\Kinect Module\PositionFeedback.cs,OrientationToString,The following statement contains a magic number: return (or.Roll * (180 / Math.PI)).ToString ("F2") + " / " + (or.Pitch * (180 / Math.PI)).ToString ("F2") + " / " + (or.Yaw * (180 / Math.PI)).ToString ("F2");  
