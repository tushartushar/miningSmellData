Implementation smell,Namespace,Class,File,Method,Description
Long Method,fyiReporting.RDL,Chart,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Chart.cs,Chart,The method has 124 lines of code.
Long Method,fyiReporting.RDL,Chart,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Chart.cs,RunPage,The method has 123 lines of code.
Long Method,fyiReporting.RDL,Chart,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Chart.cs,GenerateMatrixSeries,The method has 126 lines of code.
Long Method,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The method has 290 lines of code.
Long Method,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawPlotAreaPlain,The method has 134 lines of code.
Long Method,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawCategoryAxis,The method has 137 lines of code.
Long Method,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,Draw2ndValueAxis,The method has 151 lines of code.
Long Method,fyiReporting.RDL,Code,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Code.cs,GetAssembly,The method has 108 lines of code.
Long Method,fyiReporting.RDL,DrawString,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawString.cs,DoInstructions,The method has 102 lines of code.
Long Method,fyiReporting.RDL,Query,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Query.cs,GetData,The method has 101 lines of code.
Long Method,fyiReporting.RDL,ReportDefn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportDefn.cs,ReportDefn,The method has 149 lines of code.
Long Method,fyiReporting.RDL,Style,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Style.cs,Style,The method has 127 lines of code.
Long Method,fyiReporting.RDL,Style,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Style.cs,DrawBorder,The method has 150 lines of code.
Long Method,fyiReporting.RDL,Table,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Table.cs,PrepGroups,The method has 128 lines of code.
Long Method,fyiReporting.RDL,LaxBinder,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\LaxBinder.cs,CanConvertFrom,The method has 114 lines of code.
Long Method,fyiReporting.RDL,RenderBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderBase.cs,ProcessPage,The method has 170 lines of code.
Long Method,fyiReporting.RDL,RenderBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderBase.cs,MeasureString,The method has 147 lines of code.
Long Method,fyiReporting.RDL,RenderPdf_iTextSharp,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf_iTextSharp.cs,AddText,The method has 361 lines of code.
Long Method,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,WriteGridData,The method has 109 lines of code.
Long Method,fyiReporting.RDL,RenderTif,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderTif.cs,DrawString,The method has 109 lines of code.
Long Method,fyiReporting.RDL,RenderHtmlTable,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\HtmlConverter\RenderHtmlTable.cs,ScriptGenerate,The method has 197 lines of code.
Long Method,fyiReporting.RDL,Lexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Lexer.cs,GetNextToken,The method has 100 lines of code.
Long Method,fyiReporting.RDL,Parser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Parser.cs,MatchFuncIDent,The method has 457 lines of code.
Long Method,fyiReporting.RDL,Parser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Parser.cs,ResolveMethodCall,The method has 118 lines of code.
Long Method,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddText,The method has 151 lines of code.
Long Method,fyiReporting.RDL,RenderHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderHtml.cs,ScriptGenerate,The method has 197 lines of code.
Long Method,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The method has 310 lines of code.
Long Method,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,ProcessPage,The method has 257 lines of code.
Long Method,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,MeasureString,The method has 147 lines of code.
Long Method,fyiReporting.RDL,PageTextHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtml.cs,BuildPrivate,The method has 319 lines of code.
Long Method,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The method has 158 lines of code.
Long Method,fyiReporting.RDL,RdlEngineConfig,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\RdlEngineConfig.cs,RdlEngineConfigInit,The method has 167 lines of code.
Long Method,System.Drawing,GraphicsExtended,C:\repos\majorsilence_My-FyiReporting\RdlEngine\GraphicsExtended.cs,DrawStringJustified,The method has 223 lines of code.
Complex Method,fyiReporting.RDL,Axis,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Axis.cs,FinalPass,Cyclomatic complexity of the method is 10
Complex Method,fyiReporting.RDL,Chart,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Chart.cs,FinalPass,Cyclomatic complexity of the method is 18
Complex Method,fyiReporting.RDL,Chart,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Chart.cs,RunPage,Cyclomatic complexity of the method is 9
Complex Method,fyiReporting.RDL,ChartBar,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBar.cs,CategoryAxisSize,Cyclomatic complexity of the method is 8
Complex Method,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,Cyclomatic complexity of the method is 19
Complex Method,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetMaxMinDataValue,Cyclomatic complexity of the method is 8
Complex Method,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetValueMaxMin,Cyclomatic complexity of the method is 8
Complex Method,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,AdjustMargins,Cyclomatic complexity of the method is 8
Complex Method,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawPlot,Cyclomatic complexity of the method is 12
Complex Method,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawPlotAreaPercentStacked,Cyclomatic complexity of the method is 9
Complex Method,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawPlotAreaPlain,Cyclomatic complexity of the method is 12
Complex Method,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,CategoryAxisSize,Cyclomatic complexity of the method is 11
Complex Method,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawCategoryAxis,Cyclomatic complexity of the method is 20
Complex Method,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,Draw2ndValueAxis,Cyclomatic complexity of the method is 10
Complex Method,fyiReporting.RDL,ChartExpression,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartExpression.cs,FinalPass,Cyclomatic complexity of the method is 9
Complex Method,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,DrawPlotAreaAreaPercentStacked,Cyclomatic complexity of the method is 8
Complex Method,fyiReporting.RDL,Code,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Code.cs,GetAssembly,Cyclomatic complexity of the method is 10
Complex Method,fyiReporting.RDL,ChartMap,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMap.cs,DrawMap,Cyclomatic complexity of the method is 10
Complex Method,fyiReporting.RDL,DataRegion,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataRegion.cs,GetFilteredData,Cyclomatic complexity of the method is 9
Complex Method,fyiReporting.RDL,DataSetDefn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataSetDefn.cs,DataSetDefn,Cyclomatic complexity of the method is 8
Complex Method,fyiReporting.RDL,EmbeddedImage,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EmbeddedImage.cs,EmbeddedImage,Cyclomatic complexity of the method is 9
Complex Method,fyiReporting.RDL,DrawString,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawString.cs,DoInstructions,Cyclomatic complexity of the method is 8
Complex Method,fyiReporting.RDL,EMFPen,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFObjects\EMFPen.cs,EMFPen,Cyclomatic complexity of the method is 16
Complex Method,fyiReporting.RDL,Expression,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Expression.cs,FinalPass,Cyclomatic complexity of the method is 8
Complex Method,fyiReporting.RDL,Filter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Filter.cs,ApplyTopBottomFilter,Cyclomatic complexity of the method is 10
Complex Method,fyiReporting.RDL,Filter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Filter.cs,ApplyCompare,Cyclomatic complexity of the method is 18
Complex Method,fyiReporting.RDL,Grouping,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Grouping.cs,Grouping,Cyclomatic complexity of the method is 8
Complex Method,fyiReporting.RDL,Grouping,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Grouping.cs,FinalPass,Cyclomatic complexity of the method is 9
Complex Method,fyiReporting.RDL,List,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\List.cs,FinalPass,Cyclomatic complexity of the method is 10
Complex Method,fyiReporting.RDL,List,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\List.cs,PrepGroups,Cyclomatic complexity of the method is 13
Complex Method,fyiReporting.RDL,List,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\List.cs,RunPageGroups,Cyclomatic complexity of the method is 9
Complex Method,fyiReporting.RDL,Matrix,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Matrix.cs,Matrix,Cyclomatic complexity of the method is 12
Complex Method,fyiReporting.RDL,Matrix,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Matrix.cs,HeightOfRow,Cyclomatic complexity of the method is 18
Complex Method,fyiReporting.RDL,Matrix,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Matrix.cs,RunGetColumnWidth,Cyclomatic complexity of the method is 13
Complex Method,fyiReporting.RDL,Query,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Query.cs,FinalPass,Cyclomatic complexity of the method is 9
Complex Method,fyiReporting.RDL,Query,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Query.cs,GetData,Cyclomatic complexity of the method is 14
Complex Method,fyiReporting.RDL,Query,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Query.cs,GetData,Cyclomatic complexity of the method is 11
Complex Method,fyiReporting.RDL,Query,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Query.cs,SetData,Cyclomatic complexity of the method is 8
Complex Method,fyiReporting.RDL,Query,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Query.cs,SetData,Cyclomatic complexity of the method is 11
Complex Method,fyiReporting.RDL,Query,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Query.cs,AddParametersAsLiterals,Cyclomatic complexity of the method is 8
Complex Method,fyiReporting.RDL,QueryParameter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\QueryParameter.cs,QueryParameter,Cyclomatic complexity of the method is 8
Complex Method,fyiReporting.RDL,ReportDefn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportDefn.cs,ReportDefn,Cyclomatic complexity of the method is 10
Complex Method,fyiReporting.RDL,ReportDefn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportDefn.cs,FinalPass,Cyclomatic complexity of the method is 11
Complex Method,fyiReporting.RDL,ReportItem,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportItem.cs,FinalPass,Cyclomatic complexity of the method is 12
Complex Method,fyiReporting.RDL,ReportItem,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportItem.cs,PositioningFinalPass,Cyclomatic complexity of the method is 11
Complex Method,fyiReporting.RDL,ReportParameter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportParameter.cs,ReportParameter,Cyclomatic complexity of the method is 8
Complex Method,fyiReporting.RDL,ReportParameters,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportParameters.cs,SetRuntimeValues,Cyclomatic complexity of the method is 8
Complex Method,fyiReporting.RDL,Rows,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Rows.cs,Rows,Cyclomatic complexity of the method is 9
Complex Method,fyiReporting.RDL,Style,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Style.cs,FinalPass,Cyclomatic complexity of the method is 29
Complex Method,fyiReporting.RDL,Style,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Style.cs,DrawBorder,Cyclomatic complexity of the method is 24
Complex Method,fyiReporting.RDL,Style,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Style.cs,GetFont,Cyclomatic complexity of the method is 9
Complex Method,fyiReporting.RDL,Style,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Style.cs,GetStringFormat,Cyclomatic complexity of the method is 9
Complex Method,fyiReporting.RDL,Style,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Style.cs,GetCSS,Cyclomatic complexity of the method is 22
Complex Method,fyiReporting.RDL,Style,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Style.cs,GetStyleInfo,Cyclomatic complexity of the method is 11
Complex Method,fyiReporting.RDL,Style,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Style.cs,IsConstant,Cyclomatic complexity of the method is 37
Complex Method,fyiReporting.RDL,StyleBackgroundImage,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\StyleBackgroundImage.cs,GetPageImage,Cyclomatic complexity of the method is 8
Complex Method,fyiReporting.RDL,StyleBorderColor,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\StyleBorderColor.cs,IsConstant,Cyclomatic complexity of the method is 10
Complex Method,fyiReporting.RDL,StyleBorderStyle,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\StyleBorderStyle.cs,IsConstant,Cyclomatic complexity of the method is 10
Complex Method,fyiReporting.RDL,StyleBorderWidth,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\StyleBorderWidth.cs,IsConstant,Cyclomatic complexity of the method is 10
Complex Method,fyiReporting.RDL,SubreportParameter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\SubreportParameter.cs,SubreportParameter,Cyclomatic complexity of the method is 8
Complex Method,fyiReporting.RDL,Table,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Table.cs,Table,Cyclomatic complexity of the method is 8
Complex Method,fyiReporting.RDL,Table,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Table.cs,VerifyCC,Cyclomatic complexity of the method is 8
Complex Method,fyiReporting.RDL,Table,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Table.cs,Run,Cyclomatic complexity of the method is 8
Complex Method,fyiReporting.RDL,Table,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Table.cs,RunPageHeader,Cyclomatic complexity of the method is 9
Complex Method,fyiReporting.RDL,Table,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Table.cs,PrepGroups,Cyclomatic complexity of the method is 26
Complex Method,fyiReporting.RDL,Table,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Table.cs,PrepRecursiveGroup,Cyclomatic complexity of the method is 12
Complex Method,fyiReporting.RDL,Table,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Table.cs,RunGroups,Cyclomatic complexity of the method is 13
Complex Method,fyiReporting.RDL,Table,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Table.cs,RunGroupsPage,Cyclomatic complexity of the method is 13
Complex Method,fyiReporting.RDL,Table,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Table.cs,RunRecursiveGroups,Cyclomatic complexity of the method is 10
Complex Method,fyiReporting.RDL,Table,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Table.cs,RunRecursiveGroupsPage,Cyclomatic complexity of the method is 13
Complex Method,fyiReporting.RDL,TableCell,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\TableCell.cs,TableCell,Cyclomatic complexity of the method is 9
Complex Method,fyiReporting.RDL,TableGroup,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\TableGroup.cs,FinalPass,Cyclomatic complexity of the method is 8
Complex Method,fyiReporting.RDL,Textbox,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Textbox.cs,FinalPass,Cyclomatic complexity of the method is 8
Complex Method,fyiReporting.RDL,Textbox,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Textbox.cs,RunPage,Cyclomatic complexity of the method is 15
Complex Method,fyiReporting.RDL,LaxBinder,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\LaxBinder.cs,BindToMethod,Cyclomatic complexity of the method is 11
Complex Method,fyiReporting.RDL,LaxBinder,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\LaxBinder.cs,SelectProperty,Cyclomatic complexity of the method is 8
Complex Method,fyiReporting.RDL,LaxBinder,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\LaxBinder.cs,CanConvertFrom,Cyclomatic complexity of the method is 23
Complex Method,fyiReporting.RDL,RenderBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderBase.cs,ProcessPage,Cyclomatic complexity of the method is 18
Complex Method,fyiReporting.RDL,RenderBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderBase.cs,MeasureString,Cyclomatic complexity of the method is 16
Complex Method,fyiReporting.RDL,RenderBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderBase.cs,MeasureString,Cyclomatic complexity of the method is 8
Complex Method,fyiReporting.RDL,RenderExcel2003,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderExcel2003.cs,CopyRow,Cyclomatic complexity of the method is 9
Complex Method,fyiReporting.RDL,RenderPdf_iTextSharp,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf_iTextSharp.cs,AddText,Cyclomatic complexity of the method is 17
Complex Method,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,WriteGridData,Cyclomatic complexity of the method is 10
Complex Method,fyiReporting.RDL,RenderRtf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderRtf.cs,TableRowStart,Cyclomatic complexity of the method is 8
Complex Method,fyiReporting.RDL,RenderTif,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderTif.cs,DrawString,Cyclomatic complexity of the method is 8
Complex Method,fyiReporting.RDL,RenderTif,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderTif.cs,ConvertToBitonal,Cyclomatic complexity of the method is 8
Complex Method,fyiReporting.RDL,RenderHtmlTable,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\HtmlConverter\RenderHtmlTable.cs,CssPosition,Cyclomatic complexity of the method is 14
Complex Method,fyiReporting.RDL,RenderHtmlTable,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\HtmlConverter\RenderHtmlTable.cs,CssPrefix,Cyclomatic complexity of the method is 9
Complex Method,fyiReporting.RDL,RenderHtmlTable,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\HtmlConverter\RenderHtmlTable.cs,TableCellStart,Cyclomatic complexity of the method is 11
Complex Method,fyiReporting.RDL,RenderHtmlTable,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\HtmlConverter\RenderHtmlTable.cs,SortType,Cyclomatic complexity of the method is 11
Complex Method,fyiReporting.RDL,RenderHtmlTable,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\HtmlConverter\RenderHtmlTable.cs,Image,Cyclomatic complexity of the method is 9
Complex Method,fyiReporting.RDL,Parser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Parser.cs,MatchFuncIDent,Cyclomatic complexity of the method is 23
Complex Method,fyiReporting.RDL,Parser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Parser.cs,ResolveAggrScope,Cyclomatic complexity of the method is 9
Complex Method,fyiReporting.RDL,Parser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Parser.cs,ResolveMethodCall,Cyclomatic complexity of the method is 18
Complex Method,fyiReporting.RDL,VBFunctions,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\VBFunctions.cs,InStrRev,Cyclomatic complexity of the method is 8
Complex Method,fyiReporting.RDL,VBFunctions,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\VBFunctions.cs,Replace,Cyclomatic complexity of the method is 11
Complex Method,fyiReporting.RDL,MhtBuilder,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtBuilder.cs,QuotedPrintableEncode,Cyclomatic complexity of the method is 8
Complex Method,fyiReporting.RDL,MhtWebFile,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtWebFile.cs,HtmlDecode,Cyclomatic complexity of the method is 8
Complex Method,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddText,Cyclomatic complexity of the method is 12
Complex Method,fyiReporting.RDL,RenderHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderHtml.cs,CssPosition,Cyclomatic complexity of the method is 13
Complex Method,fyiReporting.RDL,RenderHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderHtml.cs,CssPrefix,Cyclomatic complexity of the method is 9
Complex Method,fyiReporting.RDL,RenderHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderHtml.cs,TableCellStart,Cyclomatic complexity of the method is 11
Complex Method,fyiReporting.RDL,RenderHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderHtml.cs,SortType,Cyclomatic complexity of the method is 11
Complex Method,fyiReporting.RDL,RenderHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderHtml.cs,Image,Cyclomatic complexity of the method is 8
Complex Method,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,Cyclomatic complexity of the method is 17
Complex Method,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,ProcessPage,Cyclomatic complexity of the method is 26
Complex Method,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,MeasureString,Cyclomatic complexity of the method is 16
Complex Method,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,MeasureString,Cyclomatic complexity of the method is 8
Complex Method,fyiReporting.RDL,PageTextHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtml.cs,BuildPrivate,Cyclomatic complexity of the method is 13
Complex Method,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,Cyclomatic complexity of the method is 9
Complex Method,fyiReporting.RDL,RdlEngineConfig,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\RdlEngineConfig.cs,RdlEngineConfigInit,Cyclomatic complexity of the method is 11
Complex Method,fyiReporting.RDL,RdlEngineConfig,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\RdlEngineConfig.cs,GetDataSource,Cyclomatic complexity of the method is 13
Complex Method,fyiReporting.RDL,RdlEngineConfig,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\RdlEngineConfig.cs,GetCustomReportItem,Cyclomatic complexity of the method is 11
Complex Method,System.Drawing,GraphicsExtended,C:\repos\majorsilence_My-FyiReporting\RdlEngine\GraphicsExtended.cs,DrawStringJustified,Cyclomatic complexity of the method is 28
Long Parameter List,fyiReporting.RDL,ChartBar,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBar.cs,ChartBar,The method has 8 parameters. Parameters: r' row' c' m' showTooltips' showTooltipsX' _ToolTipYFormat' _ToolTipXFormat
Long Parameter List,fyiReporting.RDL,ChartBar,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBar.cs,DrawColumnBar,The method has 6 parameters. Parameters: rpt' g' brush' rect' iRow' iCol
Long Parameter List,fyiReporting.RDL,ChartBar,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBar.cs,DrawValueAxis,The method has 7 parameters. Parameters: rpt' g' min' max' rect' plotTop' plotBottom
Long Parameter List,fyiReporting.RDL,ChartBar,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBar.cs,DrawValueAxisGrid,The method has 5 parameters. Parameters: rpt' g' gl' s' e
Long Parameter List,fyiReporting.RDL,ChartBar,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBar.cs,DrawValueAxisTick,The method has 6 parameters. Parameters: rpt' g' bMajor' tickType' gl' p
Long Parameter List,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,ChartBase,The method has 8 parameters. Parameters: r' row' c' m' showTooltips' showTooltipsX' _ToolTipYFormat' _ToolTipXFormat
Long Parameter List,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegendBox,The method has 6 parameters. Parameters: g' b' marker' x' y' boxSize
Long Parameter List,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegendBox,The method has 7 parameters. Parameters: g' b' marker' x' y' boxSize' intLineSize
Long Parameter List,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegendMarker,The method has 7 parameters. Parameters: g' b' p' marker' x' y' mSize
Long Parameter List,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegendMeasure,The method has 7 parameters. Parameters: rpt' g' f' sf' maxSize' maxWidth' maxHeight
Long Parameter List,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawCategoryLabel,The method has 5 parameters. Parameters: rpt' g' t' a' rect
Long Parameter List,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawDataPoint,The method has 5 parameters. Parameters: rpt' g' p' row' col
Long Parameter List,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawDataPoint,The method has 5 parameters. Parameters: rpt' g' rect' row' col
Long Parameter List,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawDataPoint,The method has 6 parameters. Parameters: rpt' g' p' rect' row' col
Long Parameter List,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetMaxMinDataValue,The method has 5 parameters. Parameters: rpt' max' min' xyb' WhichYAxis
Long Parameter List,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetValueMaxMin,The method has 5 parameters. Parameters: rpt' max' min' xyb' WhichYAxis
Long Parameter List,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,SetIncrementAndInterval,The method has 6 parameters. Parameters: rpt' a' min' max' incr' interval
Long Parameter List,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,ChartBubble,The method has 8 parameters. Parameters: r' row' c' m' showTooltips' showTooltipsX' _ToolTipYFormat' _ToolTipXFormat
Long Parameter List,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawPlot,The method has 8 parameters. Parameters: rpt' g' xmin' xmax' ymin' ymax' bmin' bmax
Long Parameter List,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawLineBetweenPoints,The method has 5 parameters. Parameters: g' rpt' brush' points' intLineSize
Long Parameter List,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawBubble,The method has 11 parameters. Parameters: rpt' g' brush' p' iRow' iCol' bmin' bmax' bv' xv' yv
Long Parameter List,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,BubbleSize,The method has 6 parameters. Parameters: rpt' iRow' iCol' minB' maxB' bv
Long Parameter List,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawValueAxis,The method has 7 parameters. Parameters: rpt' g' min' max' rect' plotLeft' plotRight
Long Parameter List,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawValueAxisGrid,The method has 5 parameters. Parameters: rpt' g' gl' s' e
Long Parameter List,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawValueAxisTick,The method has 6 parameters. Parameters: rpt' g' bMajor' tickType' gl' p
Long Parameter List,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawCategoryAxis,The method has 7 parameters. Parameters: rpt' g' min' max' rect' plotTop' plotBottom
Long Parameter List,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawCategoryAxisGrid,The method has 5 parameters. Parameters: rpt' g' gl' s' e
Long Parameter List,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawCategoryAxisTick,The method has 6 parameters. Parameters: rpt' g' bMajor' tickType' gl' p
Long Parameter List,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,ChartColumn,The method has 8 parameters. Parameters: r' row' c' m' showTooltips' showTooltipsX' _ToolTipYFormat' _ToolTipXFormat
Long Parameter List,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawPlotAreaPlain,The method has 5 parameters. Parameters: rpt' g' max' min' ScaleFactor
Long Parameter List,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawLegendLineMarker,The method has 7 parameters. Parameters: g' b' p' marker' x' y' mSize
Long Parameter List,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawLineBetweenPoints,The method has 5 parameters. Parameters: g' rpt' brush' points' intLineSize
Long Parameter List,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawCategoryAxis,The method has 5 parameters. Parameters: rpt' g' rect' plotTop' maxWidth
Long Parameter List,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawCategoryAxisGrid,The method has 5 parameters. Parameters: rpt' g' gl' s' e
Long Parameter List,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawColumnBar,The method has 6 parameters. Parameters: rpt' g' brush' rect' iRow' iCol
Long Parameter List,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawValueAxis,The method has 9 parameters. Parameters: rpt' g' min' max' rect' plotLeft' plotRight' incr' intervalCount
Long Parameter List,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,Draw2ndValueAxis,The method has 10 parameters. Parameters: rpt' g' min' max' rect' plotLeft' plotRight' incr' intervalCount' ScaleFactor
Long Parameter List,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawValueAxisGrid,The method has 5 parameters. Parameters: rpt' g' gl' s' e
Long Parameter List,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawValueAxisTick,The method has 6 parameters. Parameters: rpt' g' bMajor' tickType' gl' p
Long Parameter List,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,ChartLine,The method has 8 parameters. Parameters: r' row' c' m' showTooltips' showTooltipsX' _ToolTipYFormat' _ToolTipXFormat
Long Parameter List,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,DrawLineBetweenPoints,The method has 5 parameters. Parameters: g' rpt' brush' points' intLineSize
Long Parameter List,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,DrawLinePoint,The method has 7 parameters. Parameters: rpt' g' brush' marker' p' iRow' iCol
Long Parameter List,fyiReporting.RDL,ChartPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartPie.cs,ChartPie,The method has 8 parameters. Parameters: r' row' c' m' showTooltips' showTooltipsX' _ToolTipYFormat' _ToolTipXFormat
Long Parameter List,fyiReporting.RDL,ChartPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartPie.cs,DrawPie,The method has 8 parameters. Parameters: g' rpt' brush' rect' iRow' iCol' startAngle' endAngle
Long Parameter List,fyiReporting.RDL,ChartMap,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMap.cs,ChartMap,The method has 8 parameters. Parameters: r' row' c' m' showTooltips' showTooltipsX' _ToolTipYFormat' _ToolTipXFormat
Long Parameter List,fyiReporting.RDL,ChartMap,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMap.cs,DrawMap,The method has 5 parameters. Parameters: rpt' g' mapfile' max' min
Long Parameter List,fyiReporting.RDL,Details,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Details.cs,RunPage,The method has 5 parameters. Parameters: pgs' rs' start' end' footerHeight
Long Parameter List,fyiReporting.RDL,EMF,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMF.cs,MetafileCallback,The method has 5 parameters. Parameters: recordType' flags' dataSize' data' callbackData
Long Parameter List,fyiReporting.RDL,Comment,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\Comment.cs,Comment,The method has 5 parameters. Parameters: Xin' Yin' WidthIn' HeightIn' ObjectTableIn
Long Parameter List,fyiReporting.RDL,DrawCurve,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawCurve.cs,DrawCurve,The method has 5 parameters. Parameters: Xin' Yin' WidthIn' HeightIn' ObjectTableIn
Long Parameter List,fyiReporting.RDL,DrawCurve,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawCurve.cs,DoFloat,The method has 6 parameters. Parameters: NumberOfSegments' _br' p' Offset' NumberOfPoints' Tension
Long Parameter List,fyiReporting.RDL,DrawCurve,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawCurve.cs,DoCompressed,The method has 6 parameters. Parameters: NumberOfSegments' _br' p' Offset' NumberOfPoints' Tension
Long Parameter List,fyiReporting.RDL,DrawCurve,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawCurve.cs,DoInstructions,The method has 5 parameters. Parameters: points' p' Offset' NumberOfPoints' Tension
Long Parameter List,fyiReporting.RDL,DrawEllipse,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawEllipse.cs,DrawEllipse,The method has 5 parameters. Parameters: Xin' Yin' WidthIn' HeightIn' ObjectTableIn
Long Parameter List,fyiReporting.RDL,DrawEllipse,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawEllipse.cs,DoEllipse,The method has 5 parameters. Parameters: p' Xp' Yp' Wid' Hgt
Long Parameter List,fyiReporting.RDL,DrawLines,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawLines.cs,DrawLines,The method has 5 parameters. Parameters: Xin' Yin' WidthIn' HeightIn' ObjectTableIn
Long Parameter List,fyiReporting.RDL,DrawLines,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawLines.cs,DoInstructions,The method has 5 parameters. Parameters: Xa' Xb' Ya' Yb' p
Long Parameter List,fyiReporting.RDL,DrawPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawPie.cs,DrawPie,The method has 5 parameters. Parameters: Xin' Yin' WidthIn' HeightIn' ObjectTableIn
Long Parameter List,fyiReporting.RDL,DrawPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawPie.cs,DoInstructions,The method has 7 parameters. Parameters: recX' recY' recWidth' recHeight' p' StartAngle' SweepAngle
Long Parameter List,fyiReporting.RDL,DrawRects,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawRects.cs,DrawRects,The method has 5 parameters. Parameters: Xin' Yin' WidthIn' HeightIn' ObjectTableIn
Long Parameter List,fyiReporting.RDL,DrawRects,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawRects.cs,DoInstructions,The method has 5 parameters. Parameters: recX' recY' recWidth' recHeight' p
Long Parameter List,fyiReporting.RDL,DrawString,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawString.cs,DrawString,The method has 5 parameters. Parameters: Xin' Yin' WidthIn' HeightIn' ObjectTableIn
Long Parameter List,fyiReporting.RDL,DrawString,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawString.cs,DoInstructions,The method has 8 parameters. Parameters: f' sf' br' recX' recY' recWidth' recHeight' Text
Long Parameter List,fyiReporting.RDL,FillEllipse,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillEllipse.cs,FillEllipse,The method has 5 parameters. Parameters: Xin' Yin' WidthIn' HeightIn' ObjectTableIn
Long Parameter List,fyiReporting.RDL,FillEllipse,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillEllipse.cs,DoInstructions,The method has 5 parameters. Parameters: Xp' Yp' Wid' Hgt' b
Long Parameter List,fyiReporting.RDL,FillPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillPie.cs,FillPie,The method has 5 parameters. Parameters: Xin' Yin' WidthIn' HeightIn' ObjectTableIn
Long Parameter List,fyiReporting.RDL,FillPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillPie.cs,DoInstructions,The method has 7 parameters. Parameters: recX' recY' recWidth' recHeight' b' StartAngle' SweepAngle
Long Parameter List,fyiReporting.RDL,FillPolygon,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillPolygon.cs,FillPolygon,The method has 5 parameters. Parameters: Xin' Yin' WidthIn' HeightIn' ObjectTableIn
Long Parameter List,fyiReporting.RDL,FillRects,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillRects.cs,FillRects,The method has 5 parameters. Parameters: Xin' Yin' WidthIn' HeightIn' ObjectTableIn
Long Parameter List,fyiReporting.RDL,FillRects,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillRects.cs,DoInstructions,The method has 5 parameters. Parameters: recX' recY' recWidth' recHeight' b
Long Parameter List,fyiReporting.RDL,Matrix,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Matrix.cs,RunPageColumns,The method has 5 parameters. Parameters: pgs' wc' matrix' iRow' maxColumns
Long Parameter List,fyiReporting.RDL,Matrix,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Matrix.cs,HandleRowGrouping,The method has 8 parameters. Parameters: rpt' wc' rows' r' m' rgi' iRow' maxRows
Long Parameter List,fyiReporting.RDL,Matrix,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Matrix.cs,HandleColumnGrouping,The method has 8 parameters. Parameters: rpt' wc' rows' r' m' cgi' iRow' maxColumns
Long Parameter List,fyiReporting.RDL,Matrix,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Matrix.cs,RunColumnHeaders,The method has 8 parameters. Parameters: rpt' wc' m' matrix' _Data' iRow' iColumn' level
Long Parameter List,fyiReporting.RDL,Matrix,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Matrix.cs,RunColumnStaticHeaders,The method has 7 parameters. Parameters: rpt' wc' matrix' _Data' iRow' iColumn' level
Long Parameter List,fyiReporting.RDL,Matrix,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Matrix.cs,RunDataColumn,The method has 10 parameters. Parameters: rpt' wc' rm' cm' matrix' _Data' iRow' iColumn' level' rowcell
Long Parameter List,fyiReporting.RDL,Matrix,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Matrix.cs,RunDataRow,The method has 9 parameters. Parameters: rpt' wc' rm' cm' matrix' _Data' iRow' iColumn' level
Long Parameter List,fyiReporting.RDL,Matrix,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Matrix.cs,RunRowHeaders,The method has 8 parameters. Parameters: rpt' wc' m' matrix' _Data' iRow' iColumn' level
Long Parameter List,fyiReporting.RDL,Matrix,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Matrix.cs,RunRowStaticHeaders,The method has 6 parameters. Parameters: rpt' wc' matrix' _Data' iRow' level
Long Parameter List,fyiReporting.RDL,Matrix,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Matrix.cs,RunGetMatrixCell,The method has 7 parameters. Parameters: rpt' me' iRow' _Data' rows' firstRow' lastRow
Long Parameter List,fyiReporting.RDL,Matrix,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Matrix.cs,RunGetMatrixCell,The method has 8 parameters. Parameters: rpt' me' rcell' ccell' _Data' rows' firstRow' lastRow
Long Parameter List,fyiReporting.RDL,NameLookup,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\NameLookup.cs,NameLookup,The method has 12 parameters. Parameters: f' p' r' gbl' u' ascope' ag' mt' cm' i' ds' ct
Long Parameter List,fyiReporting.RDL,ReportDefn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportDefn.cs,ReportDefn,The method has 8 parameters. Parameters: xNode' replog' folder' getpswd' objcount' crossdel' overwriteConnectionString' overwriteInSubreport
Long Parameter List,fyiReporting.RDL,Rows,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Rows.cs,Rows,The method has 5 parameters. Parameters: rpt' r' start' end' ba
Long Parameter List,fyiReporting.RDL,Style,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Style.cs,DrawStyleLine,The method has 5 parameters. Parameters: rpt' g' r' s' e
Long Parameter List,fyiReporting.RDL,Style,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Style.cs,DrawString,The method has 6 parameters. Parameters: rpt' g' o' tc' r' rect
Long Parameter List,fyiReporting.RDL,Style,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Style.cs,MeasureString,The method has 6 parameters. Parameters: rpt' g' o' tc' r' maxWidth
Long Parameter List,fyiReporting.RDL,Style,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Style.cs,MeasureStringDefaults,The method has 6 parameters. Parameters: rpt' g' o' tc' r' maxWidth
Long Parameter List,fyiReporting.RDL,Style,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Style.cs,GetFormatedString,The method has 5 parameters. Parameters: rpt' s' row' o' tc
Long Parameter List,fyiReporting.RDL,Table,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Table.cs,RunGroupsPage,The method has 5 parameters. Parameters: pgs' wc' groupEntries' endRow' groupHeight
Long Parameter List,fyiReporting.RDL,LaxBinder,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\LaxBinder.cs,BindToMethod,The method has 7 parameters. Parameters: bindingAttr' match' args' modifiers' culture' names' state
Long Parameter List,fyiReporting.RDL,LaxBinder,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\LaxBinder.cs,SelectProperty,The method has 5 parameters. Parameters: bindingAttr' match' returnType' indexes' modifiers
Long Parameter List,fyiReporting.RDL,RenderBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderBase.cs,AddLine,The method has 5 parameters. Parameters: x' y' x2' y2' si
Long Parameter List,fyiReporting.RDL,RenderBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderBase.cs,AddLine,The method has 7 parameters. Parameters: x' y' x2' y2' width' c' ls
Long Parameter List,fyiReporting.RDL,RenderBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderBase.cs,AddImage,The method has 13 parameters. Parameters: name' si' imf' x' y' width' height' clipRect' im' samplesW' samplesH' url' tooltip
Long Parameter List,fyiReporting.RDL,RenderBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderBase.cs,AddRectangle,The method has 7 parameters. Parameters: x' y' height' width' si' url' tooltip
Long Parameter List,fyiReporting.RDL,RenderBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderBase.cs,AddPie,The method has 7 parameters. Parameters: x' y' height' width' si' url' tooltip
Long Parameter List,fyiReporting.RDL,RenderBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderBase.cs,AddEllipse,The method has 6 parameters. Parameters: x' y' height' width' si' url
Long Parameter List,fyiReporting.RDL,RenderBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderBase.cs,AddText,The method has 11 parameters. Parameters: x' y' height' width' sa' si' tw' bWrap' url' bNoClip' tooltip
Long Parameter List,fyiReporting.RDL,RenderBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderBase.cs,MeasureString,The method has 5 parameters. Parameters: s' g' drawFont' drawFormat' cra
Long Parameter List,fyiReporting.RDL,RenderBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderBase.cs,MeasureString32,The method has 5 parameters. Parameters: s' g' drawFont' drawFormat' cra
Long Parameter List,fyiReporting.RDL,RenderBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderBase.cs,MatrixStart,The method has 6 parameters. Parameters: m' matrix' r' headerRows' maxRows' maxCols
Long Parameter List,fyiReporting.RDL,RenderBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderBase.cs,MatrixCellStart,The method has 8 parameters. Parameters: m' ri' row' column' r' h' w' colSpan
Long Parameter List,fyiReporting.RDL,RenderBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderBase.cs,MatrixCellEnd,The method has 5 parameters. Parameters: m' ri' row' column' r
Long Parameter List,fyiReporting.RDL,RenderExcel2003,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderExcel2003.cs,CopyRow,The method has 6 parameters. Parameters: srcSheet' destSheet' srcRow' destRow' styleMap' retVal
Long Parameter List,fyiReporting.RDL,RenderPdf_iTextSharp,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf_iTextSharp.cs,AddLine,The method has 7 parameters. Parameters: x' y' x2' y2' width' c' ls
Long Parameter List,fyiReporting.RDL,RenderPdf_iTextSharp,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf_iTextSharp.cs,AddImage,The method has 13 parameters. Parameters: name' si' imf' x' y' width' height' clipRect' im' samplesW' samplesH' url' tooltip
Long Parameter List,fyiReporting.RDL,RenderPdf_iTextSharp,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf_iTextSharp.cs,AddRectangle,The method has 7 parameters. Parameters: x' y' height' width' si' url' tooltip
Long Parameter List,fyiReporting.RDL,RenderPdf_iTextSharp,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf_iTextSharp.cs,AddPie,The method has 7 parameters. Parameters: x' y' height' width' si' url' tooltip
Long Parameter List,fyiReporting.RDL,RenderPdf_iTextSharp,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf_iTextSharp.cs,AddEllipse,The method has 6 parameters. Parameters: x' y' height' width' si' url
Long Parameter List,fyiReporting.RDL,RenderPdf_iTextSharp,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf_iTextSharp.cs,AddText,The method has 11 parameters. Parameters: x' y' height' width' sa' si' tw' bWrap' url' bNoClip' tooltip
Long Parameter List,fyiReporting.RDL,RenderPdf_iTextSharp,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf_iTextSharp.cs,iAddFillRect,The method has 5 parameters. Parameters: x' y' width' height' c
Long Parameter List,fyiReporting.RDL,RenderPdf_iTextSharp,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf_iTextSharp.cs,iAddBorder,The method has 5 parameters. Parameters: si' x' y' height' width
Long Parameter List,fyiReporting.RDL,RenderPdf_iTextSharp,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf_iTextSharp.cs,iAddFillRect,The method has 5 parameters. Parameters: x' y' width' height' si
Long Parameter List,fyiReporting.RDL,RenderPdf_iTextSharp,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf_iTextSharp.cs,iAddCurve,The method has 10 parameters. Parameters: X1' Y1' X2' Y2' X3' Y3' X4' Y4' si' url
Long Parameter List,fyiReporting.RDL,RenderExcel,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderExcel.cs,MatrixStart,The method has 6 parameters. Parameters: m' matrix' r' headerRows' maxRows' maxCols
Long Parameter List,fyiReporting.RDL,RenderExcel,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderExcel.cs,MatrixCellStart,The method has 8 parameters. Parameters: m' ri' row' column' r' h' w' colSpan
Long Parameter List,fyiReporting.RDL,RenderExcel,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderExcel.cs,MatrixCellEnd,The method has 5 parameters. Parameters: m' ri' row' column' r
Long Parameter List,fyiReporting.RDL,RenderCsv,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderCsv.cs,MatrixStart,The method has 6 parameters. Parameters: m' matrix' r' headerRows' maxRows' maxCols
Long Parameter List,fyiReporting.RDL,RenderCsv,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderCsv.cs,MatrixCellStart,The method has 8 parameters. Parameters: m' ri' row' column' r' h' w' colSpan
Long Parameter List,fyiReporting.RDL,RenderCsv,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderCsv.cs,MatrixCellEnd,The method has 5 parameters. Parameters: m' ri' row' column' r
Long Parameter List,fyiReporting.RDL,RenderRtf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderRtf.cs,MatrixStart,The method has 6 parameters. Parameters: m' matrix' r' headerRows' maxRows' maxCols
Long Parameter List,fyiReporting.RDL,RenderRtf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderRtf.cs,MatrixCellStart,The method has 8 parameters. Parameters: m' ri' row' column' r' h' w' colSpan
Long Parameter List,fyiReporting.RDL,RenderRtf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderRtf.cs,MatrixCellEnd,The method has 5 parameters. Parameters: m' ri' row' column' r
Long Parameter List,fyiReporting.RDL,RenderTif,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderTif.cs,DrawLine,The method has 8 parameters. Parameters: c' bs' w' g' x' y' x2' y2
Long Parameter List,fyiReporting.RDL,RenderTif,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderTif.cs,DrawCurve,The method has 7 parameters. Parameters: c' bs' w' g' points' Offset' Tension
Long Parameter List,fyiReporting.RDL,RenderTif,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderTif.cs,MatrixStart,The method has 6 parameters. Parameters: m' matrix' r' headerRows' maxRows' maxCols
Long Parameter List,fyiReporting.RDL,RenderTif,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderTif.cs,MatrixCellStart,The method has 8 parameters. Parameters: m' ri' row' column' r' h' w' colSpan
Long Parameter List,fyiReporting.RDL,RenderTif,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderTif.cs,MatrixCellEnd,The method has 5 parameters. Parameters: m' ri' row' column' r
Long Parameter List,fyiReporting.RDL,RenderHtmlTable,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\HtmlConverter\RenderHtmlTable.cs,CssAdd,The method has 6 parameters. Parameters: s' rl' row' bForceRelative' h' w
Long Parameter List,fyiReporting.RDL,RenderHtmlTable,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\HtmlConverter\RenderHtmlTable.cs,CssPosition,The method has 5 parameters. Parameters: rl' row' bForceRelative' h' w
Long Parameter List,fyiReporting.RDL,RenderHtmlTable,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\HtmlConverter\RenderHtmlTable.cs,MatrixStart,The method has 6 parameters. Parameters: m' matrix' r' headerRows' maxRows' maxCols
Long Parameter List,fyiReporting.RDL,RenderHtmlTable,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\HtmlConverter\RenderHtmlTable.cs,MatrixCellStart,The method has 8 parameters. Parameters: m' ri' row' column' r' h' w' colSpan
Long Parameter List,fyiReporting.RDL,RenderHtmlTable,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\HtmlConverter\RenderHtmlTable.cs,MatrixCellEnd,The method has 5 parameters. Parameters: m' ri' row' column' r
Long Parameter List,fyiReporting.RDL,PdfOutlineEntry,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfOutline.cs,PdfOutlineEntry,The method has 5 parameters. Parameters: pa' p' text' x' y
Long Parameter List,fyiReporting.RDL,Token,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Token.cs,Token,The method has 6 parameters. Parameters: value' startLine' startCol' endLine' endCol' type
Long Parameter List,fyiReporting.RDL,Financial,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\Financial.cs,DDB,The method has 5 parameters. Parameters: cost' salvage' life' period' factor
Long Parameter List,fyiReporting.RDL,Financial,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\Financial.cs,FV,The method has 5 parameters. Parameters: rate' periods' pmt' presentValue' endOfPeriod
Long Parameter List,fyiReporting.RDL,Financial,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\Financial.cs,IPmt,The method has 6 parameters. Parameters: rate' period' periods' presentValue' futureValue' endOfPeriod
Long Parameter List,fyiReporting.RDL,Financial,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\Financial.cs,NPer,The method has 5 parameters. Parameters: rate' pmt' presentValue' futureValue' endOfPeriod
Long Parameter List,fyiReporting.RDL,Financial,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\Financial.cs,Pmt,The method has 5 parameters. Parameters: rate' periods' presentValue' futureValue' endOfPeriod
Long Parameter List,fyiReporting.RDL,Financial,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\Financial.cs,PV,The method has 5 parameters. Parameters: rate' periods' pmt' futureValue' endOfPeriod
Long Parameter List,fyiReporting.RDL,Financial,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\Financial.cs,Rate,The method has 6 parameters. Parameters: periods' pmt' presentValue' futureValue' endOfPeriod' guess
Long Parameter List,fyiReporting.RDL,Financial,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\Financial.cs,RateGuess,The method has 6 parameters. Parameters: periods' pmt' pv' fv' type' rate
Long Parameter List,fyiReporting.RDL,FunctionCustomStatic,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\FunctionCustomStatic.cs,FunctionCustomStatic,The method has 5 parameters. Parameters: cm' c' f' a' type
Long Parameter List,fyiReporting.RDL,VBFunctions,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\VBFunctions.cs,Replace,The method has 5 parameters. Parameters: str' find' replacewith' start' count
Long Parameter List,fyiReporting.RDL,VBFunctions,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\VBFunctions.cs,Replace,The method has 6 parameters. Parameters: str' find' replacewith' start' count' compare
Long Parameter List,fyiReporting.RDL,IPresent,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\IPresent.cs,MatrixStart,The method has 6 parameters. Parameters: m' matrix' r' headerRows' maxRows' maxCols
Long Parameter List,fyiReporting.RDL,IPresent,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\IPresent.cs,MatrixCellStart,The method has 8 parameters. Parameters: m' ri' row' column' r' h' w' colSpan
Long Parameter List,fyiReporting.RDL,IPresent,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\IPresent.cs,MatrixCellEnd,The method has 5 parameters. Parameters: m' ri' row' column' r
Long Parameter List,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddLine,The method has 5 parameters. Parameters: x' y' x2' y2' si
Long Parameter List,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddLine,The method has 7 parameters. Parameters: x' y' x2' y2' width' c' ls
Long Parameter List,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddFillRect,The method has 5 parameters. Parameters: x' y' width' height' c
Long Parameter List,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddFillRect,The method has 6 parameters. Parameters: x' y' width' height' si' patterns
Long Parameter List,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddImage,The method has 15 parameters. Parameters: images' name' contentRef' si' imf' x' y' width' height' clipRect' im' samplesW' samplesH' url' tooltip
Long Parameter List,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddRectangle,The method has 8 parameters. Parameters: x' y' height' width' si' url' patterns' tooltip
Long Parameter List,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddPie,The method has 8 parameters. Parameters: x' y' height' width' si' url' patterns' tooltip
Long Parameter List,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddCurve,The method has 10 parameters. Parameters: X1' Y1' X2' Y2' X3' Y3' X4' Y4' si' url
Long Parameter List,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddEllipse,The method has 6 parameters. Parameters: x' y' height' width' si' url
Long Parameter List,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddText,The method has 12 parameters. Parameters: x' y' height' width' sa' si' fonts' tw' bWrap' url' bNoClip' tooltip
Long Parameter List,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddBorder,The method has 5 parameters. Parameters: si' x' y' height' width
Long Parameter List,fyiReporting.RDL,PdfImages,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfImage.cs,GetPdfImage,The method has 7 parameters. Parameters: p' imgname' contentRef' imf' ba' width' height
Long Parameter List,fyiReporting.RDL,PdfImageEntry,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfImage.cs,PdfImageEntry,The method has 8 parameters. Parameters: pa' p' contentRef' nm' imgf' im' width' height
Long Parameter List,fyiReporting.RDL,PdfPage,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfPage.cs,AddHyperlink,The method has 5 parameters. Parameters: x' y' height' width' url
Long Parameter List,fyiReporting.RDL,PdfPage,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfPage.cs,AddToolTip,The method has 5 parameters. Parameters: x' y' height' width' tooltip
Long Parameter List,fyiReporting.RDL,RenderHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderHtml.cs,CssAdd,The method has 6 parameters. Parameters: s' rl' row' bForceRelative' h' w
Long Parameter List,fyiReporting.RDL,RenderHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderHtml.cs,CssPosition,The method has 5 parameters. Parameters: rl' row' bForceRelative' h' w
Long Parameter List,fyiReporting.RDL,RenderHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderHtml.cs,MatrixStart,The method has 6 parameters. Parameters: m' matrix' r' headerRows' maxRows' maxCols
Long Parameter List,fyiReporting.RDL,RenderHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderHtml.cs,MatrixCellStart,The method has 8 parameters. Parameters: m' ri' row' column' r' h' w' colSpan
Long Parameter List,fyiReporting.RDL,RenderHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderHtml.cs,MatrixCellEnd,The method has 5 parameters. Parameters: m' ri' row' column' r
Long Parameter List,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddLine,The method has 5 parameters. Parameters: x' y' x2' y2' si
Long Parameter List,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddLine,The method has 7 parameters. Parameters: x' y' x2' y2' width' c' ls
Long Parameter List,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddFillRect,The method has 5 parameters. Parameters: x' y' width' height' c
Long Parameter List,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddFillRect,The method has 6 parameters. Parameters: x' y' width' height' si' patterns
Long Parameter List,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddBorder,The method has 5 parameters. Parameters: si' x' y' height' width
Long Parameter List,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddImage,The method has 15 parameters. Parameters: images' name' contentRef' si' imf' x' y' width' height' clipRect' im' samplesW' samplesH' url' tooltip
Long Parameter List,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddRectangle,The method has 8 parameters. Parameters: x' y' height' width' si' url' patterns' tooltip
Long Parameter List,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddPie,The method has 8 parameters. Parameters: x' y' height' width' si' url' patterns' tooltip
Long Parameter List,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddCurve,The method has 10 parameters. Parameters: X1' Y1' X2' Y2' X3' Y3' X4' Y4' si' url
Long Parameter List,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddEllipse,The method has 6 parameters. Parameters: x' y' height' width' si' url
Long Parameter List,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The method has 12 parameters. Parameters: x' y' height' width' sa' si' fonts' tw' bWrap' url' bNoClip' tooltip
Long Parameter List,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,MeasureString,The method has 5 parameters. Parameters: s' g' drawFont' drawFormat' cra
Long Parameter List,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,MeasureString32,The method has 5 parameters. Parameters: s' g' drawFont' drawFormat' cra
Long Parameter List,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,MatrixStart,The method has 6 parameters. Parameters: m' matrix' r' headerRows' maxRows' maxCols
Long Parameter List,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,MatrixCellStart,The method has 8 parameters. Parameters: m' ri' row' column' r' h' w' colSpan
Long Parameter List,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,MatrixCellEnd,The method has 5 parameters. Parameters: m' ri' row' column' r
Long Parameter List,fyiReporting.RDL,RenderXml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderXml.cs,MatrixStart,The method has 6 parameters. Parameters: m' matrix' r' headerRows' maxRows' maxCols
Long Parameter List,fyiReporting.RDL,RenderXml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderXml.cs,MatrixCellStart,The method has 8 parameters. Parameters: m' ri' row' column' r' h' w' colSpan
Long Parameter List,fyiReporting.RDL,RenderXml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderXml.cs,MatrixCellEnd,The method has 5 parameters. Parameters: m' ri' row' column' r
Long Parameter List,fyiReporting.RDL,SqlConfigEntry,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\RdlEngineConfig.cs,SqlConfigEntry,The method has 6 parameters. Parameters: provider' file' cname' codemodule' tselect' msg
Long Parameter List,System.Drawing,GraphicsExtended,C:\repos\majorsilence_My-FyiReporting\RdlEngine\GraphicsExtended.cs,DrawStringJustified,The method has 5 parameters. Parameters: graphics' s' font' brush' layoutRectangle
Long Parameter List,System.Drawing,GraphicsExtended,C:\repos\majorsilence_My-FyiReporting\RdlEngine\GraphicsExtended.cs,DrawStringJustified,The method has 6 parameters. Parameters: graphics' s' font' brush' layoutRectangle' paragraphFormat
Long Parameter List,System.Drawing,Word,C:\repos\majorsilence_My-FyiReporting\RdlEngine\GraphicsExtended.cs,Word,The method has 6 parameters. Parameters: s' length' startBold' stopBold' startItalic' stopItalic
Long Identifier,fyiReporting.RDL,ReportDefn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportDefn.cs,,The length of the parameter GetDataSourceReferencePassword is 30.
Long Statement,fyiReporting.RDL,Chart,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Chart.cs,RunPage,The length of the statement  "                    emf.ProcessEMF(ba); //Process takes the bytearray of EMFplus data and breaks it down into lines'ellipses'text'rectangles " is 120.
Long Statement,fyiReporting.RDL,ChartBar,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBar.cs,Draw,The length of the statement  "                _mf = new System.Drawing.Imaging.Metafile(_aStream' HDC' new RectangleF(0' 0' _bm.Width' _bm.Height)' System.Drawing.Imaging.MetafileFrameUnit.Pixel); " is 150.
Long Statement,fyiReporting.RDL,ChartBar,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBar.cs,Draw,The length of the statement  "						new System.Drawing.Rectangle(Layout.LeftMargin' _bm.Height-Layout.BottomMargin' _bm.Width - Layout.LeftMargin - Layout.RightMargin' vaSize.Height)' Layout.TopMargin' _bm.Height - Layout.BottomMargin); " is 200.
Long Statement,fyiReporting.RDL,ChartBar,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBar.cs,Draw,The length of the statement  "						new System.Drawing.Rectangle(Layout.LeftMargin - caSize.Width' Layout.TopMargin' caSize.Width' _bm.Height - Layout.TopMargin - Layout.BottomMargin)); " is 149.
Long Statement,fyiReporting.RDL,ChartBar,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBar.cs,Draw,The length of the statement  "                if ((ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.Stacked) " is 133.
Long Statement,fyiReporting.RDL,ChartBar,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBar.cs,Draw,The length of the statement  "                else if ((ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.PercentStacked) " is 145.
Long Statement,fyiReporting.RDL,ChartBar,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBar.cs,DrawPlotAreaPercentStacked,The length of the statement  "                        String val = "ToolTip:" + t.ToString(_tooltipYFormat) + "|X:" + (int)rect.X + "|Y:" + (int)rect.Y + "|W:" + rect.Width + "|H:" + rect.Height; " is 141.
Long Statement,fyiReporting.RDL,ChartBar,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBar.cs,DrawPlotAreaPlain,The length of the statement  "                        String val = "ToolTip:" + v.ToString(_tooltipYFormat) + "|X:" + (int)Layout.PlotArea.Left + "|Y:" + (int)(barLoc) + "|W:" + x + "|H:" + heightBar; " is 146.
Long Statement,fyiReporting.RDL,ChartBar,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBar.cs,DrawPlotAreaStacked,The length of the statement  "                        String val = "ToolTip:" + v.ToString(_tooltipYFormat) + "|X:" + (int)rect.X + "|Y:" + (int)rect.Y + "|W:" + rect.Width + "|H:" + rect.Height; " is 141.
Long Statement,fyiReporting.RDL,ChartBar,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBar.cs,DrawCategoryAxis,The length of the statement  "					System.Drawing.Rectangle drawRect = new System.Drawing.Rectangle(rect.Left + tSize.Width' drawLoc' rect.Width-tSize.Width' drawHeight); " is 135.
Long Statement,fyiReporting.RDL,ChartBar,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBar.cs,DrawColumnBar,The length of the statement  "            if ((ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.Stacked || " is 135.
Long Statement,fyiReporting.RDL,ChartBar,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBar.cs,DrawColumnBar,The length of the statement  "                (ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.PercentStacked) " is 136.
Long Statement,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The length of the statement  "                        if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush))) " is 126.
Long Statement,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The length of the statement  "                                    if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles " is 190.
Long Statement,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The length of the statement  "                                if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines " is 129.
Long Statement,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The length of the statement  "                                if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                           " is 135.
Long Statement,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetMaxMinDataValue,The length of the statement  "            if ((ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.Stacked) " is 133.
Long Statement,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPatterned,The length of the statement  "                    PatternBrush = new HatchBrush(HatchStyle.Cross' Color.Red' Color.White); // was weave... but I Especially didn't want to draw that in PDF - GJL " is 143.
Long Statement,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPatterned,The length of the statement  "                    PatternBrush = new HatchBrush(HatchStyle.LargeCheckerBoard' Color.Gold' Color.White); // was wave... but I didn't want to draw that in PDF - GJL " is 144.
Long Statement,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetValueMaxMin,The length of the statement  "            if ((ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.PercentStacked) " is 140.
Long Statement,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,SetIncrementAndInterval,The length of the statement  "            interval = _gridIncrs; //PJR 20071113 - gridincrements set by Max value now                 // assume an interval count of 10 to start " is 134.
Long Statement,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,Draw,The length of the statement  "                _mf = new System.Drawing.Imaging.Metafile(_aStream' HDC' new RectangleF(0' 0' _bm.Width' _bm.Height)' System.Drawing.Imaging.MetafileFrameUnit.Pixel); " is 150.
Long Statement,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,Draw,The length of the statement  "						new System.Drawing.Rectangle(Layout.LeftMargin - vaSize.Width' Layout.TopMargin' vaSize.Width' Layout.PlotArea.Height)' Layout.LeftMargin' _bm.Width - Layout.RightMargin); " is 171.
Long Statement,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,Draw,The length of the statement  "                        new System.Drawing.Rectangle(Layout.LeftMargin' _bm.Height - Layout.BottomMargin' _bm.Width - Layout.LeftMargin - Layout.RightMargin' vaSize.Height)'  " is 149.
Long Statement,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawPlot,The length of the statement  "                    if ((ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.Line || (ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.SmoothLine || isLine) " is 275.
Long Statement,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawLineBetweenPoints,The length of the statement  "                if ((ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.Smooth && points.Length > 2) " is 153.
Long Statement,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawValueAxis,The length of the statement  "                        new System.Drawing.Rectangle(rect.Left + tSize.Width' rect.Top + rect.Height - h - size.Height / 2' rect.Width - tSize.Width' size.Height); " is 139.
Long Statement,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawValueAxis,The length of the statement  "                        new System.Drawing.Rectangle(rect.Left + tSize.Width' rect.Top + rect.Height - h - size.Height / 2' rect.Width - tSize.Width' size.Height); " is 139.
Long Statement,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawValueAxis,The length of the statement  "                DrawValueAxisGrid(rpt' g' a.MajorGridLines' new Point(plotLeft' rect.Top + rect.Height - h)' new Point(plotRight' rect.Top + rect.Height - h)); " is 143.
Long Statement,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawCategoryAxis,The length of the statement  "                DrawCategoryAxisGrid(rpt' g' a.MajorGridLines' new Point(rect.Left + x' plotTop)' new Point(rect.Left + x' plotBottom)); " is 120.
Long Statement,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,Draw,The length of the statement  "                _mf = new System.Drawing.Imaging.Metafile(_aStream' HDC' new RectangleF(0' 0' _bm.Width' _bm.Height)'System.Drawing.Imaging.MetafileFrameUnit.Pixel); " is 149.
Long Statement,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,Draw,The length of the statement  "                int intervalCount = 0; //GJL - Used to get the interval count out of DrawValueAxis so that we don't recalculate it again. " is 121.
Long Statement,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,Draw,The length of the statement  "						new System.Drawing.Rectangle(Layout.LeftMargin - vaSize.Width' Layout.TopMargin' vaSize.Width' _bm.Height - Layout.TopMargin - Layout.BottomMargin)' Layout.LeftMargin' Layout.Width - Layout.RightMargin'out incr'out intervalCount); " is 230.
Long Statement,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,Draw,The length of the statement  "                //******************************************************************************************************************************************** " is 142.
Long Statement,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,Draw,The length of the statement  "                    Draw2ndValueAxis(rpt' g' min' max' new System.Drawing.Rectangle(Layout.LeftMargin + Layout.PlotArea.Width' Layout.TopMargin' vaSize2.Width' _bm.Height - Layout.TopMargin - Layout.BottomMargin)' Layout.LeftMargin' Layout.Width - Layout.RightMargin' incr' intervalCount' ref ScaleFactor); " is 286.
Long Statement,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,Draw,The length of the statement  "                        new System.Drawing.Rectangle(Layout.LeftMargin' _bm.Height - Layout.BottomMargin' Layout.PlotArea.Width' caSize.Height)' Layout.TopMargin' caSize.Width); " is 153.
Long Statement,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,Draw,The length of the statement  "                if ((ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.Stacked) " is 133.
Long Statement,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,Draw,The length of the statement  "                else if ((ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.PercentStacked) " is 145.
Long Statement,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawPlotAreaPercentStacked,The length of the statement  "                    //    String val = "ToolTip:" + t + "|X:" + (int)rect.X + "|Y:" + (int)(rect.Y) + "|W:" + rect.Width + "|H:" + rect.Height; " is 123.
Long Statement,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawPlotAreaPercentStacked,The length of the statement  "                        String val = "ToolTip:" + display + "|X:" + (int)rect.X + "|Y:" + (int)rect.Y + "|W:" + rect.Width + "|H:" + rect.Height; " is 121.
Long Statement,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawPlotAreaPlain,The length of the statement  "                                    String val = "ToolTip:" + tooltipVal.ToString(_tooltipYFormat) + "|X:" + barLoc + "|Y:" + (int)(Layout.PlotArea.Top + (maxBarHeight - h)) + "|W:" + widthBar + "|H:" + h; " is 169.
Long Statement,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawPlotAreaPlain,The length of the statement  "                                    System.Drawing.Rectangle r = new System.Drawing.Rectangle(lineLoc' Layout.PlotArea.Top + (maxBarHeight - h)' widthBar' h); " is 122.
Long Statement,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawPlotAreaPlain,The length of the statement  "                                    if (DrawMarker) { DrawLegendLineMarker(g' GetSeriesBrush(rpt' iRow' iCol)' new Pen(GetSeriesBrush(rpt' iRow' iCol))' SeriesMarker[iCol - 1]' p.X - 5' p.Y - 5' 10);} " is 164.
Long Statement,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawPlotAreaPlain,The length of the statement  "                                        String val = "ToolTip:" + tooltipVal.ToString(_tooltipYFormat) + "|X:" + (int)(p.X - 5) + "|Y:" + (int)(p.Y - 5) + "|W:10|H:10"; " is 128.
Long Statement,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawLineBetweenPoints,The length of the statement  "                if ((ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.Smooth && points.Length > 2) " is 153.
Long Statement,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawPlotAreaStacked,The length of the statement  "                        String val = "ToolTip:" + t.ToString(_tooltipYFormat) + "|X:" + (int)rect.X + "|Y:" + (int)(rect.Y) + "|W:" + rect.Width + "|H:" + rect.Height; " is 143.
Long Statement,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawCategoryAxis,The length of the statement  "			DrawTitle(rpt' g' a.Title' new System.Drawing.Rectangle(rect.Left' rect.Bottom-tSize.Height' rect.Width' tSize.Height)); " is 120.
Long Statement,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawCategoryAxis,The length of the statement  "            int PreviousLocation = rect.Left; //used to keep track of previous gridline location on x axis - set to x position of category axis at start " is 140.
Long Statement,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawCategoryAxis,The length of the statement  "                        DrawCategoryAxisGrid(rpt' g' a.MajorGridLines' new Point(drawLoc' rect.Top)' new Point(drawLoc' plotTop)); //Don't overdraw the Y axis on the first gridline " is 156.
Long Statement,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawCategoryAxis,The length of the statement  "                        DrawCategoryLabel(rpt' g' MonthString' a.Style' new System.Drawing.Rectangle(catlabelLoc' rect.Top - (lSize.Height - 25)' lSize.Width' lSize.Height)); " is 150.
Long Statement,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawCategoryAxis,The length of the statement  "                DrawCategoryLabel(rpt' g' MonthString' a.Style' new System.Drawing.Rectangle(catlabelLoc' rect.Top - (lSize.Height - 25)' lSize.Width' lSize.Height)); " is 150.
Long Statement,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawColumnBar,The length of the statement  "            if ((ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.Stacked || " is 135.
Long Statement,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawColumnBar,The length of the statement  "                (ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.PercentStacked) " is 136.
Long Statement,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawValueAxis,The length of the statement  "						new System.Drawing.Rectangle(rect.Left+tSize.Width' rect.Top + rect.Height - h - size.Height/2' rect.Width-tSize.Width' size.Height); " is 133.
Long Statement,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawValueAxis,The length of the statement  "						new System.Drawing.Rectangle(rect.Left+tSize.Width' rect.Top + rect.Height - h - size.Height/2' rect.Width-tSize.Width' size.Height); " is 133.
Long Statement,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawValueAxis,The length of the statement  "				DrawValueAxisGrid(rpt' g' a.MajorGridLines' new Point(plotLeft' rect.Top + rect.Height - h)' new Point(plotRight' rect.Top + rect.Height - h)); " is 143.
Long Statement,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,Draw2ndValueAxis,The length of the statement  "            DrawTitle(rpt' g' a.Title2' new System.Drawing.Rectangle((int)rect.Right - tSize.Width' rect.Top' tSize.Width' rect.Height)); " is 125.
Long Statement,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,Draw2ndValueAxis,The length of the statement  "                        new System.Drawing.Rectangle(rect.Left - (int)(tSize.Width * .5)' rect.Top + rect.Height - h - size.Height / 2' rect.Width - tSize.Width' size.Height); " is 151.
Long Statement,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,Draw2ndValueAxis,The length of the statement  "                        new System.Drawing.Rectangle(rect.Left - (int)(tSize.Width * .5)' rect.Top + rect.Height - h - size.Height / 2' rect.Width - tSize.Width * 2' size.Height); " is 155.
Long Statement,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,Draw2ndValueAxis,The length of the statement  "                DrawValueAxisTick(rpt' g' true' a.MajorTickMarks' a.MajorGridLines' new Point(plotRight - (AxisTickMarkMajorLen / 2)' rect.Top + rect.Height - h)); " is 147.
Long Statement,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,Draw,The length of the statement  "                _mf = new System.Drawing.Imaging.Metafile(_aStream' HDC' new RectangleF(0' 0' _bm.Width' _bm.Height)' System.Drawing.Imaging.MetafileFrameUnit.Pixel); " is 150.
Long Statement,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,Draw,The length of the statement  "						new System.Drawing.Rectangle(Layout.LeftMargin - vaSize.Width' Layout.TopMargin' vaSize.Width' Layout.PlotArea.Height)' Layout.LeftMargin' _bm.Width - Layout.RightMargin'out incr'out intervalCount); " is 198.
Long Statement,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,Draw,The length of the statement  "                        new System.Drawing.Rectangle(Layout.LeftMargin' _bm.Height - Layout.BottomMargin' Layout.PlotArea.Width' caSize.Height)' Layout.TopMargin' " is 138.
Long Statement,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,Draw,The length of the statement  "                    if ((ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.Stacked) " is 133.
Long Statement,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,Draw,The length of the statement  "                    else if ((ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.PercentStacked) " is 145.
Long Statement,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,DrawPlotAreaArea,The length of the statement  "                        String val = "ToolTip:" + v.ToString(_tooltipYFormat) + "|X:" + (int)(p.X - 5) + "|Y:" + (int)(p.Y - 5) + "|W:" + 10 + "|H:" + 10; " is 130.
Long Statement,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,DrawPlotAreaAreaPercentStacked,The length of the statement  "                        String val = "ToolTip:" + v.ToString(_tooltipYFormat) + "|X:" + (int)(p.X - 5) + "|Y:" + (int)(p.Y - 5) + "|W:" + 10 + "|H:" + 10; " is 130.
Long Statement,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,DrawPlotAreaAreaStacked,The length of the statement  "                        String val = "ToolTip:" + v.ToString(_tooltipYFormat) + "|X:" + (int)(saveP[iRow - 1].X - 5) + "|Y:" + (int)(saveP[iRow - 1].Y - 5) + "|W:" + 10 + "|H:" + 10; " is 158.
Long Statement,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,DrawPlotAreaLine,The length of the statement  "                        String val = "ToolTip:" + v.ToString(_tooltipYFormat) + "|X:" + (int)(p.X - 5) + "|Y:" + (int)(p.Y - 5) + "|W:" + 10 + "|H:" + 10; " is 130.
Long Statement,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,DrawLineBetweenPoints,The length of the statement  "                if ((ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.Smooth && points.Length > 2) " is 153.
Long Statement,fyiReporting.RDL,ChartPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartPie.cs,Draw,The length of the statement  "                _mf = new System.Drawing.Imaging.Metafile(_aStream' HDC' new RectangleF(0' 0' _bm.Width' _bm.Height)' System.Drawing.Imaging.MetafileFrameUnit.Pixel); " is 150.
Long Statement,fyiReporting.RDL,ChartPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartPie.cs,Draw,The length of the statement  "						new System.Drawing.Rectangle(Layout.LeftMargin' _bm.Height-Layout.BottomMargin' _bm.Width - Layout.LeftMargin - Layout.RightMargin' caSize.Height)); " is 148.
Long Statement,fyiReporting.RDL,ChartPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartPie.cs,DrawCategoryAxis,The length of the statement  "			DrawTitle(rpt' g' a.Title' new System.Drawing.Rectangle(rect.Left' rect.Bottom-tSize.Height' rect.Width' tSize.Height)); " is 120.
Long Statement,fyiReporting.RDL,ChartPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartPie.cs,DrawCategoryAxis,The length of the statement  "					System.Drawing.Rectangle drawRect = new System.Drawing.Rectangle(drawLoc' rect.Top' drawWidth' rect.Height-tSize.Height); " is 121.
Long Statement,fyiReporting.RDL,ChartPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartPie.cs,DrawPie,The length of the statement  "            if ((ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.Exploded) " is 134.
Long Statement,fyiReporting.RDL,Code,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Code.cs,GetAssembly,The length of the statement  "                    re = Path.Combine(AppDomain.CurrentDomain.BaseDirectory' "RdlEngine.dll");   // this can fail especially in web scenarios " is 121.
Long Statement,fyiReporting.RDL,Code,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Code.cs,GetAssembly,The length of the statement  "                re = Path.Combine(RdlEngineConfig.DirectoryLoadedFrom' "RdlEngine.dll");     // use RdlEngineConfig.xml directory when available " is 128.
Long Statement,fyiReporting.RDL,Code,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Code.cs,GetAssembly,The length of the statement  "				StringBuilder err = new StringBuilder(string.Format("Code element has {0} error(s).  Line numbers are relative to Code element."' cr.Errors.Count)); " is 148.
Long Statement,fyiReporting.RDL,Code,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Code.cs,Load,The length of the statement  "				wc.Instance = _Assembly.CreateInstance("fyiReporting.vbgen." + this._Classname' false' BindingFlags.CreateInstance' null' args' null' null);  " is 140.
Long Statement,fyiReporting.RDL,ChartMap,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMap.cs,Draw,The length of the statement  "                _mf = new System.Drawing.Imaging.Metafile(_aStream' HDC' new RectangleF(0' 0' _bm.Width' _bm.Height)'System.Drawing.Imaging.MetafileFrameUnit.Pixel); " is 149.
Long Statement,fyiReporting.RDL,DynamicExpression,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DynamicExpression.cs,DoParse,The length of the statement  "				rpt.rl.LogError(4' "Expression:" + _Source + "\r\nConstant Optimization exception:\r\n" + ex.Message + "\r\nStack trace:\r\n" + ex.StackTrace ); " is 144.
Long Statement,fyiReporting.RDL,DataRegion,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataRegion.cs,FinalPass,The length of the statement  "				OwnerReport.rl.LogError(8' String.Format("The DataRegion '{0}' is not allowed in a PageHeader or PageFooter"' this.Name == null? "unknown": Name.Nm) ); " is 151.
Long Statement,fyiReporting.RDL,DataRegion,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataRegion.cs,FinalPass,The length of the statement  "					OwnerReport.rl.LogError(8' string.Format("{0} must specify a DataSetName."'this.Name == null? "DataRegions": this.Name.Nm)); " is 124.
Long Statement,fyiReporting.RDL,DrawEllipse,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawEllipse.cs,DoEllipse,The length of the statement  "            //Lines.AppendFormat("{0} {1} {2} RG\t"' Math.Round(R / 255.0' 3)' Math.Round(G / 255.0' 3)' Math.Round(B / 255.0' 3)); //Set RGB colours " is 137.
Long Statement,fyiReporting.RDL,DrawEllipse,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawEllipse.cs,DoEllipse,The length of the statement  "            //Lines.AppendFormat("{0} {1} {2} rg\t"' Math.Round(R / 255.0' 3)' Math.Round(G / 255.0' 3)' Math.Round(B / 255.0' 3)); //Set RGB colours " is 137.
Long Statement,fyiReporting.RDL,FillEllipse,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillEllipse.cs,DoInstructions,The length of the statement  "                    //Lines.AppendFormat("{0} {1} {2} RG\t"' Math.Round(theBrush.Color.R / 255.0' 3)' Math.Round(theBrush.Color.G / 255.0' 3)' Math.Round(theBrush.Color.B / 255.0' 3)); //Set RGB colours " is 182.
Long Statement,fyiReporting.RDL,FillEllipse,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillEllipse.cs,DoInstructions,The length of the statement  "                    //Lines.AppendFormat("{0} {1} {2} rg\t"' Math.Round(theBrush.Color.R / 255.0' 3)' Math.Round(theBrush.Color.G / 255.0' 3)' Math.Round(theBrush.Color.B / 255.0' 3)); //Set RGB colours " is 182.
Long Statement,fyiReporting.RDL,Expression,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Expression.cs,FinalPass,The length of the statement  "				OwnerReport.rl.LogError(4' "Expression:" + _Source + "\r\nConstant Optimization exception:\r\n" + ex.Message + "\r\nStack trace:\r\n" + ex.StackTrace ); " is 152.
Long Statement,fyiReporting.RDL,Image,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Image.cs,RunPage,The length of the statement  "					default: // from old code where all images convert to jpeg' i don't know why. May be need delete it and add all support formats. " is 128.
Long Statement,fyiReporting.RDL,Query,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Query.cs,FinalPass,The length of the statement  "						OwnerReport.rl.LogError(8' String.Format("Column '{0}' is not uniquely defined within the SQL Select columns."' qc.colName)); " is 125.
Long Statement,fyiReporting.RDL,RDLParser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\RDLParser.cs,Parse,The length of the statement  "			ReportDefn rd = new ReportDefn(xNode' rl' this._Folder' this._DataSourceReferencePassword' oc' OnSubReportGetContent' OverwriteConnectionString' OverwriteInSubreport); " is 167.
Long Statement,fyiReporting.RDL,ReportItem,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportItem.cs,PositioningFinalPass,The length of the statement  "                if (xw <= x && xw + w2 >= x + w &&       // if item above completely covers the report item then it will be pushed down first " is 125.
Long Statement,fyiReporting.RDL,ReportItem,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportItem.cs,PositioningFinalPass,The length of the statement  "            //    //if (xw > right || x > xw + w2)                    // this allows items to be repositioned only based on what's above them " is 129.
Long Statement,fyiReporting.RDL,ReportParameter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportParameter.cs,SetRuntimeValues,The length of the statement  "                throw new ArgumentException(string.Format("{0} is not a MultiValue parameter. SetRuntimeValues only valid for MultiValue parameters"' this.Name.Nm)); " is 149.
Long Statement,fyiReporting.RDL,Style,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Style.cs,DrawBorder,The length of the statement  "					topWidth = bottomWidth = leftWidth = rightWidth = (int) new RSize(this.OwnerReport' BorderWidth.Default.EvaluateString(rpt' r)).PixelsX; " is 136.
Long Statement,fyiReporting.RDL,StyleBackgroundImage,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\StyleBackgroundImage.cs,GetPageImage,The length of the statement  "                encoderParameters.Param[0] = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality' ImageQualityManager.EmbeddedImageQuality); " is 132.
Long Statement,fyiReporting.RDL,Subreport,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Subreport.cs,FinalPass,The length of the statement  "				OwnerReport.rl.LogError(8' String.Format("The Subreport '{0}' is not allowed in a PageHeader or PageFooter"' this.Name == null? "unknown": Name.Nm) ); " is 150.
Long Statement,fyiReporting.RDL,Table,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Table.cs,PrepRecursiveGroup,The length of the statement  "            List<Row> odata = new List<Row>(wc.Data.Data);			// this is the old data that we'll recreate using the recursive hierarchy " is 122.
Long Statement,fyiReporting.RDL,Textbox,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Textbox.cs,FinalPass,The length of the statement  "					OwnerReport.rl.LogError(4' "HideDuplicate '" +_HideDuplicates + "' is not a Group or DataSet name.   It will be ignored."); " is 123.
Long Statement,fyiReporting.RDL,RenderBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderBase.cs,ProcessPage,The length of the statement  "                    RectangleF r2 = new RectangleF(i.X + i.SI.PaddingLeft' i.Y + i.SI.PaddingTop' i.W - i.SI.PaddingLeft - i.SI.PaddingRight' i.H - i.SI.PaddingTop - i.SI.PaddingBottom); " is 166.
Long Statement,fyiReporting.RDL,RenderBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderBase.cs,ProcessPage,The length of the statement  "                            adjustedRect.X' adjustedRect.Y' adjustedRect.Width' adjustedRect.Height' clipRect' i.ImageData' i.SamplesW' i.SamplesH' i.HyperLink' i.Tooltip); " is 144.
Long Statement,fyiReporting.RDL,RenderExcel2003,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderExcel2003.cs,CopyRow,The length of the statement  "                        if (newMergedRegion.FirstColumn == 0 && newMergedRegion.LastColumn == 6 && newMergedRegion.FirstRow == newMergedRegion.LastRow) " is 127.
Long Statement,fyiReporting.RDL,RenderPdf_iTextSharp,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf_iTextSharp.cs,AddText,The length of the statement  "                    //25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text " is 162.
Long Statement,fyiReporting.RDL,RenderPdf_iTextSharp,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf_iTextSharp.cs,AddText,The length of the statement  "                            //else use Column text to wrap or clip (wrap: for example a text like an URL so word break is not working here' itextsharp ColumnText do the work for us) " is 153.
Long Statement,fyiReporting.RDL,RenderPdf_iTextSharp,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf_iTextSharp.cs,AddText,The length of the statement  "                            ct.SetSimpleColumn(myPhrase' x + si.PaddingLeft' PageSize.yHeight - startY' x + width - si.PaddingRight' PageSize.yHeight - y - si.PaddingBottom - height' 10f' align); " is 167.
Long Statement,fyiReporting.RDL,RenderPdf_iTextSharp,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf_iTextSharp.cs,AddText,The length of the statement  "                        _contentByte.SetTextMatrix((float)radsCos' (float)radsSin' (float)-radsSin' (float)radsCos' startX' PageSize.yHeight - startY); " is 127.
Long Statement,fyiReporting.RDL,RenderPdf_iTextSharp,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf_iTextSharp.cs,AddText,The length of the statement  "                        AddLine(startX' startY + (si.FontSize / 2) + 1' maxX' startY + (si.FontSize / 2) + 1' 1' si.Color' BorderStyleEnum.Solid); " is 122.
Long Statement,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,SetMerge,The length of the statement  "                if (si.Name == name)                            // WRP 31102008 sheet already exists add merge data to correct table/list " is 121.
Long Statement,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,GetCellFormatIndex,The length of the statement  "                    && change))  //general code (default format) already added - checking to see if format has changed - need another entry if that is the case " is 139.
Long Statement,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,GetCellFormatIndex,The length of the statement  "                sb.AppendFormat("<xf numFmtId= \"{0}\" fontId= \"{1}\" fillId= \"{2}\" borderId= \"{3}\" xfId= \"0\" applyNumberFormat= \"1\" "' (StyleInfo.GetFormatCode(si._Format))' fi' filli' bi); " is 183.
Long Statement,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,GetCellFormatIndex,The length of the statement  "                        sb.AppendFormat("<xf numFmtId= \"{0}\" fontId= \"{1}\" fillId= \"{2}\" borderId= \"{3}\" xfId= \"0\" applyNumberFormat= \"1\" "' (_FormatCache.GetIndex(f) + 164)' fi' filli' bi); " is 178.
Long Statement,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,GetFormatIndex,The length of the statement  "                sb.AppendFormat("<numFmt numFmtId = \"{0}\" formatCode =\"{1}\"/> "' (_FormatCache.Count + 164)' si._Format);  //WRP 31102008 "164" seems to be default base value for user defined formats " is 187.
Long Statement,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,WriteStyles,The length of the statement  "            sb.AppendLine("<cellStyleXfs count=\"1\"><xf numFmtId= \"0\" fontId=\"0\" fillId=\"0\" borderId=\"0\" /></cellStyleXfs>"); " is 122.
Long Statement,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,WriteStyles,The length of the statement  "            sb.AppendLine("<dxfs count=\"0\"/><tableStyles count=\"0\" defaultTableStyle=\"TableStyleMedium9\" defaultPivotStyle=\"PivotStyleLight16\"/>"); " is 143.
Long Statement,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,WriteTheme,The length of the statement  "                "<a:font script=\"Cher\" typeface=\"Plantagenet Cherokee\"/><a:font script=\"Yiii\" typeface=\"Microsoft Yi Baiti\"/>" + " is 120.
Long Statement,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,WriteTheme,The length of the statement  "                "</a:gs><a:gs pos=\"100000\"><a:schemeClr val=\"phClr\"><a:tint val=\"15000\"/><a:satMod val=\"350000\"/></a:schemeClr>" + " is 122.
Long Statement,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,WriteTheme,The length of the statement  "                "</a:schemeClr></a:gs><a:gs pos=\"100000\"><a:schemeClr val=\"phClr\"><a:shade val=\"94000\"/><a:satMod val=\"135000\"/>" + " is 123.
Long Statement,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,WriteTheme,The length of the statement  "                "<a:ln w=\"9525\" cap=\"flat\" cmpd=\"sng\" algn=\"ctr\"><a:solidFill><a:schemeClr val=\"phClr\"><a:shade val=\"95000\"/>" + " is 124.
Long Statement,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,WriteTheme,The length of the statement  "                "<a:schemeClr val=\"phClr\"><a:tint val=\"40000\"/><a:satMod val=\"350000\"/></a:schemeClr></a:gs><a:gs pos=\"40000\">" + " is 121.
Long Statement,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,WriteTheme,The length of the statement  "                "</a:gs><a:gs pos=\"100000\"><a:schemeClr val=\"phClr\"><a:shade val=\"20000\"/><a:satMod val=\"255000\"/></a:schemeClr>" + " is 123.
Long Statement,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,WriteTheme,The length of the statement  "                "</a:gradFill><a:gradFill rotWithShape=\"1\"><a:gsLst><a:gs pos=\"0\"><a:schemeClr val=\"phClr\"><a:tint val=\"80000\"/>" + " is 123.
Long Statement,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,WriteTheme,The length of the statement  "                "<a:satMod val=\"300000\"/></a:schemeClr></a:gs><a:gs pos=\"100000\"><a:schemeClr val=\"phClr\"><a:shade val=\"30000\"/>" + " is 123.
Long Statement,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,WriteTheme,The length of the statement  "                "<a:fillToRect l=\"50000\" t=\"50000\" r=\"50000\" b=\"50000\"/></a:path></a:gradFill></a:bgFillStyleLst></a:fmtScheme>" + " is 122.
Long Statement,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,WriteWorkbookRels,The length of the statement  "                sb.AppendFormat("<Relationship Id=\"rId{0}\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet\" " + " is 135.
Long Statement,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,WriteApp,The length of the statement  "            sb.Append("<HeadingPairs><vt:vector size=\"2\" baseType=\"variant\"><vt:variant><vt:lpstr>Worksheets</vt:lpstr></vt:variant><vt:variant>"); " is 139.
Long Statement,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,CheckMergedCellsFormat,The length of the statement  "                char[] chrs = { 'A'''B'''C'''D'''E'''F'''G'''H'''I'''J'''K'''L'''M'''N'''O'''P'''Q'''R'''S'''T'''U'''V'''W'''X'''Y'''Z' };  " is 122.
Long Statement,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,WriteGridData,The length of the statement  "            //WRP 311008 various date format expressions for date matching  - specific formats should be added here if required - format should match report format " is 151.
Long Statement,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,WriteGridData,The length of the statement  "             string[] dateformats = new string[] {"d/M/yyyy"'"d/M/yy"'"M/d/yyyy"'"M/d/yy"'"MMMM dd' yyyy"'"d-MMM-yyyy"'"d-MMM-yy"'"d-MMMM-yyyy"'"d-MMMM-yy"'"d/MMMM/yyyy"'"d-MMMM-yyyy"'"d MMM yyyy"}; " is 185.
Long Statement,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,WriteGridData,The length of the statement  "            DateTime BaseDate = new DateTime(1899' 12' 31);     // WRP 31102008 Excel07 base date - includes 1/jan/1900 with a base value of 1 " is 130.
Long Statement,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,WriteGridData,The length of the statement  "            int Days = 0;                                       //WRP 31102008 used to store number of days since basedate (Excel07 format for a date) " is 138.
Long Statement,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,WriteGridData,The length of the statement  "                        //using specific date formats (ignore culture) to check for date value - cannot have any string values in data sheet - must reference them from sharedstring XML document. " is 170.
Long Statement,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,WriteGridData,The length of the statement  "                        if ((DateTime.TryParseExact(value' dateformats' System.Globalization.CultureInfo.InvariantCulture' System.Globalization.DateTimeStyles.None' out ValueDate))) " is 157.
Long Statement,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,WriteGridData,The length of the statement  "                            if (Days >= 60) Days++;          // WRP 31102008 must allow adjust for 29 Feb 1900 which Excel considers a valid date  - it is NOT!!! " is 133.
Long Statement,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,WriteGridData,The length of the statement  "                        {   //WRP 31102008 RDL number values in reports contain fromatting characters - need to remove these to extract pure numbers " is 124.
Long Statement,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,WriteGridData,The length of the statement  "                            if (value.IndexOf('%') != -1)       //WRP 31102008 if a properly RDL formatted percentage need to remove "%" and pass throught value/100 to excel for correct formatting " is 168.
Long Statement,fyiReporting.RDL,RenderExcel,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderExcel.cs,TableCellStart,The length of the statement  "                _Excel.SetMerge(string.Format("{0}{1}:{2}{3}"' (char)('A' + _ExcelCol)' _ExcelRow + 1' (char)('A' + _ExcelCol + t.ColSpan - 1)' _ExcelRow + 1)' SheetName); " is 155.
Long Statement,fyiReporting.RDL,RenderTif,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderTif.cs,DrawPie,The length of the statement  "                g.FillPie(new SolidBrush(si.BackgroundColor)' (int)r.X' (int)r.Y' (int)r.Width' (int)r.Height' (float)pp.StartAngle' (float)pp.SweepAngle); " is 139.
Long Statement,fyiReporting.RDL,RenderTif,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderTif.cs,ConvertToBitonal,The length of the statement  "            BitmapData sourceData = source.LockBits(new System.Drawing.Rectangle(0' 0' source.Width' source.Height)' ImageLockMode.ReadOnly' PixelFormat.Format32bppArgb); " is 158.
Long Statement,fyiReporting.RDL,RenderTif,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderTif.cs,ConvertToBitonal,The length of the statement  "            BitmapData destinationData = destination.LockBits(new System.Drawing.Rectangle(0' 0' destination.Width' destination.Height)' ImageLockMode.WriteOnly' PixelFormat.Format1bppIndexed); " is 181.
Long Statement,fyiReporting.RDL,RenderHtmlTable,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\HtmlConverter\RenderHtmlTable.cs,ScriptGenerate,The length of the statement  "				ftw.WriteLine("        if (node.childNodes[ci].tagName && node.childNodes[ci].tagName.toLowerCase() == 'span') arrowNode = node.childNodes[ci];"); " is 146.
Long Statement,fyiReporting.RDL,RenderHtmlTable,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\HtmlConverter\RenderHtmlTable.cs,ScriptGenerate,The length of the statement  "				ftw.WriteLine("    for (j=header_rows;j<table.rows.length-footer_rows;j++) { newRows[j-header_rows] = table.rows[j]; }"); " is 121.
Long Statement,fyiReporting.RDL,RenderHtmlTable,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\HtmlConverter\RenderHtmlTable.cs,TableCellStart,The length of the statement  "					tw.Write(" onClick=\"hideShow(this' {0}' '{1}')\" onMouseOver=\"style.cursor ='hand';style.cursor ='pointer'\">"' groupNestCount' name); " is 136.
Long Statement,fyiReporting.RDL,RenderHtmlTable,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\HtmlConverter\RenderHtmlTable.cs,TableCellStart,The length of the statement  "					tw.Write("<a href=\"#\" title='Sort' onclick=\"sort_table(this'{0}'{1}'{2});return false;\">"'sortcmp' headerRows' footerRows); " is 127.
Long Statement,fyiReporting.RDL,RenderHtmlTable,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\HtmlConverter\RenderHtmlTable.cs,Line,The length of the statement  "				t = "<TABLE style=\"border-collapse:collapse;BORDER-STYLE: none;WIDTH: {0}; POSITION: absolute; LEFT: {1}; TOP: {2}; HEIGHT: {3}; BACKGROUND-COLOR:{4};\"><TBODY><TR style=\"WIDTH:{0}\"><TD style=\"WIDTH:{0}\"></TD></TR></TBODY></TABLE>"; " is 237.
Long Statement,fyiReporting.RDL,RenderHtmlTable,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\HtmlConverter\RenderHtmlTable.cs,Line,The length of the statement  "				t = "<TABLE style=\"border-collapse:collapse;BORDER-STYLE: none;WIDTH: {0}; POSITION: absolute; LEFT: {1}; TOP: {2}; HEIGHT: {3}; BACKGROUND-COLOR:{4};\"><TBODY><TR style=\"HEIGHT:{3}\"><TD style=\"HEIGHT:{3}\"></TD></TR></TBODY></TABLE>"; " is 239.
Long Statement,fyiReporting.RDL,Lexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Lexer.cs,ReadIdentifier,The length of the statement  "			else if (key == "or" || key == "orelse")    // technically 'or' and 'orelse' mean different things; but we treat the same " is 121.
Long Statement,fyiReporting.RDL,Parser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Parser.cs,MatchFuncIDent,The length of the statement  "							throw new ParserException(string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Fields") + GetLocationInfo(curToken)); " is 134.
Long Statement,fyiReporting.RDL,Parser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Parser.cs,MatchFuncIDent,The length of the statement  "                            throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Parameters") + GetLocationInfo(curToken))); " is 140.
Long Statement,fyiReporting.RDL,Parser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Parser.cs,MatchFuncIDent,The length of the statement  "                            throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "ReportItems") + GetLocationInfo(curToken))); " is 141.
Long Statement,fyiReporting.RDL,Parser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Parser.cs,MatchFuncIDent,The length of the statement  "							throw new ParserException(string.Format(Strings.Parser_ErrorP_RunningValueNotSupported' aggrFunc) + GetLocationInfo(curToken)); " is 127.
Long Statement,fyiReporting.RDL,Financial,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\Financial.cs,DDB,The length of the statement  "				return cost - salvage - depreciation;		// for last year we force the depreciation so that cost - total depreciation = salvage " is 125.
Long Statement,fyiReporting.RDL,FunctionAggr,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\FunctionAggr.cs,GetDataScope,The length of the statement  "						if (row == null || row.R.CurrentGroups == null)     // currentGroups can be null when reference Textbox in header/footer that has a scoped aggr function reference (TODO: this is a problem!) " is 189.
Long Statement,fyiReporting.RDL,FunctionFormat,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\FunctionFormat.cs,EvaluateString,The length of the statement  "				rpt.rl.LogError(2' String.Format("Format string:{1} Value Type:{2} Exception:{0}"' ex.Message' format' o.GetType().Name)); " is 122.
Long Statement,fyiReporting.RDL,VBFunctions,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\VBFunctions.cs,InStrRev,The length of the statement  "			while (inc >= string2.Length)	// go thru the string backwards; but string still needs to long enough to hold find string " is 120.
Long Statement,fyiReporting.RDL,MhtBuilder,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtBuilder.cs,AppendMhtHeader,The length of the statement  "			AppendMhtLine("X-MimeOLE: Produced by " + this.GetType().ToString() + " " + Assembly.GetExecutingAssembly().GetName().Version.ToString()); " is 138.
Long Statement,fyiReporting.RDL,MhtBuilder,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtBuilder.cs,DownloadHtmlFile,The length of the statement  "				throw new Exception(string.Format(Strings.MhtBuilder_Error_UnableDownload' Url' _HtmlFile.DownloadException.Message)' _HtmlFile.DownloadException); " is 147.
Long Statement,fyiReporting.RDL,MhtBuilder,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtBuilder.cs,ValidateFilename,The length of the statement  "				throw new Exception(string.Format(Strings.MhtBuilder_Error_FilenameNoExtension' Path.GetFileName(FilePath)' fileExtensions)); " is 125.
Long Statement,fyiReporting.RDL,ExtendedBinaryReader,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtWebClientLocal.cs,ReadToEnd,The length of the statement  "				//				for (int chunk = this.BaseStream.Read(buffer' read' buffer.Length - read); chunk > 0; chunk = this.BaseStream.Read(buffer' read' buffer.Length - read)) " is 157.
Long Statement,fyiReporting.RDL,MhtWebFile,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtWebFile.cs,FilenameFromUrl,The length of the statement  "					filename = Path.GetFileNameWithoutExtension(filename) + "_" + u.Query.GetHashCode().ToString() + this.DownloadExtension; " is 120.
Long Statement,fyiReporting.RDL,MhtWebFile,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtWebFile.cs,HtmlLookup,The length of the statement  "							"\"-quot"' "&-amp"' "<-lt"' ">-gt"' "\x00a0-nbsp"' "\x00a1-iexcl"' "\x00a2-cent"' "\x00a3-pound"' "\x00a4-curren"' "\x00a5-yen"' "\x00a6-brvbar"' "\x00a7-sect"' "\x00a8-uml"' "\x00a9-copy"' "\x00aa-ordf"' "\x00ab-laquo"'  " is 220.
Long Statement,fyiReporting.RDL,MhtWebFile,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtWebFile.cs,HtmlLookup,The length of the statement  "							"\x00ac-not"' "\x00ad-shy"' "\x00ae-reg"' "\x00af-macr"' "\x00b0-deg"' "\x00b1-plusmn"' "\x00b2-sup2"' "\x00b3-sup3"' "\x00b4-acute"' "\x00b5-micro"' "\x00b6-para"' "\x00b7-middot"' "\x00b8-cedil"' "\x00b9-sup1"' "\x00ba-ordm"' "\x00bb-raquo"'  " is 243.
Long Statement,fyiReporting.RDL,MhtWebFile,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtWebFile.cs,HtmlLookup,The length of the statement  "							"\x00bc-frac14"' "\x00bd-frac12"' "\x00be-frac34"' "\x00bf-iquest"' "\x00c0-Agrave"' "\x00c1-Aacute"' "\x00c2-Acirc"' "\x00c3-Atilde"' "\x00c4-Auml"' "\x00c5-Aring"' "\x00c6-AElig"' "\x00c7-Ccedil"' "\x00c8-Egrave"' "\x00c9-Eacute"' "\x00ca-Ecirc"' "\x00cb-Euml"'  " is 263.
Long Statement,fyiReporting.RDL,MhtWebFile,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtWebFile.cs,HtmlLookup,The length of the statement  "							"\x00cc-Igrave"' "\x00cd-Iacute"' "\x00ce-Icirc"' "\x00cf-Iuml"' "\x00d0-ETH"' "\x00d1-Ntilde"' "\x00d2-Ograve"' "\x00d3-Oacute"' "\x00d4-Ocirc"' "\x00d5-Otilde"' "\x00d6-Ouml"' "\x00d7-times"' "\x00d8-Oslash"' "\x00d9-Ugrave"' "\x00da-Uacute"' "\x00db-Ucirc"'  " is 260.
Long Statement,fyiReporting.RDL,MhtWebFile,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtWebFile.cs,HtmlLookup,The length of the statement  "							"\x00dc-Uuml"' "\x00dd-Yacute"' "\x00de-THORN"' "\x00df-szlig"' "\x00e0-agrave"' "\x00e1-aacute"' "\x00e2-acirc"' "\x00e3-atilde"' "\x00e4-auml"' "\x00e5-aring"' "\x00e6-aelig"' "\x00e7-ccedil"' "\x00e8-egrave"' "\x00e9-eacute"' "\x00ea-ecirc"' "\x00eb-euml"'  " is 259.
Long Statement,fyiReporting.RDL,MhtWebFile,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtWebFile.cs,HtmlLookup,The length of the statement  "							"\x00ec-igrave"' "\x00ed-iacute"' "\x00ee-icirc"' "\x00ef-iuml"' "\x00f0-eth"' "\x00f1-ntilde"' "\x00f2-ograve"' "\x00f3-oacute"' "\x00f4-ocirc"' "\x00f5-otilde"' "\x00f6-ouml"' "\x00f7-divide"' "\x00f8-oslash"' "\x00f9-ugrave"' "\x00fa-uacute"' "\x00fb-ucirc"'  " is 261.
Long Statement,fyiReporting.RDL,MhtWebFile,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtWebFile.cs,HtmlLookup,The length of the statement  "							"\x00fc-uuml"' "\x00fd-yacute"' "\x00fe-thorn"' "\x00ff-yuml"' "\u0152-OElig"' "\u0153-oelig"' "\u0160-Scaron"' "\u0161-scaron"' "\u0178-Yuml"' "\u0192-fnof"' "\u02c6-circ"' "\u02dc-tilde"' "\u0391-Alpha"' "\u0392-Beta"' "\u0393-Gamma"' "\u0394-Delta"'  " is 252.
Long Statement,fyiReporting.RDL,MhtWebFile,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtWebFile.cs,HtmlLookup,The length of the statement  "							"\u0395-Epsilon"' "\u0396-Zeta"' "\u0397-Eta"' "\u0398-Theta"' "\u0399-Iota"' "\u039a-Kappa"' "\u039b-Lambda"' "\u039c-Mu"' "\u039d-Nu"' "\u039e-Xi"' "\u039f-Omicron"' "\u03a0-Pi"' "\u03a1-Rho"' "\u03a3-Sigma"' "\u03a4-Tau"' "\u03a5-Upsilon"'  " is 242.
Long Statement,fyiReporting.RDL,MhtWebFile,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtWebFile.cs,HtmlLookup,The length of the statement  "							"\u03a6-Phi"' "\u03a7-Chi"' "\u03a8-Psi"' "\u03a9-Omega"' "\u03b1-alpha"' "\u03b2-beta"' "\u03b3-gamma"' "\u03b4-delta"' "\u03b5-epsilon"' "\u03b6-zeta"' "\u03b7-eta"' "\u03b8-theta"' "\u03b9-iota"' "\u03ba-kappa"' "\u03bb-lambda"' "\u03bc-mu"'  " is 244.
Long Statement,fyiReporting.RDL,MhtWebFile,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtWebFile.cs,HtmlLookup,The length of the statement  "							"\u03bd-nu"' "\u03be-xi"' "\u03bf-omicron"' "\u03c0-pi"' "\u03c1-rho"' "\u03c2-sigmaf"' "\u03c3-sigma"' "\u03c4-tau"' "\u03c5-upsilon"' "\u03c6-phi"' "\u03c7-chi"' "\u03c8-psi"' "\u03c9-omega"' "\u03d1-thetasym"' "\u03d2-upsih"' "\u03d6-piv"'  " is 242.
Long Statement,fyiReporting.RDL,MhtWebFile,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtWebFile.cs,HtmlLookup,The length of the statement  "							"\u2002-ensp"' "\u2003-emsp"' "\u2009-thinsp"' "\u200c-zwnj"' "\u200d-zwj"' "\u200e-lrm"' "\u200f-rlm"' "\u2013-ndash"' "\u2014-mdash"' "\u2018-lsquo"' "\u2019-rsquo"' "\u201a-sbquo"' "\u201c-ldquo"' "\u201d-rdquo"' "\u201e-bdquo"' "\u2020-dagger"'  " is 248.
Long Statement,fyiReporting.RDL,MhtWebFile,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtWebFile.cs,HtmlLookup,The length of the statement  "							"\u2021-Dagger"' "\u2022-bull"' "\u2026-hellip"' "\u2030-permil"' "\u2032-prime"' "\u2033-Prime"' "\u2039-lsaquo"' "\u203a-rsaquo"' "\u203e-oline"' "\u2044-frasl"' "\u20ac-euro"' "\u2111-image"' "\u2118-weierp"' "\u211c-real"' "\u2122-trade"' "\u2135-alefsym"'  " is 260.
Long Statement,fyiReporting.RDL,MhtWebFile,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtWebFile.cs,HtmlLookup,The length of the statement  "							"\u2190-larr"' "\u2191-uarr"' "\u2192-rarr"' "\u2193-darr"' "\u2194-harr"' "\u21b5-crarr"' "\u21d0-lArr"' "\u21d1-uArr"' "\u21d2-rArr"' "\u21d3-dArr"' "\u21d4-hArr"' "\u2200-forall"' "\u2202-part"' "\u2203-exist"' "\u2205-empty"' "\u2207-nabla"'  " is 245.
Long Statement,fyiReporting.RDL,MhtWebFile,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtWebFile.cs,HtmlLookup,The length of the statement  "							"\u2208-isin"' "\u2209-notin"' "\u220b-ni"' "\u220f-prod"' "\u2211-sum"' "\u2212-minus"' "\u2217-lowast"' "\u221a-radic"' "\u221d-prop"' "\u221e-infin"' "\u2220-ang"' "\u2227-and"' "\u2228-or"' "\u2229-cap"' "\u222a-cup"' "\u222b-int"'  " is 235.
Long Statement,fyiReporting.RDL,MhtWebFile,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtWebFile.cs,HtmlLookup,The length of the statement  "							"\u2234-there4"' "\u223c-sim"' "\u2245-cong"' "\u2248-asymp"' "\u2260-ne"' "\u2261-equiv"' "\u2264-le"' "\u2265-ge"' "\u2282-sub"' "\u2283-sup"' "\u2284-nsub"' "\u2286-sube"' "\u2287-supe"' "\u2295-oplus"' "\u2297-otimes"' "\u22a5-perp"'  " is 237.
Long Statement,fyiReporting.RDL,MhtWebFile,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtWebFile.cs,HtmlLookup,The length of the statement  "							"\u22c5-sdot"' "\u2308-lceil"' "\u2309-rceil"' "\u230a-lfloor"' "\u230b-rfloor"' "\u2329-lang"' "\u232a-rang"' "\u25ca-loz"' "\u2660-spades"' "\u2663-clubs"' "\u2665-hearts"' "\u2666-diams" " is 189.
Long Statement,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddImage,The length of the statement  "                                      clipRect.X + pSize.leftMargin' pSize.yHeight - clipRect.Y - clipRect.Height - pSize.topMargin' clipRect.Width' clipRect.Height); " is 128.
Long Statement,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddImage,The length of the statement  "			elements.AppendFormat(NumberFormatInfo.InvariantInfo' "\t/{0} Do\tQ\t"' imgname);	// do the image then pop graphics state " is 121.
Long Statement,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddCurve,The length of the statement  "				elements.AppendFormat("{0} {1} {2} RG\t"' Math.Round(si.BColorTop.R / 255.0' 3)' Math.Round(si.BColorTop.G / 255.0' 3)' Math.Round(si.BColorTop.B / 255.0' 3)); //Set Stroking colours " is 182.
Long Statement,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddCurve,The length of the statement  "				elements.AppendFormat("{0} {1} {2} rg\t"' Math.Round(si.BackgroundColor.R / 255.0' 3)' Math.Round(si.BackgroundColor.G / 255.0' 3)' Math.Round(si.BackgroundColor.B / 255.0' 3)); //Set Non Stroking colours " is 204.
Long Statement,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddCurve,The length of the statement  "			elements.AppendFormat("{0} {1} {2} {3} {4} {5}  c\t"' X2' pSize.yHeight -Y2' X3'pSize.yHeight-Y3' X4'pSize.yHeight- Y4);		 " is 120.
Long Statement,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddEllipse,The length of the statement  "				//Ok we need to draw 4 bezier curves - Unfortunately we cant call drawcurve 4 times because of the fill - we would end up drawing 4 filled arcs with an empty diamond in the middle " is 179.
Long Statement,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddEllipse,The length of the statement  "					elements.AppendFormat("{0} {1} {2} RG\t"' Math.Round(si.BColorTop.R / 255.0' 3)' Math.Round(si.BColorTop.G / 255.0' 3)' Math.Round(si.BColorTop.B / 255.0' 3)); //Set Stroking colours " is 182.
Long Statement,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddEllipse,The length of the statement  "					elements.AppendFormat("{0} {1} {2} rg\t"' Math.Round(si.BackgroundColor.R / 255.0' 3)' Math.Round(si.BackgroundColor.G / 255.0' 3)' Math.Round(si.BackgroundColor.B / 255.0' 3)); //Set Non Stroking colours " is 204.
Long Statement,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddEllipse,The length of the statement  "            	elements.AppendFormat("{0} {1} {2} {3} {4} {5}  c\t"' X2' pSize.yHeight -Y2' X3'pSize.yHeight-Y3' X4'pSize.yHeight- Y4);	 " is 120.
Long Statement,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddEllipse,The length of the statement  "            	elements.AppendFormat("{0} {1} {2} {3} {4} {5}  c\t"' X3' pSize.yHeight -Y3' X2'pSize.yHeight-Y2' X1'pSize.yHeight- Y1);	 " is 120.
Long Statement,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddEllipse,The length of the statement  "                elements.AppendFormat("{0} {1} {2} {3} {4} {5}  c\t"' X2' pSize.yHeight -Y2' X3'pSize.yHeight-Y3' X4'pSize.yHeight- Y4);	 " is 120.
Long Statement,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddEllipse,The length of the statement  "                elements.AppendFormat("{0} {1} {2} {3} {4} {5}  c\t"' X3' pSize.yHeight -Y3' X2'pSize.yHeight-Y2' X1'pSize.yHeight- Y1); " is 120.
Long Statement,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddText,The length of the statement  "					//25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text " is 162.
Long Statement,fyiReporting.RDL,PdfPage,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfPage.cs,AddHyperlink,The length of the statement  "			annotsDict += string.Format(@"<</Type /Annot /Subtype /Link /Rect [{0} {1} {2} {3}] /Border [0 0 0] /A <</S /URI /URI ({4})>>>>"' " is 129.
Long Statement,fyiReporting.RDL,PdfPage,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfPage.cs,AddToolTip,The length of the statement  "            annotsDict += string.Format(@"<</Type /Annot /Rect [{0} {1} {2} {3}] /Border [0 0 0] /IC [1.0 1.0 0.666656] /CA 0.00500488 /C [1.0 0.0 0.0] /Name/Comment /T(Value) /Contents({4}) /F 288 /Subtype/Square>>"'  /*/A <</S /URI /URI ({4})>>*/ " is 236.
Long Statement,fyiReporting.RDL,PdfPage,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfPage.cs,GetPageDict,The length of the statement  "			//	resourceDict=string.Format("/Resources<</Font<<{0}>>/ProcSet[/PDF/Text/ImageB]/XObject <<{1}>>>>"'fontRef' imageRef); " is 120.
Long Statement,fyiReporting.RDL,RenderHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderHtml.cs,ScriptGenerate,The length of the statement  "				ftw.WriteLine("        if (node.childNodes[ci].tagName && node.childNodes[ci].tagName.toLowerCase() == 'span') arrowNode = node.childNodes[ci];"); " is 146.
Long Statement,fyiReporting.RDL,RenderHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderHtml.cs,ScriptGenerate,The length of the statement  "				ftw.WriteLine("    for (j=header_rows;j<table.rows.length-footer_rows;j++) { newRows[j-header_rows] = table.rows[j]; }"); " is 121.
Long Statement,fyiReporting.RDL,RenderHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderHtml.cs,TableCellStart,The length of the statement  "					tw.Write(" onClick=\"hideShow(this' {0}' '{1}')\" onMouseOver=\"style.cursor ='hand';style.cursor ='pointer'\">"' groupNestCount' name); " is 136.
Long Statement,fyiReporting.RDL,RenderHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderHtml.cs,TableCellStart,The length of the statement  "					tw.Write("<a href=\"#\" title='Sort' onclick=\"sort_table(this'{0}'{1}'{2});return false;\">"'sortcmp' headerRows' footerRows); " is 127.
Long Statement,fyiReporting.RDL,RenderHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderHtml.cs,Line,The length of the statement  "				t = "<TABLE style=\"border-collapse:collapse;BORDER-STYLE: none;WIDTH: {0}; POSITION: absolute; LEFT: {1}; TOP: {2}; HEIGHT: {3}; BACKGROUND-COLOR:{4};\"><TBODY><TR style=\"WIDTH:{0}\"><TD style=\"WIDTH:{0}\"></TD></TR></TBODY></TABLE>"; " is 237.
Long Statement,fyiReporting.RDL,RenderHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderHtml.cs,Line,The length of the statement  "				t = "<TABLE style=\"border-collapse:collapse;BORDER-STYLE: none;WIDTH: {0}; POSITION: absolute; LEFT: {1}; TOP: {2}; HEIGHT: {3}; BACKGROUND-COLOR:{4};\"><TBODY><TR style=\"HEIGHT:{3}\"><TD style=\"HEIGHT:{3}\"></TD></TR></TBODY></TABLE>"; " is 239.
Long Statement,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The length of the statement  "                    //25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text " is 162.
Long Statement,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The length of the statement  "                            //else use Column text to wrap or clip (wrap: for example a text like an URL so word break is not working here' itextsharp ColumnText do the work for us) " is 153.
Long Statement,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The length of the statement  "                            ct.SetSimpleColumn(myPhrase' x + si.PaddingLeft' _pSize.yHeight - startY' x + width - si.PaddingRight' _pSize.yHeight - y - si.PaddingBottom - height' 10f' align); " is 163.
Long Statement,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The length of the statement  "                        iAddLine(startX' startY + (si.FontSize / 2) + 1' maxX' startY + (si.FontSize / 2) + 1' 1' si.Color' BorderStyleEnum.Solid); " is 123.
Long Statement,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,RunPages,The length of the statement  "                    pdfdocument.SetPageSize(new iTextSharp.text.Rectangle(r.ReportDefinition.PageWidth.ToPoints()' r.ReportDefinition.PageHeight.ToPoints())); " is 138.
Long Statement,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,ProcessPage,The length of the statement  "                        outline.Bookmarks.Add(new PdfOutlineEntry(anchor' page.objectNum' pt.Bookmark' pt.X' elements.PageSize.yHeight - pt.Y)); " is 120.
Long Statement,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,ProcessPage,The length of the statement  "                    RectangleF r2 = new RectangleF(i.X + i.SI.PaddingLeft' i.Y + i.SI.PaddingTop' i.W - i.SI.PaddingLeft - i.SI.PaddingRight' i.H - i.SI.PaddingTop - i.SI.PaddingBottom); " is 166.
Long Statement,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,ProcessPage,The length of the statement  "                            adjustedRect.X' adjustedRect.Y' adjustedRect.Width' adjustedRect.Height' clipRect' i.ImageData' i.SamplesW' i.SamplesH' i.HyperLink' i.Tooltip); " is 144.
Long Statement,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,ProcessPage,The length of the statement  "                           adjustedRect.X' adjustedRect.Y' adjustedRect.Width' adjustedRect.Height' clipRect' i.ImageData' i.SamplesW' i.SamplesH' i.HyperLink' i.Tooltip); " is 144.
Long Statement,fyiReporting.RDL,RdlEngineConfig,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\RdlEngineConfig.cs,GetDataSource,The length of the statement  "                        sce = new SqlConfigEntry(provider' codemodule' cname' null' tselect' string.Format(Strings.RdlEngineConfig_Error_CashModuleNotFound' codemodule)); " is 146.
Long Statement,fyiReporting.RDL,StyleInfo,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\StyleInfo.cs,GetTextAlign,The length of the statement  "                ta = (TextAlignEnum)Enum.Parse(typeof(TextAlignEnum)' System.Globalization.CultureInfo.CurrentCulture.TextInfo.ToTitleCase(v)); " is 127.
Long Statement,System.Drawing,GraphicsExtended,C:\repos\majorsilence_My-FyiReporting\RdlEngine\GraphicsExtended.cs,DrawStringJustified,The length of the statement  "                    SizeF paragraphFormatSize = graphics.MeasureString(paragraphFormat.ToString()' new Font(font.FontFamily' font.Size' FontStyle.Regular)' layoutRectangle.Size' stringFormat); " is 172.
Long Statement,System.Drawing,GraphicsExtended,C:\repos\majorsilence_My-FyiReporting\RdlEngine\GraphicsExtended.cs,DrawStringJustified,The length of the statement  "                                rectangleF = new RectangleF(layoutRectangle.Left' (float)currentTop' layoutRectangle.Width' (float)(currentTop + lineHeight)); " is 126.
Complex Conditional,fyiReporting.RDL,CategoryGrouping,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\CategoryGrouping.cs,CategoryGrouping,The conditional expression  "(_DynamicCategories == null && _StaticCategories == null) ||  				(_DynamicCategories != null && _StaticCategories != null)"  is complex.
Complex Conditional,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The conditional expression  "(bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush))"  is complex.
Complex Conditional,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetValueMaxMin,The conditional expression  "vAxisMax != int.MinValue && ! vAxisMax.Equals(double.NaN) &&                  vAxisMin != int.MinValue && ! vAxisMin.Equals(double.NaN)"  is complex.
Complex Conditional,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawPlot,The conditional expression  "xv < xmin || yv < ymin || xv > xmax || yv > ymax"  is complex.
Complex Conditional,fyiReporting.RDL,ColumnGrouping,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ColumnGrouping.cs,ColumnGrouping,The conditional expression  "(_DynamicColumns != null && _StaticColumns != null) ||  				(_DynamicColumns == null && _StaticColumns == null)"  is complex.
Complex Conditional,fyiReporting.RDL,Matrix,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Matrix.cs,HeightOfRow,The conditional expression  "iRow == 0 && matrix[0' 0] != null &&  				(this.ColumnGroupings.Items.Count > 1 ||  				this.RowGroupings.Items.Count > 1)"  is complex.
Complex Conditional,fyiReporting.RDL,Query,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Query.cs,AddParameters,The conditional expression  "this._QueryParameters == null ||  				this._QueryParameters.Items == null ||  				this._QueryParameters.Items.Count == 0 ||                  this._QueryParameters.ContainsArray"  is complex.
Complex Conditional,fyiReporting.RDL,Rectangle,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Rectangle.cs,RunPage,The conditional expression  "this.PageBreakAtStart && !IsTableOrMatrixCell(r) && !pgs.CurrentPage.IsEmpty() && !bHidden"  is complex.
Complex Conditional,fyiReporting.RDL,UserReportParameter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportParameter.cs,GetDataValueFromDisplay,The conditional expression  "dvalue != null &&                  DisplayValues != null &&                  DataValues != null &&                  DisplayValues.Length == DataValues.Length"  is complex.
Complex Conditional,fyiReporting.RDL,Table,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Table.cs,RunPrep,The conditional expression  "_TableGroups != null ||   				(_Details != null &&  				 (_Details.Sorting != null ||  				 _Details.Grouping != null))"  is complex.
Complex Conditional,fyiReporting.RDL,RenderPdf_iTextSharp,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf_iTextSharp.cs,AddText,The conditional expression  "!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0"  is complex.
Complex Conditional,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,GetFormatIndex,The conditional expression  "(StyleInfo.GetFormatCode(si._Format) == 999)                  && (si._Format != string.Empty)                  && (si._Format != null)                  && !(UserDefinedFormatExists(_FormatCache'si._Format))"  is complex.
Complex Conditional,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,GetBorderIndex,The conditional expression  "si.BStyleLeft == BorderStyleEnum.None &&                  si.BStyleRight == BorderStyleEnum.None &&                  si.BStyleBottom == BorderStyleEnum.None &&                  si.BStyleTop == BorderStyleEnum.None"  is complex.
Complex Conditional,fyiReporting.RDL,RenderHtmlTable,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\HtmlConverter\RenderHtmlTable.cs,CssPosition,The conditional expression  "p is RowGrouping ||  					p is MatrixCell ||  					p is ColumnGrouping ||  					p is Corner"  is complex.
Complex Conditional,fyiReporting.RDL,RenderHtmlTable,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\HtmlConverter\RenderHtmlTable.cs,CssPrefix,The conditional expression  "p is RowGrouping ||  					p is MatrixCell ||  					p is ColumnGrouping ||  					p is Corner"  is complex.
Complex Conditional,fyiReporting.RDL,RenderHtmlTable,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\HtmlConverter\RenderHtmlTable.cs,Textbox,The conditional expression  "tp == typeof(TableCell) ||  				tp == typeof(Corner) ||  				tp == typeof(DynamicColumns) ||  				tp == typeof(DynamicRows) ||  				tp == typeof(StaticRow) ||  				tp == typeof(StaticColumn) ||  				tp == typeof(Subtotal) ||  				tp == typeof(MatrixCell)"  is complex.
Complex Conditional,fyiReporting.RDL,RenderHtmlTable,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\HtmlConverter\RenderHtmlTable.cs,IsTableSortable,The conditional expression  "t.TableGroups != null || t.Details == null ||   				t.Details.TableRows == null || t.Details.TableRows.Items.Count != 1"  is complex.
Complex Conditional,fyiReporting.RDL,Lexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Lexer.cs,ReadIdentifier,The conditional expression  "Char.IsLetterOrDigit(cPeek) || cPeek == '.' ||                          cPeek == '!' || cPeek == '_'"  is complex.
Complex Conditional,fyiReporting.RDL,Lexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Lexer.cs,ReadIdentifier,The conditional expression  "Char.IsLetterOrDigit(cPeek) || cPeek == '@' ||  					cPeek == '?' || cPeek == '_' || cPeek == '}' ||  					cPeek == '!'"  is complex.
Complex Conditional,fyiReporting.RDL,Parser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Parser.cs,MatchExprRelop,The conditional expression  "(t = curToken.Type) == TokenTypes.EQUAL ||  				t == TokenTypes.NOTEQUAL ||  				t == TokenTypes.GREATERTHAN ||  				t == TokenTypes.GREATERTHANOREQUAL ||  				t == TokenTypes.LESSTHAN ||  				t == TokenTypes.LESSTHANOREQUAL"  is complex.
Complex Conditional,fyiReporting.RDL,VBFunctions,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\VBFunctions.cs,InStr,The conditional expression  "string1 == null || string2 == null ||   				string1.Length == 0 || start > string1.Length ||  				start < 1"  is complex.
Complex Conditional,fyiReporting.RDL,VBFunctions,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\VBFunctions.cs,InStrRev,The conditional expression  "string1 == null || string2 == null ||   				string1.Length == 0 || string2.Length > string1.Length"  is complex.
Complex Conditional,fyiReporting.RDL,VBFunctions,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\VBFunctions.cs,IsNumeric,The conditional expression  "expression is bool || expression is byte || expression is sbyte ||                  expression is decimal ||                  expression is double || expression is float ||                  expression is Int16 || expression is Int32 || expression is Int64 ||                  expression is UInt16 || expression is UInt32 || expression is UInt64"  is complex.
Complex Conditional,fyiReporting.RDL,VBFunctions,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\VBFunctions.cs,Replace,The conditional expression  "str == null || find == null || find.Length == 0 || count == 0"  is complex.
Complex Conditional,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddText,The conditional expression  "!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0"  is complex.
Complex Conditional,fyiReporting.RDL,RenderHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderHtml.cs,CssPosition,The conditional expression  "p is RowGrouping ||  					p is MatrixCell ||  					p is ColumnGrouping ||  					p is Corner"  is complex.
Complex Conditional,fyiReporting.RDL,RenderHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderHtml.cs,CssPosition,The conditional expression  "ri is Matrix || ri is Table || ri is Image || ri is Chart"  is complex.
Complex Conditional,fyiReporting.RDL,RenderHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderHtml.cs,CssPrefix,The conditional expression  "p is RowGrouping ||  					p is MatrixCell ||  					p is ColumnGrouping ||  					p is Corner"  is complex.
Complex Conditional,fyiReporting.RDL,RenderHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderHtml.cs,Textbox,The conditional expression  "tp == typeof(TableCell) ||  				tp == typeof(Corner) ||  				tp == typeof(DynamicColumns) ||  				tp == typeof(DynamicRows) ||  				tp == typeof(StaticRow) ||  				tp == typeof(StaticColumn) ||  				tp == typeof(Subtotal) ||  				tp == typeof(MatrixCell)"  is complex.
Complex Conditional,fyiReporting.RDL,RenderHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderHtml.cs,IsTableSortable,The conditional expression  "t.TableGroups != null || t.Details == null ||   				t.Details.TableRows == null || t.Details.TableRows.Items.Count != 1"  is complex.
Complex Conditional,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The conditional expression  "(platform == 4 || platform == 6 || platform == 128) && version > 8"  is complex.
Complex Conditional,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The conditional expression  "(platform == 4 || platform == 6 || platform == 128) && version > 8"  is complex.
Complex Conditional,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The conditional expression  "(platform == 4 || platform == 6 || platform == 128) && version > 8"  is complex.
Complex Conditional,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The conditional expression  "(platform == 4 || platform == 6 || platform == 128) && version > 8"  is complex.
Complex Conditional,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The conditional expression  "(platform == 4 || platform == 6 || platform == 128) && version > 8"  is complex.
Complex Conditional,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The conditional expression  "(platform == 4 || platform == 6 || platform == 128) && version > 8"  is complex.
Complex Conditional,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The conditional expression  "(platform == 4 || platform == 6 || platform == 128) && version > 8"  is complex.
Complex Conditional,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The conditional expression  "(platform == 4 || platform == 6 || platform == 128) && version > 8"  is complex.
Complex Conditional,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The conditional expression  "(platform == 4 || platform == 6 || platform == 128) && version > 8"  is complex.
Complex Conditional,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The conditional expression  "(platform == 4 || platform == 6 || platform == 128) && version > 8"  is complex.
Complex Conditional,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The conditional expression  "(platform == 4 || platform == 6 || platform == 128) && version > 8"  is complex.
Complex Conditional,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The conditional expression  "(platform == 4 || platform == 6 || platform == 128) && version > 8"  is complex.
Complex Conditional,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The conditional expression  "!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0"  is complex.
Complex Conditional,fyiReporting.RDL,PageTextHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtml.cs,BuildPrivate,The conditional expression  "ltoken == "<i>" || ltoken == "<cite>" || ltoken == "<var>" || ltoken == "<em>""  is complex.
Complex Conditional,fyiReporting.RDL,PageTextHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtml.cs,BuildPrivate,The conditional expression  "ltoken == "</i>" || ltoken == "</cite>" || ltoken == "</var>" || ltoken == "</em>""  is complex.
Virtual Method Call from Constructor,fyiReporting.RDL,GroupEntry,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\GroupEntry.cs,GroupEntry,The constructor "GroupEntry" calls a virtual method "GetTypeCode".
Empty Catch Block,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetPlotType,The method has an empty catch block.
Empty Catch Block,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetYAxis,The method has an empty catch block.
Empty Catch Block,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,getNoMarkerVal,The method has an empty catch block.
Empty Catch Block,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,getLineSize,The method has an empty catch block.
Empty Catch Block,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,getColour,The method has an empty catch block.
Empty Catch Block,fyiReporting.RDL,Image,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Image.cs,Run,The method has an empty catch block.
Empty Catch Block,fyiReporting.RDL,Parser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Parser.cs,ResolveMethodCall,The method has an empty catch block.
Empty Catch Block,fyiReporting.RDL,PageTextHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtml.cs,HandleStyleFontSize,The method has an empty catch block.
Empty Catch Block,fyiReporting.RDL,PageTextHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtml.cs,HandleStyleFontWeight,The method has an empty catch block.
Empty Catch Block,fyiReporting.RDL,PageTextHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtml.cs,ParseHtmlCmd,The method has an empty catch block.
Empty Catch Block,fyiReporting.RDL,Report,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\Report.cs,RunRenderMht,The method has an empty catch block.
Empty Catch Block,fyiReporting.RDL,StyleInfo,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\StyleInfo.cs,GetFontFamily,The method has an empty catch block.
Magic Number,fyiReporting.RDL,Axis,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Axis.cs,Axis,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Visible":  						_Visible = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "Style":  						_Style = new Style(r' this' xNodeLoop);  						break;  					case "Title":  						_Title = new Title(r' this' xNodeLoop);  						break;                      // 20022008 AJM GJL - Second Y axis                      case "Title2":                      case "fyi:Title2":                          _Title2 = new Title(r' this' xNodeLoop);                         break;  					case "Margin":  						_Margin = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "MajorTickMarks":  						_MajorTickMarks = AxisTickMarks.GetStyle(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "MinorTickMarks":  						_MinorTickMarks = AxisTickMarks.GetStyle(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "MajorGridLines":  						_MajorGridLines = new ChartGridLines(r' this' xNodeLoop);  						break;  					case "MinorGridLines":  						_MinorGridLines = new ChartGridLines(r' this' xNodeLoop);  						break;  					case "MajorInterval":  						_MajorInterval = new Expression(OwnerReport' this' xNodeLoop' ExpressionType.Integer);  						OwnerReport.rl.LogError(4' "Axis element MajorInterval is currently ignored.");  						break;  					case "MinorInterval":  						_MinorInterval = new Expression(OwnerReport' this' xNodeLoop' ExpressionType.Integer);  						OwnerReport.rl.LogError(4' "Axis element MinorInterval is currently ignored.");  						break;  					case "Reverse":  						_Reverse = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "CrossAt":  						_CrossAt = XmlUtil.Integer(xNodeLoop.InnerText);  						break;  					case "Interlaced":  						_Interlaced = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "Scalar":  						_Scalar = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "Min":  						_Min = new Expression(OwnerReport' this' xNodeLoop' ExpressionType.Integer);  						break;  					case "Max":  						_Max = new Expression(OwnerReport' this' xNodeLoop' ExpressionType.Integer);  						break;  					case "LogScale":  						_LogScale = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;                      case "Month":                      case "fyi:Month":                          _Month = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);                          break;                      case "fyi:CanOmit":                          _CanOmit = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);                          break;  					default:	  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown Axis element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,Axis,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Axis.cs,Axis,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Visible":  						_Visible = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "Style":  						_Style = new Style(r' this' xNodeLoop);  						break;  					case "Title":  						_Title = new Title(r' this' xNodeLoop);  						break;                      // 20022008 AJM GJL - Second Y axis                      case "Title2":                      case "fyi:Title2":                          _Title2 = new Title(r' this' xNodeLoop);                         break;  					case "Margin":  						_Margin = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "MajorTickMarks":  						_MajorTickMarks = AxisTickMarks.GetStyle(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "MinorTickMarks":  						_MinorTickMarks = AxisTickMarks.GetStyle(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "MajorGridLines":  						_MajorGridLines = new ChartGridLines(r' this' xNodeLoop);  						break;  					case "MinorGridLines":  						_MinorGridLines = new ChartGridLines(r' this' xNodeLoop);  						break;  					case "MajorInterval":  						_MajorInterval = new Expression(OwnerReport' this' xNodeLoop' ExpressionType.Integer);  						OwnerReport.rl.LogError(4' "Axis element MajorInterval is currently ignored.");  						break;  					case "MinorInterval":  						_MinorInterval = new Expression(OwnerReport' this' xNodeLoop' ExpressionType.Integer);  						OwnerReport.rl.LogError(4' "Axis element MinorInterval is currently ignored.");  						break;  					case "Reverse":  						_Reverse = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "CrossAt":  						_CrossAt = XmlUtil.Integer(xNodeLoop.InnerText);  						break;  					case "Interlaced":  						_Interlaced = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "Scalar":  						_Scalar = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "Min":  						_Min = new Expression(OwnerReport' this' xNodeLoop' ExpressionType.Integer);  						break;  					case "Max":  						_Max = new Expression(OwnerReport' this' xNodeLoop' ExpressionType.Integer);  						break;  					case "LogScale":  						_LogScale = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;                      case "Month":                      case "fyi:Month":                          _Month = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);                          break;                      case "fyi:CanOmit":                          _CanOmit = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);                          break;  					default:	  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown Axis element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,Axis,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Axis.cs,Axis,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Visible":  						_Visible = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "Style":  						_Style = new Style(r' this' xNodeLoop);  						break;  					case "Title":  						_Title = new Title(r' this' xNodeLoop);  						break;                      // 20022008 AJM GJL - Second Y axis                      case "Title2":                      case "fyi:Title2":                          _Title2 = new Title(r' this' xNodeLoop);                         break;  					case "Margin":  						_Margin = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "MajorTickMarks":  						_MajorTickMarks = AxisTickMarks.GetStyle(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "MinorTickMarks":  						_MinorTickMarks = AxisTickMarks.GetStyle(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "MajorGridLines":  						_MajorGridLines = new ChartGridLines(r' this' xNodeLoop);  						break;  					case "MinorGridLines":  						_MinorGridLines = new ChartGridLines(r' this' xNodeLoop);  						break;  					case "MajorInterval":  						_MajorInterval = new Expression(OwnerReport' this' xNodeLoop' ExpressionType.Integer);  						OwnerReport.rl.LogError(4' "Axis element MajorInterval is currently ignored.");  						break;  					case "MinorInterval":  						_MinorInterval = new Expression(OwnerReport' this' xNodeLoop' ExpressionType.Integer);  						OwnerReport.rl.LogError(4' "Axis element MinorInterval is currently ignored.");  						break;  					case "Reverse":  						_Reverse = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "CrossAt":  						_CrossAt = XmlUtil.Integer(xNodeLoop.InnerText);  						break;  					case "Interlaced":  						_Interlaced = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "Scalar":  						_Scalar = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "Min":  						_Min = new Expression(OwnerReport' this' xNodeLoop' ExpressionType.Integer);  						break;  					case "Max":  						_Max = new Expression(OwnerReport' this' xNodeLoop' ExpressionType.Integer);  						break;  					case "LogScale":  						_LogScale = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;                      case "Month":                      case "fyi:Month":                          _Month = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);                          break;                      case "fyi:CanOmit":                          _CanOmit = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);                          break;  					default:	  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown Axis element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,AxisTickMarks,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\AxisTickMarks.cs,GetStyle,The following statement contains a magic number: switch (s)  			{		  				case "None":  					rs = AxisTickMarksEnum.None;  					break;  				case "Inside":  					rs = AxisTickMarksEnum.Inside;  					break;  				case "Outside":  					rs = AxisTickMarksEnum.Outside;  					break;  				case "Cross":  					rs = AxisTickMarksEnum.Cross;  					break;  				default:		                      if (rl != null)  					    rl.LogError(4' "Unknown Axis Tick Mark '" + s + "'.  None assumed.");  					rs = AxisTickMarksEnum.None;  					break;  			}
Magic Number,fyiReporting.RDL,Body,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Body.cs,Body,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "ReportItems":  						_ReportItems = new ReportItems(r' this' xNodeLoop);	// need a class for this  						break;  					case "Height":  						_Height = new RSize(r' xNodeLoop);  						break;  					case "Columns":  						_Columns = XmlUtil.Integer(xNodeLoop.InnerText);  						break;  					case "ColumnSpacing":  						_ColumnSpacing = new RSize(r' xNodeLoop);  						break;  					case "Style":  						_Style = new Style(r' this' xNodeLoop);  						break;  					default:	  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown Body element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,Body,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Body.cs,Body,The following statement contains a magic number: if (_Height == null)  				OwnerReport.rl.LogError(8' "Body Height not specified.");
Magic Number,fyiReporting.RDL,CategoryAxis,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\CategoryAxis.cs,CategoryAxis,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Axis":  						_Axis = new Axis(r' this' xNodeLoop);  						break;  					default:	  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown CategoryAxis element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,CategoryGrouping,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\CategoryGrouping.cs,CategoryGrouping,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "DynamicCategories":  						_DynamicCategories = new DynamicCategories(r' this' xNodeLoop);  						break;  					case "StaticCategories":  						_StaticCategories = new StaticCategories(r' this' xNodeLoop);  						break;  					default:	  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown CategoryGrouping element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,CategoryGrouping,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\CategoryGrouping.cs,CategoryGrouping,The following statement contains a magic number: if ((_DynamicCategories == null && _StaticCategories == null) ||  				(_DynamicCategories != null && _StaticCategories != null))  				OwnerReport.rl.LogError(8' "CategoryGrouping requires either DynamicCategories element or StaticCategories element' but not both.");
Magic Number,fyiReporting.RDL,CategoryGroupings,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\CategoryGroupings.cs,CategoryGroupings,The following statement contains a magic number: if (_Items.Count == 0)  				OwnerReport.rl.LogError(8' "For CategoryGroupings at least one CategoryGrouping is required.");  			else                  _Items.TrimExcess();
Magic Number,fyiReporting.RDL,Chart,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Chart.cs,Chart,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Type":  						_Type = ChartType.GetStyle(xNodeLoop.InnerText);  						if (_Type == ChartTypeEnum.Stock ||  							_Type == ChartTypeEnum.Unknown)  						{  							OwnerReport.rl.LogError(8' "Chart type '" + xNodeLoop.InnerText + "' is not currently supported.");  						}  						break;  					case "Subtype":                          _Subtype = new Expression(r' p' xNodeLoop' ExpressionType.Enum); //AJM GJL 14082008  						break;  					case "SeriesGroupings":  						_SeriesGroupings = new SeriesGroupings(r' this' xNodeLoop);  						break;  					case "CategoryGroupings":  						_CategoryGroupings = new CategoryGroupings(r' this' xNodeLoop);  						break;  					case "ChartData":  						_ChartData = new ChartData(r' this' xNodeLoop);  						break;  					case "Legend":  						_Legend = new Legend(r' this' xNodeLoop);  						break;  					case "CategoryAxis":  						_CategoryAxis = new CategoryAxis(r' this' xNodeLoop);  						break;  					case "ValueAxis":  						_ValueAxis = new ValueAxis(r' this' xNodeLoop);  						break;  					case "Title":  						_Title = new Title(r' this' xNodeLoop);  						break;  					case "PointWidth":  						_PointWidth = XmlUtil.Integer(xNodeLoop.InnerText);  						break;  					case "Palette":                          _Palette = new Expression(r' p' xNodeLoop' ExpressionType.Enum); //AJM GJL 14082008  						break;  					case "ThreeDProperties":  						_ThreeDProperties = new ThreeDProperties(r' this' xNodeLoop);  						break;  					case "PlotArea":  						_PlotArea = new PlotArea(r' this' xNodeLoop);  						break;  					case "ChartElementOutput":  						_ChartElementOutput = fyiReporting.RDL.ChartElementOutput.GetStyle(xNodeLoop.InnerText' OwnerReport.rl);  						break;                      case "HyneWonderfulVector": //AJM GJL 14082008                      case "RenderAsVector":                      case "fyi:RenderAsVector":                          _isHYNEsWonderfulVector = new Expression(r'p'xNodeLoop'ExpressionType.Boolean);                          break;                      case "fyi:tooltip":                      case "fyi:Tooltip":                          _showTooltips = new Expression(r' p' xNodeLoop' ExpressionType.Boolean);                          break;                      case "fyi:TooltipX":                          _showTooltipsX = new Expression(r' p' xNodeLoop' ExpressionType.Boolean);                          break;                      case "fyi:TooltipYFormat":                          _ToolTipYFormat = new Expression(r' p' xNodeLoop' ExpressionType.Boolean);                          break;                      case "fyi:TooltipXFormat":                          _ToolTipXFormat = new Expression(r' p' xNodeLoop' ExpressionType.Boolean);                          break;  					default:	  						if (DataRegionElement(xNodeLoop))	// try at DataRegion level  							break;  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown Chart element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,Chart,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Chart.cs,Chart,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Type":  						_Type = ChartType.GetStyle(xNodeLoop.InnerText);  						if (_Type == ChartTypeEnum.Stock ||  							_Type == ChartTypeEnum.Unknown)  						{  							OwnerReport.rl.LogError(8' "Chart type '" + xNodeLoop.InnerText + "' is not currently supported.");  						}  						break;  					case "Subtype":                          _Subtype = new Expression(r' p' xNodeLoop' ExpressionType.Enum); //AJM GJL 14082008  						break;  					case "SeriesGroupings":  						_SeriesGroupings = new SeriesGroupings(r' this' xNodeLoop);  						break;  					case "CategoryGroupings":  						_CategoryGroupings = new CategoryGroupings(r' this' xNodeLoop);  						break;  					case "ChartData":  						_ChartData = new ChartData(r' this' xNodeLoop);  						break;  					case "Legend":  						_Legend = new Legend(r' this' xNodeLoop);  						break;  					case "CategoryAxis":  						_CategoryAxis = new CategoryAxis(r' this' xNodeLoop);  						break;  					case "ValueAxis":  						_ValueAxis = new ValueAxis(r' this' xNodeLoop);  						break;  					case "Title":  						_Title = new Title(r' this' xNodeLoop);  						break;  					case "PointWidth":  						_PointWidth = XmlUtil.Integer(xNodeLoop.InnerText);  						break;  					case "Palette":                          _Palette = new Expression(r' p' xNodeLoop' ExpressionType.Enum); //AJM GJL 14082008  						break;  					case "ThreeDProperties":  						_ThreeDProperties = new ThreeDProperties(r' this' xNodeLoop);  						break;  					case "PlotArea":  						_PlotArea = new PlotArea(r' this' xNodeLoop);  						break;  					case "ChartElementOutput":  						_ChartElementOutput = fyiReporting.RDL.ChartElementOutput.GetStyle(xNodeLoop.InnerText' OwnerReport.rl);  						break;                      case "HyneWonderfulVector": //AJM GJL 14082008                      case "RenderAsVector":                      case "fyi:RenderAsVector":                          _isHYNEsWonderfulVector = new Expression(r'p'xNodeLoop'ExpressionType.Boolean);                          break;                      case "fyi:tooltip":                      case "fyi:Tooltip":                          _showTooltips = new Expression(r' p' xNodeLoop' ExpressionType.Boolean);                          break;                      case "fyi:TooltipX":                          _showTooltipsX = new Expression(r' p' xNodeLoop' ExpressionType.Boolean);                          break;                      case "fyi:TooltipYFormat":                          _ToolTipYFormat = new Expression(r' p' xNodeLoop' ExpressionType.Boolean);                          break;                      case "fyi:TooltipXFormat":                          _ToolTipXFormat = new Expression(r' p' xNodeLoop' ExpressionType.Boolean);                          break;  					default:	  						if (DataRegionElement(xNodeLoop))	// try at DataRegion level  							break;  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown Chart element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,Chart,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Chart.cs,Chart,The following statement contains a magic number: if (_SeriesGroupings == null && _CategoryGroupings == null)  				OwnerReport.rl.LogError(8' "Chart requires either the SeriesGroupings element or CategoryGroupings element or both.");
Magic Number,fyiReporting.RDL,Chart,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Chart.cs,Chart,The following statement contains a magic number: if (OwnerReport.rl.MaxSeverity > 4)     // if we already have severe error don't check for these additional issues                  return;
Magic Number,fyiReporting.RDL,Chart,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Chart.cs,Chart,The following statement contains a magic number: switch (_Type)              {                  case ChartTypeEnum.Bubble:                      if (_ChartData == null ||                           _ChartData.Items[0].Datapoints.Items[0].DataValues.Items.Count != 3)                          OwnerReport.rl.LogError(8' "Bubble charts require three DataPoints defined.");                      break;                  case ChartTypeEnum.Scatter:                      if (_ChartData == null ||                          _ChartData.Items[0].Datapoints.Items[0].DataValues.Items.Count != 2)                          OwnerReport.rl.LogError(8' "Scatter charts require two DataPoints defined.");                      break;                  default:                      break;              }
Magic Number,fyiReporting.RDL,Chart,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Chart.cs,Chart,The following statement contains a magic number: switch (_Type)              {                  case ChartTypeEnum.Bubble:                      if (_ChartData == null ||                           _ChartData.Items[0].Datapoints.Items[0].DataValues.Items.Count != 3)                          OwnerReport.rl.LogError(8' "Bubble charts require three DataPoints defined.");                      break;                  case ChartTypeEnum.Scatter:                      if (_ChartData == null ||                          _ChartData.Items[0].Datapoints.Items[0].DataValues.Items.Count != 2)                          OwnerReport.rl.LogError(8' "Scatter charts require two DataPoints defined.");                      break;                  default:                      break;              }
Magic Number,fyiReporting.RDL,Chart,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Chart.cs,Chart,The following statement contains a magic number: switch (_Type)              {                  case ChartTypeEnum.Bubble:                      if (_ChartData == null ||                           _ChartData.Items[0].Datapoints.Items[0].DataValues.Items.Count != 3)                          OwnerReport.rl.LogError(8' "Bubble charts require three DataPoints defined.");                      break;                  case ChartTypeEnum.Scatter:                      if (_ChartData == null ||                          _ChartData.Items[0].Datapoints.Items[0].DataValues.Items.Count != 2)                          OwnerReport.rl.LogError(8' "Scatter charts require two DataPoints defined.");                      break;                  default:                      break;              }
Magic Number,fyiReporting.RDL,Chart,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Chart.cs,Chart,The following statement contains a magic number: switch (_Type)              {                  case ChartTypeEnum.Bubble:                      if (_ChartData == null ||                           _ChartData.Items[0].Datapoints.Items[0].DataValues.Items.Count != 3)                          OwnerReport.rl.LogError(8' "Bubble charts require three DataPoints defined.");                      break;                  case ChartTypeEnum.Scatter:                      if (_ChartData == null ||                          _ChartData.Items[0].Datapoints.Items[0].DataValues.Items.Count != 2)                          OwnerReport.rl.LogError(8' "Scatter charts require two DataPoints defined.");                      break;                  default:                      break;              }
Magic Number,fyiReporting.RDL,Chart,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Chart.cs,FinalPass,The following statement contains a magic number: if (this.OwnerReport.rl.MaxSeverity < 8)	// Don't take this step if already have errors  			{  				_ChartMatrix = GenerateMatrix();		//   GenerateMatrix() needs no error in defn to date  				_ChartMatrix.FinalPass();  			}
Magic Number,fyiReporting.RDL,Chart,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Chart.cs,Run,The following statement contains a magic number: try  			{  				cb = RunChartBuild(rpt' row);    				ip.Chart(this' row' cb);  			}  			catch (Exception ex)  			{  				rpt.rl.LogError(8' string.Format("Exception in Chart handling.\n{0}\n{1}"' ex.Message' ex.StackTrace));  			}  			finally  			{  				if (cb != null)  					cb.Dispose();  			}
Magic Number,fyiReporting.RDL,Chart,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Chart.cs,RunPage,The following statement contains a magic number: try  			{  				cb = RunChartBuild(rpt' row);					// Build the chart                  if (!_isHYNEsWonderfulVector.EvaluateBoolean(rpt'row)) //AJM GJL 14082008 'Classic' Rendering                   {                      System.Drawing.Image im = cb.Image(rpt);	// Grab the image                      int height = im.Height;							// save height and width                      int width = im.Width;                        MemoryStream ostrm = new MemoryStream();                      /* The following is a new image saving logic which will allow for higher                        * quality images using JPEG with 100% quality                       * 06122007AJM */                      System.Drawing.Imaging.ImageCodecInfo[] info;                      info = ImageCodecInfo.GetImageEncoders();                      EncoderParameters encoderParameters;                      encoderParameters = new EncoderParameters(1);                      // 20022008 AJM GJL - Centralised class with global encoder settings                      encoderParameters.Param[0] = new EncoderParameter(Encoder.Quality' ImageQualityManager.ChartImageQuality);                      System.Drawing.Imaging.ImageCodecInfo codec = null;                      for (int i = 0; i < info.Length; i++)                      {                          if (info[i].FormatDescription == "JPEG")                          {                              codec = info[i];                              break;                          }                      }                      im.Save(ostrm' codec' encoderParameters);                      // 06122007AJM The follow has been replaced with the code above                      //im.Save(ostrm' info);	// generate a jpeg   TODO: get png to work with pdf                        byte[] ba = ostrm.ToArray();                      ostrm.Close();                      PageImage pi = new PageImage(IMAGEFORMAT' ba' width' height);	// Create an image                        RunPageRegionBegin(pgs);                        SetPagePositionAndStyle(rpt' pi' row);                      pi.SI.BackgroundImage = null;	// chart already has the background image                        if (pgs.CurrentPage.YOffset + pi.Y + pi.H >= pgs.BottomOfPage && !pgs.CurrentPage.IsEmpty())                      {	// force page break if it doesn't fit on the page                          pgs.NextOrNew();                          pgs.CurrentPage.YOffset = OwnerReport.TopOfPage;                          if (this.YParents != null)                              pi.Y = 0;                      }                        p = pgs.CurrentPage;                        p.AddObject(pi);	// Put image onto the current page                        RunPageRegionEnd(pgs);                        if (!this.PageBreakAtEnd && !IsTableOrMatrixCell(rpt))                      {                          float newY = pi.Y + pi.H;                          p.YOffset += newY;	// bump the y location                      }                      SetPagePositionEnd(pgs' pi.Y + pi.H);                  }                  else //Ultimate Rendering - Vector //AJM GJL 14082008                  {                      System.Drawing.Imaging.Metafile im = cb.Image(rpt);	// Grab the image                      //im could still be saved to a bitmap at this point                      //if we were to offer a choice of raster or vector' it would probably                      //be easiest to draw the chart to the EMF and then save as bitmap if needed                      int height = im.Height;							// save height and width                      int width = im.Width;                      byte[] ba = cb._aStream.ToArray();                      cb._aStream.Close();                        PageImage pi = new PageImage(ImageFormat.Wmf' ba' width' height);                      RunPageRegionBegin(pgs);                        SetPagePositionAndStyle(rpt' pi' row);                      pi.SI.BackgroundImage = null;	// chart already has the background image                        if (pgs.CurrentPage.YOffset + pi.Y + pi.H >= pgs.BottomOfPage && !pgs.CurrentPage.IsEmpty())                      {	// force page break if it doesn't fit on the page                          pgs.NextOrNew();                          pgs.CurrentPage.YOffset = OwnerReport.TopOfPage;                          if (this.YParents != null)                              pi.Y = 0;                      }                        p = pgs.CurrentPage;                        //GJL 25072008 - Charts now draw in EMFplus format and not in bitmap. Still using the "PageImage" for the positioning                      //paging etc' but we don't add it to the page.                      // ******************************************************************************************************************                      // New EMF Processing... we want to add the EMF Components to the page and not the actual EMF...                      EMF emf = new EMF(pi.X' pi.Y' width' height);                      emf.ProcessEMF(ba); //Process takes the bytearray of EMFplus data and breaks it down into lines'ellipses'text'rectangles                      //etc... There are still a lot of GDI+ functions I haven't got to (and some I have no intention of getting to!).                       foreach (PageItem emfItem in emf.PageItems)                      {                          p.AddObject(emfItem);                        }                      // ******************************************************************************************************************                        //p.AddObject(pi);                      RunPageRegionEnd(pgs);                      pi.Y += p.YOffset;                      if (!this.PageBreakAtEnd && !IsTableOrMatrixCell(rpt))                      {                          float newY = pi.Y + pi.H;                          p.YOffset += newY;	// bump the y location                      }                      SetPagePositionEnd(pgs' pi.Y + pi.H); //our emf size seems to be bigger than the jpeg...                              }              }  			catch (Exception ex)  			{  				rpt.rl.LogError(8' string.Format("Exception in Chart handling.\n{0}\n{1}"' ex.Message' ex.StackTrace));  			}  			finally  			{  				if (cb != null)  					cb.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBar,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBar.cs,DrawPlotAreaPercentStacked,The following statement contains a magic number: int gapsNeeded = CategoryCount * 2;
Magic Number,fyiReporting.RDL,ChartBar,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBar.cs,DrawPlotAreaPlain,The following statement contains a magic number: int gapsNeeded = CategoryCount * 2;
Magic Number,fyiReporting.RDL,ChartBar,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBar.cs,DrawPlotAreaStacked,The following statement contains a magic number: int gapsNeeded = CategoryCount * 2;
Magic Number,fyiReporting.RDL,ChartBar,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBar.cs,DrawValueAxis,The following statement contains a magic number: for (int i = 0; i < intervalCount+1; i++)	   			{  				int x = (int) (((Math.Min(v'max)-min) / (max-min)) * rect.Width);    				if (!a.Visible)  				{  					// nothing to do  				}  				else if (s != null)  				{  					size = s.MeasureString(rpt' g' v' TypeCode.Double' null' int.MaxValue);  					System.Drawing.Rectangle vRect =   						new System.Drawing.Rectangle(rect.Left + x - size.Width/2' rect.Top+tickSize' size.Width' size.Height);  					s.DrawString(rpt' g' v' TypeCode.Double' null' vRect);  				}  				else  				{  					size = Style.MeasureStringDefaults(rpt' g' v' TypeCode.Double' null' int.MaxValue);  					System.Drawing.Rectangle vRect =   						new System.Drawing.Rectangle(rect.Left + x - size.Width/2' rect.Top+tickSize' size.Width' size.Height);  					Style.DrawStringDefaults(g' v' vRect);  				}  				if (size.Height > maxValueHeight)		// Need to keep track of the maximum height  					maxValueHeight = size.Height;		//   this is probably overkill since it should always be the same??    				DrawValueAxisGrid(rpt' g' a.MajorGridLines' new Point(rect.Left + x' plotTop)' new Point(rect.Left + x' plotBottom));  				DrawValueAxisTick(rpt' g' true' a.MajorTickMarks' a.MajorGridLines' new Point(rect.Left + x' plotBottom ));    				v += incr;  			}
Magic Number,fyiReporting.RDL,ChartBar,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBar.cs,DrawValueAxis,The following statement contains a magic number: for (int i = 0; i < intervalCount+1; i++)	   			{  				int x = (int) (((Math.Min(v'max)-min) / (max-min)) * rect.Width);    				if (!a.Visible)  				{  					// nothing to do  				}  				else if (s != null)  				{  					size = s.MeasureString(rpt' g' v' TypeCode.Double' null' int.MaxValue);  					System.Drawing.Rectangle vRect =   						new System.Drawing.Rectangle(rect.Left + x - size.Width/2' rect.Top+tickSize' size.Width' size.Height);  					s.DrawString(rpt' g' v' TypeCode.Double' null' vRect);  				}  				else  				{  					size = Style.MeasureStringDefaults(rpt' g' v' TypeCode.Double' null' int.MaxValue);  					System.Drawing.Rectangle vRect =   						new System.Drawing.Rectangle(rect.Left + x - size.Width/2' rect.Top+tickSize' size.Width' size.Height);  					Style.DrawStringDefaults(g' v' vRect);  				}  				if (size.Height > maxValueHeight)		// Need to keep track of the maximum height  					maxValueHeight = size.Height;		//   this is probably overkill since it should always be the same??    				DrawValueAxisGrid(rpt' g' a.MajorGridLines' new Point(rect.Left + x' plotTop)' new Point(rect.Left + x' plotBottom));  				DrawValueAxisTick(rpt' g' true' a.MajorTickMarks' a.MajorGridLines' new Point(rect.Left + x' plotBottom ));    				v += incr;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following statement contains a magic number: try		// no matter what we want to dispose of the graphic resources  			{  				if (s == null)  				{  					drawFont = new Font("Arial"' 10);  					drawBrush = new SolidBrush(Color.Black);  					drawFormat = new StringFormat();  					drawFormat.Alignment = StringAlignment.Near;  				}  				else  				{  					drawFont = 	s.GetFont(rpt' null);  					drawBrush = s.GetBrush(rpt' null);  					drawFormat = s.GetStringFormat(rpt' null' StringAlignment.Near);  				}    				int x' y' h;  				int maxTextWidth' maxTextHeight;  				drawFormat.FormatFlags |= StringFormatFlags.NoWrap;  				Size[] sizes = DrawLegendMeasure(rpt' g' drawFont' drawFormat'   					new SizeF(Layout.Width' Layout.Height)' out maxTextWidth' out maxTextHeight);  				int boxSize = (int) (maxTextHeight * .8);  				int totalItemWidth = 0;			// width of a legend item  				int totalWidth' totalHeight;	// final height and width of legend    				// calculate the height and width of the rectangle  				switch (l.Layout)  				{  					case LegendLayoutEnum.Row:  						// we need to loop thru all the width  						totalWidth=0;  						for (int i = 0; i < SeriesCount; i++)  						{                              if (sizes[i].Width !=0)  //14052008WRP when legend valeus are 0 don't add extra boxsize  							totalWidth += (sizes[i].Width + (boxSize * 2));  						}  						totalHeight = (int) (maxTextHeight + (maxTextHeight * .1));  						h = totalHeight;  						totalItemWidth = maxTextWidth + boxSize * 2;   						drawFormat.Alignment = StringAlignment.Near;	// Force alignment to near  						break;  					case LegendLayoutEnum.Table:                          // for table we simplify to have TWO columns (i.e. don't do anything too tricky                          totalWidth = totalItemWidth = (maxTextWidth + boxSize * 2) * 2;     // make width twice as big as longest entry                          h = (int)(maxTextHeight + (maxTextHeight * .1));                          totalHeight = h * (SeriesCount + SeriesCount % 2) / 2;                          break;  					case LegendLayoutEnum.Column:  					default:  						totalWidth = totalItemWidth = maxTextWidth + boxSize * 2;   						h = (int) (maxTextHeight + (maxTextHeight * .1));  						totalHeight = h * SeriesCount;  						break;  				}    				// calculate the location of the legend rectangle  				if (this.IsLegendInsidePlotArea())  				switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						x = Layout.PlotArea.X+2;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth;  						y = Layout.PlotArea.Y + Layout.PlotArea.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = Layout.PlotArea.X + 2;  						y = Layout.PlotArea.Y+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.PlotArea.X + Layout.PlotArea.Width - totalWidth - 2;  						y = Layout.PlotArea.Y + (Layout.PlotArea.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = Layout.PlotArea.X + (Layout.PlotArea.Width / 2) - (totalWidth / 2);  						y = Layout.PlotArea.Y + +2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.PlotArea.X + Layout.PlotArea.Width-totalWidth - 2;  						y = Layout.PlotArea.Y + +2;  						break;  				}  				else switch (l.Position)  				{  					case LegendPositionEnum.BottomCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomLeft:  					case LegendPositionEnum.LeftBottom:  						if (IsLegendInsidePlotArea())  							x = Layout.LeftMargin;  						else  							x = 0;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.BottomRight:  					case LegendPositionEnum.RightBottom:  						x = Layout.Width - totalWidth;  						y = Layout.Height - totalHeight - 2;  						break;  					case LegendPositionEnum.LeftCenter:  						x = 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.LeftTop:  					case LegendPositionEnum.TopLeft:  						x = 2;  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.RightCenter:  						x = Layout.Width - totalWidth - 2;  						y = (Layout.Height / 2) - (totalHeight/2);  						break;  					case LegendPositionEnum.TopCenter:  						x = (Layout.Width / 2) - (totalWidth / 2);  						y = Layout.TopMargin+2;  						break;  					case LegendPositionEnum.TopRight:  					case LegendPositionEnum.RightTop:  					default:  						x = Layout.Width-totalWidth - 2;  						y = Layout.TopMargin+2;  						break;  				}    				// We now know enough to calc the bounding rectangle of the legend  				rRect = new System.Drawing.Rectangle(x-1' y-1' totalWidth+2' totalHeight+2);  				if (s != null)  				{  					s.DrawBackground(rpt' g' null' rRect);	// draw (or not draw) background   					s.DrawBorder(rpt' g' null' rRect);		// draw (or not draw) border depending on style  				}                    int saveX = x;                  ChartMarkerEnum cm = this.ChartDefn.Type == ChartTypeEnum.Bubble ? ChartMarkerEnum.Bubble : ChartMarkerEnum.None;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					string c = GetSeriesValue(rpt' iCol);                      if (c != "") //14052008WRP Cater for empty strings in the legend                      {  					System.Drawing.Rectangle rect;                          // 20022008 AJM GJL - Draw correct legend icon (Column\Line)                          Type t = null;                          t = GetSeriesBrush(rpt' 1' iCol).GetType();                      /* The following 2 lines have been added to draw the correct legend for column chart with line plot types                       * 06122007AJM */                      cm = ChartMarkerEnum.None;                          bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                                                  if ((bMarker || isLine) || (this.ChartDefn.Type == ChartTypeEnum.Scatter && t == typeof(System.Drawing.Drawing2D.HatchBrush)))                          cm = SeriesMarker[iCol - 1];                          if (isLine && this.ChartDefn.Type == ChartTypeEnum.Scatter)                          {                              cm = ChartMarkerEnum.Line;                          }                                                      bool NoMarker = getNoMarkerVal(rpt' iCol' 1);                          if (NoMarker) { cm = ChartMarkerEnum.Line; }                            String LineSize = getLineSize(rpt' iCol' 1);                          int intLineSize = 2;                          switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }                              SolidBrush b;  					switch (l.Layout)  					{  						case LegendLayoutEnum.Row:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' totalItemWidth - boxSize - boxSize/2' h);                                  if (c != "") //14052008WRP to cater for empty strings in the legend                                  {  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                        if ((cm != ChartMarkerEnum.None || this.ChartDefn.Type == ChartTypeEnum.Scatter) && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines or Bubbles                                      {                                          System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                          b = new SolidBrush(hb.ForegroundColor);                                            DrawLegendBox(g' b'                                          cm' x' y + 1' boxSize'intLineSize);                                      }                                      else                                      {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x' y+1' boxSize'intLineSize);                                      }      							x += (sizes[iCol-1].Width + boxSize*2);                                   }  							break;  						case LegendLayoutEnum.Table:                              rect = new System.Drawing.Rectangle(x + boxSize + boxSize / 2' y' maxTextWidth' h);                              g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                    if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush))) //GJL 110208 - Don't draw pattern for lines                                  {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  { DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)' cm' x + 1' y' boxSize'intLineSize); }                                  if (iCol % 2 == 0)                              {                                  y += h;                                  x = saveX;                              }                              else                              {                                  x = saveX + (rRect.Width / 2);                              }                              break;                          case LegendLayoutEnum.Column:  						default:  							rect = new System.Drawing.Rectangle(x + boxSize + boxSize/2' y' maxTextWidth' h);  							g.DrawString(c' drawFont' drawBrush' rect' drawFormat);                                      if (cm != ChartMarkerEnum.None && (t == typeof(System.Drawing.Drawing2D.HatchBrush)))       //GJL 110208 - Don't draw pattern for lines                                                            {                                      System.Drawing.Drawing2D.HatchBrush hb = (System.Drawing.Drawing2D.HatchBrush)GetSeriesBrush(rpt' 1' iCol);                                      b = new SolidBrush(hb.ForegroundColor);                                        DrawLegendBox(g' /*GetSeriesBrushesExcel(iCol - 1)*/ b'                                      cm' x' y + 1' boxSize'intLineSize);                                  }                                  else                                  {                              DrawLegendBox(g' GetSeriesBrush(rpt' 1' iCol)'  								cm' x+1' y' boxSize'intLineSize);                                  }    							y += h;  							break;  					}  				}  			}              }  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegendBox,The following statement contains a magic number: DrawLegendBox(g' b' marker' x' y' boxSize' 2);
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegendBox,The following statement contains a magic number: int mSize= boxSize / 2;
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegendBox,The following statement contains a magic number: try  			{  				if (marker < ChartMarkerEnum.Count)  				{  					p = new Pen(b'intLineSize);                      if (this.ChartDefn.Type != ChartTypeEnum.Scatter)                      {  					g.DrawLine(p'  new Point(x' y + (boxSize + 1)/2)' new Point(x + boxSize' y + (boxSize + 1)/2));                      }  					x = x + (boxSize - mSize)/2;  					y = y + (boxSize - mSize)/2;  					if (mSize % 2 == 0)		  						mSize++;  				}    				if (marker == ChartMarkerEnum.None)  				{  					g.FillRectangle(b' x' y' boxSize' boxSize);  				}                  else if (marker == ChartMarkerEnum.Bubble)  				{  					g.FillEllipse(b' x' y' boxSize' boxSize);  				}                  else if (marker == ChartMarkerEnum.Line)                  {                      // this is only to draw lines for line plot types on scatter charts                      p = new Pen(b' intLineSize);                      g.DrawLine(p' new Point(x' y + (boxSize + 1) / 2)' new Point(x + boxSize' y + (boxSize + 1) / 2));                  }  				else  				{  					DrawLegendMarker(g' b' p' marker' x' y' mSize);  				}  			}  			finally  			{  				if (p != null)  					p.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegendBox,The following statement contains a magic number: try  			{  				if (marker < ChartMarkerEnum.Count)  				{  					p = new Pen(b'intLineSize);                      if (this.ChartDefn.Type != ChartTypeEnum.Scatter)                      {  					g.DrawLine(p'  new Point(x' y + (boxSize + 1)/2)' new Point(x + boxSize' y + (boxSize + 1)/2));                      }  					x = x + (boxSize - mSize)/2;  					y = y + (boxSize - mSize)/2;  					if (mSize % 2 == 0)		  						mSize++;  				}    				if (marker == ChartMarkerEnum.None)  				{  					g.FillRectangle(b' x' y' boxSize' boxSize);  				}                  else if (marker == ChartMarkerEnum.Bubble)  				{  					g.FillEllipse(b' x' y' boxSize' boxSize);  				}                  else if (marker == ChartMarkerEnum.Line)                  {                      // this is only to draw lines for line plot types on scatter charts                      p = new Pen(b' intLineSize);                      g.DrawLine(p' new Point(x' y + (boxSize + 1) / 2)' new Point(x + boxSize' y + (boxSize + 1) / 2));                  }  				else  				{  					DrawLegendMarker(g' b' p' marker' x' y' mSize);  				}  			}  			finally  			{  				if (p != null)  					p.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegendBox,The following statement contains a magic number: try  			{  				if (marker < ChartMarkerEnum.Count)  				{  					p = new Pen(b'intLineSize);                      if (this.ChartDefn.Type != ChartTypeEnum.Scatter)                      {  					g.DrawLine(p'  new Point(x' y + (boxSize + 1)/2)' new Point(x + boxSize' y + (boxSize + 1)/2));                      }  					x = x + (boxSize - mSize)/2;  					y = y + (boxSize - mSize)/2;  					if (mSize % 2 == 0)		  						mSize++;  				}    				if (marker == ChartMarkerEnum.None)  				{  					g.FillRectangle(b' x' y' boxSize' boxSize);  				}                  else if (marker == ChartMarkerEnum.Bubble)  				{  					g.FillEllipse(b' x' y' boxSize' boxSize);  				}                  else if (marker == ChartMarkerEnum.Line)                  {                      // this is only to draw lines for line plot types on scatter charts                      p = new Pen(b' intLineSize);                      g.DrawLine(p' new Point(x' y + (boxSize + 1) / 2)' new Point(x + boxSize' y + (boxSize + 1) / 2));                  }  				else  				{  					DrawLegendMarker(g' b' p' marker' x' y' mSize);  				}  			}  			finally  			{  				if (p != null)  					p.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegendBox,The following statement contains a magic number: try  			{  				if (marker < ChartMarkerEnum.Count)  				{  					p = new Pen(b'intLineSize);                      if (this.ChartDefn.Type != ChartTypeEnum.Scatter)                      {  					g.DrawLine(p'  new Point(x' y + (boxSize + 1)/2)' new Point(x + boxSize' y + (boxSize + 1)/2));                      }  					x = x + (boxSize - mSize)/2;  					y = y + (boxSize - mSize)/2;  					if (mSize % 2 == 0)		  						mSize++;  				}    				if (marker == ChartMarkerEnum.None)  				{  					g.FillRectangle(b' x' y' boxSize' boxSize);  				}                  else if (marker == ChartMarkerEnum.Bubble)  				{  					g.FillEllipse(b' x' y' boxSize' boxSize);  				}                  else if (marker == ChartMarkerEnum.Line)                  {                      // this is only to draw lines for line plot types on scatter charts                      p = new Pen(b' intLineSize);                      g.DrawLine(p' new Point(x' y + (boxSize + 1) / 2)' new Point(x + boxSize' y + (boxSize + 1) / 2));                  }  				else  				{  					DrawLegendMarker(g' b' p' marker' x' y' mSize);  				}  			}  			finally  			{  				if (p != null)  					p.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegendBox,The following statement contains a magic number: try  			{  				if (marker < ChartMarkerEnum.Count)  				{  					p = new Pen(b'intLineSize);                      if (this.ChartDefn.Type != ChartTypeEnum.Scatter)                      {  					g.DrawLine(p'  new Point(x' y + (boxSize + 1)/2)' new Point(x + boxSize' y + (boxSize + 1)/2));                      }  					x = x + (boxSize - mSize)/2;  					y = y + (boxSize - mSize)/2;  					if (mSize % 2 == 0)		  						mSize++;  				}    				if (marker == ChartMarkerEnum.None)  				{  					g.FillRectangle(b' x' y' boxSize' boxSize);  				}                  else if (marker == ChartMarkerEnum.Bubble)  				{  					g.FillEllipse(b' x' y' boxSize' boxSize);  				}                  else if (marker == ChartMarkerEnum.Line)                  {                      // this is only to draw lines for line plot types on scatter charts                      p = new Pen(b' intLineSize);                      g.DrawLine(p' new Point(x' y + (boxSize + 1) / 2)' new Point(x + boxSize' y + (boxSize + 1) / 2));                  }  				else  				{  					DrawLegendMarker(g' b' p' marker' x' y' mSize);  				}  			}  			finally  			{  				if (p != null)  					p.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegendBox,The following statement contains a magic number: try  			{  				if (marker < ChartMarkerEnum.Count)  				{  					p = new Pen(b'intLineSize);                      if (this.ChartDefn.Type != ChartTypeEnum.Scatter)                      {  					g.DrawLine(p'  new Point(x' y + (boxSize + 1)/2)' new Point(x + boxSize' y + (boxSize + 1)/2));                      }  					x = x + (boxSize - mSize)/2;  					y = y + (boxSize - mSize)/2;  					if (mSize % 2 == 0)		  						mSize++;  				}    				if (marker == ChartMarkerEnum.None)  				{  					g.FillRectangle(b' x' y' boxSize' boxSize);  				}                  else if (marker == ChartMarkerEnum.Bubble)  				{  					g.FillEllipse(b' x' y' boxSize' boxSize);  				}                  else if (marker == ChartMarkerEnum.Line)                  {                      // this is only to draw lines for line plot types on scatter charts                      p = new Pen(b' intLineSize);                      g.DrawLine(p' new Point(x' y + (boxSize + 1) / 2)' new Point(x + boxSize' y + (boxSize + 1) / 2));                  }  				else  				{  					DrawLegendMarker(g' b' p' marker' x' y' mSize);  				}  			}  			finally  			{  				if (p != null)  					p.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegendBox,The following statement contains a magic number: try  			{  				if (marker < ChartMarkerEnum.Count)  				{  					p = new Pen(b'intLineSize);                      if (this.ChartDefn.Type != ChartTypeEnum.Scatter)                      {  					g.DrawLine(p'  new Point(x' y + (boxSize + 1)/2)' new Point(x + boxSize' y + (boxSize + 1)/2));                      }  					x = x + (boxSize - mSize)/2;  					y = y + (boxSize - mSize)/2;  					if (mSize % 2 == 0)		  						mSize++;  				}    				if (marker == ChartMarkerEnum.None)  				{  					g.FillRectangle(b' x' y' boxSize' boxSize);  				}                  else if (marker == ChartMarkerEnum.Bubble)  				{  					g.FillEllipse(b' x' y' boxSize' boxSize);  				}                  else if (marker == ChartMarkerEnum.Line)                  {                      // this is only to draw lines for line plot types on scatter charts                      p = new Pen(b' intLineSize);                      g.DrawLine(p' new Point(x' y + (boxSize + 1) / 2)' new Point(x + boxSize' y + (boxSize + 1) / 2));                  }  				else  				{  					DrawLegendMarker(g' b' p' marker' x' y' mSize);  				}  			}  			finally  			{  				if (p != null)  					p.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegendMarker,The following statement contains a magic number: switch (marker)  			{                  case ChartMarkerEnum.Bubble:                  case ChartMarkerEnum.Circle:  					g.FillEllipse(b' x' y' mSize' mSize);  					break;  				case ChartMarkerEnum.Square:  					g.FillRectangle(b' x' y' mSize' mSize);  					break;  				case ChartMarkerEnum.Plus:  					// 20022008 AJM GJL - Changed to line - plus is hard to see                      p = new Pen(p.Brush' 2);  					g.DrawLine(p' new Point(x + (mSize + 1)/2' y)' new Point(x + (mSize + 1)/2' y + mSize));  					//g.DrawLine(p' new Point(x + (mSize + 1)/2' y + (mSize+1)/2)' new Point(x + mSize' y + (mSize+1)/2));  					break;  				case ChartMarkerEnum.Diamond:  					points = new PointF[5];  					points[0] = points[4] = new Point(x + (mSize + 1)/2' y);	// starting and ending point  					points[1] = new PointF(x' y + (mSize+1)/2);  					points[2] = new PointF(x + (mSize+1)/2' y+mSize);  					points[3] = new PointF(x + mSize' y + (mSize+1)/2);  					g.FillPolygon(b' points);  					break;  				case ChartMarkerEnum.Triangle:  					points = new PointF[4];  					points[0] = points[3] = new PointF(x + (mSize + 1)/2' y);	// starting and ending point  					points[1] = new PointF(x' y + mSize);  					points[2] = new PointF(x + mSize' y + mSize);  					g.FillPolygon(b' points);                      break;  				case ChartMarkerEnum.X:                      p = new Pen(p.Brush' 2);// 20022008 AJM GJL  					g.DrawLine(p' new Point(x' y)' new Point(x + mSize' y + mSize));  					g.DrawLine(p' new Point(x' y + mSize)' new Point(x + mSize' y));// 20022008 AJM GJL  					break;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegendMarker,The following statement contains a magic number: switch (marker)  			{                  case ChartMarkerEnum.Bubble:                  case ChartMarkerEnum.Circle:  					g.FillEllipse(b' x' y' mSize' mSize);  					break;  				case ChartMarkerEnum.Square:  					g.FillRectangle(b' x' y' mSize' mSize);  					break;  				case ChartMarkerEnum.Plus:  					// 20022008 AJM GJL - Changed to line - plus is hard to see                      p = new Pen(p.Brush' 2);  					g.DrawLine(p' new Point(x + (mSize + 1)/2' y)' new Point(x + (mSize + 1)/2' y + mSize));  					//g.DrawLine(p' new Point(x + (mSize + 1)/2' y + (mSize+1)/2)' new Point(x + mSize' y + (mSize+1)/2));  					break;  				case ChartMarkerEnum.Diamond:  					points = new PointF[5];  					points[0] = points[4] = new Point(x + (mSize + 1)/2' y);	// starting and ending point  					points[1] = new PointF(x' y + (mSize+1)/2);  					points[2] = new PointF(x + (mSize+1)/2' y+mSize);  					points[3] = new PointF(x + mSize' y + (mSize+1)/2);  					g.FillPolygon(b' points);  					break;  				case ChartMarkerEnum.Triangle:  					points = new PointF[4];  					points[0] = points[3] = new PointF(x + (mSize + 1)/2' y);	// starting and ending point  					points[1] = new PointF(x' y + mSize);  					points[2] = new PointF(x + mSize' y + mSize);  					g.FillPolygon(b' points);                      break;  				case ChartMarkerEnum.X:                      p = new Pen(p.Brush' 2);// 20022008 AJM GJL  					g.DrawLine(p' new Point(x' y)' new Point(x + mSize' y + mSize));  					g.DrawLine(p' new Point(x' y + mSize)' new Point(x + mSize' y));// 20022008 AJM GJL  					break;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegendMarker,The following statement contains a magic number: switch (marker)  			{                  case ChartMarkerEnum.Bubble:                  case ChartMarkerEnum.Circle:  					g.FillEllipse(b' x' y' mSize' mSize);  					break;  				case ChartMarkerEnum.Square:  					g.FillRectangle(b' x' y' mSize' mSize);  					break;  				case ChartMarkerEnum.Plus:  					// 20022008 AJM GJL - Changed to line - plus is hard to see                      p = new Pen(p.Brush' 2);  					g.DrawLine(p' new Point(x + (mSize + 1)/2' y)' new Point(x + (mSize + 1)/2' y + mSize));  					//g.DrawLine(p' new Point(x + (mSize + 1)/2' y + (mSize+1)/2)' new Point(x + mSize' y + (mSize+1)/2));  					break;  				case ChartMarkerEnum.Diamond:  					points = new PointF[5];  					points[0] = points[4] = new Point(x + (mSize + 1)/2' y);	// starting and ending point  					points[1] = new PointF(x' y + (mSize+1)/2);  					points[2] = new PointF(x + (mSize+1)/2' y+mSize);  					points[3] = new PointF(x + mSize' y + (mSize+1)/2);  					g.FillPolygon(b' points);  					break;  				case ChartMarkerEnum.Triangle:  					points = new PointF[4];  					points[0] = points[3] = new PointF(x + (mSize + 1)/2' y);	// starting and ending point  					points[1] = new PointF(x' y + mSize);  					points[2] = new PointF(x + mSize' y + mSize);  					g.FillPolygon(b' points);                      break;  				case ChartMarkerEnum.X:                      p = new Pen(p.Brush' 2);// 20022008 AJM GJL  					g.DrawLine(p' new Point(x' y)' new Point(x + mSize' y + mSize));  					g.DrawLine(p' new Point(x' y + mSize)' new Point(x + mSize' y));// 20022008 AJM GJL  					break;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegendMarker,The following statement contains a magic number: switch (marker)  			{                  case ChartMarkerEnum.Bubble:                  case ChartMarkerEnum.Circle:  					g.FillEllipse(b' x' y' mSize' mSize);  					break;  				case ChartMarkerEnum.Square:  					g.FillRectangle(b' x' y' mSize' mSize);  					break;  				case ChartMarkerEnum.Plus:  					// 20022008 AJM GJL - Changed to line - plus is hard to see                      p = new Pen(p.Brush' 2);  					g.DrawLine(p' new Point(x + (mSize + 1)/2' y)' new Point(x + (mSize + 1)/2' y + mSize));  					//g.DrawLine(p' new Point(x + (mSize + 1)/2' y + (mSize+1)/2)' new Point(x + mSize' y + (mSize+1)/2));  					break;  				case ChartMarkerEnum.Diamond:  					points = new PointF[5];  					points[0] = points[4] = new Point(x + (mSize + 1)/2' y);	// starting and ending point  					points[1] = new PointF(x' y + (mSize+1)/2);  					points[2] = new PointF(x + (mSize+1)/2' y+mSize);  					points[3] = new PointF(x + mSize' y + (mSize+1)/2);  					g.FillPolygon(b' points);  					break;  				case ChartMarkerEnum.Triangle:  					points = new PointF[4];  					points[0] = points[3] = new PointF(x + (mSize + 1)/2' y);	// starting and ending point  					points[1] = new PointF(x' y + mSize);  					points[2] = new PointF(x + mSize' y + mSize);  					g.FillPolygon(b' points);                      break;  				case ChartMarkerEnum.X:                      p = new Pen(p.Brush' 2);// 20022008 AJM GJL  					g.DrawLine(p' new Point(x' y)' new Point(x + mSize' y + mSize));  					g.DrawLine(p' new Point(x' y + mSize)' new Point(x + mSize' y));// 20022008 AJM GJL  					break;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegendMarker,The following statement contains a magic number: switch (marker)  			{                  case ChartMarkerEnum.Bubble:                  case ChartMarkerEnum.Circle:  					g.FillEllipse(b' x' y' mSize' mSize);  					break;  				case ChartMarkerEnum.Square:  					g.FillRectangle(b' x' y' mSize' mSize);  					break;  				case ChartMarkerEnum.Plus:  					// 20022008 AJM GJL - Changed to line - plus is hard to see                      p = new Pen(p.Brush' 2);  					g.DrawLine(p' new Point(x + (mSize + 1)/2' y)' new Point(x + (mSize + 1)/2' y + mSize));  					//g.DrawLine(p' new Point(x + (mSize + 1)/2' y + (mSize+1)/2)' new Point(x + mSize' y + (mSize+1)/2));  					break;  				case ChartMarkerEnum.Diamond:  					points = new PointF[5];  					points[0] = points[4] = new Point(x + (mSize + 1)/2' y);	// starting and ending point  					points[1] = new PointF(x' y + (mSize+1)/2);  					points[2] = new PointF(x + (mSize+1)/2' y+mSize);  					points[3] = new PointF(x + mSize' y + (mSize+1)/2);  					g.FillPolygon(b' points);  					break;  				case ChartMarkerEnum.Triangle:  					points = new PointF[4];  					points[0] = points[3] = new PointF(x + (mSize + 1)/2' y);	// starting and ending point  					points[1] = new PointF(x' y + mSize);  					points[2] = new PointF(x + mSize' y + mSize);  					g.FillPolygon(b' points);                      break;  				case ChartMarkerEnum.X:                      p = new Pen(p.Brush' 2);// 20022008 AJM GJL  					g.DrawLine(p' new Point(x' y)' new Point(x + mSize' y + mSize));  					g.DrawLine(p' new Point(x' y + mSize)' new Point(x + mSize' y));// 20022008 AJM GJL  					break;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegendMarker,The following statement contains a magic number: switch (marker)  			{                  case ChartMarkerEnum.Bubble:                  case ChartMarkerEnum.Circle:  					g.FillEllipse(b' x' y' mSize' mSize);  					break;  				case ChartMarkerEnum.Square:  					g.FillRectangle(b' x' y' mSize' mSize);  					break;  				case ChartMarkerEnum.Plus:  					// 20022008 AJM GJL - Changed to line - plus is hard to see                      p = new Pen(p.Brush' 2);  					g.DrawLine(p' new Point(x + (mSize + 1)/2' y)' new Point(x + (mSize + 1)/2' y + mSize));  					//g.DrawLine(p' new Point(x + (mSize + 1)/2' y + (mSize+1)/2)' new Point(x + mSize' y + (mSize+1)/2));  					break;  				case ChartMarkerEnum.Diamond:  					points = new PointF[5];  					points[0] = points[4] = new Point(x + (mSize + 1)/2' y);	// starting and ending point  					points[1] = new PointF(x' y + (mSize+1)/2);  					points[2] = new PointF(x + (mSize+1)/2' y+mSize);  					points[3] = new PointF(x + mSize' y + (mSize+1)/2);  					g.FillPolygon(b' points);  					break;  				case ChartMarkerEnum.Triangle:  					points = new PointF[4];  					points[0] = points[3] = new PointF(x + (mSize + 1)/2' y);	// starting and ending point  					points[1] = new PointF(x' y + mSize);  					points[2] = new PointF(x + mSize' y + mSize);  					g.FillPolygon(b' points);                      break;  				case ChartMarkerEnum.X:                      p = new Pen(p.Brush' 2);// 20022008 AJM GJL  					g.DrawLine(p' new Point(x' y)' new Point(x + mSize' y + mSize));  					g.DrawLine(p' new Point(x' y + mSize)' new Point(x + mSize' y));// 20022008 AJM GJL  					break;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegendMarker,The following statement contains a magic number: switch (marker)  			{                  case ChartMarkerEnum.Bubble:                  case ChartMarkerEnum.Circle:  					g.FillEllipse(b' x' y' mSize' mSize);  					break;  				case ChartMarkerEnum.Square:  					g.FillRectangle(b' x' y' mSize' mSize);  					break;  				case ChartMarkerEnum.Plus:  					// 20022008 AJM GJL - Changed to line - plus is hard to see                      p = new Pen(p.Brush' 2);  					g.DrawLine(p' new Point(x + (mSize + 1)/2' y)' new Point(x + (mSize + 1)/2' y + mSize));  					//g.DrawLine(p' new Point(x + (mSize + 1)/2' y + (mSize+1)/2)' new Point(x + mSize' y + (mSize+1)/2));  					break;  				case ChartMarkerEnum.Diamond:  					points = new PointF[5];  					points[0] = points[4] = new Point(x + (mSize + 1)/2' y);	// starting and ending point  					points[1] = new PointF(x' y + (mSize+1)/2);  					points[2] = new PointF(x + (mSize+1)/2' y+mSize);  					points[3] = new PointF(x + mSize' y + (mSize+1)/2);  					g.FillPolygon(b' points);  					break;  				case ChartMarkerEnum.Triangle:  					points = new PointF[4];  					points[0] = points[3] = new PointF(x + (mSize + 1)/2' y);	// starting and ending point  					points[1] = new PointF(x' y + mSize);  					points[2] = new PointF(x + mSize' y + mSize);  					g.FillPolygon(b' points);                      break;  				case ChartMarkerEnum.X:                      p = new Pen(p.Brush' 2);// 20022008 AJM GJL  					g.DrawLine(p' new Point(x' y)' new Point(x + mSize' y + mSize));  					g.DrawLine(p' new Point(x' y + mSize)' new Point(x + mSize' y));// 20022008 AJM GJL  					break;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegendMarker,The following statement contains a magic number: switch (marker)  			{                  case ChartMarkerEnum.Bubble:                  case ChartMarkerEnum.Circle:  					g.FillEllipse(b' x' y' mSize' mSize);  					break;  				case ChartMarkerEnum.Square:  					g.FillRectangle(b' x' y' mSize' mSize);  					break;  				case ChartMarkerEnum.Plus:  					// 20022008 AJM GJL - Changed to line - plus is hard to see                      p = new Pen(p.Brush' 2);  					g.DrawLine(p' new Point(x + (mSize + 1)/2' y)' new Point(x + (mSize + 1)/2' y + mSize));  					//g.DrawLine(p' new Point(x + (mSize + 1)/2' y + (mSize+1)/2)' new Point(x + mSize' y + (mSize+1)/2));  					break;  				case ChartMarkerEnum.Diamond:  					points = new PointF[5];  					points[0] = points[4] = new Point(x + (mSize + 1)/2' y);	// starting and ending point  					points[1] = new PointF(x' y + (mSize+1)/2);  					points[2] = new PointF(x + (mSize+1)/2' y+mSize);  					points[3] = new PointF(x + mSize' y + (mSize+1)/2);  					g.FillPolygon(b' points);  					break;  				case ChartMarkerEnum.Triangle:  					points = new PointF[4];  					points[0] = points[3] = new PointF(x + (mSize + 1)/2' y);	// starting and ending point  					points[1] = new PointF(x' y + mSize);  					points[2] = new PointF(x + mSize' y + mSize);  					g.FillPolygon(b' points);                      break;  				case ChartMarkerEnum.X:                      p = new Pen(p.Brush' 2);// 20022008 AJM GJL  					g.DrawLine(p' new Point(x' y)' new Point(x + mSize' y + mSize));  					g.DrawLine(p' new Point(x' y + mSize)' new Point(x + mSize' y));// 20022008 AJM GJL  					break;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegendMarker,The following statement contains a magic number: switch (marker)  			{                  case ChartMarkerEnum.Bubble:                  case ChartMarkerEnum.Circle:  					g.FillEllipse(b' x' y' mSize' mSize);  					break;  				case ChartMarkerEnum.Square:  					g.FillRectangle(b' x' y' mSize' mSize);  					break;  				case ChartMarkerEnum.Plus:  					// 20022008 AJM GJL - Changed to line - plus is hard to see                      p = new Pen(p.Brush' 2);  					g.DrawLine(p' new Point(x + (mSize + 1)/2' y)' new Point(x + (mSize + 1)/2' y + mSize));  					//g.DrawLine(p' new Point(x + (mSize + 1)/2' y + (mSize+1)/2)' new Point(x + mSize' y + (mSize+1)/2));  					break;  				case ChartMarkerEnum.Diamond:  					points = new PointF[5];  					points[0] = points[4] = new Point(x + (mSize + 1)/2' y);	// starting and ending point  					points[1] = new PointF(x' y + (mSize+1)/2);  					points[2] = new PointF(x + (mSize+1)/2' y+mSize);  					points[3] = new PointF(x + mSize' y + (mSize+1)/2);  					g.FillPolygon(b' points);  					break;  				case ChartMarkerEnum.Triangle:  					points = new PointF[4];  					points[0] = points[3] = new PointF(x + (mSize + 1)/2' y);	// starting and ending point  					points[1] = new PointF(x' y + mSize);  					points[2] = new PointF(x + mSize' y + mSize);  					g.FillPolygon(b' points);                      break;  				case ChartMarkerEnum.X:                      p = new Pen(p.Brush' 2);// 20022008 AJM GJL  					g.DrawLine(p' new Point(x' y)' new Point(x + mSize' y + mSize));  					g.DrawLine(p' new Point(x' y + mSize)' new Point(x + mSize' y));// 20022008 AJM GJL  					break;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegendMarker,The following statement contains a magic number: switch (marker)  			{                  case ChartMarkerEnum.Bubble:                  case ChartMarkerEnum.Circle:  					g.FillEllipse(b' x' y' mSize' mSize);  					break;  				case ChartMarkerEnum.Square:  					g.FillRectangle(b' x' y' mSize' mSize);  					break;  				case ChartMarkerEnum.Plus:  					// 20022008 AJM GJL - Changed to line - plus is hard to see                      p = new Pen(p.Brush' 2);  					g.DrawLine(p' new Point(x + (mSize + 1)/2' y)' new Point(x + (mSize + 1)/2' y + mSize));  					//g.DrawLine(p' new Point(x + (mSize + 1)/2' y + (mSize+1)/2)' new Point(x + mSize' y + (mSize+1)/2));  					break;  				case ChartMarkerEnum.Diamond:  					points = new PointF[5];  					points[0] = points[4] = new Point(x + (mSize + 1)/2' y);	// starting and ending point  					points[1] = new PointF(x' y + (mSize+1)/2);  					points[2] = new PointF(x + (mSize+1)/2' y+mSize);  					points[3] = new PointF(x + mSize' y + (mSize+1)/2);  					g.FillPolygon(b' points);  					break;  				case ChartMarkerEnum.Triangle:  					points = new PointF[4];  					points[0] = points[3] = new PointF(x + (mSize + 1)/2' y);	// starting and ending point  					points[1] = new PointF(x' y + mSize);  					points[2] = new PointF(x + mSize' y + mSize);  					g.FillPolygon(b' points);                      break;  				case ChartMarkerEnum.X:                      p = new Pen(p.Brush' 2);// 20022008 AJM GJL  					g.DrawLine(p' new Point(x' y)' new Point(x + mSize' y + mSize));  					g.DrawLine(p' new Point(x' y + mSize)' new Point(x + mSize' y));// 20022008 AJM GJL  					break;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegendMarker,The following statement contains a magic number: switch (marker)  			{                  case ChartMarkerEnum.Bubble:                  case ChartMarkerEnum.Circle:  					g.FillEllipse(b' x' y' mSize' mSize);  					break;  				case ChartMarkerEnum.Square:  					g.FillRectangle(b' x' y' mSize' mSize);  					break;  				case ChartMarkerEnum.Plus:  					// 20022008 AJM GJL - Changed to line - plus is hard to see                      p = new Pen(p.Brush' 2);  					g.DrawLine(p' new Point(x + (mSize + 1)/2' y)' new Point(x + (mSize + 1)/2' y + mSize));  					//g.DrawLine(p' new Point(x + (mSize + 1)/2' y + (mSize+1)/2)' new Point(x + mSize' y + (mSize+1)/2));  					break;  				case ChartMarkerEnum.Diamond:  					points = new PointF[5];  					points[0] = points[4] = new Point(x + (mSize + 1)/2' y);	// starting and ending point  					points[1] = new PointF(x' y + (mSize+1)/2);  					points[2] = new PointF(x + (mSize+1)/2' y+mSize);  					points[3] = new PointF(x + mSize' y + (mSize+1)/2);  					g.FillPolygon(b' points);  					break;  				case ChartMarkerEnum.Triangle:  					points = new PointF[4];  					points[0] = points[3] = new PointF(x + (mSize + 1)/2' y);	// starting and ending point  					points[1] = new PointF(x' y + mSize);  					points[2] = new PointF(x + mSize' y + mSize);  					g.FillPolygon(b' points);                      break;  				case ChartMarkerEnum.X:                      p = new Pen(p.Brush' 2);// 20022008 AJM GJL  					g.DrawLine(p' new Point(x' y)' new Point(x + mSize' y + mSize));  					g.DrawLine(p' new Point(x' y + mSize)' new Point(x + mSize' y));// 20022008 AJM GJL  					break;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegendMarker,The following statement contains a magic number: switch (marker)  			{                  case ChartMarkerEnum.Bubble:                  case ChartMarkerEnum.Circle:  					g.FillEllipse(b' x' y' mSize' mSize);  					break;  				case ChartMarkerEnum.Square:  					g.FillRectangle(b' x' y' mSize' mSize);  					break;  				case ChartMarkerEnum.Plus:  					// 20022008 AJM GJL - Changed to line - plus is hard to see                      p = new Pen(p.Brush' 2);  					g.DrawLine(p' new Point(x + (mSize + 1)/2' y)' new Point(x + (mSize + 1)/2' y + mSize));  					//g.DrawLine(p' new Point(x + (mSize + 1)/2' y + (mSize+1)/2)' new Point(x + mSize' y + (mSize+1)/2));  					break;  				case ChartMarkerEnum.Diamond:  					points = new PointF[5];  					points[0] = points[4] = new Point(x + (mSize + 1)/2' y);	// starting and ending point  					points[1] = new PointF(x' y + (mSize+1)/2);  					points[2] = new PointF(x + (mSize+1)/2' y+mSize);  					points[3] = new PointF(x + mSize' y + (mSize+1)/2);  					g.FillPolygon(b' points);  					break;  				case ChartMarkerEnum.Triangle:  					points = new PointF[4];  					points[0] = points[3] = new PointF(x + (mSize + 1)/2' y);	// starting and ending point  					points[1] = new PointF(x' y + mSize);  					points[2] = new PointF(x + mSize' y + mSize);  					g.FillPolygon(b' points);                      break;  				case ChartMarkerEnum.X:                      p = new Pen(p.Brush' 2);// 20022008 AJM GJL  					g.DrawLine(p' new Point(x' y)' new Point(x + mSize' y + mSize));  					g.DrawLine(p' new Point(x' y + mSize)' new Point(x + mSize' y));// 20022008 AJM GJL  					break;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegendMarker,The following statement contains a magic number: switch (marker)  			{                  case ChartMarkerEnum.Bubble:                  case ChartMarkerEnum.Circle:  					g.FillEllipse(b' x' y' mSize' mSize);  					break;  				case ChartMarkerEnum.Square:  					g.FillRectangle(b' x' y' mSize' mSize);  					break;  				case ChartMarkerEnum.Plus:  					// 20022008 AJM GJL - Changed to line - plus is hard to see                      p = new Pen(p.Brush' 2);  					g.DrawLine(p' new Point(x + (mSize + 1)/2' y)' new Point(x + (mSize + 1)/2' y + mSize));  					//g.DrawLine(p' new Point(x + (mSize + 1)/2' y + (mSize+1)/2)' new Point(x + mSize' y + (mSize+1)/2));  					break;  				case ChartMarkerEnum.Diamond:  					points = new PointF[5];  					points[0] = points[4] = new Point(x + (mSize + 1)/2' y);	// starting and ending point  					points[1] = new PointF(x' y + (mSize+1)/2);  					points[2] = new PointF(x + (mSize+1)/2' y+mSize);  					points[3] = new PointF(x + mSize' y + (mSize+1)/2);  					g.FillPolygon(b' points);  					break;  				case ChartMarkerEnum.Triangle:  					points = new PointF[4];  					points[0] = points[3] = new PointF(x + (mSize + 1)/2' y);	// starting and ending point  					points[1] = new PointF(x' y + mSize);  					points[2] = new PointF(x + mSize' y + mSize);  					g.FillPolygon(b' points);                      break;  				case ChartMarkerEnum.X:                      p = new Pen(p.Brush' 2);// 20022008 AJM GJL  					g.DrawLine(p' new Point(x' y)' new Point(x + mSize' y + mSize));  					g.DrawLine(p' new Point(x' y + mSize)' new Point(x + mSize' y));// 20022008 AJM GJL  					break;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegendMarker,The following statement contains a magic number: switch (marker)  			{                  case ChartMarkerEnum.Bubble:                  case ChartMarkerEnum.Circle:  					g.FillEllipse(b' x' y' mSize' mSize);  					break;  				case ChartMarkerEnum.Square:  					g.FillRectangle(b' x' y' mSize' mSize);  					break;  				case ChartMarkerEnum.Plus:  					// 20022008 AJM GJL - Changed to line - plus is hard to see                      p = new Pen(p.Brush' 2);  					g.DrawLine(p' new Point(x + (mSize + 1)/2' y)' new Point(x + (mSize + 1)/2' y + mSize));  					//g.DrawLine(p' new Point(x + (mSize + 1)/2' y + (mSize+1)/2)' new Point(x + mSize' y + (mSize+1)/2));  					break;  				case ChartMarkerEnum.Diamond:  					points = new PointF[5];  					points[0] = points[4] = new Point(x + (mSize + 1)/2' y);	// starting and ending point  					points[1] = new PointF(x' y + (mSize+1)/2);  					points[2] = new PointF(x + (mSize+1)/2' y+mSize);  					points[3] = new PointF(x + mSize' y + (mSize+1)/2);  					g.FillPolygon(b' points);  					break;  				case ChartMarkerEnum.Triangle:  					points = new PointF[4];  					points[0] = points[3] = new PointF(x + (mSize + 1)/2' y);	// starting and ending point  					points[1] = new PointF(x' y + mSize);  					points[2] = new PointF(x + mSize' y + mSize);  					g.FillPolygon(b' points);                      break;  				case ChartMarkerEnum.X:                      p = new Pen(p.Brush' 2);// 20022008 AJM GJL  					g.DrawLine(p' new Point(x' y)' new Point(x + mSize' y + mSize));  					g.DrawLine(p' new Point(x' y + mSize)' new Point(x + mSize' y));// 20022008 AJM GJL  					break;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegendMarker,The following statement contains a magic number: switch (marker)  			{                  case ChartMarkerEnum.Bubble:                  case ChartMarkerEnum.Circle:  					g.FillEllipse(b' x' y' mSize' mSize);  					break;  				case ChartMarkerEnum.Square:  					g.FillRectangle(b' x' y' mSize' mSize);  					break;  				case ChartMarkerEnum.Plus:  					// 20022008 AJM GJL - Changed to line - plus is hard to see                      p = new Pen(p.Brush' 2);  					g.DrawLine(p' new Point(x + (mSize + 1)/2' y)' new Point(x + (mSize + 1)/2' y + mSize));  					//g.DrawLine(p' new Point(x + (mSize + 1)/2' y + (mSize+1)/2)' new Point(x + mSize' y + (mSize+1)/2));  					break;  				case ChartMarkerEnum.Diamond:  					points = new PointF[5];  					points[0] = points[4] = new Point(x + (mSize + 1)/2' y);	// starting and ending point  					points[1] = new PointF(x' y + (mSize+1)/2);  					points[2] = new PointF(x + (mSize+1)/2' y+mSize);  					points[3] = new PointF(x + mSize' y + (mSize+1)/2);  					g.FillPolygon(b' points);  					break;  				case ChartMarkerEnum.Triangle:  					points = new PointF[4];  					points[0] = points[3] = new PointF(x + (mSize + 1)/2' y);	// starting and ending point  					points[1] = new PointF(x' y + mSize);  					points[2] = new PointF(x + mSize' y + mSize);  					g.FillPolygon(b' points);                      break;  				case ChartMarkerEnum.X:                      p = new Pen(p.Brush' 2);// 20022008 AJM GJL  					g.DrawLine(p' new Point(x' y)' new Point(x + mSize' y + mSize));  					g.DrawLine(p' new Point(x' y + mSize)' new Point(x + mSize' y));// 20022008 AJM GJL  					break;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegendMarker,The following statement contains a magic number: switch (marker)  			{                  case ChartMarkerEnum.Bubble:                  case ChartMarkerEnum.Circle:  					g.FillEllipse(b' x' y' mSize' mSize);  					break;  				case ChartMarkerEnum.Square:  					g.FillRectangle(b' x' y' mSize' mSize);  					break;  				case ChartMarkerEnum.Plus:  					// 20022008 AJM GJL - Changed to line - plus is hard to see                      p = new Pen(p.Brush' 2);  					g.DrawLine(p' new Point(x + (mSize + 1)/2' y)' new Point(x + (mSize + 1)/2' y + mSize));  					//g.DrawLine(p' new Point(x + (mSize + 1)/2' y + (mSize+1)/2)' new Point(x + mSize' y + (mSize+1)/2));  					break;  				case ChartMarkerEnum.Diamond:  					points = new PointF[5];  					points[0] = points[4] = new Point(x + (mSize + 1)/2' y);	// starting and ending point  					points[1] = new PointF(x' y + (mSize+1)/2);  					points[2] = new PointF(x + (mSize+1)/2' y+mSize);  					points[3] = new PointF(x + mSize' y + (mSize+1)/2);  					g.FillPolygon(b' points);  					break;  				case ChartMarkerEnum.Triangle:  					points = new PointF[4];  					points[0] = points[3] = new PointF(x + (mSize + 1)/2' y);	// starting and ending point  					points[1] = new PointF(x' y + mSize);  					points[2] = new PointF(x + mSize' y + mSize);  					g.FillPolygon(b' points);                      break;  				case ChartMarkerEnum.X:                      p = new Pen(p.Brush' 2);// 20022008 AJM GJL  					g.DrawLine(p' new Point(x' y)' new Point(x + mSize' y + mSize));  					g.DrawLine(p' new Point(x' y + mSize)' new Point(x + mSize' y));// 20022008 AJM GJL  					break;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetDataValue,The following statement contains a magic number: if (xyb == 0)              {                  v = ce.Value.EvaluateDouble(rpt' lrow);                  mce.Value = v;					// cache so we don't need to calculate again              }              else if (xyb == 1)                  v = ce.Value2.EvaluateDouble(rpt' lrow);              else if (xyb == 2)                  v = ce.Value3.EvaluateDouble(rpt' lrow);
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetMaxMinDataValue,The following statement contains a magic number: for (int iRow = 1; iRow <= CategoryCount; iRow++)  			{  				for (int iCol = 1; iCol <= SeriesCount; iCol++)  				{  					// 20022008 AJM GJL                      if (WhichYAxis == 2)                      {                          if (GetYAxis(rpt' iCol' 1).ToUpper() == "RIGHT")                          {                              v = GetDataValue(rpt' iRow' iCol' xyb);                              if (v < min)                                  min = v;                              if (v > max)                                  max = v;                                                        }                      }                      else                      {                          if (GetYAxis(rpt' iCol' 1).ToUpper() != "RIGHT")                          {  					v = GetDataValue(rpt' iRow' iCol' xyb);  					if (v < min)  						min = v;  					if (v > max)  						max = v;                            }                      }                  				}  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesEarthTones,The following statement contains a magic number: switch (i % 22)  			{  				case 0: return Brushes.Maroon;  				case 1: return Brushes.Brown;  				case 2: return Brushes.Chocolate;  				case 3: return Brushes.IndianRed;  				case 4: return Brushes.Peru;  				case 5: return Brushes.BurlyWood;  				case 6: return Brushes.AntiqueWhite;  				case 7: return Brushes.FloralWhite;  				case 8: return Brushes.Ivory;  				case 9: return Brushes.LightCoral;  				case 10:return Brushes.DarkSalmon;  				case 11: return Brushes.LightSalmon;  				case 12: return Brushes.PeachPuff;  				case 13: return Brushes.NavajoWhite;  				case 14: return Brushes.Moccasin;  				case 15: return Brushes.PapayaWhip;  				case 16: return Brushes.Goldenrod;  				case 17: return Brushes.DarkGoldenrod;  				case 18: return Brushes.DarkKhaki;  				case 19: return Brushes.Khaki;  				case 20: return Brushes.Beige;  				case 21: return Brushes.Cornsilk;  				default: return Brushes.Brown;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesEarthTones,The following statement contains a magic number: switch (i % 22)  			{  				case 0: return Brushes.Maroon;  				case 1: return Brushes.Brown;  				case 2: return Brushes.Chocolate;  				case 3: return Brushes.IndianRed;  				case 4: return Brushes.Peru;  				case 5: return Brushes.BurlyWood;  				case 6: return Brushes.AntiqueWhite;  				case 7: return Brushes.FloralWhite;  				case 8: return Brushes.Ivory;  				case 9: return Brushes.LightCoral;  				case 10:return Brushes.DarkSalmon;  				case 11: return Brushes.LightSalmon;  				case 12: return Brushes.PeachPuff;  				case 13: return Brushes.NavajoWhite;  				case 14: return Brushes.Moccasin;  				case 15: return Brushes.PapayaWhip;  				case 16: return Brushes.Goldenrod;  				case 17: return Brushes.DarkGoldenrod;  				case 18: return Brushes.DarkKhaki;  				case 19: return Brushes.Khaki;  				case 20: return Brushes.Beige;  				case 21: return Brushes.Cornsilk;  				default: return Brushes.Brown;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesEarthTones,The following statement contains a magic number: switch (i % 22)  			{  				case 0: return Brushes.Maroon;  				case 1: return Brushes.Brown;  				case 2: return Brushes.Chocolate;  				case 3: return Brushes.IndianRed;  				case 4: return Brushes.Peru;  				case 5: return Brushes.BurlyWood;  				case 6: return Brushes.AntiqueWhite;  				case 7: return Brushes.FloralWhite;  				case 8: return Brushes.Ivory;  				case 9: return Brushes.LightCoral;  				case 10:return Brushes.DarkSalmon;  				case 11: return Brushes.LightSalmon;  				case 12: return Brushes.PeachPuff;  				case 13: return Brushes.NavajoWhite;  				case 14: return Brushes.Moccasin;  				case 15: return Brushes.PapayaWhip;  				case 16: return Brushes.Goldenrod;  				case 17: return Brushes.DarkGoldenrod;  				case 18: return Brushes.DarkKhaki;  				case 19: return Brushes.Khaki;  				case 20: return Brushes.Beige;  				case 21: return Brushes.Cornsilk;  				default: return Brushes.Brown;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesEarthTones,The following statement contains a magic number: switch (i % 22)  			{  				case 0: return Brushes.Maroon;  				case 1: return Brushes.Brown;  				case 2: return Brushes.Chocolate;  				case 3: return Brushes.IndianRed;  				case 4: return Brushes.Peru;  				case 5: return Brushes.BurlyWood;  				case 6: return Brushes.AntiqueWhite;  				case 7: return Brushes.FloralWhite;  				case 8: return Brushes.Ivory;  				case 9: return Brushes.LightCoral;  				case 10:return Brushes.DarkSalmon;  				case 11: return Brushes.LightSalmon;  				case 12: return Brushes.PeachPuff;  				case 13: return Brushes.NavajoWhite;  				case 14: return Brushes.Moccasin;  				case 15: return Brushes.PapayaWhip;  				case 16: return Brushes.Goldenrod;  				case 17: return Brushes.DarkGoldenrod;  				case 18: return Brushes.DarkKhaki;  				case 19: return Brushes.Khaki;  				case 20: return Brushes.Beige;  				case 21: return Brushes.Cornsilk;  				default: return Brushes.Brown;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesEarthTones,The following statement contains a magic number: switch (i % 22)  			{  				case 0: return Brushes.Maroon;  				case 1: return Brushes.Brown;  				case 2: return Brushes.Chocolate;  				case 3: return Brushes.IndianRed;  				case 4: return Brushes.Peru;  				case 5: return Brushes.BurlyWood;  				case 6: return Brushes.AntiqueWhite;  				case 7: return Brushes.FloralWhite;  				case 8: return Brushes.Ivory;  				case 9: return Brushes.LightCoral;  				case 10:return Brushes.DarkSalmon;  				case 11: return Brushes.LightSalmon;  				case 12: return Brushes.PeachPuff;  				case 13: return Brushes.NavajoWhite;  				case 14: return Brushes.Moccasin;  				case 15: return Brushes.PapayaWhip;  				case 16: return Brushes.Goldenrod;  				case 17: return Brushes.DarkGoldenrod;  				case 18: return Brushes.DarkKhaki;  				case 19: return Brushes.Khaki;  				case 20: return Brushes.Beige;  				case 21: return Brushes.Cornsilk;  				default: return Brushes.Brown;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesEarthTones,The following statement contains a magic number: switch (i % 22)  			{  				case 0: return Brushes.Maroon;  				case 1: return Brushes.Brown;  				case 2: return Brushes.Chocolate;  				case 3: return Brushes.IndianRed;  				case 4: return Brushes.Peru;  				case 5: return Brushes.BurlyWood;  				case 6: return Brushes.AntiqueWhite;  				case 7: return Brushes.FloralWhite;  				case 8: return Brushes.Ivory;  				case 9: return Brushes.LightCoral;  				case 10:return Brushes.DarkSalmon;  				case 11: return Brushes.LightSalmon;  				case 12: return Brushes.PeachPuff;  				case 13: return Brushes.NavajoWhite;  				case 14: return Brushes.Moccasin;  				case 15: return Brushes.PapayaWhip;  				case 16: return Brushes.Goldenrod;  				case 17: return Brushes.DarkGoldenrod;  				case 18: return Brushes.DarkKhaki;  				case 19: return Brushes.Khaki;  				case 20: return Brushes.Beige;  				case 21: return Brushes.Cornsilk;  				default: return Brushes.Brown;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesEarthTones,The following statement contains a magic number: switch (i % 22)  			{  				case 0: return Brushes.Maroon;  				case 1: return Brushes.Brown;  				case 2: return Brushes.Chocolate;  				case 3: return Brushes.IndianRed;  				case 4: return Brushes.Peru;  				case 5: return Brushes.BurlyWood;  				case 6: return Brushes.AntiqueWhite;  				case 7: return Brushes.FloralWhite;  				case 8: return Brushes.Ivory;  				case 9: return Brushes.LightCoral;  				case 10:return Brushes.DarkSalmon;  				case 11: return Brushes.LightSalmon;  				case 12: return Brushes.PeachPuff;  				case 13: return Brushes.NavajoWhite;  				case 14: return Brushes.Moccasin;  				case 15: return Brushes.PapayaWhip;  				case 16: return Brushes.Goldenrod;  				case 17: return Brushes.DarkGoldenrod;  				case 18: return Brushes.DarkKhaki;  				case 19: return Brushes.Khaki;  				case 20: return Brushes.Beige;  				case 21: return Brushes.Cornsilk;  				default: return Brushes.Brown;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesEarthTones,The following statement contains a magic number: switch (i % 22)  			{  				case 0: return Brushes.Maroon;  				case 1: return Brushes.Brown;  				case 2: return Brushes.Chocolate;  				case 3: return Brushes.IndianRed;  				case 4: return Brushes.Peru;  				case 5: return Brushes.BurlyWood;  				case 6: return Brushes.AntiqueWhite;  				case 7: return Brushes.FloralWhite;  				case 8: return Brushes.Ivory;  				case 9: return Brushes.LightCoral;  				case 10:return Brushes.DarkSalmon;  				case 11: return Brushes.LightSalmon;  				case 12: return Brushes.PeachPuff;  				case 13: return Brushes.NavajoWhite;  				case 14: return Brushes.Moccasin;  				case 15: return Brushes.PapayaWhip;  				case 16: return Brushes.Goldenrod;  				case 17: return Brushes.DarkGoldenrod;  				case 18: return Brushes.DarkKhaki;  				case 19: return Brushes.Khaki;  				case 20: return Brushes.Beige;  				case 21: return Brushes.Cornsilk;  				default: return Brushes.Brown;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesEarthTones,The following statement contains a magic number: switch (i % 22)  			{  				case 0: return Brushes.Maroon;  				case 1: return Brushes.Brown;  				case 2: return Brushes.Chocolate;  				case 3: return Brushes.IndianRed;  				case 4: return Brushes.Peru;  				case 5: return Brushes.BurlyWood;  				case 6: return Brushes.AntiqueWhite;  				case 7: return Brushes.FloralWhite;  				case 8: return Brushes.Ivory;  				case 9: return Brushes.LightCoral;  				case 10:return Brushes.DarkSalmon;  				case 11: return Brushes.LightSalmon;  				case 12: return Brushes.PeachPuff;  				case 13: return Brushes.NavajoWhite;  				case 14: return Brushes.Moccasin;  				case 15: return Brushes.PapayaWhip;  				case 16: return Brushes.Goldenrod;  				case 17: return Brushes.DarkGoldenrod;  				case 18: return Brushes.DarkKhaki;  				case 19: return Brushes.Khaki;  				case 20: return Brushes.Beige;  				case 21: return Brushes.Cornsilk;  				default: return Brushes.Brown;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesEarthTones,The following statement contains a magic number: switch (i % 22)  			{  				case 0: return Brushes.Maroon;  				case 1: return Brushes.Brown;  				case 2: return Brushes.Chocolate;  				case 3: return Brushes.IndianRed;  				case 4: return Brushes.Peru;  				case 5: return Brushes.BurlyWood;  				case 6: return Brushes.AntiqueWhite;  				case 7: return Brushes.FloralWhite;  				case 8: return Brushes.Ivory;  				case 9: return Brushes.LightCoral;  				case 10:return Brushes.DarkSalmon;  				case 11: return Brushes.LightSalmon;  				case 12: return Brushes.PeachPuff;  				case 13: return Brushes.NavajoWhite;  				case 14: return Brushes.Moccasin;  				case 15: return Brushes.PapayaWhip;  				case 16: return Brushes.Goldenrod;  				case 17: return Brushes.DarkGoldenrod;  				case 18: return Brushes.DarkKhaki;  				case 19: return Brushes.Khaki;  				case 20: return Brushes.Beige;  				case 21: return Brushes.Cornsilk;  				default: return Brushes.Brown;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesEarthTones,The following statement contains a magic number: switch (i % 22)  			{  				case 0: return Brushes.Maroon;  				case 1: return Brushes.Brown;  				case 2: return Brushes.Chocolate;  				case 3: return Brushes.IndianRed;  				case 4: return Brushes.Peru;  				case 5: return Brushes.BurlyWood;  				case 6: return Brushes.AntiqueWhite;  				case 7: return Brushes.FloralWhite;  				case 8: return Brushes.Ivory;  				case 9: return Brushes.LightCoral;  				case 10:return Brushes.DarkSalmon;  				case 11: return Brushes.LightSalmon;  				case 12: return Brushes.PeachPuff;  				case 13: return Brushes.NavajoWhite;  				case 14: return Brushes.Moccasin;  				case 15: return Brushes.PapayaWhip;  				case 16: return Brushes.Goldenrod;  				case 17: return Brushes.DarkGoldenrod;  				case 18: return Brushes.DarkKhaki;  				case 19: return Brushes.Khaki;  				case 20: return Brushes.Beige;  				case 21: return Brushes.Cornsilk;  				default: return Brushes.Brown;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesEarthTones,The following statement contains a magic number: switch (i % 22)  			{  				case 0: return Brushes.Maroon;  				case 1: return Brushes.Brown;  				case 2: return Brushes.Chocolate;  				case 3: return Brushes.IndianRed;  				case 4: return Brushes.Peru;  				case 5: return Brushes.BurlyWood;  				case 6: return Brushes.AntiqueWhite;  				case 7: return Brushes.FloralWhite;  				case 8: return Brushes.Ivory;  				case 9: return Brushes.LightCoral;  				case 10:return Brushes.DarkSalmon;  				case 11: return Brushes.LightSalmon;  				case 12: return Brushes.PeachPuff;  				case 13: return Brushes.NavajoWhite;  				case 14: return Brushes.Moccasin;  				case 15: return Brushes.PapayaWhip;  				case 16: return Brushes.Goldenrod;  				case 17: return Brushes.DarkGoldenrod;  				case 18: return Brushes.DarkKhaki;  				case 19: return Brushes.Khaki;  				case 20: return Brushes.Beige;  				case 21: return Brushes.Cornsilk;  				default: return Brushes.Brown;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesEarthTones,The following statement contains a magic number: switch (i % 22)  			{  				case 0: return Brushes.Maroon;  				case 1: return Brushes.Brown;  				case 2: return Brushes.Chocolate;  				case 3: return Brushes.IndianRed;  				case 4: return Brushes.Peru;  				case 5: return Brushes.BurlyWood;  				case 6: return Brushes.AntiqueWhite;  				case 7: return Brushes.FloralWhite;  				case 8: return Brushes.Ivory;  				case 9: return Brushes.LightCoral;  				case 10:return Brushes.DarkSalmon;  				case 11: return Brushes.LightSalmon;  				case 12: return Brushes.PeachPuff;  				case 13: return Brushes.NavajoWhite;  				case 14: return Brushes.Moccasin;  				case 15: return Brushes.PapayaWhip;  				case 16: return Brushes.Goldenrod;  				case 17: return Brushes.DarkGoldenrod;  				case 18: return Brushes.DarkKhaki;  				case 19: return Brushes.Khaki;  				case 20: return Brushes.Beige;  				case 21: return Brushes.Cornsilk;  				default: return Brushes.Brown;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesEarthTones,The following statement contains a magic number: switch (i % 22)  			{  				case 0: return Brushes.Maroon;  				case 1: return Brushes.Brown;  				case 2: return Brushes.Chocolate;  				case 3: return Brushes.IndianRed;  				case 4: return Brushes.Peru;  				case 5: return Brushes.BurlyWood;  				case 6: return Brushes.AntiqueWhite;  				case 7: return Brushes.FloralWhite;  				case 8: return Brushes.Ivory;  				case 9: return Brushes.LightCoral;  				case 10:return Brushes.DarkSalmon;  				case 11: return Brushes.LightSalmon;  				case 12: return Brushes.PeachPuff;  				case 13: return Brushes.NavajoWhite;  				case 14: return Brushes.Moccasin;  				case 15: return Brushes.PapayaWhip;  				case 16: return Brushes.Goldenrod;  				case 17: return Brushes.DarkGoldenrod;  				case 18: return Brushes.DarkKhaki;  				case 19: return Brushes.Khaki;  				case 20: return Brushes.Beige;  				case 21: return Brushes.Cornsilk;  				default: return Brushes.Brown;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesEarthTones,The following statement contains a magic number: switch (i % 22)  			{  				case 0: return Brushes.Maroon;  				case 1: return Brushes.Brown;  				case 2: return Brushes.Chocolate;  				case 3: return Brushes.IndianRed;  				case 4: return Brushes.Peru;  				case 5: return Brushes.BurlyWood;  				case 6: return Brushes.AntiqueWhite;  				case 7: return Brushes.FloralWhite;  				case 8: return Brushes.Ivory;  				case 9: return Brushes.LightCoral;  				case 10:return Brushes.DarkSalmon;  				case 11: return Brushes.LightSalmon;  				case 12: return Brushes.PeachPuff;  				case 13: return Brushes.NavajoWhite;  				case 14: return Brushes.Moccasin;  				case 15: return Brushes.PapayaWhip;  				case 16: return Brushes.Goldenrod;  				case 17: return Brushes.DarkGoldenrod;  				case 18: return Brushes.DarkKhaki;  				case 19: return Brushes.Khaki;  				case 20: return Brushes.Beige;  				case 21: return Brushes.Cornsilk;  				default: return Brushes.Brown;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesEarthTones,The following statement contains a magic number: switch (i % 22)  			{  				case 0: return Brushes.Maroon;  				case 1: return Brushes.Brown;  				case 2: return Brushes.Chocolate;  				case 3: return Brushes.IndianRed;  				case 4: return Brushes.Peru;  				case 5: return Brushes.BurlyWood;  				case 6: return Brushes.AntiqueWhite;  				case 7: return Brushes.FloralWhite;  				case 8: return Brushes.Ivory;  				case 9: return Brushes.LightCoral;  				case 10:return Brushes.DarkSalmon;  				case 11: return Brushes.LightSalmon;  				case 12: return Brushes.PeachPuff;  				case 13: return Brushes.NavajoWhite;  				case 14: return Brushes.Moccasin;  				case 15: return Brushes.PapayaWhip;  				case 16: return Brushes.Goldenrod;  				case 17: return Brushes.DarkGoldenrod;  				case 18: return Brushes.DarkKhaki;  				case 19: return Brushes.Khaki;  				case 20: return Brushes.Beige;  				case 21: return Brushes.Cornsilk;  				default: return Brushes.Brown;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesEarthTones,The following statement contains a magic number: switch (i % 22)  			{  				case 0: return Brushes.Maroon;  				case 1: return Brushes.Brown;  				case 2: return Brushes.Chocolate;  				case 3: return Brushes.IndianRed;  				case 4: return Brushes.Peru;  				case 5: return Brushes.BurlyWood;  				case 6: return Brushes.AntiqueWhite;  				case 7: return Brushes.FloralWhite;  				case 8: return Brushes.Ivory;  				case 9: return Brushes.LightCoral;  				case 10:return Brushes.DarkSalmon;  				case 11: return Brushes.LightSalmon;  				case 12: return Brushes.PeachPuff;  				case 13: return Brushes.NavajoWhite;  				case 14: return Brushes.Moccasin;  				case 15: return Brushes.PapayaWhip;  				case 16: return Brushes.Goldenrod;  				case 17: return Brushes.DarkGoldenrod;  				case 18: return Brushes.DarkKhaki;  				case 19: return Brushes.Khaki;  				case 20: return Brushes.Beige;  				case 21: return Brushes.Cornsilk;  				default: return Brushes.Brown;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesEarthTones,The following statement contains a magic number: switch (i % 22)  			{  				case 0: return Brushes.Maroon;  				case 1: return Brushes.Brown;  				case 2: return Brushes.Chocolate;  				case 3: return Brushes.IndianRed;  				case 4: return Brushes.Peru;  				case 5: return Brushes.BurlyWood;  				case 6: return Brushes.AntiqueWhite;  				case 7: return Brushes.FloralWhite;  				case 8: return Brushes.Ivory;  				case 9: return Brushes.LightCoral;  				case 10:return Brushes.DarkSalmon;  				case 11: return Brushes.LightSalmon;  				case 12: return Brushes.PeachPuff;  				case 13: return Brushes.NavajoWhite;  				case 14: return Brushes.Moccasin;  				case 15: return Brushes.PapayaWhip;  				case 16: return Brushes.Goldenrod;  				case 17: return Brushes.DarkGoldenrod;  				case 18: return Brushes.DarkKhaki;  				case 19: return Brushes.Khaki;  				case 20: return Brushes.Beige;  				case 21: return Brushes.Cornsilk;  				default: return Brushes.Brown;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesEarthTones,The following statement contains a magic number: switch (i % 22)  			{  				case 0: return Brushes.Maroon;  				case 1: return Brushes.Brown;  				case 2: return Brushes.Chocolate;  				case 3: return Brushes.IndianRed;  				case 4: return Brushes.Peru;  				case 5: return Brushes.BurlyWood;  				case 6: return Brushes.AntiqueWhite;  				case 7: return Brushes.FloralWhite;  				case 8: return Brushes.Ivory;  				case 9: return Brushes.LightCoral;  				case 10:return Brushes.DarkSalmon;  				case 11: return Brushes.LightSalmon;  				case 12: return Brushes.PeachPuff;  				case 13: return Brushes.NavajoWhite;  				case 14: return Brushes.Moccasin;  				case 15: return Brushes.PapayaWhip;  				case 16: return Brushes.Goldenrod;  				case 17: return Brushes.DarkGoldenrod;  				case 18: return Brushes.DarkKhaki;  				case 19: return Brushes.Khaki;  				case 20: return Brushes.Beige;  				case 21: return Brushes.Cornsilk;  				default: return Brushes.Brown;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesEarthTones,The following statement contains a magic number: switch (i % 22)  			{  				case 0: return Brushes.Maroon;  				case 1: return Brushes.Brown;  				case 2: return Brushes.Chocolate;  				case 3: return Brushes.IndianRed;  				case 4: return Brushes.Peru;  				case 5: return Brushes.BurlyWood;  				case 6: return Brushes.AntiqueWhite;  				case 7: return Brushes.FloralWhite;  				case 8: return Brushes.Ivory;  				case 9: return Brushes.LightCoral;  				case 10:return Brushes.DarkSalmon;  				case 11: return Brushes.LightSalmon;  				case 12: return Brushes.PeachPuff;  				case 13: return Brushes.NavajoWhite;  				case 14: return Brushes.Moccasin;  				case 15: return Brushes.PapayaWhip;  				case 16: return Brushes.Goldenrod;  				case 17: return Brushes.DarkGoldenrod;  				case 18: return Brushes.DarkKhaki;  				case 19: return Brushes.Khaki;  				case 20: return Brushes.Beige;  				case 21: return Brushes.Cornsilk;  				default: return Brushes.Brown;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesEarthTones,The following statement contains a magic number: switch (i % 22)  			{  				case 0: return Brushes.Maroon;  				case 1: return Brushes.Brown;  				case 2: return Brushes.Chocolate;  				case 3: return Brushes.IndianRed;  				case 4: return Brushes.Peru;  				case 5: return Brushes.BurlyWood;  				case 6: return Brushes.AntiqueWhite;  				case 7: return Brushes.FloralWhite;  				case 8: return Brushes.Ivory;  				case 9: return Brushes.LightCoral;  				case 10:return Brushes.DarkSalmon;  				case 11: return Brushes.LightSalmon;  				case 12: return Brushes.PeachPuff;  				case 13: return Brushes.NavajoWhite;  				case 14: return Brushes.Moccasin;  				case 15: return Brushes.PapayaWhip;  				case 16: return Brushes.Goldenrod;  				case 17: return Brushes.DarkGoldenrod;  				case 18: return Brushes.DarkKhaki;  				case 19: return Brushes.Khaki;  				case 20: return Brushes.Beige;  				case 21: return Brushes.Cornsilk;  				default: return Brushes.Brown;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesExcel,The following statement contains a magic number: switch (i % 11)				// Just a guess at what these might actually be  			{                  //Gil's Excel 080208 - from excel 2007                  case 0: return Brushes.Blue;                  case 1: return Brushes.Red;                  case 2: return Brushes.Green;                  case 3: return Brushes.Purple;                  case 4: return Brushes.DeepSkyBlue;                  case 5: return Brushes.Orange;                  case 6: return Brushes.Magenta;                  case 7: return Brushes.Gold;                  case 8: return Brushes.Lime;                  case 9: return Brushes.Teal;                  case 10: return Brushes.Pink;                  default: return Brushes.Blue;                 			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesExcel,The following statement contains a magic number: switch (i % 11)				// Just a guess at what these might actually be  			{                  //Gil's Excel 080208 - from excel 2007                  case 0: return Brushes.Blue;                  case 1: return Brushes.Red;                  case 2: return Brushes.Green;                  case 3: return Brushes.Purple;                  case 4: return Brushes.DeepSkyBlue;                  case 5: return Brushes.Orange;                  case 6: return Brushes.Magenta;                  case 7: return Brushes.Gold;                  case 8: return Brushes.Lime;                  case 9: return Brushes.Teal;                  case 10: return Brushes.Pink;                  default: return Brushes.Blue;                 			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesExcel,The following statement contains a magic number: switch (i % 11)				// Just a guess at what these might actually be  			{                  //Gil's Excel 080208 - from excel 2007                  case 0: return Brushes.Blue;                  case 1: return Brushes.Red;                  case 2: return Brushes.Green;                  case 3: return Brushes.Purple;                  case 4: return Brushes.DeepSkyBlue;                  case 5: return Brushes.Orange;                  case 6: return Brushes.Magenta;                  case 7: return Brushes.Gold;                  case 8: return Brushes.Lime;                  case 9: return Brushes.Teal;                  case 10: return Brushes.Pink;                  default: return Brushes.Blue;                 			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesExcel,The following statement contains a magic number: switch (i % 11)				// Just a guess at what these might actually be  			{                  //Gil's Excel 080208 - from excel 2007                  case 0: return Brushes.Blue;                  case 1: return Brushes.Red;                  case 2: return Brushes.Green;                  case 3: return Brushes.Purple;                  case 4: return Brushes.DeepSkyBlue;                  case 5: return Brushes.Orange;                  case 6: return Brushes.Magenta;                  case 7: return Brushes.Gold;                  case 8: return Brushes.Lime;                  case 9: return Brushes.Teal;                  case 10: return Brushes.Pink;                  default: return Brushes.Blue;                 			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesExcel,The following statement contains a magic number: switch (i % 11)				// Just a guess at what these might actually be  			{                  //Gil's Excel 080208 - from excel 2007                  case 0: return Brushes.Blue;                  case 1: return Brushes.Red;                  case 2: return Brushes.Green;                  case 3: return Brushes.Purple;                  case 4: return Brushes.DeepSkyBlue;                  case 5: return Brushes.Orange;                  case 6: return Brushes.Magenta;                  case 7: return Brushes.Gold;                  case 8: return Brushes.Lime;                  case 9: return Brushes.Teal;                  case 10: return Brushes.Pink;                  default: return Brushes.Blue;                 			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesExcel,The following statement contains a magic number: switch (i % 11)				// Just a guess at what these might actually be  			{                  //Gil's Excel 080208 - from excel 2007                  case 0: return Brushes.Blue;                  case 1: return Brushes.Red;                  case 2: return Brushes.Green;                  case 3: return Brushes.Purple;                  case 4: return Brushes.DeepSkyBlue;                  case 5: return Brushes.Orange;                  case 6: return Brushes.Magenta;                  case 7: return Brushes.Gold;                  case 8: return Brushes.Lime;                  case 9: return Brushes.Teal;                  case 10: return Brushes.Pink;                  default: return Brushes.Blue;                 			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesExcel,The following statement contains a magic number: switch (i % 11)				// Just a guess at what these might actually be  			{                  //Gil's Excel 080208 - from excel 2007                  case 0: return Brushes.Blue;                  case 1: return Brushes.Red;                  case 2: return Brushes.Green;                  case 3: return Brushes.Purple;                  case 4: return Brushes.DeepSkyBlue;                  case 5: return Brushes.Orange;                  case 6: return Brushes.Magenta;                  case 7: return Brushes.Gold;                  case 8: return Brushes.Lime;                  case 9: return Brushes.Teal;                  case 10: return Brushes.Pink;                  default: return Brushes.Blue;                 			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesExcel,The following statement contains a magic number: switch (i % 11)				// Just a guess at what these might actually be  			{                  //Gil's Excel 080208 - from excel 2007                  case 0: return Brushes.Blue;                  case 1: return Brushes.Red;                  case 2: return Brushes.Green;                  case 3: return Brushes.Purple;                  case 4: return Brushes.DeepSkyBlue;                  case 5: return Brushes.Orange;                  case 6: return Brushes.Magenta;                  case 7: return Brushes.Gold;                  case 8: return Brushes.Lime;                  case 9: return Brushes.Teal;                  case 10: return Brushes.Pink;                  default: return Brushes.Blue;                 			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesExcel,The following statement contains a magic number: switch (i % 11)				// Just a guess at what these might actually be  			{                  //Gil's Excel 080208 - from excel 2007                  case 0: return Brushes.Blue;                  case 1: return Brushes.Red;                  case 2: return Brushes.Green;                  case 3: return Brushes.Purple;                  case 4: return Brushes.DeepSkyBlue;                  case 5: return Brushes.Orange;                  case 6: return Brushes.Magenta;                  case 7: return Brushes.Gold;                  case 8: return Brushes.Lime;                  case 9: return Brushes.Teal;                  case 10: return Brushes.Pink;                  default: return Brushes.Blue;                 			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesExcel,The following statement contains a magic number: switch (i % 11)				// Just a guess at what these might actually be  			{                  //Gil's Excel 080208 - from excel 2007                  case 0: return Brushes.Blue;                  case 1: return Brushes.Red;                  case 2: return Brushes.Green;                  case 3: return Brushes.Purple;                  case 4: return Brushes.DeepSkyBlue;                  case 5: return Brushes.Orange;                  case 6: return Brushes.Magenta;                  case 7: return Brushes.Gold;                  case 8: return Brushes.Lime;                  case 9: return Brushes.Teal;                  case 10: return Brushes.Pink;                  default: return Brushes.Blue;                 			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPatterned,The following statement contains a magic number: switch (i % 10)              {                  case 0:                      PatternBrush = new HatchBrush(HatchStyle.LargeConfetti' Color.Blue'Color.White);                      break;                  case 1:                      PatternBrush = new HatchBrush(HatchStyle.Cross' Color.Red' Color.White); // was weave... but I Especially didn't want to draw that in PDF - GJL                      break;                  case 2:                      PatternBrush = new HatchBrush(HatchStyle.DarkDownwardDiagonal' Color.Green' Color.White);                      break;                  case 3:                      PatternBrush = new HatchBrush(HatchStyle.OutlinedDiamond' Color.Purple' Color.White);                      break;                  case 4:                      PatternBrush = new HatchBrush(HatchStyle.DarkHorizontal' Color.DeepSkyBlue' Color.White);                      break;                  case 5:                      PatternBrush = new HatchBrush(HatchStyle.SmallConfetti' Color.Orange' Color.White);                      break;                  case 6:                      PatternBrush = new HatchBrush(HatchStyle.HorizontalBrick' Color.Magenta' Color.White);                      break;                  case 7:                      PatternBrush = new HatchBrush(HatchStyle.LargeCheckerBoard' Color.Gold' Color.White); // was wave... but I didn't want to draw that in PDF - GJL                      break;                  case 8:                      PatternBrush = new HatchBrush(HatchStyle.Vertical' Color.Lime' Color.White);                      break;                  case 9:                      PatternBrush = new HatchBrush(HatchStyle.SolidDiamond' Color.Teal' Color.White);                      break;                  case 10:                      PatternBrush = new HatchBrush(HatchStyle.DiagonalBrick' Color.Pink' Color.White);                      break;                  default:                      PatternBrush = new HatchBrush(HatchStyle.BackwardDiagonal' Color.Blue' Color.White);                      break;                                   }
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPatterned,The following statement contains a magic number: switch (i % 10)              {                  case 0:                      PatternBrush = new HatchBrush(HatchStyle.LargeConfetti' Color.Blue'Color.White);                      break;                  case 1:                      PatternBrush = new HatchBrush(HatchStyle.Cross' Color.Red' Color.White); // was weave... but I Especially didn't want to draw that in PDF - GJL                      break;                  case 2:                      PatternBrush = new HatchBrush(HatchStyle.DarkDownwardDiagonal' Color.Green' Color.White);                      break;                  case 3:                      PatternBrush = new HatchBrush(HatchStyle.OutlinedDiamond' Color.Purple' Color.White);                      break;                  case 4:                      PatternBrush = new HatchBrush(HatchStyle.DarkHorizontal' Color.DeepSkyBlue' Color.White);                      break;                  case 5:                      PatternBrush = new HatchBrush(HatchStyle.SmallConfetti' Color.Orange' Color.White);                      break;                  case 6:                      PatternBrush = new HatchBrush(HatchStyle.HorizontalBrick' Color.Magenta' Color.White);                      break;                  case 7:                      PatternBrush = new HatchBrush(HatchStyle.LargeCheckerBoard' Color.Gold' Color.White); // was wave... but I didn't want to draw that in PDF - GJL                      break;                  case 8:                      PatternBrush = new HatchBrush(HatchStyle.Vertical' Color.Lime' Color.White);                      break;                  case 9:                      PatternBrush = new HatchBrush(HatchStyle.SolidDiamond' Color.Teal' Color.White);                      break;                  case 10:                      PatternBrush = new HatchBrush(HatchStyle.DiagonalBrick' Color.Pink' Color.White);                      break;                  default:                      PatternBrush = new HatchBrush(HatchStyle.BackwardDiagonal' Color.Blue' Color.White);                      break;                                   }
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPatterned,The following statement contains a magic number: switch (i % 10)              {                  case 0:                      PatternBrush = new HatchBrush(HatchStyle.LargeConfetti' Color.Blue'Color.White);                      break;                  case 1:                      PatternBrush = new HatchBrush(HatchStyle.Cross' Color.Red' Color.White); // was weave... but I Especially didn't want to draw that in PDF - GJL                      break;                  case 2:                      PatternBrush = new HatchBrush(HatchStyle.DarkDownwardDiagonal' Color.Green' Color.White);                      break;                  case 3:                      PatternBrush = new HatchBrush(HatchStyle.OutlinedDiamond' Color.Purple' Color.White);                      break;                  case 4:                      PatternBrush = new HatchBrush(HatchStyle.DarkHorizontal' Color.DeepSkyBlue' Color.White);                      break;                  case 5:                      PatternBrush = new HatchBrush(HatchStyle.SmallConfetti' Color.Orange' Color.White);                      break;                  case 6:                      PatternBrush = new HatchBrush(HatchStyle.HorizontalBrick' Color.Magenta' Color.White);                      break;                  case 7:                      PatternBrush = new HatchBrush(HatchStyle.LargeCheckerBoard' Color.Gold' Color.White); // was wave... but I didn't want to draw that in PDF - GJL                      break;                  case 8:                      PatternBrush = new HatchBrush(HatchStyle.Vertical' Color.Lime' Color.White);                      break;                  case 9:                      PatternBrush = new HatchBrush(HatchStyle.SolidDiamond' Color.Teal' Color.White);                      break;                  case 10:                      PatternBrush = new HatchBrush(HatchStyle.DiagonalBrick' Color.Pink' Color.White);                      break;                  default:                      PatternBrush = new HatchBrush(HatchStyle.BackwardDiagonal' Color.Blue' Color.White);                      break;                                   }
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPatterned,The following statement contains a magic number: switch (i % 10)              {                  case 0:                      PatternBrush = new HatchBrush(HatchStyle.LargeConfetti' Color.Blue'Color.White);                      break;                  case 1:                      PatternBrush = new HatchBrush(HatchStyle.Cross' Color.Red' Color.White); // was weave... but I Especially didn't want to draw that in PDF - GJL                      break;                  case 2:                      PatternBrush = new HatchBrush(HatchStyle.DarkDownwardDiagonal' Color.Green' Color.White);                      break;                  case 3:                      PatternBrush = new HatchBrush(HatchStyle.OutlinedDiamond' Color.Purple' Color.White);                      break;                  case 4:                      PatternBrush = new HatchBrush(HatchStyle.DarkHorizontal' Color.DeepSkyBlue' Color.White);                      break;                  case 5:                      PatternBrush = new HatchBrush(HatchStyle.SmallConfetti' Color.Orange' Color.White);                      break;                  case 6:                      PatternBrush = new HatchBrush(HatchStyle.HorizontalBrick' Color.Magenta' Color.White);                      break;                  case 7:                      PatternBrush = new HatchBrush(HatchStyle.LargeCheckerBoard' Color.Gold' Color.White); // was wave... but I didn't want to draw that in PDF - GJL                      break;                  case 8:                      PatternBrush = new HatchBrush(HatchStyle.Vertical' Color.Lime' Color.White);                      break;                  case 9:                      PatternBrush = new HatchBrush(HatchStyle.SolidDiamond' Color.Teal' Color.White);                      break;                  case 10:                      PatternBrush = new HatchBrush(HatchStyle.DiagonalBrick' Color.Pink' Color.White);                      break;                  default:                      PatternBrush = new HatchBrush(HatchStyle.BackwardDiagonal' Color.Blue' Color.White);                      break;                                   }
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPatterned,The following statement contains a magic number: switch (i % 10)              {                  case 0:                      PatternBrush = new HatchBrush(HatchStyle.LargeConfetti' Color.Blue'Color.White);                      break;                  case 1:                      PatternBrush = new HatchBrush(HatchStyle.Cross' Color.Red' Color.White); // was weave... but I Especially didn't want to draw that in PDF - GJL                      break;                  case 2:                      PatternBrush = new HatchBrush(HatchStyle.DarkDownwardDiagonal' Color.Green' Color.White);                      break;                  case 3:                      PatternBrush = new HatchBrush(HatchStyle.OutlinedDiamond' Color.Purple' Color.White);                      break;                  case 4:                      PatternBrush = new HatchBrush(HatchStyle.DarkHorizontal' Color.DeepSkyBlue' Color.White);                      break;                  case 5:                      PatternBrush = new HatchBrush(HatchStyle.SmallConfetti' Color.Orange' Color.White);                      break;                  case 6:                      PatternBrush = new HatchBrush(HatchStyle.HorizontalBrick' Color.Magenta' Color.White);                      break;                  case 7:                      PatternBrush = new HatchBrush(HatchStyle.LargeCheckerBoard' Color.Gold' Color.White); // was wave... but I didn't want to draw that in PDF - GJL                      break;                  case 8:                      PatternBrush = new HatchBrush(HatchStyle.Vertical' Color.Lime' Color.White);                      break;                  case 9:                      PatternBrush = new HatchBrush(HatchStyle.SolidDiamond' Color.Teal' Color.White);                      break;                  case 10:                      PatternBrush = new HatchBrush(HatchStyle.DiagonalBrick' Color.Pink' Color.White);                      break;                  default:                      PatternBrush = new HatchBrush(HatchStyle.BackwardDiagonal' Color.Blue' Color.White);                      break;                                   }
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPatterned,The following statement contains a magic number: switch (i % 10)              {                  case 0:                      PatternBrush = new HatchBrush(HatchStyle.LargeConfetti' Color.Blue'Color.White);                      break;                  case 1:                      PatternBrush = new HatchBrush(HatchStyle.Cross' Color.Red' Color.White); // was weave... but I Especially didn't want to draw that in PDF - GJL                      break;                  case 2:                      PatternBrush = new HatchBrush(HatchStyle.DarkDownwardDiagonal' Color.Green' Color.White);                      break;                  case 3:                      PatternBrush = new HatchBrush(HatchStyle.OutlinedDiamond' Color.Purple' Color.White);                      break;                  case 4:                      PatternBrush = new HatchBrush(HatchStyle.DarkHorizontal' Color.DeepSkyBlue' Color.White);                      break;                  case 5:                      PatternBrush = new HatchBrush(HatchStyle.SmallConfetti' Color.Orange' Color.White);                      break;                  case 6:                      PatternBrush = new HatchBrush(HatchStyle.HorizontalBrick' Color.Magenta' Color.White);                      break;                  case 7:                      PatternBrush = new HatchBrush(HatchStyle.LargeCheckerBoard' Color.Gold' Color.White); // was wave... but I didn't want to draw that in PDF - GJL                      break;                  case 8:                      PatternBrush = new HatchBrush(HatchStyle.Vertical' Color.Lime' Color.White);                      break;                  case 9:                      PatternBrush = new HatchBrush(HatchStyle.SolidDiamond' Color.Teal' Color.White);                      break;                  case 10:                      PatternBrush = new HatchBrush(HatchStyle.DiagonalBrick' Color.Pink' Color.White);                      break;                  default:                      PatternBrush = new HatchBrush(HatchStyle.BackwardDiagonal' Color.Blue' Color.White);                      break;                                   }
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPatterned,The following statement contains a magic number: switch (i % 10)              {                  case 0:                      PatternBrush = new HatchBrush(HatchStyle.LargeConfetti' Color.Blue'Color.White);                      break;                  case 1:                      PatternBrush = new HatchBrush(HatchStyle.Cross' Color.Red' Color.White); // was weave... but I Especially didn't want to draw that in PDF - GJL                      break;                  case 2:                      PatternBrush = new HatchBrush(HatchStyle.DarkDownwardDiagonal' Color.Green' Color.White);                      break;                  case 3:                      PatternBrush = new HatchBrush(HatchStyle.OutlinedDiamond' Color.Purple' Color.White);                      break;                  case 4:                      PatternBrush = new HatchBrush(HatchStyle.DarkHorizontal' Color.DeepSkyBlue' Color.White);                      break;                  case 5:                      PatternBrush = new HatchBrush(HatchStyle.SmallConfetti' Color.Orange' Color.White);                      break;                  case 6:                      PatternBrush = new HatchBrush(HatchStyle.HorizontalBrick' Color.Magenta' Color.White);                      break;                  case 7:                      PatternBrush = new HatchBrush(HatchStyle.LargeCheckerBoard' Color.Gold' Color.White); // was wave... but I didn't want to draw that in PDF - GJL                      break;                  case 8:                      PatternBrush = new HatchBrush(HatchStyle.Vertical' Color.Lime' Color.White);                      break;                  case 9:                      PatternBrush = new HatchBrush(HatchStyle.SolidDiamond' Color.Teal' Color.White);                      break;                  case 10:                      PatternBrush = new HatchBrush(HatchStyle.DiagonalBrick' Color.Pink' Color.White);                      break;                  default:                      PatternBrush = new HatchBrush(HatchStyle.BackwardDiagonal' Color.Blue' Color.White);                      break;                                   }
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPatterned,The following statement contains a magic number: switch (i % 10)              {                  case 0:                      PatternBrush = new HatchBrush(HatchStyle.LargeConfetti' Color.Blue'Color.White);                      break;                  case 1:                      PatternBrush = new HatchBrush(HatchStyle.Cross' Color.Red' Color.White); // was weave... but I Especially didn't want to draw that in PDF - GJL                      break;                  case 2:                      PatternBrush = new HatchBrush(HatchStyle.DarkDownwardDiagonal' Color.Green' Color.White);                      break;                  case 3:                      PatternBrush = new HatchBrush(HatchStyle.OutlinedDiamond' Color.Purple' Color.White);                      break;                  case 4:                      PatternBrush = new HatchBrush(HatchStyle.DarkHorizontal' Color.DeepSkyBlue' Color.White);                      break;                  case 5:                      PatternBrush = new HatchBrush(HatchStyle.SmallConfetti' Color.Orange' Color.White);                      break;                  case 6:                      PatternBrush = new HatchBrush(HatchStyle.HorizontalBrick' Color.Magenta' Color.White);                      break;                  case 7:                      PatternBrush = new HatchBrush(HatchStyle.LargeCheckerBoard' Color.Gold' Color.White); // was wave... but I didn't want to draw that in PDF - GJL                      break;                  case 8:                      PatternBrush = new HatchBrush(HatchStyle.Vertical' Color.Lime' Color.White);                      break;                  case 9:                      PatternBrush = new HatchBrush(HatchStyle.SolidDiamond' Color.Teal' Color.White);                      break;                  case 10:                      PatternBrush = new HatchBrush(HatchStyle.DiagonalBrick' Color.Pink' Color.White);                      break;                  default:                      PatternBrush = new HatchBrush(HatchStyle.BackwardDiagonal' Color.Blue' Color.White);                      break;                                   }
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPatterned,The following statement contains a magic number: switch (i % 10)              {                  case 0:                      PatternBrush = new HatchBrush(HatchStyle.LargeConfetti' Color.Blue'Color.White);                      break;                  case 1:                      PatternBrush = new HatchBrush(HatchStyle.Cross' Color.Red' Color.White); // was weave... but I Especially didn't want to draw that in PDF - GJL                      break;                  case 2:                      PatternBrush = new HatchBrush(HatchStyle.DarkDownwardDiagonal' Color.Green' Color.White);                      break;                  case 3:                      PatternBrush = new HatchBrush(HatchStyle.OutlinedDiamond' Color.Purple' Color.White);                      break;                  case 4:                      PatternBrush = new HatchBrush(HatchStyle.DarkHorizontal' Color.DeepSkyBlue' Color.White);                      break;                  case 5:                      PatternBrush = new HatchBrush(HatchStyle.SmallConfetti' Color.Orange' Color.White);                      break;                  case 6:                      PatternBrush = new HatchBrush(HatchStyle.HorizontalBrick' Color.Magenta' Color.White);                      break;                  case 7:                      PatternBrush = new HatchBrush(HatchStyle.LargeCheckerBoard' Color.Gold' Color.White); // was wave... but I didn't want to draw that in PDF - GJL                      break;                  case 8:                      PatternBrush = new HatchBrush(HatchStyle.Vertical' Color.Lime' Color.White);                      break;                  case 9:                      PatternBrush = new HatchBrush(HatchStyle.SolidDiamond' Color.Teal' Color.White);                      break;                  case 10:                      PatternBrush = new HatchBrush(HatchStyle.DiagonalBrick' Color.Pink' Color.White);                      break;                  default:                      PatternBrush = new HatchBrush(HatchStyle.BackwardDiagonal' Color.Blue' Color.White);                      break;                                   }
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPatterned,The following statement contains a magic number: switch (i % 10)              {                  case 0:                      PatternBrush = new HatchBrush(HatchStyle.LargeConfetti' Color.Blue'Color.White);                      break;                  case 1:                      PatternBrush = new HatchBrush(HatchStyle.Cross' Color.Red' Color.White); // was weave... but I Especially didn't want to draw that in PDF - GJL                      break;                  case 2:                      PatternBrush = new HatchBrush(HatchStyle.DarkDownwardDiagonal' Color.Green' Color.White);                      break;                  case 3:                      PatternBrush = new HatchBrush(HatchStyle.OutlinedDiamond' Color.Purple' Color.White);                      break;                  case 4:                      PatternBrush = new HatchBrush(HatchStyle.DarkHorizontal' Color.DeepSkyBlue' Color.White);                      break;                  case 5:                      PatternBrush = new HatchBrush(HatchStyle.SmallConfetti' Color.Orange' Color.White);                      break;                  case 6:                      PatternBrush = new HatchBrush(HatchStyle.HorizontalBrick' Color.Magenta' Color.White);                      break;                  case 7:                      PatternBrush = new HatchBrush(HatchStyle.LargeCheckerBoard' Color.Gold' Color.White); // was wave... but I didn't want to draw that in PDF - GJL                      break;                  case 8:                      PatternBrush = new HatchBrush(HatchStyle.Vertical' Color.Lime' Color.White);                      break;                  case 9:                      PatternBrush = new HatchBrush(HatchStyle.SolidDiamond' Color.Teal' Color.White);                      break;                  case 10:                      PatternBrush = new HatchBrush(HatchStyle.DiagonalBrick' Color.Pink' Color.White);                      break;                  default:                      PatternBrush = new HatchBrush(HatchStyle.BackwardDiagonal' Color.Blue' Color.White);                      break;                                   }
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPatternedBlack,The following statement contains a magic number: switch (i % 10)              {                  case 0:                      PatternBrush = new HatchBrush(HatchStyle.LargeConfetti' Color.Black' Color.White);                      break;                  case 1:                      PatternBrush = new HatchBrush(HatchStyle.Weave' Color.Black' Color.White);                      break;                  case 2:                      PatternBrush = new HatchBrush(HatchStyle.DarkDownwardDiagonal' Color.Black' Color.White);                      break;                  case 3:                      PatternBrush = new HatchBrush(HatchStyle.OutlinedDiamond' Color.Black' Color.White);                      break;                  case 4:                      PatternBrush = new HatchBrush(HatchStyle.DarkHorizontal' Color.Black' Color.White);                      break;                  case 5:                      PatternBrush = new HatchBrush(HatchStyle.SmallConfetti' Color.Black' Color.White);                      break;                  case 6:                      PatternBrush = new HatchBrush(HatchStyle.HorizontalBrick' Color.Black' Color.White);                      break;                  case 7:                      PatternBrush = new HatchBrush(HatchStyle.Wave' Color.Black' Color.White);                      break;                  case 8:                      PatternBrush = new HatchBrush(HatchStyle.Vertical' Color.Black' Color.White);                      break;                  case 9:                      PatternBrush = new HatchBrush(HatchStyle.SolidDiamond' Color.Black' Color.White);                      break;                  case 10:                      PatternBrush = new HatchBrush(HatchStyle.DiagonalBrick' Color.Black' Color.White);                      break;                  default:                      PatternBrush = new HatchBrush(HatchStyle.BackwardDiagonal' Color.Black' Color.White);                      break;    			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPatternedBlack,The following statement contains a magic number: switch (i % 10)              {                  case 0:                      PatternBrush = new HatchBrush(HatchStyle.LargeConfetti' Color.Black' Color.White);                      break;                  case 1:                      PatternBrush = new HatchBrush(HatchStyle.Weave' Color.Black' Color.White);                      break;                  case 2:                      PatternBrush = new HatchBrush(HatchStyle.DarkDownwardDiagonal' Color.Black' Color.White);                      break;                  case 3:                      PatternBrush = new HatchBrush(HatchStyle.OutlinedDiamond' Color.Black' Color.White);                      break;                  case 4:                      PatternBrush = new HatchBrush(HatchStyle.DarkHorizontal' Color.Black' Color.White);                      break;                  case 5:                      PatternBrush = new HatchBrush(HatchStyle.SmallConfetti' Color.Black' Color.White);                      break;                  case 6:                      PatternBrush = new HatchBrush(HatchStyle.HorizontalBrick' Color.Black' Color.White);                      break;                  case 7:                      PatternBrush = new HatchBrush(HatchStyle.Wave' Color.Black' Color.White);                      break;                  case 8:                      PatternBrush = new HatchBrush(HatchStyle.Vertical' Color.Black' Color.White);                      break;                  case 9:                      PatternBrush = new HatchBrush(HatchStyle.SolidDiamond' Color.Black' Color.White);                      break;                  case 10:                      PatternBrush = new HatchBrush(HatchStyle.DiagonalBrick' Color.Black' Color.White);                      break;                  default:                      PatternBrush = new HatchBrush(HatchStyle.BackwardDiagonal' Color.Black' Color.White);                      break;    			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPatternedBlack,The following statement contains a magic number: switch (i % 10)              {                  case 0:                      PatternBrush = new HatchBrush(HatchStyle.LargeConfetti' Color.Black' Color.White);                      break;                  case 1:                      PatternBrush = new HatchBrush(HatchStyle.Weave' Color.Black' Color.White);                      break;                  case 2:                      PatternBrush = new HatchBrush(HatchStyle.DarkDownwardDiagonal' Color.Black' Color.White);                      break;                  case 3:                      PatternBrush = new HatchBrush(HatchStyle.OutlinedDiamond' Color.Black' Color.White);                      break;                  case 4:                      PatternBrush = new HatchBrush(HatchStyle.DarkHorizontal' Color.Black' Color.White);                      break;                  case 5:                      PatternBrush = new HatchBrush(HatchStyle.SmallConfetti' Color.Black' Color.White);                      break;                  case 6:                      PatternBrush = new HatchBrush(HatchStyle.HorizontalBrick' Color.Black' Color.White);                      break;                  case 7:                      PatternBrush = new HatchBrush(HatchStyle.Wave' Color.Black' Color.White);                      break;                  case 8:                      PatternBrush = new HatchBrush(HatchStyle.Vertical' Color.Black' Color.White);                      break;                  case 9:                      PatternBrush = new HatchBrush(HatchStyle.SolidDiamond' Color.Black' Color.White);                      break;                  case 10:                      PatternBrush = new HatchBrush(HatchStyle.DiagonalBrick' Color.Black' Color.White);                      break;                  default:                      PatternBrush = new HatchBrush(HatchStyle.BackwardDiagonal' Color.Black' Color.White);                      break;    			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPatternedBlack,The following statement contains a magic number: switch (i % 10)              {                  case 0:                      PatternBrush = new HatchBrush(HatchStyle.LargeConfetti' Color.Black' Color.White);                      break;                  case 1:                      PatternBrush = new HatchBrush(HatchStyle.Weave' Color.Black' Color.White);                      break;                  case 2:                      PatternBrush = new HatchBrush(HatchStyle.DarkDownwardDiagonal' Color.Black' Color.White);                      break;                  case 3:                      PatternBrush = new HatchBrush(HatchStyle.OutlinedDiamond' Color.Black' Color.White);                      break;                  case 4:                      PatternBrush = new HatchBrush(HatchStyle.DarkHorizontal' Color.Black' Color.White);                      break;                  case 5:                      PatternBrush = new HatchBrush(HatchStyle.SmallConfetti' Color.Black' Color.White);                      break;                  case 6:                      PatternBrush = new HatchBrush(HatchStyle.HorizontalBrick' Color.Black' Color.White);                      break;                  case 7:                      PatternBrush = new HatchBrush(HatchStyle.Wave' Color.Black' Color.White);                      break;                  case 8:                      PatternBrush = new HatchBrush(HatchStyle.Vertical' Color.Black' Color.White);                      break;                  case 9:                      PatternBrush = new HatchBrush(HatchStyle.SolidDiamond' Color.Black' Color.White);                      break;                  case 10:                      PatternBrush = new HatchBrush(HatchStyle.DiagonalBrick' Color.Black' Color.White);                      break;                  default:                      PatternBrush = new HatchBrush(HatchStyle.BackwardDiagonal' Color.Black' Color.White);                      break;    			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPatternedBlack,The following statement contains a magic number: switch (i % 10)              {                  case 0:                      PatternBrush = new HatchBrush(HatchStyle.LargeConfetti' Color.Black' Color.White);                      break;                  case 1:                      PatternBrush = new HatchBrush(HatchStyle.Weave' Color.Black' Color.White);                      break;                  case 2:                      PatternBrush = new HatchBrush(HatchStyle.DarkDownwardDiagonal' Color.Black' Color.White);                      break;                  case 3:                      PatternBrush = new HatchBrush(HatchStyle.OutlinedDiamond' Color.Black' Color.White);                      break;                  case 4:                      PatternBrush = new HatchBrush(HatchStyle.DarkHorizontal' Color.Black' Color.White);                      break;                  case 5:                      PatternBrush = new HatchBrush(HatchStyle.SmallConfetti' Color.Black' Color.White);                      break;                  case 6:                      PatternBrush = new HatchBrush(HatchStyle.HorizontalBrick' Color.Black' Color.White);                      break;                  case 7:                      PatternBrush = new HatchBrush(HatchStyle.Wave' Color.Black' Color.White);                      break;                  case 8:                      PatternBrush = new HatchBrush(HatchStyle.Vertical' Color.Black' Color.White);                      break;                  case 9:                      PatternBrush = new HatchBrush(HatchStyle.SolidDiamond' Color.Black' Color.White);                      break;                  case 10:                      PatternBrush = new HatchBrush(HatchStyle.DiagonalBrick' Color.Black' Color.White);                      break;                  default:                      PatternBrush = new HatchBrush(HatchStyle.BackwardDiagonal' Color.Black' Color.White);                      break;    			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPatternedBlack,The following statement contains a magic number: switch (i % 10)              {                  case 0:                      PatternBrush = new HatchBrush(HatchStyle.LargeConfetti' Color.Black' Color.White);                      break;                  case 1:                      PatternBrush = new HatchBrush(HatchStyle.Weave' Color.Black' Color.White);                      break;                  case 2:                      PatternBrush = new HatchBrush(HatchStyle.DarkDownwardDiagonal' Color.Black' Color.White);                      break;                  case 3:                      PatternBrush = new HatchBrush(HatchStyle.OutlinedDiamond' Color.Black' Color.White);                      break;                  case 4:                      PatternBrush = new HatchBrush(HatchStyle.DarkHorizontal' Color.Black' Color.White);                      break;                  case 5:                      PatternBrush = new HatchBrush(HatchStyle.SmallConfetti' Color.Black' Color.White);                      break;                  case 6:                      PatternBrush = new HatchBrush(HatchStyle.HorizontalBrick' Color.Black' Color.White);                      break;                  case 7:                      PatternBrush = new HatchBrush(HatchStyle.Wave' Color.Black' Color.White);                      break;                  case 8:                      PatternBrush = new HatchBrush(HatchStyle.Vertical' Color.Black' Color.White);                      break;                  case 9:                      PatternBrush = new HatchBrush(HatchStyle.SolidDiamond' Color.Black' Color.White);                      break;                  case 10:                      PatternBrush = new HatchBrush(HatchStyle.DiagonalBrick' Color.Black' Color.White);                      break;                  default:                      PatternBrush = new HatchBrush(HatchStyle.BackwardDiagonal' Color.Black' Color.White);                      break;    			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPatternedBlack,The following statement contains a magic number: switch (i % 10)              {                  case 0:                      PatternBrush = new HatchBrush(HatchStyle.LargeConfetti' Color.Black' Color.White);                      break;                  case 1:                      PatternBrush = new HatchBrush(HatchStyle.Weave' Color.Black' Color.White);                      break;                  case 2:                      PatternBrush = new HatchBrush(HatchStyle.DarkDownwardDiagonal' Color.Black' Color.White);                      break;                  case 3:                      PatternBrush = new HatchBrush(HatchStyle.OutlinedDiamond' Color.Black' Color.White);                      break;                  case 4:                      PatternBrush = new HatchBrush(HatchStyle.DarkHorizontal' Color.Black' Color.White);                      break;                  case 5:                      PatternBrush = new HatchBrush(HatchStyle.SmallConfetti' Color.Black' Color.White);                      break;                  case 6:                      PatternBrush = new HatchBrush(HatchStyle.HorizontalBrick' Color.Black' Color.White);                      break;                  case 7:                      PatternBrush = new HatchBrush(HatchStyle.Wave' Color.Black' Color.White);                      break;                  case 8:                      PatternBrush = new HatchBrush(HatchStyle.Vertical' Color.Black' Color.White);                      break;                  case 9:                      PatternBrush = new HatchBrush(HatchStyle.SolidDiamond' Color.Black' Color.White);                      break;                  case 10:                      PatternBrush = new HatchBrush(HatchStyle.DiagonalBrick' Color.Black' Color.White);                      break;                  default:                      PatternBrush = new HatchBrush(HatchStyle.BackwardDiagonal' Color.Black' Color.White);                      break;    			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPatternedBlack,The following statement contains a magic number: switch (i % 10)              {                  case 0:                      PatternBrush = new HatchBrush(HatchStyle.LargeConfetti' Color.Black' Color.White);                      break;                  case 1:                      PatternBrush = new HatchBrush(HatchStyle.Weave' Color.Black' Color.White);                      break;                  case 2:                      PatternBrush = new HatchBrush(HatchStyle.DarkDownwardDiagonal' Color.Black' Color.White);                      break;                  case 3:                      PatternBrush = new HatchBrush(HatchStyle.OutlinedDiamond' Color.Black' Color.White);                      break;                  case 4:                      PatternBrush = new HatchBrush(HatchStyle.DarkHorizontal' Color.Black' Color.White);                      break;                  case 5:                      PatternBrush = new HatchBrush(HatchStyle.SmallConfetti' Color.Black' Color.White);                      break;                  case 6:                      PatternBrush = new HatchBrush(HatchStyle.HorizontalBrick' Color.Black' Color.White);                      break;                  case 7:                      PatternBrush = new HatchBrush(HatchStyle.Wave' Color.Black' Color.White);                      break;                  case 8:                      PatternBrush = new HatchBrush(HatchStyle.Vertical' Color.Black' Color.White);                      break;                  case 9:                      PatternBrush = new HatchBrush(HatchStyle.SolidDiamond' Color.Black' Color.White);                      break;                  case 10:                      PatternBrush = new HatchBrush(HatchStyle.DiagonalBrick' Color.Black' Color.White);                      break;                  default:                      PatternBrush = new HatchBrush(HatchStyle.BackwardDiagonal' Color.Black' Color.White);                      break;    			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPatternedBlack,The following statement contains a magic number: switch (i % 10)              {                  case 0:                      PatternBrush = new HatchBrush(HatchStyle.LargeConfetti' Color.Black' Color.White);                      break;                  case 1:                      PatternBrush = new HatchBrush(HatchStyle.Weave' Color.Black' Color.White);                      break;                  case 2:                      PatternBrush = new HatchBrush(HatchStyle.DarkDownwardDiagonal' Color.Black' Color.White);                      break;                  case 3:                      PatternBrush = new HatchBrush(HatchStyle.OutlinedDiamond' Color.Black' Color.White);                      break;                  case 4:                      PatternBrush = new HatchBrush(HatchStyle.DarkHorizontal' Color.Black' Color.White);                      break;                  case 5:                      PatternBrush = new HatchBrush(HatchStyle.SmallConfetti' Color.Black' Color.White);                      break;                  case 6:                      PatternBrush = new HatchBrush(HatchStyle.HorizontalBrick' Color.Black' Color.White);                      break;                  case 7:                      PatternBrush = new HatchBrush(HatchStyle.Wave' Color.Black' Color.White);                      break;                  case 8:                      PatternBrush = new HatchBrush(HatchStyle.Vertical' Color.Black' Color.White);                      break;                  case 9:                      PatternBrush = new HatchBrush(HatchStyle.SolidDiamond' Color.Black' Color.White);                      break;                  case 10:                      PatternBrush = new HatchBrush(HatchStyle.DiagonalBrick' Color.Black' Color.White);                      break;                  default:                      PatternBrush = new HatchBrush(HatchStyle.BackwardDiagonal' Color.Black' Color.White);                      break;    			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPatternedBlack,The following statement contains a magic number: switch (i % 10)              {                  case 0:                      PatternBrush = new HatchBrush(HatchStyle.LargeConfetti' Color.Black' Color.White);                      break;                  case 1:                      PatternBrush = new HatchBrush(HatchStyle.Weave' Color.Black' Color.White);                      break;                  case 2:                      PatternBrush = new HatchBrush(HatchStyle.DarkDownwardDiagonal' Color.Black' Color.White);                      break;                  case 3:                      PatternBrush = new HatchBrush(HatchStyle.OutlinedDiamond' Color.Black' Color.White);                      break;                  case 4:                      PatternBrush = new HatchBrush(HatchStyle.DarkHorizontal' Color.Black' Color.White);                      break;                  case 5:                      PatternBrush = new HatchBrush(HatchStyle.SmallConfetti' Color.Black' Color.White);                      break;                  case 6:                      PatternBrush = new HatchBrush(HatchStyle.HorizontalBrick' Color.Black' Color.White);                      break;                  case 7:                      PatternBrush = new HatchBrush(HatchStyle.Wave' Color.Black' Color.White);                      break;                  case 8:                      PatternBrush = new HatchBrush(HatchStyle.Vertical' Color.Black' Color.White);                      break;                  case 9:                      PatternBrush = new HatchBrush(HatchStyle.SolidDiamond' Color.Black' Color.White);                      break;                  case 10:                      PatternBrush = new HatchBrush(HatchStyle.DiagonalBrick' Color.Black' Color.White);                      break;                  default:                      PatternBrush = new HatchBrush(HatchStyle.BackwardDiagonal' Color.Black' Color.White);                      break;    			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesGrayScale,The following statement contains a magic number: switch (i % 10)			  			{  				case 0: return Brushes.Gray;  				case 1: return Brushes.SlateGray;  				case 2: return Brushes.DarkGray;  				case 3: return Brushes.LightGray;  				case 4: return Brushes.DarkSlateGray;  				case 5: return Brushes.DimGray;  				case 6: return Brushes.LightSlateGray;  				case 7: return Brushes.Black;  				case 8: return Brushes.White;  				case 9: return Brushes.Gainsboro;  				default: return Brushes.Gray;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesGrayScale,The following statement contains a magic number: switch (i % 10)			  			{  				case 0: return Brushes.Gray;  				case 1: return Brushes.SlateGray;  				case 2: return Brushes.DarkGray;  				case 3: return Brushes.LightGray;  				case 4: return Brushes.DarkSlateGray;  				case 5: return Brushes.DimGray;  				case 6: return Brushes.LightSlateGray;  				case 7: return Brushes.Black;  				case 8: return Brushes.White;  				case 9: return Brushes.Gainsboro;  				default: return Brushes.Gray;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesGrayScale,The following statement contains a magic number: switch (i % 10)			  			{  				case 0: return Brushes.Gray;  				case 1: return Brushes.SlateGray;  				case 2: return Brushes.DarkGray;  				case 3: return Brushes.LightGray;  				case 4: return Brushes.DarkSlateGray;  				case 5: return Brushes.DimGray;  				case 6: return Brushes.LightSlateGray;  				case 7: return Brushes.Black;  				case 8: return Brushes.White;  				case 9: return Brushes.Gainsboro;  				default: return Brushes.Gray;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesGrayScale,The following statement contains a magic number: switch (i % 10)			  			{  				case 0: return Brushes.Gray;  				case 1: return Brushes.SlateGray;  				case 2: return Brushes.DarkGray;  				case 3: return Brushes.LightGray;  				case 4: return Brushes.DarkSlateGray;  				case 5: return Brushes.DimGray;  				case 6: return Brushes.LightSlateGray;  				case 7: return Brushes.Black;  				case 8: return Brushes.White;  				case 9: return Brushes.Gainsboro;  				default: return Brushes.Gray;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesGrayScale,The following statement contains a magic number: switch (i % 10)			  			{  				case 0: return Brushes.Gray;  				case 1: return Brushes.SlateGray;  				case 2: return Brushes.DarkGray;  				case 3: return Brushes.LightGray;  				case 4: return Brushes.DarkSlateGray;  				case 5: return Brushes.DimGray;  				case 6: return Brushes.LightSlateGray;  				case 7: return Brushes.Black;  				case 8: return Brushes.White;  				case 9: return Brushes.Gainsboro;  				default: return Brushes.Gray;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesGrayScale,The following statement contains a magic number: switch (i % 10)			  			{  				case 0: return Brushes.Gray;  				case 1: return Brushes.SlateGray;  				case 2: return Brushes.DarkGray;  				case 3: return Brushes.LightGray;  				case 4: return Brushes.DarkSlateGray;  				case 5: return Brushes.DimGray;  				case 6: return Brushes.LightSlateGray;  				case 7: return Brushes.Black;  				case 8: return Brushes.White;  				case 9: return Brushes.Gainsboro;  				default: return Brushes.Gray;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesGrayScale,The following statement contains a magic number: switch (i % 10)			  			{  				case 0: return Brushes.Gray;  				case 1: return Brushes.SlateGray;  				case 2: return Brushes.DarkGray;  				case 3: return Brushes.LightGray;  				case 4: return Brushes.DarkSlateGray;  				case 5: return Brushes.DimGray;  				case 6: return Brushes.LightSlateGray;  				case 7: return Brushes.Black;  				case 8: return Brushes.White;  				case 9: return Brushes.Gainsboro;  				default: return Brushes.Gray;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesGrayScale,The following statement contains a magic number: switch (i % 10)			  			{  				case 0: return Brushes.Gray;  				case 1: return Brushes.SlateGray;  				case 2: return Brushes.DarkGray;  				case 3: return Brushes.LightGray;  				case 4: return Brushes.DarkSlateGray;  				case 5: return Brushes.DimGray;  				case 6: return Brushes.LightSlateGray;  				case 7: return Brushes.Black;  				case 8: return Brushes.White;  				case 9: return Brushes.Gainsboro;  				default: return Brushes.Gray;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesGrayScale,The following statement contains a magic number: switch (i % 10)			  			{  				case 0: return Brushes.Gray;  				case 1: return Brushes.SlateGray;  				case 2: return Brushes.DarkGray;  				case 3: return Brushes.LightGray;  				case 4: return Brushes.DarkSlateGray;  				case 5: return Brushes.DimGray;  				case 6: return Brushes.LightSlateGray;  				case 7: return Brushes.Black;  				case 8: return Brushes.White;  				case 9: return Brushes.Gainsboro;  				default: return Brushes.Gray;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesLight,The following statement contains a magic number: switch (i % 13)  			{  				case 0: return Brushes.LightBlue;  				case 1: return Brushes.LightCoral;  				case 2: return Brushes.LightCyan;  				case 3: return Brushes.LightGoldenrodYellow;  				case 4: return Brushes.LightGray;  				case 5: return Brushes.LightGreen;  				case 6: return Brushes.LightPink;  				case 7: return Brushes.LightSalmon;  				case 8: return Brushes.LightSeaGreen;  				case 9: return Brushes.LightSkyBlue;  				case 10: return Brushes.LightSlateGray;  				case 11: return Brushes.LightSteelBlue;  				case 12: return Brushes.LightYellow;  				default: return Brushes.LightBlue;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesLight,The following statement contains a magic number: switch (i % 13)  			{  				case 0: return Brushes.LightBlue;  				case 1: return Brushes.LightCoral;  				case 2: return Brushes.LightCyan;  				case 3: return Brushes.LightGoldenrodYellow;  				case 4: return Brushes.LightGray;  				case 5: return Brushes.LightGreen;  				case 6: return Brushes.LightPink;  				case 7: return Brushes.LightSalmon;  				case 8: return Brushes.LightSeaGreen;  				case 9: return Brushes.LightSkyBlue;  				case 10: return Brushes.LightSlateGray;  				case 11: return Brushes.LightSteelBlue;  				case 12: return Brushes.LightYellow;  				default: return Brushes.LightBlue;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesLight,The following statement contains a magic number: switch (i % 13)  			{  				case 0: return Brushes.LightBlue;  				case 1: return Brushes.LightCoral;  				case 2: return Brushes.LightCyan;  				case 3: return Brushes.LightGoldenrodYellow;  				case 4: return Brushes.LightGray;  				case 5: return Brushes.LightGreen;  				case 6: return Brushes.LightPink;  				case 7: return Brushes.LightSalmon;  				case 8: return Brushes.LightSeaGreen;  				case 9: return Brushes.LightSkyBlue;  				case 10: return Brushes.LightSlateGray;  				case 11: return Brushes.LightSteelBlue;  				case 12: return Brushes.LightYellow;  				default: return Brushes.LightBlue;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesLight,The following statement contains a magic number: switch (i % 13)  			{  				case 0: return Brushes.LightBlue;  				case 1: return Brushes.LightCoral;  				case 2: return Brushes.LightCyan;  				case 3: return Brushes.LightGoldenrodYellow;  				case 4: return Brushes.LightGray;  				case 5: return Brushes.LightGreen;  				case 6: return Brushes.LightPink;  				case 7: return Brushes.LightSalmon;  				case 8: return Brushes.LightSeaGreen;  				case 9: return Brushes.LightSkyBlue;  				case 10: return Brushes.LightSlateGray;  				case 11: return Brushes.LightSteelBlue;  				case 12: return Brushes.LightYellow;  				default: return Brushes.LightBlue;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesLight,The following statement contains a magic number: switch (i % 13)  			{  				case 0: return Brushes.LightBlue;  				case 1: return Brushes.LightCoral;  				case 2: return Brushes.LightCyan;  				case 3: return Brushes.LightGoldenrodYellow;  				case 4: return Brushes.LightGray;  				case 5: return Brushes.LightGreen;  				case 6: return Brushes.LightPink;  				case 7: return Brushes.LightSalmon;  				case 8: return Brushes.LightSeaGreen;  				case 9: return Brushes.LightSkyBlue;  				case 10: return Brushes.LightSlateGray;  				case 11: return Brushes.LightSteelBlue;  				case 12: return Brushes.LightYellow;  				default: return Brushes.LightBlue;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesLight,The following statement contains a magic number: switch (i % 13)  			{  				case 0: return Brushes.LightBlue;  				case 1: return Brushes.LightCoral;  				case 2: return Brushes.LightCyan;  				case 3: return Brushes.LightGoldenrodYellow;  				case 4: return Brushes.LightGray;  				case 5: return Brushes.LightGreen;  				case 6: return Brushes.LightPink;  				case 7: return Brushes.LightSalmon;  				case 8: return Brushes.LightSeaGreen;  				case 9: return Brushes.LightSkyBlue;  				case 10: return Brushes.LightSlateGray;  				case 11: return Brushes.LightSteelBlue;  				case 12: return Brushes.LightYellow;  				default: return Brushes.LightBlue;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesLight,The following statement contains a magic number: switch (i % 13)  			{  				case 0: return Brushes.LightBlue;  				case 1: return Brushes.LightCoral;  				case 2: return Brushes.LightCyan;  				case 3: return Brushes.LightGoldenrodYellow;  				case 4: return Brushes.LightGray;  				case 5: return Brushes.LightGreen;  				case 6: return Brushes.LightPink;  				case 7: return Brushes.LightSalmon;  				case 8: return Brushes.LightSeaGreen;  				case 9: return Brushes.LightSkyBlue;  				case 10: return Brushes.LightSlateGray;  				case 11: return Brushes.LightSteelBlue;  				case 12: return Brushes.LightYellow;  				default: return Brushes.LightBlue;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesLight,The following statement contains a magic number: switch (i % 13)  			{  				case 0: return Brushes.LightBlue;  				case 1: return Brushes.LightCoral;  				case 2: return Brushes.LightCyan;  				case 3: return Brushes.LightGoldenrodYellow;  				case 4: return Brushes.LightGray;  				case 5: return Brushes.LightGreen;  				case 6: return Brushes.LightPink;  				case 7: return Brushes.LightSalmon;  				case 8: return Brushes.LightSeaGreen;  				case 9: return Brushes.LightSkyBlue;  				case 10: return Brushes.LightSlateGray;  				case 11: return Brushes.LightSteelBlue;  				case 12: return Brushes.LightYellow;  				default: return Brushes.LightBlue;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesLight,The following statement contains a magic number: switch (i % 13)  			{  				case 0: return Brushes.LightBlue;  				case 1: return Brushes.LightCoral;  				case 2: return Brushes.LightCyan;  				case 3: return Brushes.LightGoldenrodYellow;  				case 4: return Brushes.LightGray;  				case 5: return Brushes.LightGreen;  				case 6: return Brushes.LightPink;  				case 7: return Brushes.LightSalmon;  				case 8: return Brushes.LightSeaGreen;  				case 9: return Brushes.LightSkyBlue;  				case 10: return Brushes.LightSlateGray;  				case 11: return Brushes.LightSteelBlue;  				case 12: return Brushes.LightYellow;  				default: return Brushes.LightBlue;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesLight,The following statement contains a magic number: switch (i % 13)  			{  				case 0: return Brushes.LightBlue;  				case 1: return Brushes.LightCoral;  				case 2: return Brushes.LightCyan;  				case 3: return Brushes.LightGoldenrodYellow;  				case 4: return Brushes.LightGray;  				case 5: return Brushes.LightGreen;  				case 6: return Brushes.LightPink;  				case 7: return Brushes.LightSalmon;  				case 8: return Brushes.LightSeaGreen;  				case 9: return Brushes.LightSkyBlue;  				case 10: return Brushes.LightSlateGray;  				case 11: return Brushes.LightSteelBlue;  				case 12: return Brushes.LightYellow;  				default: return Brushes.LightBlue;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesLight,The following statement contains a magic number: switch (i % 13)  			{  				case 0: return Brushes.LightBlue;  				case 1: return Brushes.LightCoral;  				case 2: return Brushes.LightCyan;  				case 3: return Brushes.LightGoldenrodYellow;  				case 4: return Brushes.LightGray;  				case 5: return Brushes.LightGreen;  				case 6: return Brushes.LightPink;  				case 7: return Brushes.LightSalmon;  				case 8: return Brushes.LightSeaGreen;  				case 9: return Brushes.LightSkyBlue;  				case 10: return Brushes.LightSlateGray;  				case 11: return Brushes.LightSteelBlue;  				case 12: return Brushes.LightYellow;  				default: return Brushes.LightBlue;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesLight,The following statement contains a magic number: switch (i % 13)  			{  				case 0: return Brushes.LightBlue;  				case 1: return Brushes.LightCoral;  				case 2: return Brushes.LightCyan;  				case 3: return Brushes.LightGoldenrodYellow;  				case 4: return Brushes.LightGray;  				case 5: return Brushes.LightGreen;  				case 6: return Brushes.LightPink;  				case 7: return Brushes.LightSalmon;  				case 8: return Brushes.LightSeaGreen;  				case 9: return Brushes.LightSkyBlue;  				case 10: return Brushes.LightSlateGray;  				case 11: return Brushes.LightSteelBlue;  				case 12: return Brushes.LightYellow;  				default: return Brushes.LightBlue;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPastel,The following statement contains a magic number: switch (i % 26)	  			{  				case 0: return Brushes.CadetBlue;  				case 1: return Brushes.MediumTurquoise;  				case 2: return Brushes.Aquamarine;  				case 3: return Brushes.LightCyan;  				case 4: return Brushes.Azure;  				case 5: return Brushes.AliceBlue;  				case 6: return Brushes.MintCream;  				case 7: return Brushes.DarkSeaGreen;  				case 8: return Brushes.PaleGreen;  				case 9: return Brushes.LightGreen;  				case 10: return Brushes.MediumPurple;  				case 11: return Brushes.CornflowerBlue;  				case 12: return Brushes.Lavender;  				case 13: return Brushes.GhostWhite;  				case 14: return Brushes.PaleGoldenrod;  				case 15: return Brushes.LightGoldenrodYellow;  				case 16: return Brushes.LemonChiffon;  				case 17: return Brushes.LightYellow;  				case 18: return Brushes.Orchid;  				case 19: return Brushes.Plum;  				case 20: return Brushes.LightPink;  				case 21: return Brushes.Pink;  				case 22: return Brushes.LavenderBlush;  				case 23: return Brushes.Linen;  				case 24: return Brushes.PaleTurquoise;  				case 25: return Brushes.OldLace;  				default: return Brushes.CadetBlue;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPastel,The following statement contains a magic number: switch (i % 26)	  			{  				case 0: return Brushes.CadetBlue;  				case 1: return Brushes.MediumTurquoise;  				case 2: return Brushes.Aquamarine;  				case 3: return Brushes.LightCyan;  				case 4: return Brushes.Azure;  				case 5: return Brushes.AliceBlue;  				case 6: return Brushes.MintCream;  				case 7: return Brushes.DarkSeaGreen;  				case 8: return Brushes.PaleGreen;  				case 9: return Brushes.LightGreen;  				case 10: return Brushes.MediumPurple;  				case 11: return Brushes.CornflowerBlue;  				case 12: return Brushes.Lavender;  				case 13: return Brushes.GhostWhite;  				case 14: return Brushes.PaleGoldenrod;  				case 15: return Brushes.LightGoldenrodYellow;  				case 16: return Brushes.LemonChiffon;  				case 17: return Brushes.LightYellow;  				case 18: return Brushes.Orchid;  				case 19: return Brushes.Plum;  				case 20: return Brushes.LightPink;  				case 21: return Brushes.Pink;  				case 22: return Brushes.LavenderBlush;  				case 23: return Brushes.Linen;  				case 24: return Brushes.PaleTurquoise;  				case 25: return Brushes.OldLace;  				default: return Brushes.CadetBlue;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPastel,The following statement contains a magic number: switch (i % 26)	  			{  				case 0: return Brushes.CadetBlue;  				case 1: return Brushes.MediumTurquoise;  				case 2: return Brushes.Aquamarine;  				case 3: return Brushes.LightCyan;  				case 4: return Brushes.Azure;  				case 5: return Brushes.AliceBlue;  				case 6: return Brushes.MintCream;  				case 7: return Brushes.DarkSeaGreen;  				case 8: return Brushes.PaleGreen;  				case 9: return Brushes.LightGreen;  				case 10: return Brushes.MediumPurple;  				case 11: return Brushes.CornflowerBlue;  				case 12: return Brushes.Lavender;  				case 13: return Brushes.GhostWhite;  				case 14: return Brushes.PaleGoldenrod;  				case 15: return Brushes.LightGoldenrodYellow;  				case 16: return Brushes.LemonChiffon;  				case 17: return Brushes.LightYellow;  				case 18: return Brushes.Orchid;  				case 19: return Brushes.Plum;  				case 20: return Brushes.LightPink;  				case 21: return Brushes.Pink;  				case 22: return Brushes.LavenderBlush;  				case 23: return Brushes.Linen;  				case 24: return Brushes.PaleTurquoise;  				case 25: return Brushes.OldLace;  				default: return Brushes.CadetBlue;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPastel,The following statement contains a magic number: switch (i % 26)	  			{  				case 0: return Brushes.CadetBlue;  				case 1: return Brushes.MediumTurquoise;  				case 2: return Brushes.Aquamarine;  				case 3: return Brushes.LightCyan;  				case 4: return Brushes.Azure;  				case 5: return Brushes.AliceBlue;  				case 6: return Brushes.MintCream;  				case 7: return Brushes.DarkSeaGreen;  				case 8: return Brushes.PaleGreen;  				case 9: return Brushes.LightGreen;  				case 10: return Brushes.MediumPurple;  				case 11: return Brushes.CornflowerBlue;  				case 12: return Brushes.Lavender;  				case 13: return Brushes.GhostWhite;  				case 14: return Brushes.PaleGoldenrod;  				case 15: return Brushes.LightGoldenrodYellow;  				case 16: return Brushes.LemonChiffon;  				case 17: return Brushes.LightYellow;  				case 18: return Brushes.Orchid;  				case 19: return Brushes.Plum;  				case 20: return Brushes.LightPink;  				case 21: return Brushes.Pink;  				case 22: return Brushes.LavenderBlush;  				case 23: return Brushes.Linen;  				case 24: return Brushes.PaleTurquoise;  				case 25: return Brushes.OldLace;  				default: return Brushes.CadetBlue;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPastel,The following statement contains a magic number: switch (i % 26)	  			{  				case 0: return Brushes.CadetBlue;  				case 1: return Brushes.MediumTurquoise;  				case 2: return Brushes.Aquamarine;  				case 3: return Brushes.LightCyan;  				case 4: return Brushes.Azure;  				case 5: return Brushes.AliceBlue;  				case 6: return Brushes.MintCream;  				case 7: return Brushes.DarkSeaGreen;  				case 8: return Brushes.PaleGreen;  				case 9: return Brushes.LightGreen;  				case 10: return Brushes.MediumPurple;  				case 11: return Brushes.CornflowerBlue;  				case 12: return Brushes.Lavender;  				case 13: return Brushes.GhostWhite;  				case 14: return Brushes.PaleGoldenrod;  				case 15: return Brushes.LightGoldenrodYellow;  				case 16: return Brushes.LemonChiffon;  				case 17: return Brushes.LightYellow;  				case 18: return Brushes.Orchid;  				case 19: return Brushes.Plum;  				case 20: return Brushes.LightPink;  				case 21: return Brushes.Pink;  				case 22: return Brushes.LavenderBlush;  				case 23: return Brushes.Linen;  				case 24: return Brushes.PaleTurquoise;  				case 25: return Brushes.OldLace;  				default: return Brushes.CadetBlue;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPastel,The following statement contains a magic number: switch (i % 26)	  			{  				case 0: return Brushes.CadetBlue;  				case 1: return Brushes.MediumTurquoise;  				case 2: return Brushes.Aquamarine;  				case 3: return Brushes.LightCyan;  				case 4: return Brushes.Azure;  				case 5: return Brushes.AliceBlue;  				case 6: return Brushes.MintCream;  				case 7: return Brushes.DarkSeaGreen;  				case 8: return Brushes.PaleGreen;  				case 9: return Brushes.LightGreen;  				case 10: return Brushes.MediumPurple;  				case 11: return Brushes.CornflowerBlue;  				case 12: return Brushes.Lavender;  				case 13: return Brushes.GhostWhite;  				case 14: return Brushes.PaleGoldenrod;  				case 15: return Brushes.LightGoldenrodYellow;  				case 16: return Brushes.LemonChiffon;  				case 17: return Brushes.LightYellow;  				case 18: return Brushes.Orchid;  				case 19: return Brushes.Plum;  				case 20: return Brushes.LightPink;  				case 21: return Brushes.Pink;  				case 22: return Brushes.LavenderBlush;  				case 23: return Brushes.Linen;  				case 24: return Brushes.PaleTurquoise;  				case 25: return Brushes.OldLace;  				default: return Brushes.CadetBlue;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPastel,The following statement contains a magic number: switch (i % 26)	  			{  				case 0: return Brushes.CadetBlue;  				case 1: return Brushes.MediumTurquoise;  				case 2: return Brushes.Aquamarine;  				case 3: return Brushes.LightCyan;  				case 4: return Brushes.Azure;  				case 5: return Brushes.AliceBlue;  				case 6: return Brushes.MintCream;  				case 7: return Brushes.DarkSeaGreen;  				case 8: return Brushes.PaleGreen;  				case 9: return Brushes.LightGreen;  				case 10: return Brushes.MediumPurple;  				case 11: return Brushes.CornflowerBlue;  				case 12: return Brushes.Lavender;  				case 13: return Brushes.GhostWhite;  				case 14: return Brushes.PaleGoldenrod;  				case 15: return Brushes.LightGoldenrodYellow;  				case 16: return Brushes.LemonChiffon;  				case 17: return Brushes.LightYellow;  				case 18: return Brushes.Orchid;  				case 19: return Brushes.Plum;  				case 20: return Brushes.LightPink;  				case 21: return Brushes.Pink;  				case 22: return Brushes.LavenderBlush;  				case 23: return Brushes.Linen;  				case 24: return Brushes.PaleTurquoise;  				case 25: return Brushes.OldLace;  				default: return Brushes.CadetBlue;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPastel,The following statement contains a magic number: switch (i % 26)	  			{  				case 0: return Brushes.CadetBlue;  				case 1: return Brushes.MediumTurquoise;  				case 2: return Brushes.Aquamarine;  				case 3: return Brushes.LightCyan;  				case 4: return Brushes.Azure;  				case 5: return Brushes.AliceBlue;  				case 6: return Brushes.MintCream;  				case 7: return Brushes.DarkSeaGreen;  				case 8: return Brushes.PaleGreen;  				case 9: return Brushes.LightGreen;  				case 10: return Brushes.MediumPurple;  				case 11: return Brushes.CornflowerBlue;  				case 12: return Brushes.Lavender;  				case 13: return Brushes.GhostWhite;  				case 14: return Brushes.PaleGoldenrod;  				case 15: return Brushes.LightGoldenrodYellow;  				case 16: return Brushes.LemonChiffon;  				case 17: return Brushes.LightYellow;  				case 18: return Brushes.Orchid;  				case 19: return Brushes.Plum;  				case 20: return Brushes.LightPink;  				case 21: return Brushes.Pink;  				case 22: return Brushes.LavenderBlush;  				case 23: return Brushes.Linen;  				case 24: return Brushes.PaleTurquoise;  				case 25: return Brushes.OldLace;  				default: return Brushes.CadetBlue;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPastel,The following statement contains a magic number: switch (i % 26)	  			{  				case 0: return Brushes.CadetBlue;  				case 1: return Brushes.MediumTurquoise;  				case 2: return Brushes.Aquamarine;  				case 3: return Brushes.LightCyan;  				case 4: return Brushes.Azure;  				case 5: return Brushes.AliceBlue;  				case 6: return Brushes.MintCream;  				case 7: return Brushes.DarkSeaGreen;  				case 8: return Brushes.PaleGreen;  				case 9: return Brushes.LightGreen;  				case 10: return Brushes.MediumPurple;  				case 11: return Brushes.CornflowerBlue;  				case 12: return Brushes.Lavender;  				case 13: return Brushes.GhostWhite;  				case 14: return Brushes.PaleGoldenrod;  				case 15: return Brushes.LightGoldenrodYellow;  				case 16: return Brushes.LemonChiffon;  				case 17: return Brushes.LightYellow;  				case 18: return Brushes.Orchid;  				case 19: return Brushes.Plum;  				case 20: return Brushes.LightPink;  				case 21: return Brushes.Pink;  				case 22: return Brushes.LavenderBlush;  				case 23: return Brushes.Linen;  				case 24: return Brushes.PaleTurquoise;  				case 25: return Brushes.OldLace;  				default: return Brushes.CadetBlue;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPastel,The following statement contains a magic number: switch (i % 26)	  			{  				case 0: return Brushes.CadetBlue;  				case 1: return Brushes.MediumTurquoise;  				case 2: return Brushes.Aquamarine;  				case 3: return Brushes.LightCyan;  				case 4: return Brushes.Azure;  				case 5: return Brushes.AliceBlue;  				case 6: return Brushes.MintCream;  				case 7: return Brushes.DarkSeaGreen;  				case 8: return Brushes.PaleGreen;  				case 9: return Brushes.LightGreen;  				case 10: return Brushes.MediumPurple;  				case 11: return Brushes.CornflowerBlue;  				case 12: return Brushes.Lavender;  				case 13: return Brushes.GhostWhite;  				case 14: return Brushes.PaleGoldenrod;  				case 15: return Brushes.LightGoldenrodYellow;  				case 16: return Brushes.LemonChiffon;  				case 17: return Brushes.LightYellow;  				case 18: return Brushes.Orchid;  				case 19: return Brushes.Plum;  				case 20: return Brushes.LightPink;  				case 21: return Brushes.Pink;  				case 22: return Brushes.LavenderBlush;  				case 23: return Brushes.Linen;  				case 24: return Brushes.PaleTurquoise;  				case 25: return Brushes.OldLace;  				default: return Brushes.CadetBlue;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPastel,The following statement contains a magic number: switch (i % 26)	  			{  				case 0: return Brushes.CadetBlue;  				case 1: return Brushes.MediumTurquoise;  				case 2: return Brushes.Aquamarine;  				case 3: return Brushes.LightCyan;  				case 4: return Brushes.Azure;  				case 5: return Brushes.AliceBlue;  				case 6: return Brushes.MintCream;  				case 7: return Brushes.DarkSeaGreen;  				case 8: return Brushes.PaleGreen;  				case 9: return Brushes.LightGreen;  				case 10: return Brushes.MediumPurple;  				case 11: return Brushes.CornflowerBlue;  				case 12: return Brushes.Lavender;  				case 13: return Brushes.GhostWhite;  				case 14: return Brushes.PaleGoldenrod;  				case 15: return Brushes.LightGoldenrodYellow;  				case 16: return Brushes.LemonChiffon;  				case 17: return Brushes.LightYellow;  				case 18: return Brushes.Orchid;  				case 19: return Brushes.Plum;  				case 20: return Brushes.LightPink;  				case 21: return Brushes.Pink;  				case 22: return Brushes.LavenderBlush;  				case 23: return Brushes.Linen;  				case 24: return Brushes.PaleTurquoise;  				case 25: return Brushes.OldLace;  				default: return Brushes.CadetBlue;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPastel,The following statement contains a magic number: switch (i % 26)	  			{  				case 0: return Brushes.CadetBlue;  				case 1: return Brushes.MediumTurquoise;  				case 2: return Brushes.Aquamarine;  				case 3: return Brushes.LightCyan;  				case 4: return Brushes.Azure;  				case 5: return Brushes.AliceBlue;  				case 6: return Brushes.MintCream;  				case 7: return Brushes.DarkSeaGreen;  				case 8: return Brushes.PaleGreen;  				case 9: return Brushes.LightGreen;  				case 10: return Brushes.MediumPurple;  				case 11: return Brushes.CornflowerBlue;  				case 12: return Brushes.Lavender;  				case 13: return Brushes.GhostWhite;  				case 14: return Brushes.PaleGoldenrod;  				case 15: return Brushes.LightGoldenrodYellow;  				case 16: return Brushes.LemonChiffon;  				case 17: return Brushes.LightYellow;  				case 18: return Brushes.Orchid;  				case 19: return Brushes.Plum;  				case 20: return Brushes.LightPink;  				case 21: return Brushes.Pink;  				case 22: return Brushes.LavenderBlush;  				case 23: return Brushes.Linen;  				case 24: return Brushes.PaleTurquoise;  				case 25: return Brushes.OldLace;  				default: return Brushes.CadetBlue;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPastel,The following statement contains a magic number: switch (i % 26)	  			{  				case 0: return Brushes.CadetBlue;  				case 1: return Brushes.MediumTurquoise;  				case 2: return Brushes.Aquamarine;  				case 3: return Brushes.LightCyan;  				case 4: return Brushes.Azure;  				case 5: return Brushes.AliceBlue;  				case 6: return Brushes.MintCream;  				case 7: return Brushes.DarkSeaGreen;  				case 8: return Brushes.PaleGreen;  				case 9: return Brushes.LightGreen;  				case 10: return Brushes.MediumPurple;  				case 11: return Brushes.CornflowerBlue;  				case 12: return Brushes.Lavender;  				case 13: return Brushes.GhostWhite;  				case 14: return Brushes.PaleGoldenrod;  				case 15: return Brushes.LightGoldenrodYellow;  				case 16: return Brushes.LemonChiffon;  				case 17: return Brushes.LightYellow;  				case 18: return Brushes.Orchid;  				case 19: return Brushes.Plum;  				case 20: return Brushes.LightPink;  				case 21: return Brushes.Pink;  				case 22: return Brushes.LavenderBlush;  				case 23: return Brushes.Linen;  				case 24: return Brushes.PaleTurquoise;  				case 25: return Brushes.OldLace;  				default: return Brushes.CadetBlue;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPastel,The following statement contains a magic number: switch (i % 26)	  			{  				case 0: return Brushes.CadetBlue;  				case 1: return Brushes.MediumTurquoise;  				case 2: return Brushes.Aquamarine;  				case 3: return Brushes.LightCyan;  				case 4: return Brushes.Azure;  				case 5: return Brushes.AliceBlue;  				case 6: return Brushes.MintCream;  				case 7: return Brushes.DarkSeaGreen;  				case 8: return Brushes.PaleGreen;  				case 9: return Brushes.LightGreen;  				case 10: return Brushes.MediumPurple;  				case 11: return Brushes.CornflowerBlue;  				case 12: return Brushes.Lavender;  				case 13: return Brushes.GhostWhite;  				case 14: return Brushes.PaleGoldenrod;  				case 15: return Brushes.LightGoldenrodYellow;  				case 16: return Brushes.LemonChiffon;  				case 17: return Brushes.LightYellow;  				case 18: return Brushes.Orchid;  				case 19: return Brushes.Plum;  				case 20: return Brushes.LightPink;  				case 21: return Brushes.Pink;  				case 22: return Brushes.LavenderBlush;  				case 23: return Brushes.Linen;  				case 24: return Brushes.PaleTurquoise;  				case 25: return Brushes.OldLace;  				default: return Brushes.CadetBlue;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPastel,The following statement contains a magic number: switch (i % 26)	  			{  				case 0: return Brushes.CadetBlue;  				case 1: return Brushes.MediumTurquoise;  				case 2: return Brushes.Aquamarine;  				case 3: return Brushes.LightCyan;  				case 4: return Brushes.Azure;  				case 5: return Brushes.AliceBlue;  				case 6: return Brushes.MintCream;  				case 7: return Brushes.DarkSeaGreen;  				case 8: return Brushes.PaleGreen;  				case 9: return Brushes.LightGreen;  				case 10: return Brushes.MediumPurple;  				case 11: return Brushes.CornflowerBlue;  				case 12: return Brushes.Lavender;  				case 13: return Brushes.GhostWhite;  				case 14: return Brushes.PaleGoldenrod;  				case 15: return Brushes.LightGoldenrodYellow;  				case 16: return Brushes.LemonChiffon;  				case 17: return Brushes.LightYellow;  				case 18: return Brushes.Orchid;  				case 19: return Brushes.Plum;  				case 20: return Brushes.LightPink;  				case 21: return Brushes.Pink;  				case 22: return Brushes.LavenderBlush;  				case 23: return Brushes.Linen;  				case 24: return Brushes.PaleTurquoise;  				case 25: return Brushes.OldLace;  				default: return Brushes.CadetBlue;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPastel,The following statement contains a magic number: switch (i % 26)	  			{  				case 0: return Brushes.CadetBlue;  				case 1: return Brushes.MediumTurquoise;  				case 2: return Brushes.Aquamarine;  				case 3: return Brushes.LightCyan;  				case 4: return Brushes.Azure;  				case 5: return Brushes.AliceBlue;  				case 6: return Brushes.MintCream;  				case 7: return Brushes.DarkSeaGreen;  				case 8: return Brushes.PaleGreen;  				case 9: return Brushes.LightGreen;  				case 10: return Brushes.MediumPurple;  				case 11: return Brushes.CornflowerBlue;  				case 12: return Brushes.Lavender;  				case 13: return Brushes.GhostWhite;  				case 14: return Brushes.PaleGoldenrod;  				case 15: return Brushes.LightGoldenrodYellow;  				case 16: return Brushes.LemonChiffon;  				case 17: return Brushes.LightYellow;  				case 18: return Brushes.Orchid;  				case 19: return Brushes.Plum;  				case 20: return Brushes.LightPink;  				case 21: return Brushes.Pink;  				case 22: return Brushes.LavenderBlush;  				case 23: return Brushes.Linen;  				case 24: return Brushes.PaleTurquoise;  				case 25: return Brushes.OldLace;  				default: return Brushes.CadetBlue;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPastel,The following statement contains a magic number: switch (i % 26)	  			{  				case 0: return Brushes.CadetBlue;  				case 1: return Brushes.MediumTurquoise;  				case 2: return Brushes.Aquamarine;  				case 3: return Brushes.LightCyan;  				case 4: return Brushes.Azure;  				case 5: return Brushes.AliceBlue;  				case 6: return Brushes.MintCream;  				case 7: return Brushes.DarkSeaGreen;  				case 8: return Brushes.PaleGreen;  				case 9: return Brushes.LightGreen;  				case 10: return Brushes.MediumPurple;  				case 11: return Brushes.CornflowerBlue;  				case 12: return Brushes.Lavender;  				case 13: return Brushes.GhostWhite;  				case 14: return Brushes.PaleGoldenrod;  				case 15: return Brushes.LightGoldenrodYellow;  				case 16: return Brushes.LemonChiffon;  				case 17: return Brushes.LightYellow;  				case 18: return Brushes.Orchid;  				case 19: return Brushes.Plum;  				case 20: return Brushes.LightPink;  				case 21: return Brushes.Pink;  				case 22: return Brushes.LavenderBlush;  				case 23: return Brushes.Linen;  				case 24: return Brushes.PaleTurquoise;  				case 25: return Brushes.OldLace;  				default: return Brushes.CadetBlue;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPastel,The following statement contains a magic number: switch (i % 26)	  			{  				case 0: return Brushes.CadetBlue;  				case 1: return Brushes.MediumTurquoise;  				case 2: return Brushes.Aquamarine;  				case 3: return Brushes.LightCyan;  				case 4: return Brushes.Azure;  				case 5: return Brushes.AliceBlue;  				case 6: return Brushes.MintCream;  				case 7: return Brushes.DarkSeaGreen;  				case 8: return Brushes.PaleGreen;  				case 9: return Brushes.LightGreen;  				case 10: return Brushes.MediumPurple;  				case 11: return Brushes.CornflowerBlue;  				case 12: return Brushes.Lavender;  				case 13: return Brushes.GhostWhite;  				case 14: return Brushes.PaleGoldenrod;  				case 15: return Brushes.LightGoldenrodYellow;  				case 16: return Brushes.LemonChiffon;  				case 17: return Brushes.LightYellow;  				case 18: return Brushes.Orchid;  				case 19: return Brushes.Plum;  				case 20: return Brushes.LightPink;  				case 21: return Brushes.Pink;  				case 22: return Brushes.LavenderBlush;  				case 23: return Brushes.Linen;  				case 24: return Brushes.PaleTurquoise;  				case 25: return Brushes.OldLace;  				default: return Brushes.CadetBlue;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPastel,The following statement contains a magic number: switch (i % 26)	  			{  				case 0: return Brushes.CadetBlue;  				case 1: return Brushes.MediumTurquoise;  				case 2: return Brushes.Aquamarine;  				case 3: return Brushes.LightCyan;  				case 4: return Brushes.Azure;  				case 5: return Brushes.AliceBlue;  				case 6: return Brushes.MintCream;  				case 7: return Brushes.DarkSeaGreen;  				case 8: return Brushes.PaleGreen;  				case 9: return Brushes.LightGreen;  				case 10: return Brushes.MediumPurple;  				case 11: return Brushes.CornflowerBlue;  				case 12: return Brushes.Lavender;  				case 13: return Brushes.GhostWhite;  				case 14: return Brushes.PaleGoldenrod;  				case 15: return Brushes.LightGoldenrodYellow;  				case 16: return Brushes.LemonChiffon;  				case 17: return Brushes.LightYellow;  				case 18: return Brushes.Orchid;  				case 19: return Brushes.Plum;  				case 20: return Brushes.LightPink;  				case 21: return Brushes.Pink;  				case 22: return Brushes.LavenderBlush;  				case 23: return Brushes.Linen;  				case 24: return Brushes.PaleTurquoise;  				case 25: return Brushes.OldLace;  				default: return Brushes.CadetBlue;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPastel,The following statement contains a magic number: switch (i % 26)	  			{  				case 0: return Brushes.CadetBlue;  				case 1: return Brushes.MediumTurquoise;  				case 2: return Brushes.Aquamarine;  				case 3: return Brushes.LightCyan;  				case 4: return Brushes.Azure;  				case 5: return Brushes.AliceBlue;  				case 6: return Brushes.MintCream;  				case 7: return Brushes.DarkSeaGreen;  				case 8: return Brushes.PaleGreen;  				case 9: return Brushes.LightGreen;  				case 10: return Brushes.MediumPurple;  				case 11: return Brushes.CornflowerBlue;  				case 12: return Brushes.Lavender;  				case 13: return Brushes.GhostWhite;  				case 14: return Brushes.PaleGoldenrod;  				case 15: return Brushes.LightGoldenrodYellow;  				case 16: return Brushes.LemonChiffon;  				case 17: return Brushes.LightYellow;  				case 18: return Brushes.Orchid;  				case 19: return Brushes.Plum;  				case 20: return Brushes.LightPink;  				case 21: return Brushes.Pink;  				case 22: return Brushes.LavenderBlush;  				case 23: return Brushes.Linen;  				case 24: return Brushes.PaleTurquoise;  				case 25: return Brushes.OldLace;  				default: return Brushes.CadetBlue;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPastel,The following statement contains a magic number: switch (i % 26)	  			{  				case 0: return Brushes.CadetBlue;  				case 1: return Brushes.MediumTurquoise;  				case 2: return Brushes.Aquamarine;  				case 3: return Brushes.LightCyan;  				case 4: return Brushes.Azure;  				case 5: return Brushes.AliceBlue;  				case 6: return Brushes.MintCream;  				case 7: return Brushes.DarkSeaGreen;  				case 8: return Brushes.PaleGreen;  				case 9: return Brushes.LightGreen;  				case 10: return Brushes.MediumPurple;  				case 11: return Brushes.CornflowerBlue;  				case 12: return Brushes.Lavender;  				case 13: return Brushes.GhostWhite;  				case 14: return Brushes.PaleGoldenrod;  				case 15: return Brushes.LightGoldenrodYellow;  				case 16: return Brushes.LemonChiffon;  				case 17: return Brushes.LightYellow;  				case 18: return Brushes.Orchid;  				case 19: return Brushes.Plum;  				case 20: return Brushes.LightPink;  				case 21: return Brushes.Pink;  				case 22: return Brushes.LavenderBlush;  				case 23: return Brushes.Linen;  				case 24: return Brushes.PaleTurquoise;  				case 25: return Brushes.OldLace;  				default: return Brushes.CadetBlue;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPastel,The following statement contains a magic number: switch (i % 26)	  			{  				case 0: return Brushes.CadetBlue;  				case 1: return Brushes.MediumTurquoise;  				case 2: return Brushes.Aquamarine;  				case 3: return Brushes.LightCyan;  				case 4: return Brushes.Azure;  				case 5: return Brushes.AliceBlue;  				case 6: return Brushes.MintCream;  				case 7: return Brushes.DarkSeaGreen;  				case 8: return Brushes.PaleGreen;  				case 9: return Brushes.LightGreen;  				case 10: return Brushes.MediumPurple;  				case 11: return Brushes.CornflowerBlue;  				case 12: return Brushes.Lavender;  				case 13: return Brushes.GhostWhite;  				case 14: return Brushes.PaleGoldenrod;  				case 15: return Brushes.LightGoldenrodYellow;  				case 16: return Brushes.LemonChiffon;  				case 17: return Brushes.LightYellow;  				case 18: return Brushes.Orchid;  				case 19: return Brushes.Plum;  				case 20: return Brushes.LightPink;  				case 21: return Brushes.Pink;  				case 22: return Brushes.LavenderBlush;  				case 23: return Brushes.Linen;  				case 24: return Brushes.PaleTurquoise;  				case 25: return Brushes.OldLace;  				default: return Brushes.CadetBlue;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPastel,The following statement contains a magic number: switch (i % 26)	  			{  				case 0: return Brushes.CadetBlue;  				case 1: return Brushes.MediumTurquoise;  				case 2: return Brushes.Aquamarine;  				case 3: return Brushes.LightCyan;  				case 4: return Brushes.Azure;  				case 5: return Brushes.AliceBlue;  				case 6: return Brushes.MintCream;  				case 7: return Brushes.DarkSeaGreen;  				case 8: return Brushes.PaleGreen;  				case 9: return Brushes.LightGreen;  				case 10: return Brushes.MediumPurple;  				case 11: return Brushes.CornflowerBlue;  				case 12: return Brushes.Lavender;  				case 13: return Brushes.GhostWhite;  				case 14: return Brushes.PaleGoldenrod;  				case 15: return Brushes.LightGoldenrodYellow;  				case 16: return Brushes.LemonChiffon;  				case 17: return Brushes.LightYellow;  				case 18: return Brushes.Orchid;  				case 19: return Brushes.Plum;  				case 20: return Brushes.LightPink;  				case 21: return Brushes.Pink;  				case 22: return Brushes.LavenderBlush;  				case 23: return Brushes.Linen;  				case 24: return Brushes.PaleTurquoise;  				case 25: return Brushes.OldLace;  				default: return Brushes.CadetBlue;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPastel,The following statement contains a magic number: switch (i % 26)	  			{  				case 0: return Brushes.CadetBlue;  				case 1: return Brushes.MediumTurquoise;  				case 2: return Brushes.Aquamarine;  				case 3: return Brushes.LightCyan;  				case 4: return Brushes.Azure;  				case 5: return Brushes.AliceBlue;  				case 6: return Brushes.MintCream;  				case 7: return Brushes.DarkSeaGreen;  				case 8: return Brushes.PaleGreen;  				case 9: return Brushes.LightGreen;  				case 10: return Brushes.MediumPurple;  				case 11: return Brushes.CornflowerBlue;  				case 12: return Brushes.Lavender;  				case 13: return Brushes.GhostWhite;  				case 14: return Brushes.PaleGoldenrod;  				case 15: return Brushes.LightGoldenrodYellow;  				case 16: return Brushes.LemonChiffon;  				case 17: return Brushes.LightYellow;  				case 18: return Brushes.Orchid;  				case 19: return Brushes.Plum;  				case 20: return Brushes.LightPink;  				case 21: return Brushes.Pink;  				case 22: return Brushes.LavenderBlush;  				case 23: return Brushes.Linen;  				case 24: return Brushes.PaleTurquoise;  				case 25: return Brushes.OldLace;  				default: return Brushes.CadetBlue;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetSeriesBrushesPastel,The following statement contains a magic number: switch (i % 26)	  			{  				case 0: return Brushes.CadetBlue;  				case 1: return Brushes.MediumTurquoise;  				case 2: return Brushes.Aquamarine;  				case 3: return Brushes.LightCyan;  				case 4: return Brushes.Azure;  				case 5: return Brushes.AliceBlue;  				case 6: return Brushes.MintCream;  				case 7: return Brushes.DarkSeaGreen;  				case 8: return Brushes.PaleGreen;  				case 9: return Brushes.LightGreen;  				case 10: return Brushes.MediumPurple;  				case 11: return Brushes.CornflowerBlue;  				case 12: return Brushes.Lavender;  				case 13: return Brushes.GhostWhite;  				case 14: return Brushes.PaleGoldenrod;  				case 15: return Brushes.LightGoldenrodYellow;  				case 16: return Brushes.LemonChiffon;  				case 17: return Brushes.LightYellow;  				case 18: return Brushes.Orchid;  				case 19: return Brushes.Plum;  				case 20: return Brushes.LightPink;  				case 21: return Brushes.Pink;  				case 22: return Brushes.LavenderBlush;  				case 23: return Brushes.Linen;  				case 24: return Brushes.PaleTurquoise;  				case 25: return Brushes.OldLace;  				default: return Brushes.CadetBlue;  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetValueMaxMin,The following statement contains a magic number: if (vAxisMax != int.MinValue && ! vAxisMax.Equals(double.NaN))  				max = vAxisMax;  			else  			{  				//  				//int gridIncrs=10;		// assume 10 grid increments for now                  _gridIncrs = 10; //PJR 20071113 - grid incrs set & adjusted in here now                    double incr = max / _gridIncrs;	// should be range between max and min?  				double log = Math.Floor(Math.Log10(Math.Abs(incr)));      				double logPow = Math.Pow(10' log) * Math.Sign(max);                  double logDig = (int) (incr / logPow + .5);    				// promote the MSD to either 1' 2' or 5                  if (logDig > 5.0)                      logDig = 10.0;                  else if (logDig > 2.0)                      logDig = 5.0;                  else if (logDig > 1.0)                      logDig = 2.0;                  //PJR 20071113 - reduce scale for large overscale options by decreasing _gridIncrs                  while (max < logDig * logPow * _gridIncrs)                  {                      _gridIncrs--;                  }                  //_gridIncrs++;                    //PJR 20071113 - expand scale so that it is able to fit the max value by increasing _gridIncrs                  while (max > logDig * logPow * _gridIncrs)                  {                      _gridIncrs++;                  }  // 20022008 AJM GJL                  double tmpMax = max;                  // 04032008 AJM - Fixing Strange Number Choice with small numbers                  max = /*(int)*/ (logDig * logPow * _gridIncrs /*+ 0.5*/);                                   if (tmpMax > max - ((max / _gridIncrs) * .5))                  {                        max += (max / _gridIncrs);                      _gridIncrs++;                  }  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetValueMaxMin,The following statement contains a magic number: if (vAxisMax != int.MinValue && ! vAxisMax.Equals(double.NaN))  				max = vAxisMax;  			else  			{  				//  				//int gridIncrs=10;		// assume 10 grid increments for now                  _gridIncrs = 10; //PJR 20071113 - grid incrs set & adjusted in here now                    double incr = max / _gridIncrs;	// should be range between max and min?  				double log = Math.Floor(Math.Log10(Math.Abs(incr)));      				double logPow = Math.Pow(10' log) * Math.Sign(max);                  double logDig = (int) (incr / logPow + .5);    				// promote the MSD to either 1' 2' or 5                  if (logDig > 5.0)                      logDig = 10.0;                  else if (logDig > 2.0)                      logDig = 5.0;                  else if (logDig > 1.0)                      logDig = 2.0;                  //PJR 20071113 - reduce scale for large overscale options by decreasing _gridIncrs                  while (max < logDig * logPow * _gridIncrs)                  {                      _gridIncrs--;                  }                  //_gridIncrs++;                    //PJR 20071113 - expand scale so that it is able to fit the max value by increasing _gridIncrs                  while (max > logDig * logPow * _gridIncrs)                  {                      _gridIncrs++;                  }  // 20022008 AJM GJL                  double tmpMax = max;                  // 04032008 AJM - Fixing Strange Number Choice with small numbers                  max = /*(int)*/ (logDig * logPow * _gridIncrs /*+ 0.5*/);                                   if (tmpMax > max - ((max / _gridIncrs) * .5))                  {                        max += (max / _gridIncrs);                      _gridIncrs++;                  }  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetValueMaxMin,The following statement contains a magic number: if (vAxisMax != int.MinValue && ! vAxisMax.Equals(double.NaN))  				max = vAxisMax;  			else  			{  				//  				//int gridIncrs=10;		// assume 10 grid increments for now                  _gridIncrs = 10; //PJR 20071113 - grid incrs set & adjusted in here now                    double incr = max / _gridIncrs;	// should be range between max and min?  				double log = Math.Floor(Math.Log10(Math.Abs(incr)));      				double logPow = Math.Pow(10' log) * Math.Sign(max);                  double logDig = (int) (incr / logPow + .5);    				// promote the MSD to either 1' 2' or 5                  if (logDig > 5.0)                      logDig = 10.0;                  else if (logDig > 2.0)                      logDig = 5.0;                  else if (logDig > 1.0)                      logDig = 2.0;                  //PJR 20071113 - reduce scale for large overscale options by decreasing _gridIncrs                  while (max < logDig * logPow * _gridIncrs)                  {                      _gridIncrs--;                  }                  //_gridIncrs++;                    //PJR 20071113 - expand scale so that it is able to fit the max value by increasing _gridIncrs                  while (max > logDig * logPow * _gridIncrs)                  {                      _gridIncrs++;                  }  // 20022008 AJM GJL                  double tmpMax = max;                  // 04032008 AJM - Fixing Strange Number Choice with small numbers                  max = /*(int)*/ (logDig * logPow * _gridIncrs /*+ 0.5*/);                                   if (tmpMax > max - ((max / _gridIncrs) * .5))                  {                        max += (max / _gridIncrs);                      _gridIncrs++;                  }  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetValueMaxMin,The following statement contains a magic number: if (vAxisMax != int.MinValue && ! vAxisMax.Equals(double.NaN))  				max = vAxisMax;  			else  			{  				//  				//int gridIncrs=10;		// assume 10 grid increments for now                  _gridIncrs = 10; //PJR 20071113 - grid incrs set & adjusted in here now                    double incr = max / _gridIncrs;	// should be range between max and min?  				double log = Math.Floor(Math.Log10(Math.Abs(incr)));      				double logPow = Math.Pow(10' log) * Math.Sign(max);                  double logDig = (int) (incr / logPow + .5);    				// promote the MSD to either 1' 2' or 5                  if (logDig > 5.0)                      logDig = 10.0;                  else if (logDig > 2.0)                      logDig = 5.0;                  else if (logDig > 1.0)                      logDig = 2.0;                  //PJR 20071113 - reduce scale for large overscale options by decreasing _gridIncrs                  while (max < logDig * logPow * _gridIncrs)                  {                      _gridIncrs--;                  }                  //_gridIncrs++;                    //PJR 20071113 - expand scale so that it is able to fit the max value by increasing _gridIncrs                  while (max > logDig * logPow * _gridIncrs)                  {                      _gridIncrs++;                  }  // 20022008 AJM GJL                  double tmpMax = max;                  // 04032008 AJM - Fixing Strange Number Choice with small numbers                  max = /*(int)*/ (logDig * logPow * _gridIncrs /*+ 0.5*/);                                   if (tmpMax > max - ((max / _gridIncrs) * .5))                  {                        max += (max / _gridIncrs);                      _gridIncrs++;                  }  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetValueMaxMin,The following statement contains a magic number: if (vAxisMax != int.MinValue && ! vAxisMax.Equals(double.NaN))  				max = vAxisMax;  			else  			{  				//  				//int gridIncrs=10;		// assume 10 grid increments for now                  _gridIncrs = 10; //PJR 20071113 - grid incrs set & adjusted in here now                    double incr = max / _gridIncrs;	// should be range between max and min?  				double log = Math.Floor(Math.Log10(Math.Abs(incr)));      				double logPow = Math.Pow(10' log) * Math.Sign(max);                  double logDig = (int) (incr / logPow + .5);    				// promote the MSD to either 1' 2' or 5                  if (logDig > 5.0)                      logDig = 10.0;                  else if (logDig > 2.0)                      logDig = 5.0;                  else if (logDig > 1.0)                      logDig = 2.0;                  //PJR 20071113 - reduce scale for large overscale options by decreasing _gridIncrs                  while (max < logDig * logPow * _gridIncrs)                  {                      _gridIncrs--;                  }                  //_gridIncrs++;                    //PJR 20071113 - expand scale so that it is able to fit the max value by increasing _gridIncrs                  while (max > logDig * logPow * _gridIncrs)                  {                      _gridIncrs++;                  }  // 20022008 AJM GJL                  double tmpMax = max;                  // 04032008 AJM - Fixing Strange Number Choice with small numbers                  max = /*(int)*/ (logDig * logPow * _gridIncrs /*+ 0.5*/);                                   if (tmpMax > max - ((max / _gridIncrs) * .5))                  {                        max += (max / _gridIncrs);                      _gridIncrs++;                  }  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetValueMaxMin,The following statement contains a magic number: if (vAxisMax != int.MinValue && ! vAxisMax.Equals(double.NaN))  				max = vAxisMax;  			else  			{  				//  				//int gridIncrs=10;		// assume 10 grid increments for now                  _gridIncrs = 10; //PJR 20071113 - grid incrs set & adjusted in here now                    double incr = max / _gridIncrs;	// should be range between max and min?  				double log = Math.Floor(Math.Log10(Math.Abs(incr)));      				double logPow = Math.Pow(10' log) * Math.Sign(max);                  double logDig = (int) (incr / logPow + .5);    				// promote the MSD to either 1' 2' or 5                  if (logDig > 5.0)                      logDig = 10.0;                  else if (logDig > 2.0)                      logDig = 5.0;                  else if (logDig > 1.0)                      logDig = 2.0;                  //PJR 20071113 - reduce scale for large overscale options by decreasing _gridIncrs                  while (max < logDig * logPow * _gridIncrs)                  {                      _gridIncrs--;                  }                  //_gridIncrs++;                    //PJR 20071113 - expand scale so that it is able to fit the max value by increasing _gridIncrs                  while (max > logDig * logPow * _gridIncrs)                  {                      _gridIncrs++;                  }  // 20022008 AJM GJL                  double tmpMax = max;                  // 04032008 AJM - Fixing Strange Number Choice with small numbers                  max = /*(int)*/ (logDig * logPow * _gridIncrs /*+ 0.5*/);                                   if (tmpMax > max - ((max / _gridIncrs) * .5))                  {                        max += (max / _gridIncrs);                      _gridIncrs++;                  }  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetValueMaxMin,The following statement contains a magic number: if (vAxisMax != int.MinValue && ! vAxisMax.Equals(double.NaN))  				max = vAxisMax;  			else  			{  				//  				//int gridIncrs=10;		// assume 10 grid increments for now                  _gridIncrs = 10; //PJR 20071113 - grid incrs set & adjusted in here now                    double incr = max / _gridIncrs;	// should be range between max and min?  				double log = Math.Floor(Math.Log10(Math.Abs(incr)));      				double logPow = Math.Pow(10' log) * Math.Sign(max);                  double logDig = (int) (incr / logPow + .5);    				// promote the MSD to either 1' 2' or 5                  if (logDig > 5.0)                      logDig = 10.0;                  else if (logDig > 2.0)                      logDig = 5.0;                  else if (logDig > 1.0)                      logDig = 2.0;                  //PJR 20071113 - reduce scale for large overscale options by decreasing _gridIncrs                  while (max < logDig * logPow * _gridIncrs)                  {                      _gridIncrs--;                  }                  //_gridIncrs++;                    //PJR 20071113 - expand scale so that it is able to fit the max value by increasing _gridIncrs                  while (max > logDig * logPow * _gridIncrs)                  {                      _gridIncrs++;                  }  // 20022008 AJM GJL                  double tmpMax = max;                  // 04032008 AJM - Fixing Strange Number Choice with small numbers                  max = /*(int)*/ (logDig * logPow * _gridIncrs /*+ 0.5*/);                                   if (tmpMax > max - ((max / _gridIncrs) * .5))                  {                        max += (max / _gridIncrs);                      _gridIncrs++;                  }  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetValueMaxMin,The following statement contains a magic number: if (vAxisMax != int.MinValue && ! vAxisMax.Equals(double.NaN))  				max = vAxisMax;  			else  			{  				//  				//int gridIncrs=10;		// assume 10 grid increments for now                  _gridIncrs = 10; //PJR 20071113 - grid incrs set & adjusted in here now                    double incr = max / _gridIncrs;	// should be range between max and min?  				double log = Math.Floor(Math.Log10(Math.Abs(incr)));      				double logPow = Math.Pow(10' log) * Math.Sign(max);                  double logDig = (int) (incr / logPow + .5);    				// promote the MSD to either 1' 2' or 5                  if (logDig > 5.0)                      logDig = 10.0;                  else if (logDig > 2.0)                      logDig = 5.0;                  else if (logDig > 1.0)                      logDig = 2.0;                  //PJR 20071113 - reduce scale for large overscale options by decreasing _gridIncrs                  while (max < logDig * logPow * _gridIncrs)                  {                      _gridIncrs--;                  }                  //_gridIncrs++;                    //PJR 20071113 - expand scale so that it is able to fit the max value by increasing _gridIncrs                  while (max > logDig * logPow * _gridIncrs)                  {                      _gridIncrs++;                  }  // 20022008 AJM GJL                  double tmpMax = max;                  // 04032008 AJM - Fixing Strange Number Choice with small numbers                  max = /*(int)*/ (logDig * logPow * _gridIncrs /*+ 0.5*/);                                   if (tmpMax > max - ((max / _gridIncrs) * .5))                  {                        max += (max / _gridIncrs);                      _gridIncrs++;                  }  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,GetValueMaxMin,The following statement contains a magic number: if (vAxisMax != int.MinValue && ! vAxisMax.Equals(double.NaN))  				max = vAxisMax;  			else  			{  				//  				//int gridIncrs=10;		// assume 10 grid increments for now                  _gridIncrs = 10; //PJR 20071113 - grid incrs set & adjusted in here now                    double incr = max / _gridIncrs;	// should be range between max and min?  				double log = Math.Floor(Math.Log10(Math.Abs(incr)));      				double logPow = Math.Pow(10' log) * Math.Sign(max);                  double logDig = (int) (incr / logPow + .5);    				// promote the MSD to either 1' 2' or 5                  if (logDig > 5.0)                      logDig = 10.0;                  else if (logDig > 2.0)                      logDig = 5.0;                  else if (logDig > 1.0)                      logDig = 2.0;                  //PJR 20071113 - reduce scale for large overscale options by decreasing _gridIncrs                  while (max < logDig * logPow * _gridIncrs)                  {                      _gridIncrs--;                  }                  //_gridIncrs++;                    //PJR 20071113 - expand scale so that it is able to fit the max value by increasing _gridIncrs                  while (max > logDig * logPow * _gridIncrs)                  {                      _gridIncrs++;                  }  // 20022008 AJM GJL                  double tmpMax = max;                  // 04032008 AJM - Fixing Strange Number Choice with small numbers                  max = /*(int)*/ (logDig * logPow * _gridIncrs /*+ 0.5*/);                                   if (tmpMax > max - ((max / _gridIncrs) * .5))                  {                        max += (max / _gridIncrs);                      _gridIncrs++;                  }  			}
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,AdjustMargins,The following statement contains a magic number: if (Layout.RightMargin < min + this._LastCategoryWidth/2)  				Layout.RightMargin = min + this._LastCategoryWidth/2;
Magic Number,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,AdjustMargins,The following statement contains a magic number: if (Layout.RightMargin < min + this._LastCategoryWidth/2)  				Layout.RightMargin = min + this._LastCategoryWidth/2;
Magic Number,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,Draw,The following statement contains a magic number: using(Graphics g = Graphics.FromImage(_mf))  			{                  // 06122007AJM Used to Force Higher Quality                  g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.HighQualityBicubic;                  g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.HighQuality;                  g.PixelOffsetMode = System.Drawing.Drawing2D.PixelOffsetMode.None;                  g.CompositingQuality = System.Drawing.Drawing2D.CompositingQuality.HighQuality;                  g.PageUnit = GraphicsUnit.Pixel;    				// Adjust the top margin to depend on the title height  				Size titleSize = DrawTitleMeasure(rpt' g' ChartDefn.Title);  				Layout.TopMargin = titleSize.Height;    				// 20022008 AJM GJL - Added new required info   				double ymax=0'ymin=0;	// Get the max and min values for the y axis  				GetValueMaxMin(rpt' ref ymax' ref ymin' 1'1);                    double xmax = 0' xmin = 0;  // Get the max and min values for the x axis                  GetValueMaxMin(rpt' ref xmax' ref xmin' 0'1);                    double bmax = 0' bmin = 0;  // Get the max and min values for the bubble size                  if (ChartDefn.Type == ChartTypeEnum.Bubble)     // only applies to bubble (not scatter)                      GetValueMaxMin(rpt' ref bmax' ref bmin' 2'1);                    DrawChartStyle(rpt' g);  				  				// Draw title; routine determines if necessary  				DrawTitle(rpt' g' ChartDefn.Title' new System.Drawing.Rectangle(0' 0' Layout.Width' Layout.TopMargin));    				// Adjust the left margin to depend on the Value Axis  				Size vaSize = ValueAxisSize(rpt' g' ymin' ymax);  				Layout.LeftMargin = vaSize.Width;    				// Draw legend  				System.Drawing.Rectangle lRect = DrawLegend(rpt'g' false' true);    				// Adjust the bottom margin to depend on the Category Axis  				Size caSize = CategoryAxisSize(rpt' g' xmin' xmax);  				Layout.BottomMargin = caSize.Height;    				AdjustMargins(lRect'rpt'g);		// Adjust margins based on legend.    				// Draw Plot area  				DrawPlotAreaStyle(rpt' g' lRect);    				// Draw Value Axis  				if (vaSize.Width > 0)	// If we made room for the axis - we need to draw it  					DrawValueAxis(rpt' g' ymin' ymax'   						new System.Drawing.Rectangle(Layout.LeftMargin - vaSize.Width' Layout.TopMargin' vaSize.Width' Layout.PlotArea.Height)' Layout.LeftMargin' _bm.Width - Layout.RightMargin);                    // Draw Category Axis                  if (caSize.Height > 0)                      DrawCategoryAxis(rpt' g' xmin' xmax'                          new System.Drawing.Rectangle(Layout.LeftMargin' _bm.Height - Layout.BottomMargin' _bm.Width - Layout.LeftMargin - Layout.RightMargin' vaSize.Height)'                           Layout.TopMargin' _bm.Height - Layout.BottomMargin);    				// Draw Plot area data   				DrawPlot(rpt' g' xmin' xmax' ymin' ymax' bmin' bmax);                  DrawLegend(rpt' g' false' false);  			}
Magic Number,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawPlot,The following statement contains a magic number: for (int iCol = 1; iCol <= SeriesCount; iCol++)              {                  //handle either line scatter or line plot type GJL 020308                  Point lastPoint = new Point();                  Point[] Points = new Point[2];                  bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                  for (int iRow = 1; iRow <= CategoryCount; iRow++)                  {                      double xv = this.GetDataValue(rpt' iRow' iCol' 0);                      double yv = this.GetDataValue(rpt' iRow' iCol' 1);                      double bv = this.ChartDefn.Type == ChartTypeEnum.Bubble ?                          this.GetDataValue(rpt' iRow' iCol' 2) : 0;                      if (xv < xmin || yv < ymin || xv > xmax || yv > ymax)                           continue;                      int x = (int)(((Math.Min(xv' xmax) - xmin) / (xmax - xmin)) * maxPointWidth);                      int y = (int)(((Math.Min(yv' ymax) - ymin) / (ymax - ymin)) * maxPointHeight);                      if (y != int.MinValue && x != int.MinValue)                      {                                          Point p = new Point(Layout.PlotArea.Left + x' Layout.PlotArea.Top + (maxPointHeight - y));                          //GJL 010308 Line subtype scatter plot                      if ((ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.Line || (ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.SmoothLine || isLine)                          {                              if (!(lastPoint.IsEmpty))                              {                              Points[0] = lastPoint;                              Points[1] = p;                              String LineSize = getLineSize(rpt' iCol' 1);                              int intLineSize = 2;                              switch (LineSize)                              {                                  case "Small": intLineSize = 1;                                      break;                                  case "Regular": intLineSize = 2;                                      break;                                  case "Large": intLineSize = 3;                                      break;                                  case "Extra Large": intLineSize = 4;                                      break;                                  case "Super Size": intLineSize = 5;                                      break;                              }                              DrawLineBetweenPoints(g' rpt' GetSeriesBrush(rpt' iRow' iCol)' Points' intLineSize);                              //Add a metafilecomment to use as a tooltip GJL 26092008                                                          if (_showToolTips || _showToolTipsX)                              {                                  string display = "";                                  if (_showToolTipsX) display = xv.ToString(_tooltipXFormat);                                  if (_showToolTips)                                  {                                      if (display.Length > 0) display += " ' ";                                      display += yv.ToString(_tooltipYFormat);                                  }                                  String val = "ToolTip:" + display + "|X:" + (int)(p.X - 3) + "|Y:" + (int)(p.Y - 3) + "|W:" + 6 + "|H:" + 6;                                                               g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                              }                                  }                          }                          else                          {                                DrawBubble(rpt' g' GetSeriesBrush(rpt' iRow' iCol)' p' iRow' iCol' bmin' bmax' bv'xv'yv);                            }                          lastPoint = p;                       }                                   }              }
Magic Number,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawPlot,The following statement contains a magic number: for (int iCol = 1; iCol <= SeriesCount; iCol++)              {                  //handle either line scatter or line plot type GJL 020308                  Point lastPoint = new Point();                  Point[] Points = new Point[2];                  bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                  for (int iRow = 1; iRow <= CategoryCount; iRow++)                  {                      double xv = this.GetDataValue(rpt' iRow' iCol' 0);                      double yv = this.GetDataValue(rpt' iRow' iCol' 1);                      double bv = this.ChartDefn.Type == ChartTypeEnum.Bubble ?                          this.GetDataValue(rpt' iRow' iCol' 2) : 0;                      if (xv < xmin || yv < ymin || xv > xmax || yv > ymax)                           continue;                      int x = (int)(((Math.Min(xv' xmax) - xmin) / (xmax - xmin)) * maxPointWidth);                      int y = (int)(((Math.Min(yv' ymax) - ymin) / (ymax - ymin)) * maxPointHeight);                      if (y != int.MinValue && x != int.MinValue)                      {                                          Point p = new Point(Layout.PlotArea.Left + x' Layout.PlotArea.Top + (maxPointHeight - y));                          //GJL 010308 Line subtype scatter plot                      if ((ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.Line || (ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.SmoothLine || isLine)                          {                              if (!(lastPoint.IsEmpty))                              {                              Points[0] = lastPoint;                              Points[1] = p;                              String LineSize = getLineSize(rpt' iCol' 1);                              int intLineSize = 2;                              switch (LineSize)                              {                                  case "Small": intLineSize = 1;                                      break;                                  case "Regular": intLineSize = 2;                                      break;                                  case "Large": intLineSize = 3;                                      break;                                  case "Extra Large": intLineSize = 4;                                      break;                                  case "Super Size": intLineSize = 5;                                      break;                              }                              DrawLineBetweenPoints(g' rpt' GetSeriesBrush(rpt' iRow' iCol)' Points' intLineSize);                              //Add a metafilecomment to use as a tooltip GJL 26092008                                                          if (_showToolTips || _showToolTipsX)                              {                                  string display = "";                                  if (_showToolTipsX) display = xv.ToString(_tooltipXFormat);                                  if (_showToolTips)                                  {                                      if (display.Length > 0) display += " ' ";                                      display += yv.ToString(_tooltipYFormat);                                  }                                  String val = "ToolTip:" + display + "|X:" + (int)(p.X - 3) + "|Y:" + (int)(p.Y - 3) + "|W:" + 6 + "|H:" + 6;                                                               g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                              }                                  }                          }                          else                          {                                DrawBubble(rpt' g' GetSeriesBrush(rpt' iRow' iCol)' p' iRow' iCol' bmin' bmax' bv'xv'yv);                            }                          lastPoint = p;                       }                                   }              }
Magic Number,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawPlot,The following statement contains a magic number: for (int iCol = 1; iCol <= SeriesCount; iCol++)              {                  //handle either line scatter or line plot type GJL 020308                  Point lastPoint = new Point();                  Point[] Points = new Point[2];                  bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                  for (int iRow = 1; iRow <= CategoryCount; iRow++)                  {                      double xv = this.GetDataValue(rpt' iRow' iCol' 0);                      double yv = this.GetDataValue(rpt' iRow' iCol' 1);                      double bv = this.ChartDefn.Type == ChartTypeEnum.Bubble ?                          this.GetDataValue(rpt' iRow' iCol' 2) : 0;                      if (xv < xmin || yv < ymin || xv > xmax || yv > ymax)                           continue;                      int x = (int)(((Math.Min(xv' xmax) - xmin) / (xmax - xmin)) * maxPointWidth);                      int y = (int)(((Math.Min(yv' ymax) - ymin) / (ymax - ymin)) * maxPointHeight);                      if (y != int.MinValue && x != int.MinValue)                      {                                          Point p = new Point(Layout.PlotArea.Left + x' Layout.PlotArea.Top + (maxPointHeight - y));                          //GJL 010308 Line subtype scatter plot                      if ((ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.Line || (ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.SmoothLine || isLine)                          {                              if (!(lastPoint.IsEmpty))                              {                              Points[0] = lastPoint;                              Points[1] = p;                              String LineSize = getLineSize(rpt' iCol' 1);                              int intLineSize = 2;                              switch (LineSize)                              {                                  case "Small": intLineSize = 1;                                      break;                                  case "Regular": intLineSize = 2;                                      break;                                  case "Large": intLineSize = 3;                                      break;                                  case "Extra Large": intLineSize = 4;                                      break;                                  case "Super Size": intLineSize = 5;                                      break;                              }                              DrawLineBetweenPoints(g' rpt' GetSeriesBrush(rpt' iRow' iCol)' Points' intLineSize);                              //Add a metafilecomment to use as a tooltip GJL 26092008                                                          if (_showToolTips || _showToolTipsX)                              {                                  string display = "";                                  if (_showToolTipsX) display = xv.ToString(_tooltipXFormat);                                  if (_showToolTips)                                  {                                      if (display.Length > 0) display += " ' ";                                      display += yv.ToString(_tooltipYFormat);                                  }                                  String val = "ToolTip:" + display + "|X:" + (int)(p.X - 3) + "|Y:" + (int)(p.Y - 3) + "|W:" + 6 + "|H:" + 6;                                                               g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                              }                                  }                          }                          else                          {                                DrawBubble(rpt' g' GetSeriesBrush(rpt' iRow' iCol)' p' iRow' iCol' bmin' bmax' bv'xv'yv);                            }                          lastPoint = p;                       }                                   }              }
Magic Number,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawPlot,The following statement contains a magic number: for (int iCol = 1; iCol <= SeriesCount; iCol++)              {                  //handle either line scatter or line plot type GJL 020308                  Point lastPoint = new Point();                  Point[] Points = new Point[2];                  bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                  for (int iRow = 1; iRow <= CategoryCount; iRow++)                  {                      double xv = this.GetDataValue(rpt' iRow' iCol' 0);                      double yv = this.GetDataValue(rpt' iRow' iCol' 1);                      double bv = this.ChartDefn.Type == ChartTypeEnum.Bubble ?                          this.GetDataValue(rpt' iRow' iCol' 2) : 0;                      if (xv < xmin || yv < ymin || xv > xmax || yv > ymax)                           continue;                      int x = (int)(((Math.Min(xv' xmax) - xmin) / (xmax - xmin)) * maxPointWidth);                      int y = (int)(((Math.Min(yv' ymax) - ymin) / (ymax - ymin)) * maxPointHeight);                      if (y != int.MinValue && x != int.MinValue)                      {                                          Point p = new Point(Layout.PlotArea.Left + x' Layout.PlotArea.Top + (maxPointHeight - y));                          //GJL 010308 Line subtype scatter plot                      if ((ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.Line || (ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.SmoothLine || isLine)                          {                              if (!(lastPoint.IsEmpty))                              {                              Points[0] = lastPoint;                              Points[1] = p;                              String LineSize = getLineSize(rpt' iCol' 1);                              int intLineSize = 2;                              switch (LineSize)                              {                                  case "Small": intLineSize = 1;                                      break;                                  case "Regular": intLineSize = 2;                                      break;                                  case "Large": intLineSize = 3;                                      break;                                  case "Extra Large": intLineSize = 4;                                      break;                                  case "Super Size": intLineSize = 5;                                      break;                              }                              DrawLineBetweenPoints(g' rpt' GetSeriesBrush(rpt' iRow' iCol)' Points' intLineSize);                              //Add a metafilecomment to use as a tooltip GJL 26092008                                                          if (_showToolTips || _showToolTipsX)                              {                                  string display = "";                                  if (_showToolTipsX) display = xv.ToString(_tooltipXFormat);                                  if (_showToolTips)                                  {                                      if (display.Length > 0) display += " ' ";                                      display += yv.ToString(_tooltipYFormat);                                  }                                  String val = "ToolTip:" + display + "|X:" + (int)(p.X - 3) + "|Y:" + (int)(p.Y - 3) + "|W:" + 6 + "|H:" + 6;                                                               g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                              }                                  }                          }                          else                          {                                DrawBubble(rpt' g' GetSeriesBrush(rpt' iRow' iCol)' p' iRow' iCol' bmin' bmax' bv'xv'yv);                            }                          lastPoint = p;                       }                                   }              }
Magic Number,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawPlot,The following statement contains a magic number: for (int iCol = 1; iCol <= SeriesCount; iCol++)              {                  //handle either line scatter or line plot type GJL 020308                  Point lastPoint = new Point();                  Point[] Points = new Point[2];                  bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                  for (int iRow = 1; iRow <= CategoryCount; iRow++)                  {                      double xv = this.GetDataValue(rpt' iRow' iCol' 0);                      double yv = this.GetDataValue(rpt' iRow' iCol' 1);                      double bv = this.ChartDefn.Type == ChartTypeEnum.Bubble ?                          this.GetDataValue(rpt' iRow' iCol' 2) : 0;                      if (xv < xmin || yv < ymin || xv > xmax || yv > ymax)                           continue;                      int x = (int)(((Math.Min(xv' xmax) - xmin) / (xmax - xmin)) * maxPointWidth);                      int y = (int)(((Math.Min(yv' ymax) - ymin) / (ymax - ymin)) * maxPointHeight);                      if (y != int.MinValue && x != int.MinValue)                      {                                          Point p = new Point(Layout.PlotArea.Left + x' Layout.PlotArea.Top + (maxPointHeight - y));                          //GJL 010308 Line subtype scatter plot                      if ((ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.Line || (ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.SmoothLine || isLine)                          {                              if (!(lastPoint.IsEmpty))                              {                              Points[0] = lastPoint;                              Points[1] = p;                              String LineSize = getLineSize(rpt' iCol' 1);                              int intLineSize = 2;                              switch (LineSize)                              {                                  case "Small": intLineSize = 1;                                      break;                                  case "Regular": intLineSize = 2;                                      break;                                  case "Large": intLineSize = 3;                                      break;                                  case "Extra Large": intLineSize = 4;                                      break;                                  case "Super Size": intLineSize = 5;                                      break;                              }                              DrawLineBetweenPoints(g' rpt' GetSeriesBrush(rpt' iRow' iCol)' Points' intLineSize);                              //Add a metafilecomment to use as a tooltip GJL 26092008                                                          if (_showToolTips || _showToolTipsX)                              {                                  string display = "";                                  if (_showToolTipsX) display = xv.ToString(_tooltipXFormat);                                  if (_showToolTips)                                  {                                      if (display.Length > 0) display += " ' ";                                      display += yv.ToString(_tooltipYFormat);                                  }                                  String val = "ToolTip:" + display + "|X:" + (int)(p.X - 3) + "|Y:" + (int)(p.Y - 3) + "|W:" + 6 + "|H:" + 6;                                                               g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                              }                                  }                          }                          else                          {                                DrawBubble(rpt' g' GetSeriesBrush(rpt' iRow' iCol)' p' iRow' iCol' bmin' bmax' bv'xv'yv);                            }                          lastPoint = p;                       }                                   }              }
Magic Number,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawPlot,The following statement contains a magic number: for (int iCol = 1; iCol <= SeriesCount; iCol++)              {                  //handle either line scatter or line plot type GJL 020308                  Point lastPoint = new Point();                  Point[] Points = new Point[2];                  bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                  for (int iRow = 1; iRow <= CategoryCount; iRow++)                  {                      double xv = this.GetDataValue(rpt' iRow' iCol' 0);                      double yv = this.GetDataValue(rpt' iRow' iCol' 1);                      double bv = this.ChartDefn.Type == ChartTypeEnum.Bubble ?                          this.GetDataValue(rpt' iRow' iCol' 2) : 0;                      if (xv < xmin || yv < ymin || xv > xmax || yv > ymax)                           continue;                      int x = (int)(((Math.Min(xv' xmax) - xmin) / (xmax - xmin)) * maxPointWidth);                      int y = (int)(((Math.Min(yv' ymax) - ymin) / (ymax - ymin)) * maxPointHeight);                      if (y != int.MinValue && x != int.MinValue)                      {                                          Point p = new Point(Layout.PlotArea.Left + x' Layout.PlotArea.Top + (maxPointHeight - y));                          //GJL 010308 Line subtype scatter plot                      if ((ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.Line || (ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.SmoothLine || isLine)                          {                              if (!(lastPoint.IsEmpty))                              {                              Points[0] = lastPoint;                              Points[1] = p;                              String LineSize = getLineSize(rpt' iCol' 1);                              int intLineSize = 2;                              switch (LineSize)                              {                                  case "Small": intLineSize = 1;                                      break;                                  case "Regular": intLineSize = 2;                                      break;                                  case "Large": intLineSize = 3;                                      break;                                  case "Extra Large": intLineSize = 4;                                      break;                                  case "Super Size": intLineSize = 5;                                      break;                              }                              DrawLineBetweenPoints(g' rpt' GetSeriesBrush(rpt' iRow' iCol)' Points' intLineSize);                              //Add a metafilecomment to use as a tooltip GJL 26092008                                                          if (_showToolTips || _showToolTipsX)                              {                                  string display = "";                                  if (_showToolTipsX) display = xv.ToString(_tooltipXFormat);                                  if (_showToolTips)                                  {                                      if (display.Length > 0) display += " ' ";                                      display += yv.ToString(_tooltipYFormat);                                  }                                  String val = "ToolTip:" + display + "|X:" + (int)(p.X - 3) + "|Y:" + (int)(p.Y - 3) + "|W:" + 6 + "|H:" + 6;                                                               g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                              }                                  }                          }                          else                          {                                DrawBubble(rpt' g' GetSeriesBrush(rpt' iRow' iCol)' p' iRow' iCol' bmin' bmax' bv'xv'yv);                            }                          lastPoint = p;                       }                                   }              }
Magic Number,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawPlot,The following statement contains a magic number: for (int iCol = 1; iCol <= SeriesCount; iCol++)              {                  //handle either line scatter or line plot type GJL 020308                  Point lastPoint = new Point();                  Point[] Points = new Point[2];                  bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                  for (int iRow = 1; iRow <= CategoryCount; iRow++)                  {                      double xv = this.GetDataValue(rpt' iRow' iCol' 0);                      double yv = this.GetDataValue(rpt' iRow' iCol' 1);                      double bv = this.ChartDefn.Type == ChartTypeEnum.Bubble ?                          this.GetDataValue(rpt' iRow' iCol' 2) : 0;                      if (xv < xmin || yv < ymin || xv > xmax || yv > ymax)                           continue;                      int x = (int)(((Math.Min(xv' xmax) - xmin) / (xmax - xmin)) * maxPointWidth);                      int y = (int)(((Math.Min(yv' ymax) - ymin) / (ymax - ymin)) * maxPointHeight);                      if (y != int.MinValue && x != int.MinValue)                      {                                          Point p = new Point(Layout.PlotArea.Left + x' Layout.PlotArea.Top + (maxPointHeight - y));                          //GJL 010308 Line subtype scatter plot                      if ((ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.Line || (ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.SmoothLine || isLine)                          {                              if (!(lastPoint.IsEmpty))                              {                              Points[0] = lastPoint;                              Points[1] = p;                              String LineSize = getLineSize(rpt' iCol' 1);                              int intLineSize = 2;                              switch (LineSize)                              {                                  case "Small": intLineSize = 1;                                      break;                                  case "Regular": intLineSize = 2;                                      break;                                  case "Large": intLineSize = 3;                                      break;                                  case "Extra Large": intLineSize = 4;                                      break;                                  case "Super Size": intLineSize = 5;                                      break;                              }                              DrawLineBetweenPoints(g' rpt' GetSeriesBrush(rpt' iRow' iCol)' Points' intLineSize);                              //Add a metafilecomment to use as a tooltip GJL 26092008                                                          if (_showToolTips || _showToolTipsX)                              {                                  string display = "";                                  if (_showToolTipsX) display = xv.ToString(_tooltipXFormat);                                  if (_showToolTips)                                  {                                      if (display.Length > 0) display += " ' ";                                      display += yv.ToString(_tooltipYFormat);                                  }                                  String val = "ToolTip:" + display + "|X:" + (int)(p.X - 3) + "|Y:" + (int)(p.Y - 3) + "|W:" + 6 + "|H:" + 6;                                                               g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                              }                                  }                          }                          else                          {                                DrawBubble(rpt' g' GetSeriesBrush(rpt' iRow' iCol)' p' iRow' iCol' bmin' bmax' bv'xv'yv);                            }                          lastPoint = p;                       }                                   }              }
Magic Number,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawPlot,The following statement contains a magic number: for (int iCol = 1; iCol <= SeriesCount; iCol++)              {                  //handle either line scatter or line plot type GJL 020308                  Point lastPoint = new Point();                  Point[] Points = new Point[2];                  bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                  for (int iRow = 1; iRow <= CategoryCount; iRow++)                  {                      double xv = this.GetDataValue(rpt' iRow' iCol' 0);                      double yv = this.GetDataValue(rpt' iRow' iCol' 1);                      double bv = this.ChartDefn.Type == ChartTypeEnum.Bubble ?                          this.GetDataValue(rpt' iRow' iCol' 2) : 0;                      if (xv < xmin || yv < ymin || xv > xmax || yv > ymax)                           continue;                      int x = (int)(((Math.Min(xv' xmax) - xmin) / (xmax - xmin)) * maxPointWidth);                      int y = (int)(((Math.Min(yv' ymax) - ymin) / (ymax - ymin)) * maxPointHeight);                      if (y != int.MinValue && x != int.MinValue)                      {                                          Point p = new Point(Layout.PlotArea.Left + x' Layout.PlotArea.Top + (maxPointHeight - y));                          //GJL 010308 Line subtype scatter plot                      if ((ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.Line || (ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.SmoothLine || isLine)                          {                              if (!(lastPoint.IsEmpty))                              {                              Points[0] = lastPoint;                              Points[1] = p;                              String LineSize = getLineSize(rpt' iCol' 1);                              int intLineSize = 2;                              switch (LineSize)                              {                                  case "Small": intLineSize = 1;                                      break;                                  case "Regular": intLineSize = 2;                                      break;                                  case "Large": intLineSize = 3;                                      break;                                  case "Extra Large": intLineSize = 4;                                      break;                                  case "Super Size": intLineSize = 5;                                      break;                              }                              DrawLineBetweenPoints(g' rpt' GetSeriesBrush(rpt' iRow' iCol)' Points' intLineSize);                              //Add a metafilecomment to use as a tooltip GJL 26092008                                                          if (_showToolTips || _showToolTipsX)                              {                                  string display = "";                                  if (_showToolTipsX) display = xv.ToString(_tooltipXFormat);                                  if (_showToolTips)                                  {                                      if (display.Length > 0) display += " ' ";                                      display += yv.ToString(_tooltipYFormat);                                  }                                  String val = "ToolTip:" + display + "|X:" + (int)(p.X - 3) + "|Y:" + (int)(p.Y - 3) + "|W:" + 6 + "|H:" + 6;                                                               g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                              }                                  }                          }                          else                          {                                DrawBubble(rpt' g' GetSeriesBrush(rpt' iRow' iCol)' p' iRow' iCol' bmin' bmax' bv'xv'yv);                            }                          lastPoint = p;                       }                                   }              }
Magic Number,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawPlot,The following statement contains a magic number: for (int iCol = 1; iCol <= SeriesCount; iCol++)              {                  //handle either line scatter or line plot type GJL 020308                  Point lastPoint = new Point();                  Point[] Points = new Point[2];                  bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                  for (int iRow = 1; iRow <= CategoryCount; iRow++)                  {                      double xv = this.GetDataValue(rpt' iRow' iCol' 0);                      double yv = this.GetDataValue(rpt' iRow' iCol' 1);                      double bv = this.ChartDefn.Type == ChartTypeEnum.Bubble ?                          this.GetDataValue(rpt' iRow' iCol' 2) : 0;                      if (xv < xmin || yv < ymin || xv > xmax || yv > ymax)                           continue;                      int x = (int)(((Math.Min(xv' xmax) - xmin) / (xmax - xmin)) * maxPointWidth);                      int y = (int)(((Math.Min(yv' ymax) - ymin) / (ymax - ymin)) * maxPointHeight);                      if (y != int.MinValue && x != int.MinValue)                      {                                          Point p = new Point(Layout.PlotArea.Left + x' Layout.PlotArea.Top + (maxPointHeight - y));                          //GJL 010308 Line subtype scatter plot                      if ((ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.Line || (ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.SmoothLine || isLine)                          {                              if (!(lastPoint.IsEmpty))                              {                              Points[0] = lastPoint;                              Points[1] = p;                              String LineSize = getLineSize(rpt' iCol' 1);                              int intLineSize = 2;                              switch (LineSize)                              {                                  case "Small": intLineSize = 1;                                      break;                                  case "Regular": intLineSize = 2;                                      break;                                  case "Large": intLineSize = 3;                                      break;                                  case "Extra Large": intLineSize = 4;                                      break;                                  case "Super Size": intLineSize = 5;                                      break;                              }                              DrawLineBetweenPoints(g' rpt' GetSeriesBrush(rpt' iRow' iCol)' Points' intLineSize);                              //Add a metafilecomment to use as a tooltip GJL 26092008                                                          if (_showToolTips || _showToolTipsX)                              {                                  string display = "";                                  if (_showToolTipsX) display = xv.ToString(_tooltipXFormat);                                  if (_showToolTips)                                  {                                      if (display.Length > 0) display += " ' ";                                      display += yv.ToString(_tooltipYFormat);                                  }                                  String val = "ToolTip:" + display + "|X:" + (int)(p.X - 3) + "|Y:" + (int)(p.Y - 3) + "|W:" + 6 + "|H:" + 6;                                                               g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                              }                                  }                          }                          else                          {                                DrawBubble(rpt' g' GetSeriesBrush(rpt' iRow' iCol)' p' iRow' iCol' bmin' bmax' bv'xv'yv);                            }                          lastPoint = p;                       }                                   }              }
Magic Number,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawPlot,The following statement contains a magic number: for (int iCol = 1; iCol <= SeriesCount; iCol++)              {                  //handle either line scatter or line plot type GJL 020308                  Point lastPoint = new Point();                  Point[] Points = new Point[2];                  bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                  for (int iRow = 1; iRow <= CategoryCount; iRow++)                  {                      double xv = this.GetDataValue(rpt' iRow' iCol' 0);                      double yv = this.GetDataValue(rpt' iRow' iCol' 1);                      double bv = this.ChartDefn.Type == ChartTypeEnum.Bubble ?                          this.GetDataValue(rpt' iRow' iCol' 2) : 0;                      if (xv < xmin || yv < ymin || xv > xmax || yv > ymax)                           continue;                      int x = (int)(((Math.Min(xv' xmax) - xmin) / (xmax - xmin)) * maxPointWidth);                      int y = (int)(((Math.Min(yv' ymax) - ymin) / (ymax - ymin)) * maxPointHeight);                      if (y != int.MinValue && x != int.MinValue)                      {                                          Point p = new Point(Layout.PlotArea.Left + x' Layout.PlotArea.Top + (maxPointHeight - y));                          //GJL 010308 Line subtype scatter plot                      if ((ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.Line || (ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.SmoothLine || isLine)                          {                              if (!(lastPoint.IsEmpty))                              {                              Points[0] = lastPoint;                              Points[1] = p;                              String LineSize = getLineSize(rpt' iCol' 1);                              int intLineSize = 2;                              switch (LineSize)                              {                                  case "Small": intLineSize = 1;                                      break;                                  case "Regular": intLineSize = 2;                                      break;                                  case "Large": intLineSize = 3;                                      break;                                  case "Extra Large": intLineSize = 4;                                      break;                                  case "Super Size": intLineSize = 5;                                      break;                              }                              DrawLineBetweenPoints(g' rpt' GetSeriesBrush(rpt' iRow' iCol)' Points' intLineSize);                              //Add a metafilecomment to use as a tooltip GJL 26092008                                                          if (_showToolTips || _showToolTipsX)                              {                                  string display = "";                                  if (_showToolTipsX) display = xv.ToString(_tooltipXFormat);                                  if (_showToolTips)                                  {                                      if (display.Length > 0) display += " ' ";                                      display += yv.ToString(_tooltipYFormat);                                  }                                  String val = "ToolTip:" + display + "|X:" + (int)(p.X - 3) + "|Y:" + (int)(p.Y - 3) + "|W:" + 6 + "|H:" + 6;                                                               g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                              }                                  }                          }                          else                          {                                DrawBubble(rpt' g' GetSeriesBrush(rpt' iRow' iCol)' p' iRow' iCol' bmin' bmax' bv'xv'yv);                            }                          lastPoint = p;                       }                                   }              }
Magic Number,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawPlot,The following statement contains a magic number: for (int iCol = 1; iCol <= SeriesCount; iCol++)              {                  //handle either line scatter or line plot type GJL 020308                  Point lastPoint = new Point();                  Point[] Points = new Point[2];                  bool isLine = GetPlotType(rpt' iCol' 1).ToUpper() == "LINE";                  for (int iRow = 1; iRow <= CategoryCount; iRow++)                  {                      double xv = this.GetDataValue(rpt' iRow' iCol' 0);                      double yv = this.GetDataValue(rpt' iRow' iCol' 1);                      double bv = this.ChartDefn.Type == ChartTypeEnum.Bubble ?                          this.GetDataValue(rpt' iRow' iCol' 2) : 0;                      if (xv < xmin || yv < ymin || xv > xmax || yv > ymax)                           continue;                      int x = (int)(((Math.Min(xv' xmax) - xmin) / (xmax - xmin)) * maxPointWidth);                      int y = (int)(((Math.Min(yv' ymax) - ymin) / (ymax - ymin)) * maxPointHeight);                      if (y != int.MinValue && x != int.MinValue)                      {                                          Point p = new Point(Layout.PlotArea.Left + x' Layout.PlotArea.Top + (maxPointHeight - y));                          //GJL 010308 Line subtype scatter plot                      if ((ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.Line || (ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.SmoothLine || isLine)                          {                              if (!(lastPoint.IsEmpty))                              {                              Points[0] = lastPoint;                              Points[1] = p;                              String LineSize = getLineSize(rpt' iCol' 1);                              int intLineSize = 2;                              switch (LineSize)                              {                                  case "Small": intLineSize = 1;                                      break;                                  case "Regular": intLineSize = 2;                                      break;                                  case "Large": intLineSize = 3;                                      break;                                  case "Extra Large": intLineSize = 4;                                      break;                                  case "Super Size": intLineSize = 5;                                      break;                              }                              DrawLineBetweenPoints(g' rpt' GetSeriesBrush(rpt' iRow' iCol)' Points' intLineSize);                              //Add a metafilecomment to use as a tooltip GJL 26092008                                                          if (_showToolTips || _showToolTipsX)                              {                                  string display = "";                                  if (_showToolTipsX) display = xv.ToString(_tooltipXFormat);                                  if (_showToolTips)                                  {                                      if (display.Length > 0) display += " ' ";                                      display += yv.ToString(_tooltipYFormat);                                  }                                  String val = "ToolTip:" + display + "|X:" + (int)(p.X - 3) + "|Y:" + (int)(p.Y - 3) + "|W:" + 6 + "|H:" + 6;                                                               g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                              }                                  }                          }                          else                          {                                DrawBubble(rpt' g' GetSeriesBrush(rpt' iRow' iCol)' p' iRow' iCol' bmin' bmax' bv'xv'yv);                            }                          lastPoint = p;                       }                                   }              }
Magic Number,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawLineBetweenPoints,The following statement contains a magic number: DrawLineBetweenPoints(g' rpt' brush' points' 2);
Magic Number,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawLineBetweenPoints,The following statement contains a magic number: try              {                  if (brush.GetType() == typeof(System.Drawing.Drawing2D.HatchBrush))                  {                      System.Drawing.Drawing2D.HatchBrush tmpBrush = (System.Drawing.Drawing2D.HatchBrush)brush;                      p = new Pen(new SolidBrush(tmpBrush.ForegroundColor)' intLineSize); //1.5F);    // todo - use line from style ????                  }                  else                  {                      p = new Pen(brush' intLineSize);                  }                    if ((ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.Smooth && points.Length > 2)                      g.DrawCurve(p' points' 0.5F);                  else                      g.DrawLines(p' points);              }              finally              {                  if (p != null)                      p.Dispose();              }
Magic Number,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawBubble,The following statement contains a magic number: int radius=  diameter /2;
Magic Number,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawBubble,The following statement contains a magic number: try  			{                  if (this.ChartDefn.Type == ChartTypeEnum.Scatter &&                      brush.GetType() == typeof(System.Drawing.Drawing2D.HatchBrush))                  {                      System.Drawing.Drawing2D.HatchBrush tmpBrush = (System.Drawing.Drawing2D.HatchBrush)brush;                      SolidBrush br = new SolidBrush(tmpBrush.ForegroundColor);                      pen = new Pen(new SolidBrush(tmpBrush.ForegroundColor));                      DrawLegendMarker(g' br' pen' SeriesMarker[iCol - 1]' p.X - radius' p.Y - radius' diameter);                                          DrawDataPoint(rpt' g' new Point(p.X - 3' p.Y + 3)' iRow' iCol);                                     }                  else                  {  				    pen = new Pen(brush);                      DrawLegendMarker(g' brush' pen' ChartMarkerEnum.Bubble' p.X - radius' p.Y - radius' diameter);                      DrawDataPoint(rpt' g' new Point(p.X - 3' p.Y + 3)' iRow' iCol);  			    }                  //Add a metafilecomment to use as a tooltip GJL 26092008                                   if (_showToolTips || _showToolTipsX)                  {                      string display = "";                      if (_showToolTipsX) display = xv.ToString(_tooltipXFormat);                      if (_showToolTips)                      {                          if (display.Length > 0) display += " ' ";                          display += yv.ToString(_tooltipYFormat);                      }                      String val = "ToolTip:" + display + "|X:" + (int)(p.X - 3) + "|Y:" + (int)(p.Y - 3) + "|W:" + 6 + "|H:" + 6;                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                  }  			}  			finally  			{  				if (pen != null)  					pen.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawBubble,The following statement contains a magic number: try  			{                  if (this.ChartDefn.Type == ChartTypeEnum.Scatter &&                      brush.GetType() == typeof(System.Drawing.Drawing2D.HatchBrush))                  {                      System.Drawing.Drawing2D.HatchBrush tmpBrush = (System.Drawing.Drawing2D.HatchBrush)brush;                      SolidBrush br = new SolidBrush(tmpBrush.ForegroundColor);                      pen = new Pen(new SolidBrush(tmpBrush.ForegroundColor));                      DrawLegendMarker(g' br' pen' SeriesMarker[iCol - 1]' p.X - radius' p.Y - radius' diameter);                                          DrawDataPoint(rpt' g' new Point(p.X - 3' p.Y + 3)' iRow' iCol);                                     }                  else                  {  				    pen = new Pen(brush);                      DrawLegendMarker(g' brush' pen' ChartMarkerEnum.Bubble' p.X - radius' p.Y - radius' diameter);                      DrawDataPoint(rpt' g' new Point(p.X - 3' p.Y + 3)' iRow' iCol);  			    }                  //Add a metafilecomment to use as a tooltip GJL 26092008                                   if (_showToolTips || _showToolTipsX)                  {                      string display = "";                      if (_showToolTipsX) display = xv.ToString(_tooltipXFormat);                      if (_showToolTips)                      {                          if (display.Length > 0) display += " ' ";                          display += yv.ToString(_tooltipYFormat);                      }                      String val = "ToolTip:" + display + "|X:" + (int)(p.X - 3) + "|Y:" + (int)(p.Y - 3) + "|W:" + 6 + "|H:" + 6;                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                  }  			}  			finally  			{  				if (pen != null)  					pen.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawBubble,The following statement contains a magic number: try  			{                  if (this.ChartDefn.Type == ChartTypeEnum.Scatter &&                      brush.GetType() == typeof(System.Drawing.Drawing2D.HatchBrush))                  {                      System.Drawing.Drawing2D.HatchBrush tmpBrush = (System.Drawing.Drawing2D.HatchBrush)brush;                      SolidBrush br = new SolidBrush(tmpBrush.ForegroundColor);                      pen = new Pen(new SolidBrush(tmpBrush.ForegroundColor));                      DrawLegendMarker(g' br' pen' SeriesMarker[iCol - 1]' p.X - radius' p.Y - radius' diameter);                                          DrawDataPoint(rpt' g' new Point(p.X - 3' p.Y + 3)' iRow' iCol);                                     }                  else                  {  				    pen = new Pen(brush);                      DrawLegendMarker(g' brush' pen' ChartMarkerEnum.Bubble' p.X - radius' p.Y - radius' diameter);                      DrawDataPoint(rpt' g' new Point(p.X - 3' p.Y + 3)' iRow' iCol);  			    }                  //Add a metafilecomment to use as a tooltip GJL 26092008                                   if (_showToolTips || _showToolTipsX)                  {                      string display = "";                      if (_showToolTipsX) display = xv.ToString(_tooltipXFormat);                      if (_showToolTips)                      {                          if (display.Length > 0) display += " ' ";                          display += yv.ToString(_tooltipYFormat);                      }                      String val = "ToolTip:" + display + "|X:" + (int)(p.X - 3) + "|Y:" + (int)(p.Y - 3) + "|W:" + 6 + "|H:" + 6;                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                  }  			}  			finally  			{  				if (pen != null)  					pen.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawBubble,The following statement contains a magic number: try  			{                  if (this.ChartDefn.Type == ChartTypeEnum.Scatter &&                      brush.GetType() == typeof(System.Drawing.Drawing2D.HatchBrush))                  {                      System.Drawing.Drawing2D.HatchBrush tmpBrush = (System.Drawing.Drawing2D.HatchBrush)brush;                      SolidBrush br = new SolidBrush(tmpBrush.ForegroundColor);                      pen = new Pen(new SolidBrush(tmpBrush.ForegroundColor));                      DrawLegendMarker(g' br' pen' SeriesMarker[iCol - 1]' p.X - radius' p.Y - radius' diameter);                                          DrawDataPoint(rpt' g' new Point(p.X - 3' p.Y + 3)' iRow' iCol);                                     }                  else                  {  				    pen = new Pen(brush);                      DrawLegendMarker(g' brush' pen' ChartMarkerEnum.Bubble' p.X - radius' p.Y - radius' diameter);                      DrawDataPoint(rpt' g' new Point(p.X - 3' p.Y + 3)' iRow' iCol);  			    }                  //Add a metafilecomment to use as a tooltip GJL 26092008                                   if (_showToolTips || _showToolTipsX)                  {                      string display = "";                      if (_showToolTipsX) display = xv.ToString(_tooltipXFormat);                      if (_showToolTips)                      {                          if (display.Length > 0) display += " ' ";                          display += yv.ToString(_tooltipYFormat);                      }                      String val = "ToolTip:" + display + "|X:" + (int)(p.X - 3) + "|Y:" + (int)(p.Y - 3) + "|W:" + 6 + "|H:" + 6;                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                  }  			}  			finally  			{  				if (pen != null)  					pen.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawBubble,The following statement contains a magic number: try  			{                  if (this.ChartDefn.Type == ChartTypeEnum.Scatter &&                      brush.GetType() == typeof(System.Drawing.Drawing2D.HatchBrush))                  {                      System.Drawing.Drawing2D.HatchBrush tmpBrush = (System.Drawing.Drawing2D.HatchBrush)brush;                      SolidBrush br = new SolidBrush(tmpBrush.ForegroundColor);                      pen = new Pen(new SolidBrush(tmpBrush.ForegroundColor));                      DrawLegendMarker(g' br' pen' SeriesMarker[iCol - 1]' p.X - radius' p.Y - radius' diameter);                                          DrawDataPoint(rpt' g' new Point(p.X - 3' p.Y + 3)' iRow' iCol);                                     }                  else                  {  				    pen = new Pen(brush);                      DrawLegendMarker(g' brush' pen' ChartMarkerEnum.Bubble' p.X - radius' p.Y - radius' diameter);                      DrawDataPoint(rpt' g' new Point(p.X - 3' p.Y + 3)' iRow' iCol);  			    }                  //Add a metafilecomment to use as a tooltip GJL 26092008                                   if (_showToolTips || _showToolTipsX)                  {                      string display = "";                      if (_showToolTipsX) display = xv.ToString(_tooltipXFormat);                      if (_showToolTips)                      {                          if (display.Length > 0) display += " ' ";                          display += yv.ToString(_tooltipYFormat);                      }                      String val = "ToolTip:" + display + "|X:" + (int)(p.X - 3) + "|Y:" + (int)(p.Y - 3) + "|W:" + 6 + "|H:" + 6;                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                  }  			}  			finally  			{  				if (pen != null)  					pen.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawBubble,The following statement contains a magic number: try  			{                  if (this.ChartDefn.Type == ChartTypeEnum.Scatter &&                      brush.GetType() == typeof(System.Drawing.Drawing2D.HatchBrush))                  {                      System.Drawing.Drawing2D.HatchBrush tmpBrush = (System.Drawing.Drawing2D.HatchBrush)brush;                      SolidBrush br = new SolidBrush(tmpBrush.ForegroundColor);                      pen = new Pen(new SolidBrush(tmpBrush.ForegroundColor));                      DrawLegendMarker(g' br' pen' SeriesMarker[iCol - 1]' p.X - radius' p.Y - radius' diameter);                                          DrawDataPoint(rpt' g' new Point(p.X - 3' p.Y + 3)' iRow' iCol);                                     }                  else                  {  				    pen = new Pen(brush);                      DrawLegendMarker(g' brush' pen' ChartMarkerEnum.Bubble' p.X - radius' p.Y - radius' diameter);                      DrawDataPoint(rpt' g' new Point(p.X - 3' p.Y + 3)' iRow' iCol);  			    }                  //Add a metafilecomment to use as a tooltip GJL 26092008                                   if (_showToolTips || _showToolTipsX)                  {                      string display = "";                      if (_showToolTipsX) display = xv.ToString(_tooltipXFormat);                      if (_showToolTips)                      {                          if (display.Length > 0) display += " ' ";                          display += yv.ToString(_tooltipYFormat);                      }                      String val = "ToolTip:" + display + "|X:" + (int)(p.X - 3) + "|Y:" + (int)(p.Y - 3) + "|W:" + 6 + "|H:" + 6;                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                  }  			}  			finally  			{  				if (pen != null)  					pen.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawBubble,The following statement contains a magic number: try  			{                  if (this.ChartDefn.Type == ChartTypeEnum.Scatter &&                      brush.GetType() == typeof(System.Drawing.Drawing2D.HatchBrush))                  {                      System.Drawing.Drawing2D.HatchBrush tmpBrush = (System.Drawing.Drawing2D.HatchBrush)brush;                      SolidBrush br = new SolidBrush(tmpBrush.ForegroundColor);                      pen = new Pen(new SolidBrush(tmpBrush.ForegroundColor));                      DrawLegendMarker(g' br' pen' SeriesMarker[iCol - 1]' p.X - radius' p.Y - radius' diameter);                                          DrawDataPoint(rpt' g' new Point(p.X - 3' p.Y + 3)' iRow' iCol);                                     }                  else                  {  				    pen = new Pen(brush);                      DrawLegendMarker(g' brush' pen' ChartMarkerEnum.Bubble' p.X - radius' p.Y - radius' diameter);                      DrawDataPoint(rpt' g' new Point(p.X - 3' p.Y + 3)' iRow' iCol);  			    }                  //Add a metafilecomment to use as a tooltip GJL 26092008                                   if (_showToolTips || _showToolTipsX)                  {                      string display = "";                      if (_showToolTipsX) display = xv.ToString(_tooltipXFormat);                      if (_showToolTips)                      {                          if (display.Length > 0) display += " ' ";                          display += yv.ToString(_tooltipYFormat);                      }                      String val = "ToolTip:" + display + "|X:" + (int)(p.X - 3) + "|Y:" + (int)(p.Y - 3) + "|W:" + 6 + "|H:" + 6;                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                  }  			}  			finally  			{  				if (pen != null)  					pen.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawBubble,The following statement contains a magic number: try  			{                  if (this.ChartDefn.Type == ChartTypeEnum.Scatter &&                      brush.GetType() == typeof(System.Drawing.Drawing2D.HatchBrush))                  {                      System.Drawing.Drawing2D.HatchBrush tmpBrush = (System.Drawing.Drawing2D.HatchBrush)brush;                      SolidBrush br = new SolidBrush(tmpBrush.ForegroundColor);                      pen = new Pen(new SolidBrush(tmpBrush.ForegroundColor));                      DrawLegendMarker(g' br' pen' SeriesMarker[iCol - 1]' p.X - radius' p.Y - radius' diameter);                                          DrawDataPoint(rpt' g' new Point(p.X - 3' p.Y + 3)' iRow' iCol);                                     }                  else                  {  				    pen = new Pen(brush);                      DrawLegendMarker(g' brush' pen' ChartMarkerEnum.Bubble' p.X - radius' p.Y - radius' diameter);                      DrawDataPoint(rpt' g' new Point(p.X - 3' p.Y + 3)' iRow' iCol);  			    }                  //Add a metafilecomment to use as a tooltip GJL 26092008                                   if (_showToolTips || _showToolTipsX)                  {                      string display = "";                      if (_showToolTipsX) display = xv.ToString(_tooltipXFormat);                      if (_showToolTips)                      {                          if (display.Length > 0) display += " ' ";                          display += yv.ToString(_tooltipYFormat);                      }                      String val = "ToolTip:" + display + "|X:" + (int)(p.X - 3) + "|Y:" + (int)(p.Y - 3) + "|W:" + 6 + "|H:" + 6;                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                  }  			}  			finally  			{  				if (pen != null)  					pen.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,BubbleSize,The following statement contains a magic number: int diameter = 5;
Magic Number,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,BubbleSize,The following statement contains a magic number: int bubbleMax = 30;
Magic Number,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,BubbleSize,The following statement contains a magic number: int bubbleMin = 4;
Magic Number,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawValueAxis,The following statement contains a magic number: for (int i = 0; i < intervalCount + 1; i++)              {                  int h = (int)(((Math.Min(v' max) - min) / (max - min)) * rect.Height);                  if (h < 0)		// this is really some form of error                  {                      v += incr;                      continue;                  }                    if (!a.Visible)                  {                      // nothing to do                  }                  else if (s != null)                  {                      Size size = s.MeasureString(rpt' g' v' TypeCode.Double' null' int.MaxValue);                      System.Drawing.Rectangle vRect =                          new System.Drawing.Rectangle(rect.Left + tSize.Width' rect.Top + rect.Height - h - size.Height / 2' rect.Width - tSize.Width' size.Height);                      s.DrawString(rpt' g' v' TypeCode.Double' null' vRect);                  }                  else                  {                      Size size = Style.MeasureStringDefaults(rpt' g' v' TypeCode.Double' null' int.MaxValue);                      System.Drawing.Rectangle vRect =                          new System.Drawing.Rectangle(rect.Left + tSize.Width' rect.Top + rect.Height - h - size.Height / 2' rect.Width - tSize.Width' size.Height);                      Style.DrawStringDefaults(g' v' vRect);                  }                    DrawValueAxisGrid(rpt' g' a.MajorGridLines' new Point(plotLeft' rect.Top + rect.Height - h)' new Point(plotRight' rect.Top + rect.Height - h));                  DrawValueAxisTick(rpt' g' true' a.MajorTickMarks' a.MajorGridLines' new Point(plotLeft' rect.Top + rect.Height - h));                    v += incr;              }
Magic Number,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawValueAxis,The following statement contains a magic number: for (int i = 0; i < intervalCount + 1; i++)              {                  int h = (int)(((Math.Min(v' max) - min) / (max - min)) * rect.Height);                  if (h < 0)		// this is really some form of error                  {                      v += incr;                      continue;                  }                    if (!a.Visible)                  {                      // nothing to do                  }                  else if (s != null)                  {                      Size size = s.MeasureString(rpt' g' v' TypeCode.Double' null' int.MaxValue);                      System.Drawing.Rectangle vRect =                          new System.Drawing.Rectangle(rect.Left + tSize.Width' rect.Top + rect.Height - h - size.Height / 2' rect.Width - tSize.Width' size.Height);                      s.DrawString(rpt' g' v' TypeCode.Double' null' vRect);                  }                  else                  {                      Size size = Style.MeasureStringDefaults(rpt' g' v' TypeCode.Double' null' int.MaxValue);                      System.Drawing.Rectangle vRect =                          new System.Drawing.Rectangle(rect.Left + tSize.Width' rect.Top + rect.Height - h - size.Height / 2' rect.Width - tSize.Width' size.Height);                      Style.DrawStringDefaults(g' v' vRect);                  }                    DrawValueAxisGrid(rpt' g' a.MajorGridLines' new Point(plotLeft' rect.Top + rect.Height - h)' new Point(plotRight' rect.Top + rect.Height - h));                  DrawValueAxisTick(rpt' g' true' a.MajorTickMarks' a.MajorGridLines' new Point(plotLeft' rect.Top + rect.Height - h));                    v += incr;              }
Magic Number,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawCategoryAxis,The following statement contains a magic number: for (int i = 0; i < intervalCount + 1; i++)              {                  int x = (int)(((Math.Min(v' max) - min) / (max - min)) * rect.Width);                    if (!a.Visible)                  {                      // nothing to do                  }                  else if (s != null)                  {                      size = s.MeasureString(rpt' g' v' TypeCode.Double' null' int.MaxValue);                      System.Drawing.Rectangle vRect =                          new System.Drawing.Rectangle(rect.Left + x - size.Width / 2' rect.Top + tickSize' size.Width' size.Height);                      s.DrawString(rpt' g' v' TypeCode.Double' null' vRect);                  }                  else                  {                      size = Style.MeasureStringDefaults(rpt' g' v' TypeCode.Double' null' int.MaxValue);                      System.Drawing.Rectangle vRect =                          new System.Drawing.Rectangle(rect.Left + x - size.Width / 2' rect.Top + tickSize' size.Width' size.Height);                      Style.DrawStringDefaults(g' v' vRect);                  }                  if (size.Height > maxValueHeight)		// Need to keep track of the maximum height                      maxValueHeight = size.Height;		//   this is probably overkill since it should always be the same??                    DrawCategoryAxisGrid(rpt' g' a.MajorGridLines' new Point(rect.Left + x' plotTop)' new Point(rect.Left + x' plotBottom));                  DrawCategoryAxisTick(rpt' g' true' a.MajorTickMarks' a.MajorGridLines' new Point(rect.Left + x' plotBottom));                    v += incr;              }
Magic Number,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawCategoryAxis,The following statement contains a magic number: for (int i = 0; i < intervalCount + 1; i++)              {                  int x = (int)(((Math.Min(v' max) - min) / (max - min)) * rect.Width);                    if (!a.Visible)                  {                      // nothing to do                  }                  else if (s != null)                  {                      size = s.MeasureString(rpt' g' v' TypeCode.Double' null' int.MaxValue);                      System.Drawing.Rectangle vRect =                          new System.Drawing.Rectangle(rect.Left + x - size.Width / 2' rect.Top + tickSize' size.Width' size.Height);                      s.DrawString(rpt' g' v' TypeCode.Double' null' vRect);                  }                  else                  {                      size = Style.MeasureStringDefaults(rpt' g' v' TypeCode.Double' null' int.MaxValue);                      System.Drawing.Rectangle vRect =                          new System.Drawing.Rectangle(rect.Left + x - size.Width / 2' rect.Top + tickSize' size.Width' size.Height);                      Style.DrawStringDefaults(g' v' vRect);                  }                  if (size.Height > maxValueHeight)		// Need to keep track of the maximum height                      maxValueHeight = size.Height;		//   this is probably overkill since it should always be the same??                    DrawCategoryAxisGrid(rpt' g' a.MajorGridLines' new Point(rect.Left + x' plotTop)' new Point(rect.Left + x' plotBottom));                  DrawCategoryAxisTick(rpt' g' true' a.MajorTickMarks' a.MajorGridLines' new Point(rect.Left + x' plotBottom));                    v += incr;              }
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,Draw,The following statement contains a magic number: using(Graphics g = Graphics.FromImage(_mf))  			{                  // 06122007AJM Used to Force Higher Quality                  g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.HighQualityBicubic;                  g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.HighQuality;                  g.PixelOffsetMode = System.Drawing.Drawing2D.PixelOffsetMode.None;                  g.CompositingQuality = System.Drawing.Drawing2D.CompositingQuality.HighQuality;    				// Adjust the top margin to depend on the title height  				Size titleSize = DrawTitleMeasure(rpt' g' ChartDefn.Title);  				Layout.TopMargin = titleSize.Height;    				double max=0'min=0;	// Get the max and min values  				GetValueMaxMin(rpt' ref max' ref min'0' 1);    				DrawChartStyle(rpt' g);  				  				// Draw title; routine determines if necessary  				DrawTitle(rpt' g' ChartDefn.Title' new System.Drawing.Rectangle(0' 0' _bm.Width' Layout.TopMargin));    				// Adjust the left margin to depend on the Value Axis  				Size vaSize = ValueAxisSize(rpt' g' min' max);  				Layout.LeftMargin = vaSize.Width;                    // Adjust the right margin to depend on the Value Axis                  bool Show2ndY = ShowRightYAxis(rpt);                  Size vaSize2= vaSize;                    if (Show2ndY)                  {                      double rmax = 0' rmin = 0;                      GetMaxMinDataValue(rpt' out rmax' out rmin' 0' 2);                      vaSize2 = ValueAxisSize(rpt' g' rmin' rmax);                      Layout.RightMargin = vaSize2.Width;                  }    				// Draw legend  				System.Drawing.Rectangle lRect = DrawLegend(rpt' g' false' true);    				// Adjust the bottom margin to depend on the Category Axis                  Size caSize = CategoryAxisSize(rpt' g);  				Layout.BottomMargin = caSize.Height;    				AdjustMargins(lRect'rpt' g);		// Adjust margins based on legend.    				// Draw Plot area  				DrawPlotAreaStyle(rpt' g' lRect);                    int intervalCount = 0; //GJL - Used to get the interval count out of DrawValueAxis so that we don't recalculate it again.                  double incr = 0.0;	//GJL - As above  				// Draw Value Axis //GJL now as by ref params to return the values to the above variables  				if (vaSize.Width > 0)	// If we made room for the axis - we need to draw it  					DrawValueAxis(rpt' g' min' max'   						new System.Drawing.Rectangle(Layout.LeftMargin - vaSize.Width' Layout.TopMargin' vaSize.Width' _bm.Height - Layout.TopMargin - Layout.BottomMargin)' Layout.LeftMargin' Layout.Width - Layout.RightMargin'out incr'out intervalCount);                                                     //********************************************************************************************************************************************                  //Draw the 2nd value axis - obviously we will only want to do this if we choose a second axis                            double ScaleFactor = 1.0;                  //Secong value axis                              if (Show2ndY)                      Draw2ndValueAxis(rpt' g' min' max' new System.Drawing.Rectangle(Layout.LeftMargin + Layout.PlotArea.Width' Layout.TopMargin' vaSize2.Width' _bm.Height - Layout.TopMargin - Layout.BottomMargin)' Layout.LeftMargin' Layout.Width - Layout.RightMargin' incr' intervalCount' ref ScaleFactor);                             				// Draw Category Axis  				if (caSize.Height > 0)                      // 090508ajm passing chart bounds in  					DrawCategoryAxis(rpt' g'                          new System.Drawing.Rectangle(Layout.LeftMargin' _bm.Height - Layout.BottomMargin' Layout.PlotArea.Width' caSize.Height)' Layout.TopMargin' caSize.Width);                  if ((ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.Stacked)  					DrawPlotAreaStacked(rpt' g' max' min);                  else if ((ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.PercentStacked)  					DrawPlotAreaPercentStacked(rpt' g);  				else  					DrawPlotAreaPlain(rpt' g' max' min'ScaleFactor);    				DrawLegend(rpt' g' false' false);    			}
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawPlotAreaPercentStacked,The following statement contains a magic number: int gapsNeeded = CategoryCount * 2;
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawPlotAreaPlain,The following statement contains a magic number: int gapsNeeded = CategoryCount * 2;
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawPlotAreaPlain,The following statement contains a magic number: for (int iRow=1; iRow <= CategoryCount; iRow++)  			{  				int barLoc=(int) (Layout.PlotArea.Left + (iRow-1) * ((double) (Layout.PlotArea.Width) / CategoryCount));    				barLoc += _GapSize;	// space before series                  lineLoc = barLoc + widthBar * ColumnCount / 2;                  for (int z = 0; z < 2; z++)                   {                      for (int iCol = 1; iCol <= SeriesCount; iCol++)                      {                          /* This for loop has been modified to select if the column should                           * be drawn based on the Plot type of the column                           * 05122007AJM */                          if (GetPlotType(rpt' iCol' iRow).ToUpper() != "LINE")                          {                              if (z == 0)                              {                                  double v = this.GetDataValue(rpt' iRow' iCol);                                  double tooltipVal = v;                                  if (GetYAxis(rpt' iCol' iRow).ToUpper() != "LEFT")                                  {                                      //Scale the Y data...                                      v /= ScaleFactor;                                  }                                    if (v.CompareTo(double.NaN) == 0)                                      v = min;                                  int h = (int)(((Math.Min(v' max) - min) / (max - min)) * maxBarHeight);                                    DrawColumnBar(rpt' g' GetSeriesBrush(rpt' iRow' iCol)'                                      new System.Drawing.Rectangle(barLoc' Layout.PlotArea.Top + (maxBarHeight - h)' widthBar' h)' iRow' iCol);                                    //Add a metafilecomment to use as a tooltip GJL 26092008                                  if (_showToolTips)                                  {                                      String val = "ToolTip:" + tooltipVal.ToString(_tooltipYFormat) + "|X:" + barLoc + "|Y:" + (int)(Layout.PlotArea.Top + (maxBarHeight - h)) + "|W:" + widthBar + "|H:" + h;                                      g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                                  }                                                                       barLoc += widthBar;                              }                          }                          else //This is a line type plot                          {                              if (z == 1)                              {                                  double v = this.GetDataValue(rpt' iRow' iCol);                                  double tooltipVal = v;                                  if (GetYAxis(rpt' iCol' iRow).ToUpper() != "LEFT")                                  {                                      //Scale the Y data...                                      v /= ScaleFactor;                                  }                                    DrawPoint = true;                                    if (v.CompareTo(double.NaN) == 0)                                  {                                      //don't draw null                                          DrawPoint = false;                                      //insert empty point                                          LastPoints[iCol] = null;                                     }                                  if (DrawPoint)                                  {                                      int h = (int)(((Math.Min(v' max) - min) / (max - min)) * maxBarHeight);                                        System.Drawing.Rectangle r = new System.Drawing.Rectangle(lineLoc' Layout.PlotArea.Top + (maxBarHeight - h)' widthBar' h);                                        Point p = new Point(r.Left' r.Top);                                      if (LastPoints[iCol - 1] == null)                                          LastPoints[iCol - 1] = p;                                      bool DrawMarker = getNoMarkerVal(rpt' iCol' 1) == false;                                      DrawDataPoint(rpt' g' new Point(p.X' p.Y - 14)' iRow' iCol);  // todo: 14 is arbitrary                                      if (DrawMarker) { DrawLegendLineMarker(g' GetSeriesBrush(rpt' iRow' iCol)' new Pen(GetSeriesBrush(rpt' iRow' iCol))' SeriesMarker[iCol - 1]' p.X - 5' p.Y - 5' 10);}                                                                                                               if (LastPoints.ContainsKey(iCol) )                                      {                                          Point[] Points = new Point[2];                                          Points[0] = p;                                          Point pt = (Point)LastPoints[iCol];                                          Points[1] = new Point(pt.X - 1' pt.Y);                                          // 05052008AJM - Allowing for breaking lines in chart                                          if (Points[1] != null) {                                              String LineSize = getLineSize(rpt' iCol' 1);                                              int intLineSize = 1;                                              switch (LineSize)                                              {                                                  case "Small": intLineSize = 1;                                                      break;                                                  case "Regular": intLineSize = 2;                                                      break;                                                  case "Large": intLineSize = 3;                                                      break;                                                  case "Extra Large": intLineSize = 4;                                                      break;                                                  case "Super Size": intLineSize = 5;                                                      break;                                              }                                                DrawLineBetweenPoints(g' rpt' GetSeriesBrush(rpt' iRow' iCol)' Points'intLineSize);                                          }                                      }                                        //Add a metafilecomment to use as a tooltip GJL 26092008                                      if (_showToolTips)                                      {                                          String val = "ToolTip:" + tooltipVal.ToString(_tooltipYFormat) + "|X:" + (int)(p.X - 5) + "|Y:" + (int)(p.Y - 5) + "|W:10|H:10";                                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                                      }                                                                              LastPoints[iCol] = p;                                  }                              }                          }                      }  				}  			}
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawPlotAreaPlain,The following statement contains a magic number: for (int iRow=1; iRow <= CategoryCount; iRow++)  			{  				int barLoc=(int) (Layout.PlotArea.Left + (iRow-1) * ((double) (Layout.PlotArea.Width) / CategoryCount));    				barLoc += _GapSize;	// space before series                  lineLoc = barLoc + widthBar * ColumnCount / 2;                  for (int z = 0; z < 2; z++)                   {                      for (int iCol = 1; iCol <= SeriesCount; iCol++)                      {                          /* This for loop has been modified to select if the column should                           * be drawn based on the Plot type of the column                           * 05122007AJM */                          if (GetPlotType(rpt' iCol' iRow).ToUpper() != "LINE")                          {                              if (z == 0)                              {                                  double v = this.GetDataValue(rpt' iRow' iCol);                                  double tooltipVal = v;                                  if (GetYAxis(rpt' iCol' iRow).ToUpper() != "LEFT")                                  {                                      //Scale the Y data...                                      v /= ScaleFactor;                                  }                                    if (v.CompareTo(double.NaN) == 0)                                      v = min;                                  int h = (int)(((Math.Min(v' max) - min) / (max - min)) * maxBarHeight);                                    DrawColumnBar(rpt' g' GetSeriesBrush(rpt' iRow' iCol)'                                      new System.Drawing.Rectangle(barLoc' Layout.PlotArea.Top + (maxBarHeight - h)' widthBar' h)' iRow' iCol);                                    //Add a metafilecomment to use as a tooltip GJL 26092008                                  if (_showToolTips)                                  {                                      String val = "ToolTip:" + tooltipVal.ToString(_tooltipYFormat) + "|X:" + barLoc + "|Y:" + (int)(Layout.PlotArea.Top + (maxBarHeight - h)) + "|W:" + widthBar + "|H:" + h;                                      g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                                  }                                                                       barLoc += widthBar;                              }                          }                          else //This is a line type plot                          {                              if (z == 1)                              {                                  double v = this.GetDataValue(rpt' iRow' iCol);                                  double tooltipVal = v;                                  if (GetYAxis(rpt' iCol' iRow).ToUpper() != "LEFT")                                  {                                      //Scale the Y data...                                      v /= ScaleFactor;                                  }                                    DrawPoint = true;                                    if (v.CompareTo(double.NaN) == 0)                                  {                                      //don't draw null                                          DrawPoint = false;                                      //insert empty point                                          LastPoints[iCol] = null;                                     }                                  if (DrawPoint)                                  {                                      int h = (int)(((Math.Min(v' max) - min) / (max - min)) * maxBarHeight);                                        System.Drawing.Rectangle r = new System.Drawing.Rectangle(lineLoc' Layout.PlotArea.Top + (maxBarHeight - h)' widthBar' h);                                        Point p = new Point(r.Left' r.Top);                                      if (LastPoints[iCol - 1] == null)                                          LastPoints[iCol - 1] = p;                                      bool DrawMarker = getNoMarkerVal(rpt' iCol' 1) == false;                                      DrawDataPoint(rpt' g' new Point(p.X' p.Y - 14)' iRow' iCol);  // todo: 14 is arbitrary                                      if (DrawMarker) { DrawLegendLineMarker(g' GetSeriesBrush(rpt' iRow' iCol)' new Pen(GetSeriesBrush(rpt' iRow' iCol))' SeriesMarker[iCol - 1]' p.X - 5' p.Y - 5' 10);}                                                                                                               if (LastPoints.ContainsKey(iCol) )                                      {                                          Point[] Points = new Point[2];                                          Points[0] = p;                                          Point pt = (Point)LastPoints[iCol];                                          Points[1] = new Point(pt.X - 1' pt.Y);                                          // 05052008AJM - Allowing for breaking lines in chart                                          if (Points[1] != null) {                                              String LineSize = getLineSize(rpt' iCol' 1);                                              int intLineSize = 1;                                              switch (LineSize)                                              {                                                  case "Small": intLineSize = 1;                                                      break;                                                  case "Regular": intLineSize = 2;                                                      break;                                                  case "Large": intLineSize = 3;                                                      break;                                                  case "Extra Large": intLineSize = 4;                                                      break;                                                  case "Super Size": intLineSize = 5;                                                      break;                                              }                                                DrawLineBetweenPoints(g' rpt' GetSeriesBrush(rpt' iRow' iCol)' Points'intLineSize);                                          }                                      }                                        //Add a metafilecomment to use as a tooltip GJL 26092008                                      if (_showToolTips)                                      {                                          String val = "ToolTip:" + tooltipVal.ToString(_tooltipYFormat) + "|X:" + (int)(p.X - 5) + "|Y:" + (int)(p.Y - 5) + "|W:10|H:10";                                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                                      }                                                                              LastPoints[iCol] = p;                                  }                              }                          }                      }  				}  			}
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawPlotAreaPlain,The following statement contains a magic number: for (int iRow=1; iRow <= CategoryCount; iRow++)  			{  				int barLoc=(int) (Layout.PlotArea.Left + (iRow-1) * ((double) (Layout.PlotArea.Width) / CategoryCount));    				barLoc += _GapSize;	// space before series                  lineLoc = barLoc + widthBar * ColumnCount / 2;                  for (int z = 0; z < 2; z++)                   {                      for (int iCol = 1; iCol <= SeriesCount; iCol++)                      {                          /* This for loop has been modified to select if the column should                           * be drawn based on the Plot type of the column                           * 05122007AJM */                          if (GetPlotType(rpt' iCol' iRow).ToUpper() != "LINE")                          {                              if (z == 0)                              {                                  double v = this.GetDataValue(rpt' iRow' iCol);                                  double tooltipVal = v;                                  if (GetYAxis(rpt' iCol' iRow).ToUpper() != "LEFT")                                  {                                      //Scale the Y data...                                      v /= ScaleFactor;                                  }                                    if (v.CompareTo(double.NaN) == 0)                                      v = min;                                  int h = (int)(((Math.Min(v' max) - min) / (max - min)) * maxBarHeight);                                    DrawColumnBar(rpt' g' GetSeriesBrush(rpt' iRow' iCol)'                                      new System.Drawing.Rectangle(barLoc' Layout.PlotArea.Top + (maxBarHeight - h)' widthBar' h)' iRow' iCol);                                    //Add a metafilecomment to use as a tooltip GJL 26092008                                  if (_showToolTips)                                  {                                      String val = "ToolTip:" + tooltipVal.ToString(_tooltipYFormat) + "|X:" + barLoc + "|Y:" + (int)(Layout.PlotArea.Top + (maxBarHeight - h)) + "|W:" + widthBar + "|H:" + h;                                      g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                                  }                                                                       barLoc += widthBar;                              }                          }                          else //This is a line type plot                          {                              if (z == 1)                              {                                  double v = this.GetDataValue(rpt' iRow' iCol);                                  double tooltipVal = v;                                  if (GetYAxis(rpt' iCol' iRow).ToUpper() != "LEFT")                                  {                                      //Scale the Y data...                                      v /= ScaleFactor;                                  }                                    DrawPoint = true;                                    if (v.CompareTo(double.NaN) == 0)                                  {                                      //don't draw null                                          DrawPoint = false;                                      //insert empty point                                          LastPoints[iCol] = null;                                     }                                  if (DrawPoint)                                  {                                      int h = (int)(((Math.Min(v' max) - min) / (max - min)) * maxBarHeight);                                        System.Drawing.Rectangle r = new System.Drawing.Rectangle(lineLoc' Layout.PlotArea.Top + (maxBarHeight - h)' widthBar' h);                                        Point p = new Point(r.Left' r.Top);                                      if (LastPoints[iCol - 1] == null)                                          LastPoints[iCol - 1] = p;                                      bool DrawMarker = getNoMarkerVal(rpt' iCol' 1) == false;                                      DrawDataPoint(rpt' g' new Point(p.X' p.Y - 14)' iRow' iCol);  // todo: 14 is arbitrary                                      if (DrawMarker) { DrawLegendLineMarker(g' GetSeriesBrush(rpt' iRow' iCol)' new Pen(GetSeriesBrush(rpt' iRow' iCol))' SeriesMarker[iCol - 1]' p.X - 5' p.Y - 5' 10);}                                                                                                               if (LastPoints.ContainsKey(iCol) )                                      {                                          Point[] Points = new Point[2];                                          Points[0] = p;                                          Point pt = (Point)LastPoints[iCol];                                          Points[1] = new Point(pt.X - 1' pt.Y);                                          // 05052008AJM - Allowing for breaking lines in chart                                          if (Points[1] != null) {                                              String LineSize = getLineSize(rpt' iCol' 1);                                              int intLineSize = 1;                                              switch (LineSize)                                              {                                                  case "Small": intLineSize = 1;                                                      break;                                                  case "Regular": intLineSize = 2;                                                      break;                                                  case "Large": intLineSize = 3;                                                      break;                                                  case "Extra Large": intLineSize = 4;                                                      break;                                                  case "Super Size": intLineSize = 5;                                                      break;                                              }                                                DrawLineBetweenPoints(g' rpt' GetSeriesBrush(rpt' iRow' iCol)' Points'intLineSize);                                          }                                      }                                        //Add a metafilecomment to use as a tooltip GJL 26092008                                      if (_showToolTips)                                      {                                          String val = "ToolTip:" + tooltipVal.ToString(_tooltipYFormat) + "|X:" + (int)(p.X - 5) + "|Y:" + (int)(p.Y - 5) + "|W:10|H:10";                                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                                      }                                                                              LastPoints[iCol] = p;                                  }                              }                          }                      }  				}  			}
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawPlotAreaPlain,The following statement contains a magic number: for (int iRow=1; iRow <= CategoryCount; iRow++)  			{  				int barLoc=(int) (Layout.PlotArea.Left + (iRow-1) * ((double) (Layout.PlotArea.Width) / CategoryCount));    				barLoc += _GapSize;	// space before series                  lineLoc = barLoc + widthBar * ColumnCount / 2;                  for (int z = 0; z < 2; z++)                   {                      for (int iCol = 1; iCol <= SeriesCount; iCol++)                      {                          /* This for loop has been modified to select if the column should                           * be drawn based on the Plot type of the column                           * 05122007AJM */                          if (GetPlotType(rpt' iCol' iRow).ToUpper() != "LINE")                          {                              if (z == 0)                              {                                  double v = this.GetDataValue(rpt' iRow' iCol);                                  double tooltipVal = v;                                  if (GetYAxis(rpt' iCol' iRow).ToUpper() != "LEFT")                                  {                                      //Scale the Y data...                                      v /= ScaleFactor;                                  }                                    if (v.CompareTo(double.NaN) == 0)                                      v = min;                                  int h = (int)(((Math.Min(v' max) - min) / (max - min)) * maxBarHeight);                                    DrawColumnBar(rpt' g' GetSeriesBrush(rpt' iRow' iCol)'                                      new System.Drawing.Rectangle(barLoc' Layout.PlotArea.Top + (maxBarHeight - h)' widthBar' h)' iRow' iCol);                                    //Add a metafilecomment to use as a tooltip GJL 26092008                                  if (_showToolTips)                                  {                                      String val = "ToolTip:" + tooltipVal.ToString(_tooltipYFormat) + "|X:" + barLoc + "|Y:" + (int)(Layout.PlotArea.Top + (maxBarHeight - h)) + "|W:" + widthBar + "|H:" + h;                                      g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                                  }                                                                       barLoc += widthBar;                              }                          }                          else //This is a line type plot                          {                              if (z == 1)                              {                                  double v = this.GetDataValue(rpt' iRow' iCol);                                  double tooltipVal = v;                                  if (GetYAxis(rpt' iCol' iRow).ToUpper() != "LEFT")                                  {                                      //Scale the Y data...                                      v /= ScaleFactor;                                  }                                    DrawPoint = true;                                    if (v.CompareTo(double.NaN) == 0)                                  {                                      //don't draw null                                          DrawPoint = false;                                      //insert empty point                                          LastPoints[iCol] = null;                                     }                                  if (DrawPoint)                                  {                                      int h = (int)(((Math.Min(v' max) - min) / (max - min)) * maxBarHeight);                                        System.Drawing.Rectangle r = new System.Drawing.Rectangle(lineLoc' Layout.PlotArea.Top + (maxBarHeight - h)' widthBar' h);                                        Point p = new Point(r.Left' r.Top);                                      if (LastPoints[iCol - 1] == null)                                          LastPoints[iCol - 1] = p;                                      bool DrawMarker = getNoMarkerVal(rpt' iCol' 1) == false;                                      DrawDataPoint(rpt' g' new Point(p.X' p.Y - 14)' iRow' iCol);  // todo: 14 is arbitrary                                      if (DrawMarker) { DrawLegendLineMarker(g' GetSeriesBrush(rpt' iRow' iCol)' new Pen(GetSeriesBrush(rpt' iRow' iCol))' SeriesMarker[iCol - 1]' p.X - 5' p.Y - 5' 10);}                                                                                                               if (LastPoints.ContainsKey(iCol) )                                      {                                          Point[] Points = new Point[2];                                          Points[0] = p;                                          Point pt = (Point)LastPoints[iCol];                                          Points[1] = new Point(pt.X - 1' pt.Y);                                          // 05052008AJM - Allowing for breaking lines in chart                                          if (Points[1] != null) {                                              String LineSize = getLineSize(rpt' iCol' 1);                                              int intLineSize = 1;                                              switch (LineSize)                                              {                                                  case "Small": intLineSize = 1;                                                      break;                                                  case "Regular": intLineSize = 2;                                                      break;                                                  case "Large": intLineSize = 3;                                                      break;                                                  case "Extra Large": intLineSize = 4;                                                      break;                                                  case "Super Size": intLineSize = 5;                                                      break;                                              }                                                DrawLineBetweenPoints(g' rpt' GetSeriesBrush(rpt' iRow' iCol)' Points'intLineSize);                                          }                                      }                                        //Add a metafilecomment to use as a tooltip GJL 26092008                                      if (_showToolTips)                                      {                                          String val = "ToolTip:" + tooltipVal.ToString(_tooltipYFormat) + "|X:" + (int)(p.X - 5) + "|Y:" + (int)(p.Y - 5) + "|W:10|H:10";                                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                                      }                                                                              LastPoints[iCol] = p;                                  }                              }                          }                      }  				}  			}
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawPlotAreaPlain,The following statement contains a magic number: for (int iRow=1; iRow <= CategoryCount; iRow++)  			{  				int barLoc=(int) (Layout.PlotArea.Left + (iRow-1) * ((double) (Layout.PlotArea.Width) / CategoryCount));    				barLoc += _GapSize;	// space before series                  lineLoc = barLoc + widthBar * ColumnCount / 2;                  for (int z = 0; z < 2; z++)                   {                      for (int iCol = 1; iCol <= SeriesCount; iCol++)                      {                          /* This for loop has been modified to select if the column should                           * be drawn based on the Plot type of the column                           * 05122007AJM */                          if (GetPlotType(rpt' iCol' iRow).ToUpper() != "LINE")                          {                              if (z == 0)                              {                                  double v = this.GetDataValue(rpt' iRow' iCol);                                  double tooltipVal = v;                                  if (GetYAxis(rpt' iCol' iRow).ToUpper() != "LEFT")                                  {                                      //Scale the Y data...                                      v /= ScaleFactor;                                  }                                    if (v.CompareTo(double.NaN) == 0)                                      v = min;                                  int h = (int)(((Math.Min(v' max) - min) / (max - min)) * maxBarHeight);                                    DrawColumnBar(rpt' g' GetSeriesBrush(rpt' iRow' iCol)'                                      new System.Drawing.Rectangle(barLoc' Layout.PlotArea.Top + (maxBarHeight - h)' widthBar' h)' iRow' iCol);                                    //Add a metafilecomment to use as a tooltip GJL 26092008                                  if (_showToolTips)                                  {                                      String val = "ToolTip:" + tooltipVal.ToString(_tooltipYFormat) + "|X:" + barLoc + "|Y:" + (int)(Layout.PlotArea.Top + (maxBarHeight - h)) + "|W:" + widthBar + "|H:" + h;                                      g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                                  }                                                                       barLoc += widthBar;                              }                          }                          else //This is a line type plot                          {                              if (z == 1)                              {                                  double v = this.GetDataValue(rpt' iRow' iCol);                                  double tooltipVal = v;                                  if (GetYAxis(rpt' iCol' iRow).ToUpper() != "LEFT")                                  {                                      //Scale the Y data...                                      v /= ScaleFactor;                                  }                                    DrawPoint = true;                                    if (v.CompareTo(double.NaN) == 0)                                  {                                      //don't draw null                                          DrawPoint = false;                                      //insert empty point                                          LastPoints[iCol] = null;                                     }                                  if (DrawPoint)                                  {                                      int h = (int)(((Math.Min(v' max) - min) / (max - min)) * maxBarHeight);                                        System.Drawing.Rectangle r = new System.Drawing.Rectangle(lineLoc' Layout.PlotArea.Top + (maxBarHeight - h)' widthBar' h);                                        Point p = new Point(r.Left' r.Top);                                      if (LastPoints[iCol - 1] == null)                                          LastPoints[iCol - 1] = p;                                      bool DrawMarker = getNoMarkerVal(rpt' iCol' 1) == false;                                      DrawDataPoint(rpt' g' new Point(p.X' p.Y - 14)' iRow' iCol);  // todo: 14 is arbitrary                                      if (DrawMarker) { DrawLegendLineMarker(g' GetSeriesBrush(rpt' iRow' iCol)' new Pen(GetSeriesBrush(rpt' iRow' iCol))' SeriesMarker[iCol - 1]' p.X - 5' p.Y - 5' 10);}                                                                                                               if (LastPoints.ContainsKey(iCol) )                                      {                                          Point[] Points = new Point[2];                                          Points[0] = p;                                          Point pt = (Point)LastPoints[iCol];                                          Points[1] = new Point(pt.X - 1' pt.Y);                                          // 05052008AJM - Allowing for breaking lines in chart                                          if (Points[1] != null) {                                              String LineSize = getLineSize(rpt' iCol' 1);                                              int intLineSize = 1;                                              switch (LineSize)                                              {                                                  case "Small": intLineSize = 1;                                                      break;                                                  case "Regular": intLineSize = 2;                                                      break;                                                  case "Large": intLineSize = 3;                                                      break;                                                  case "Extra Large": intLineSize = 4;                                                      break;                                                  case "Super Size": intLineSize = 5;                                                      break;                                              }                                                DrawLineBetweenPoints(g' rpt' GetSeriesBrush(rpt' iRow' iCol)' Points'intLineSize);                                          }                                      }                                        //Add a metafilecomment to use as a tooltip GJL 26092008                                      if (_showToolTips)                                      {                                          String val = "ToolTip:" + tooltipVal.ToString(_tooltipYFormat) + "|X:" + (int)(p.X - 5) + "|Y:" + (int)(p.Y - 5) + "|W:10|H:10";                                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                                      }                                                                              LastPoints[iCol] = p;                                  }                              }                          }                      }  				}  			}
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawPlotAreaPlain,The following statement contains a magic number: for (int iRow=1; iRow <= CategoryCount; iRow++)  			{  				int barLoc=(int) (Layout.PlotArea.Left + (iRow-1) * ((double) (Layout.PlotArea.Width) / CategoryCount));    				barLoc += _GapSize;	// space before series                  lineLoc = barLoc + widthBar * ColumnCount / 2;                  for (int z = 0; z < 2; z++)                   {                      for (int iCol = 1; iCol <= SeriesCount; iCol++)                      {                          /* This for loop has been modified to select if the column should                           * be drawn based on the Plot type of the column                           * 05122007AJM */                          if (GetPlotType(rpt' iCol' iRow).ToUpper() != "LINE")                          {                              if (z == 0)                              {                                  double v = this.GetDataValue(rpt' iRow' iCol);                                  double tooltipVal = v;                                  if (GetYAxis(rpt' iCol' iRow).ToUpper() != "LEFT")                                  {                                      //Scale the Y data...                                      v /= ScaleFactor;                                  }                                    if (v.CompareTo(double.NaN) == 0)                                      v = min;                                  int h = (int)(((Math.Min(v' max) - min) / (max - min)) * maxBarHeight);                                    DrawColumnBar(rpt' g' GetSeriesBrush(rpt' iRow' iCol)'                                      new System.Drawing.Rectangle(barLoc' Layout.PlotArea.Top + (maxBarHeight - h)' widthBar' h)' iRow' iCol);                                    //Add a metafilecomment to use as a tooltip GJL 26092008                                  if (_showToolTips)                                  {                                      String val = "ToolTip:" + tooltipVal.ToString(_tooltipYFormat) + "|X:" + barLoc + "|Y:" + (int)(Layout.PlotArea.Top + (maxBarHeight - h)) + "|W:" + widthBar + "|H:" + h;                                      g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                                  }                                                                       barLoc += widthBar;                              }                          }                          else //This is a line type plot                          {                              if (z == 1)                              {                                  double v = this.GetDataValue(rpt' iRow' iCol);                                  double tooltipVal = v;                                  if (GetYAxis(rpt' iCol' iRow).ToUpper() != "LEFT")                                  {                                      //Scale the Y data...                                      v /= ScaleFactor;                                  }                                    DrawPoint = true;                                    if (v.CompareTo(double.NaN) == 0)                                  {                                      //don't draw null                                          DrawPoint = false;                                      //insert empty point                                          LastPoints[iCol] = null;                                     }                                  if (DrawPoint)                                  {                                      int h = (int)(((Math.Min(v' max) - min) / (max - min)) * maxBarHeight);                                        System.Drawing.Rectangle r = new System.Drawing.Rectangle(lineLoc' Layout.PlotArea.Top + (maxBarHeight - h)' widthBar' h);                                        Point p = new Point(r.Left' r.Top);                                      if (LastPoints[iCol - 1] == null)                                          LastPoints[iCol - 1] = p;                                      bool DrawMarker = getNoMarkerVal(rpt' iCol' 1) == false;                                      DrawDataPoint(rpt' g' new Point(p.X' p.Y - 14)' iRow' iCol);  // todo: 14 is arbitrary                                      if (DrawMarker) { DrawLegendLineMarker(g' GetSeriesBrush(rpt' iRow' iCol)' new Pen(GetSeriesBrush(rpt' iRow' iCol))' SeriesMarker[iCol - 1]' p.X - 5' p.Y - 5' 10);}                                                                                                               if (LastPoints.ContainsKey(iCol) )                                      {                                          Point[] Points = new Point[2];                                          Points[0] = p;                                          Point pt = (Point)LastPoints[iCol];                                          Points[1] = new Point(pt.X - 1' pt.Y);                                          // 05052008AJM - Allowing for breaking lines in chart                                          if (Points[1] != null) {                                              String LineSize = getLineSize(rpt' iCol' 1);                                              int intLineSize = 1;                                              switch (LineSize)                                              {                                                  case "Small": intLineSize = 1;                                                      break;                                                  case "Regular": intLineSize = 2;                                                      break;                                                  case "Large": intLineSize = 3;                                                      break;                                                  case "Extra Large": intLineSize = 4;                                                      break;                                                  case "Super Size": intLineSize = 5;                                                      break;                                              }                                                DrawLineBetweenPoints(g' rpt' GetSeriesBrush(rpt' iRow' iCol)' Points'intLineSize);                                          }                                      }                                        //Add a metafilecomment to use as a tooltip GJL 26092008                                      if (_showToolTips)                                      {                                          String val = "ToolTip:" + tooltipVal.ToString(_tooltipYFormat) + "|X:" + (int)(p.X - 5) + "|Y:" + (int)(p.Y - 5) + "|W:10|H:10";                                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                                      }                                                                              LastPoints[iCol] = p;                                  }                              }                          }                      }  				}  			}
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawPlotAreaPlain,The following statement contains a magic number: for (int iRow=1; iRow <= CategoryCount; iRow++)  			{  				int barLoc=(int) (Layout.PlotArea.Left + (iRow-1) * ((double) (Layout.PlotArea.Width) / CategoryCount));    				barLoc += _GapSize;	// space before series                  lineLoc = barLoc + widthBar * ColumnCount / 2;                  for (int z = 0; z < 2; z++)                   {                      for (int iCol = 1; iCol <= SeriesCount; iCol++)                      {                          /* This for loop has been modified to select if the column should                           * be drawn based on the Plot type of the column                           * 05122007AJM */                          if (GetPlotType(rpt' iCol' iRow).ToUpper() != "LINE")                          {                              if (z == 0)                              {                                  double v = this.GetDataValue(rpt' iRow' iCol);                                  double tooltipVal = v;                                  if (GetYAxis(rpt' iCol' iRow).ToUpper() != "LEFT")                                  {                                      //Scale the Y data...                                      v /= ScaleFactor;                                  }                                    if (v.CompareTo(double.NaN) == 0)                                      v = min;                                  int h = (int)(((Math.Min(v' max) - min) / (max - min)) * maxBarHeight);                                    DrawColumnBar(rpt' g' GetSeriesBrush(rpt' iRow' iCol)'                                      new System.Drawing.Rectangle(barLoc' Layout.PlotArea.Top + (maxBarHeight - h)' widthBar' h)' iRow' iCol);                                    //Add a metafilecomment to use as a tooltip GJL 26092008                                  if (_showToolTips)                                  {                                      String val = "ToolTip:" + tooltipVal.ToString(_tooltipYFormat) + "|X:" + barLoc + "|Y:" + (int)(Layout.PlotArea.Top + (maxBarHeight - h)) + "|W:" + widthBar + "|H:" + h;                                      g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                                  }                                                                       barLoc += widthBar;                              }                          }                          else //This is a line type plot                          {                              if (z == 1)                              {                                  double v = this.GetDataValue(rpt' iRow' iCol);                                  double tooltipVal = v;                                  if (GetYAxis(rpt' iCol' iRow).ToUpper() != "LEFT")                                  {                                      //Scale the Y data...                                      v /= ScaleFactor;                                  }                                    DrawPoint = true;                                    if (v.CompareTo(double.NaN) == 0)                                  {                                      //don't draw null                                          DrawPoint = false;                                      //insert empty point                                          LastPoints[iCol] = null;                                     }                                  if (DrawPoint)                                  {                                      int h = (int)(((Math.Min(v' max) - min) / (max - min)) * maxBarHeight);                                        System.Drawing.Rectangle r = new System.Drawing.Rectangle(lineLoc' Layout.PlotArea.Top + (maxBarHeight - h)' widthBar' h);                                        Point p = new Point(r.Left' r.Top);                                      if (LastPoints[iCol - 1] == null)                                          LastPoints[iCol - 1] = p;                                      bool DrawMarker = getNoMarkerVal(rpt' iCol' 1) == false;                                      DrawDataPoint(rpt' g' new Point(p.X' p.Y - 14)' iRow' iCol);  // todo: 14 is arbitrary                                      if (DrawMarker) { DrawLegendLineMarker(g' GetSeriesBrush(rpt' iRow' iCol)' new Pen(GetSeriesBrush(rpt' iRow' iCol))' SeriesMarker[iCol - 1]' p.X - 5' p.Y - 5' 10);}                                                                                                               if (LastPoints.ContainsKey(iCol) )                                      {                                          Point[] Points = new Point[2];                                          Points[0] = p;                                          Point pt = (Point)LastPoints[iCol];                                          Points[1] = new Point(pt.X - 1' pt.Y);                                          // 05052008AJM - Allowing for breaking lines in chart                                          if (Points[1] != null) {                                              String LineSize = getLineSize(rpt' iCol' 1);                                              int intLineSize = 1;                                              switch (LineSize)                                              {                                                  case "Small": intLineSize = 1;                                                      break;                                                  case "Regular": intLineSize = 2;                                                      break;                                                  case "Large": intLineSize = 3;                                                      break;                                                  case "Extra Large": intLineSize = 4;                                                      break;                                                  case "Super Size": intLineSize = 5;                                                      break;                                              }                                                DrawLineBetweenPoints(g' rpt' GetSeriesBrush(rpt' iRow' iCol)' Points'intLineSize);                                          }                                      }                                        //Add a metafilecomment to use as a tooltip GJL 26092008                                      if (_showToolTips)                                      {                                          String val = "ToolTip:" + tooltipVal.ToString(_tooltipYFormat) + "|X:" + (int)(p.X - 5) + "|Y:" + (int)(p.Y - 5) + "|W:10|H:10";                                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                                      }                                                                              LastPoints[iCol] = p;                                  }                              }                          }                      }  				}  			}
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawPlotAreaPlain,The following statement contains a magic number: for (int iRow=1; iRow <= CategoryCount; iRow++)  			{  				int barLoc=(int) (Layout.PlotArea.Left + (iRow-1) * ((double) (Layout.PlotArea.Width) / CategoryCount));    				barLoc += _GapSize;	// space before series                  lineLoc = barLoc + widthBar * ColumnCount / 2;                  for (int z = 0; z < 2; z++)                   {                      for (int iCol = 1; iCol <= SeriesCount; iCol++)                      {                          /* This for loop has been modified to select if the column should                           * be drawn based on the Plot type of the column                           * 05122007AJM */                          if (GetPlotType(rpt' iCol' iRow).ToUpper() != "LINE")                          {                              if (z == 0)                              {                                  double v = this.GetDataValue(rpt' iRow' iCol);                                  double tooltipVal = v;                                  if (GetYAxis(rpt' iCol' iRow).ToUpper() != "LEFT")                                  {                                      //Scale the Y data...                                      v /= ScaleFactor;                                  }                                    if (v.CompareTo(double.NaN) == 0)                                      v = min;                                  int h = (int)(((Math.Min(v' max) - min) / (max - min)) * maxBarHeight);                                    DrawColumnBar(rpt' g' GetSeriesBrush(rpt' iRow' iCol)'                                      new System.Drawing.Rectangle(barLoc' Layout.PlotArea.Top + (maxBarHeight - h)' widthBar' h)' iRow' iCol);                                    //Add a metafilecomment to use as a tooltip GJL 26092008                                  if (_showToolTips)                                  {                                      String val = "ToolTip:" + tooltipVal.ToString(_tooltipYFormat) + "|X:" + barLoc + "|Y:" + (int)(Layout.PlotArea.Top + (maxBarHeight - h)) + "|W:" + widthBar + "|H:" + h;                                      g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                                  }                                                                       barLoc += widthBar;                              }                          }                          else //This is a line type plot                          {                              if (z == 1)                              {                                  double v = this.GetDataValue(rpt' iRow' iCol);                                  double tooltipVal = v;                                  if (GetYAxis(rpt' iCol' iRow).ToUpper() != "LEFT")                                  {                                      //Scale the Y data...                                      v /= ScaleFactor;                                  }                                    DrawPoint = true;                                    if (v.CompareTo(double.NaN) == 0)                                  {                                      //don't draw null                                          DrawPoint = false;                                      //insert empty point                                          LastPoints[iCol] = null;                                     }                                  if (DrawPoint)                                  {                                      int h = (int)(((Math.Min(v' max) - min) / (max - min)) * maxBarHeight);                                        System.Drawing.Rectangle r = new System.Drawing.Rectangle(lineLoc' Layout.PlotArea.Top + (maxBarHeight - h)' widthBar' h);                                        Point p = new Point(r.Left' r.Top);                                      if (LastPoints[iCol - 1] == null)                                          LastPoints[iCol - 1] = p;                                      bool DrawMarker = getNoMarkerVal(rpt' iCol' 1) == false;                                      DrawDataPoint(rpt' g' new Point(p.X' p.Y - 14)' iRow' iCol);  // todo: 14 is arbitrary                                      if (DrawMarker) { DrawLegendLineMarker(g' GetSeriesBrush(rpt' iRow' iCol)' new Pen(GetSeriesBrush(rpt' iRow' iCol))' SeriesMarker[iCol - 1]' p.X - 5' p.Y - 5' 10);}                                                                                                               if (LastPoints.ContainsKey(iCol) )                                      {                                          Point[] Points = new Point[2];                                          Points[0] = p;                                          Point pt = (Point)LastPoints[iCol];                                          Points[1] = new Point(pt.X - 1' pt.Y);                                          // 05052008AJM - Allowing for breaking lines in chart                                          if (Points[1] != null) {                                              String LineSize = getLineSize(rpt' iCol' 1);                                              int intLineSize = 1;                                              switch (LineSize)                                              {                                                  case "Small": intLineSize = 1;                                                      break;                                                  case "Regular": intLineSize = 2;                                                      break;                                                  case "Large": intLineSize = 3;                                                      break;                                                  case "Extra Large": intLineSize = 4;                                                      break;                                                  case "Super Size": intLineSize = 5;                                                      break;                                              }                                                DrawLineBetweenPoints(g' rpt' GetSeriesBrush(rpt' iRow' iCol)' Points'intLineSize);                                          }                                      }                                        //Add a metafilecomment to use as a tooltip GJL 26092008                                      if (_showToolTips)                                      {                                          String val = "ToolTip:" + tooltipVal.ToString(_tooltipYFormat) + "|X:" + (int)(p.X - 5) + "|Y:" + (int)(p.Y - 5) + "|W:10|H:10";                                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                                      }                                                                              LastPoints[iCol] = p;                                  }                              }                          }                      }  				}  			}
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawPlotAreaPlain,The following statement contains a magic number: for (int iRow=1; iRow <= CategoryCount; iRow++)  			{  				int barLoc=(int) (Layout.PlotArea.Left + (iRow-1) * ((double) (Layout.PlotArea.Width) / CategoryCount));    				barLoc += _GapSize;	// space before series                  lineLoc = barLoc + widthBar * ColumnCount / 2;                  for (int z = 0; z < 2; z++)                   {                      for (int iCol = 1; iCol <= SeriesCount; iCol++)                      {                          /* This for loop has been modified to select if the column should                           * be drawn based on the Plot type of the column                           * 05122007AJM */                          if (GetPlotType(rpt' iCol' iRow).ToUpper() != "LINE")                          {                              if (z == 0)                              {                                  double v = this.GetDataValue(rpt' iRow' iCol);                                  double tooltipVal = v;                                  if (GetYAxis(rpt' iCol' iRow).ToUpper() != "LEFT")                                  {                                      //Scale the Y data...                                      v /= ScaleFactor;                                  }                                    if (v.CompareTo(double.NaN) == 0)                                      v = min;                                  int h = (int)(((Math.Min(v' max) - min) / (max - min)) * maxBarHeight);                                    DrawColumnBar(rpt' g' GetSeriesBrush(rpt' iRow' iCol)'                                      new System.Drawing.Rectangle(barLoc' Layout.PlotArea.Top + (maxBarHeight - h)' widthBar' h)' iRow' iCol);                                    //Add a metafilecomment to use as a tooltip GJL 26092008                                  if (_showToolTips)                                  {                                      String val = "ToolTip:" + tooltipVal.ToString(_tooltipYFormat) + "|X:" + barLoc + "|Y:" + (int)(Layout.PlotArea.Top + (maxBarHeight - h)) + "|W:" + widthBar + "|H:" + h;                                      g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                                  }                                                                       barLoc += widthBar;                              }                          }                          else //This is a line type plot                          {                              if (z == 1)                              {                                  double v = this.GetDataValue(rpt' iRow' iCol);                                  double tooltipVal = v;                                  if (GetYAxis(rpt' iCol' iRow).ToUpper() != "LEFT")                                  {                                      //Scale the Y data...                                      v /= ScaleFactor;                                  }                                    DrawPoint = true;                                    if (v.CompareTo(double.NaN) == 0)                                  {                                      //don't draw null                                          DrawPoint = false;                                      //insert empty point                                          LastPoints[iCol] = null;                                     }                                  if (DrawPoint)                                  {                                      int h = (int)(((Math.Min(v' max) - min) / (max - min)) * maxBarHeight);                                        System.Drawing.Rectangle r = new System.Drawing.Rectangle(lineLoc' Layout.PlotArea.Top + (maxBarHeight - h)' widthBar' h);                                        Point p = new Point(r.Left' r.Top);                                      if (LastPoints[iCol - 1] == null)                                          LastPoints[iCol - 1] = p;                                      bool DrawMarker = getNoMarkerVal(rpt' iCol' 1) == false;                                      DrawDataPoint(rpt' g' new Point(p.X' p.Y - 14)' iRow' iCol);  // todo: 14 is arbitrary                                      if (DrawMarker) { DrawLegendLineMarker(g' GetSeriesBrush(rpt' iRow' iCol)' new Pen(GetSeriesBrush(rpt' iRow' iCol))' SeriesMarker[iCol - 1]' p.X - 5' p.Y - 5' 10);}                                                                                                               if (LastPoints.ContainsKey(iCol) )                                      {                                          Point[] Points = new Point[2];                                          Points[0] = p;                                          Point pt = (Point)LastPoints[iCol];                                          Points[1] = new Point(pt.X - 1' pt.Y);                                          // 05052008AJM - Allowing for breaking lines in chart                                          if (Points[1] != null) {                                              String LineSize = getLineSize(rpt' iCol' 1);                                              int intLineSize = 1;                                              switch (LineSize)                                              {                                                  case "Small": intLineSize = 1;                                                      break;                                                  case "Regular": intLineSize = 2;                                                      break;                                                  case "Large": intLineSize = 3;                                                      break;                                                  case "Extra Large": intLineSize = 4;                                                      break;                                                  case "Super Size": intLineSize = 5;                                                      break;                                              }                                                DrawLineBetweenPoints(g' rpt' GetSeriesBrush(rpt' iRow' iCol)' Points'intLineSize);                                          }                                      }                                        //Add a metafilecomment to use as a tooltip GJL 26092008                                      if (_showToolTips)                                      {                                          String val = "ToolTip:" + tooltipVal.ToString(_tooltipYFormat) + "|X:" + (int)(p.X - 5) + "|Y:" + (int)(p.Y - 5) + "|W:10|H:10";                                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                                      }                                                                              LastPoints[iCol] = p;                                  }                              }                          }                      }  				}  			}
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawPlotAreaPlain,The following statement contains a magic number: for (int iRow=1; iRow <= CategoryCount; iRow++)  			{  				int barLoc=(int) (Layout.PlotArea.Left + (iRow-1) * ((double) (Layout.PlotArea.Width) / CategoryCount));    				barLoc += _GapSize;	// space before series                  lineLoc = barLoc + widthBar * ColumnCount / 2;                  for (int z = 0; z < 2; z++)                   {                      for (int iCol = 1; iCol <= SeriesCount; iCol++)                      {                          /* This for loop has been modified to select if the column should                           * be drawn based on the Plot type of the column                           * 05122007AJM */                          if (GetPlotType(rpt' iCol' iRow).ToUpper() != "LINE")                          {                              if (z == 0)                              {                                  double v = this.GetDataValue(rpt' iRow' iCol);                                  double tooltipVal = v;                                  if (GetYAxis(rpt' iCol' iRow).ToUpper() != "LEFT")                                  {                                      //Scale the Y data...                                      v /= ScaleFactor;                                  }                                    if (v.CompareTo(double.NaN) == 0)                                      v = min;                                  int h = (int)(((Math.Min(v' max) - min) / (max - min)) * maxBarHeight);                                    DrawColumnBar(rpt' g' GetSeriesBrush(rpt' iRow' iCol)'                                      new System.Drawing.Rectangle(barLoc' Layout.PlotArea.Top + (maxBarHeight - h)' widthBar' h)' iRow' iCol);                                    //Add a metafilecomment to use as a tooltip GJL 26092008                                  if (_showToolTips)                                  {                                      String val = "ToolTip:" + tooltipVal.ToString(_tooltipYFormat) + "|X:" + barLoc + "|Y:" + (int)(Layout.PlotArea.Top + (maxBarHeight - h)) + "|W:" + widthBar + "|H:" + h;                                      g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                                  }                                                                       barLoc += widthBar;                              }                          }                          else //This is a line type plot                          {                              if (z == 1)                              {                                  double v = this.GetDataValue(rpt' iRow' iCol);                                  double tooltipVal = v;                                  if (GetYAxis(rpt' iCol' iRow).ToUpper() != "LEFT")                                  {                                      //Scale the Y data...                                      v /= ScaleFactor;                                  }                                    DrawPoint = true;                                    if (v.CompareTo(double.NaN) == 0)                                  {                                      //don't draw null                                          DrawPoint = false;                                      //insert empty point                                          LastPoints[iCol] = null;                                     }                                  if (DrawPoint)                                  {                                      int h = (int)(((Math.Min(v' max) - min) / (max - min)) * maxBarHeight);                                        System.Drawing.Rectangle r = new System.Drawing.Rectangle(lineLoc' Layout.PlotArea.Top + (maxBarHeight - h)' widthBar' h);                                        Point p = new Point(r.Left' r.Top);                                      if (LastPoints[iCol - 1] == null)                                          LastPoints[iCol - 1] = p;                                      bool DrawMarker = getNoMarkerVal(rpt' iCol' 1) == false;                                      DrawDataPoint(rpt' g' new Point(p.X' p.Y - 14)' iRow' iCol);  // todo: 14 is arbitrary                                      if (DrawMarker) { DrawLegendLineMarker(g' GetSeriesBrush(rpt' iRow' iCol)' new Pen(GetSeriesBrush(rpt' iRow' iCol))' SeriesMarker[iCol - 1]' p.X - 5' p.Y - 5' 10);}                                                                                                               if (LastPoints.ContainsKey(iCol) )                                      {                                          Point[] Points = new Point[2];                                          Points[0] = p;                                          Point pt = (Point)LastPoints[iCol];                                          Points[1] = new Point(pt.X - 1' pt.Y);                                          // 05052008AJM - Allowing for breaking lines in chart                                          if (Points[1] != null) {                                              String LineSize = getLineSize(rpt' iCol' 1);                                              int intLineSize = 1;                                              switch (LineSize)                                              {                                                  case "Small": intLineSize = 1;                                                      break;                                                  case "Regular": intLineSize = 2;                                                      break;                                                  case "Large": intLineSize = 3;                                                      break;                                                  case "Extra Large": intLineSize = 4;                                                      break;                                                  case "Super Size": intLineSize = 5;                                                      break;                                              }                                                DrawLineBetweenPoints(g' rpt' GetSeriesBrush(rpt' iRow' iCol)' Points'intLineSize);                                          }                                      }                                        //Add a metafilecomment to use as a tooltip GJL 26092008                                      if (_showToolTips)                                      {                                          String val = "ToolTip:" + tooltipVal.ToString(_tooltipYFormat) + "|X:" + (int)(p.X - 5) + "|Y:" + (int)(p.Y - 5) + "|W:10|H:10";                                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                                      }                                                                              LastPoints[iCol] = p;                                  }                              }                          }                      }  				}  			}
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawPlotAreaPlain,The following statement contains a magic number: for (int iRow=1; iRow <= CategoryCount; iRow++)  			{  				int barLoc=(int) (Layout.PlotArea.Left + (iRow-1) * ((double) (Layout.PlotArea.Width) / CategoryCount));    				barLoc += _GapSize;	// space before series                  lineLoc = barLoc + widthBar * ColumnCount / 2;                  for (int z = 0; z < 2; z++)                   {                      for (int iCol = 1; iCol <= SeriesCount; iCol++)                      {                          /* This for loop has been modified to select if the column should                           * be drawn based on the Plot type of the column                           * 05122007AJM */                          if (GetPlotType(rpt' iCol' iRow).ToUpper() != "LINE")                          {                              if (z == 0)                              {                                  double v = this.GetDataValue(rpt' iRow' iCol);                                  double tooltipVal = v;                                  if (GetYAxis(rpt' iCol' iRow).ToUpper() != "LEFT")                                  {                                      //Scale the Y data...                                      v /= ScaleFactor;                                  }                                    if (v.CompareTo(double.NaN) == 0)                                      v = min;                                  int h = (int)(((Math.Min(v' max) - min) / (max - min)) * maxBarHeight);                                    DrawColumnBar(rpt' g' GetSeriesBrush(rpt' iRow' iCol)'                                      new System.Drawing.Rectangle(barLoc' Layout.PlotArea.Top + (maxBarHeight - h)' widthBar' h)' iRow' iCol);                                    //Add a metafilecomment to use as a tooltip GJL 26092008                                  if (_showToolTips)                                  {                                      String val = "ToolTip:" + tooltipVal.ToString(_tooltipYFormat) + "|X:" + barLoc + "|Y:" + (int)(Layout.PlotArea.Top + (maxBarHeight - h)) + "|W:" + widthBar + "|H:" + h;                                      g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                                  }                                                                       barLoc += widthBar;                              }                          }                          else //This is a line type plot                          {                              if (z == 1)                              {                                  double v = this.GetDataValue(rpt' iRow' iCol);                                  double tooltipVal = v;                                  if (GetYAxis(rpt' iCol' iRow).ToUpper() != "LEFT")                                  {                                      //Scale the Y data...                                      v /= ScaleFactor;                                  }                                    DrawPoint = true;                                    if (v.CompareTo(double.NaN) == 0)                                  {                                      //don't draw null                                          DrawPoint = false;                                      //insert empty point                                          LastPoints[iCol] = null;                                     }                                  if (DrawPoint)                                  {                                      int h = (int)(((Math.Min(v' max) - min) / (max - min)) * maxBarHeight);                                        System.Drawing.Rectangle r = new System.Drawing.Rectangle(lineLoc' Layout.PlotArea.Top + (maxBarHeight - h)' widthBar' h);                                        Point p = new Point(r.Left' r.Top);                                      if (LastPoints[iCol - 1] == null)                                          LastPoints[iCol - 1] = p;                                      bool DrawMarker = getNoMarkerVal(rpt' iCol' 1) == false;                                      DrawDataPoint(rpt' g' new Point(p.X' p.Y - 14)' iRow' iCol);  // todo: 14 is arbitrary                                      if (DrawMarker) { DrawLegendLineMarker(g' GetSeriesBrush(rpt' iRow' iCol)' new Pen(GetSeriesBrush(rpt' iRow' iCol))' SeriesMarker[iCol - 1]' p.X - 5' p.Y - 5' 10);}                                                                                                               if (LastPoints.ContainsKey(iCol) )                                      {                                          Point[] Points = new Point[2];                                          Points[0] = p;                                          Point pt = (Point)LastPoints[iCol];                                          Points[1] = new Point(pt.X - 1' pt.Y);                                          // 05052008AJM - Allowing for breaking lines in chart                                          if (Points[1] != null) {                                              String LineSize = getLineSize(rpt' iCol' 1);                                              int intLineSize = 1;                                              switch (LineSize)                                              {                                                  case "Small": intLineSize = 1;                                                      break;                                                  case "Regular": intLineSize = 2;                                                      break;                                                  case "Large": intLineSize = 3;                                                      break;                                                  case "Extra Large": intLineSize = 4;                                                      break;                                                  case "Super Size": intLineSize = 5;                                                      break;                                              }                                                DrawLineBetweenPoints(g' rpt' GetSeriesBrush(rpt' iRow' iCol)' Points'intLineSize);                                          }                                      }                                        //Add a metafilecomment to use as a tooltip GJL 26092008                                      if (_showToolTips)                                      {                                          String val = "ToolTip:" + tooltipVal.ToString(_tooltipYFormat) + "|X:" + (int)(p.X - 5) + "|Y:" + (int)(p.Y - 5) + "|W:10|H:10";                                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                                      }                                                                              LastPoints[iCol] = p;                                  }                              }                          }                      }  				}  			}
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawPlotAreaPlain,The following statement contains a magic number: for (int iRow=1; iRow <= CategoryCount; iRow++)  			{  				int barLoc=(int) (Layout.PlotArea.Left + (iRow-1) * ((double) (Layout.PlotArea.Width) / CategoryCount));    				barLoc += _GapSize;	// space before series                  lineLoc = barLoc + widthBar * ColumnCount / 2;                  for (int z = 0; z < 2; z++)                   {                      for (int iCol = 1; iCol <= SeriesCount; iCol++)                      {                          /* This for loop has been modified to select if the column should                           * be drawn based on the Plot type of the column                           * 05122007AJM */                          if (GetPlotType(rpt' iCol' iRow).ToUpper() != "LINE")                          {                              if (z == 0)                              {                                  double v = this.GetDataValue(rpt' iRow' iCol);                                  double tooltipVal = v;                                  if (GetYAxis(rpt' iCol' iRow).ToUpper() != "LEFT")                                  {                                      //Scale the Y data...                                      v /= ScaleFactor;                                  }                                    if (v.CompareTo(double.NaN) == 0)                                      v = min;                                  int h = (int)(((Math.Min(v' max) - min) / (max - min)) * maxBarHeight);                                    DrawColumnBar(rpt' g' GetSeriesBrush(rpt' iRow' iCol)'                                      new System.Drawing.Rectangle(barLoc' Layout.PlotArea.Top + (maxBarHeight - h)' widthBar' h)' iRow' iCol);                                    //Add a metafilecomment to use as a tooltip GJL 26092008                                  if (_showToolTips)                                  {                                      String val = "ToolTip:" + tooltipVal.ToString(_tooltipYFormat) + "|X:" + barLoc + "|Y:" + (int)(Layout.PlotArea.Top + (maxBarHeight - h)) + "|W:" + widthBar + "|H:" + h;                                      g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                                  }                                                                       barLoc += widthBar;                              }                          }                          else //This is a line type plot                          {                              if (z == 1)                              {                                  double v = this.GetDataValue(rpt' iRow' iCol);                                  double tooltipVal = v;                                  if (GetYAxis(rpt' iCol' iRow).ToUpper() != "LEFT")                                  {                                      //Scale the Y data...                                      v /= ScaleFactor;                                  }                                    DrawPoint = true;                                    if (v.CompareTo(double.NaN) == 0)                                  {                                      //don't draw null                                          DrawPoint = false;                                      //insert empty point                                          LastPoints[iCol] = null;                                     }                                  if (DrawPoint)                                  {                                      int h = (int)(((Math.Min(v' max) - min) / (max - min)) * maxBarHeight);                                        System.Drawing.Rectangle r = new System.Drawing.Rectangle(lineLoc' Layout.PlotArea.Top + (maxBarHeight - h)' widthBar' h);                                        Point p = new Point(r.Left' r.Top);                                      if (LastPoints[iCol - 1] == null)                                          LastPoints[iCol - 1] = p;                                      bool DrawMarker = getNoMarkerVal(rpt' iCol' 1) == false;                                      DrawDataPoint(rpt' g' new Point(p.X' p.Y - 14)' iRow' iCol);  // todo: 14 is arbitrary                                      if (DrawMarker) { DrawLegendLineMarker(g' GetSeriesBrush(rpt' iRow' iCol)' new Pen(GetSeriesBrush(rpt' iRow' iCol))' SeriesMarker[iCol - 1]' p.X - 5' p.Y - 5' 10);}                                                                                                               if (LastPoints.ContainsKey(iCol) )                                      {                                          Point[] Points = new Point[2];                                          Points[0] = p;                                          Point pt = (Point)LastPoints[iCol];                                          Points[1] = new Point(pt.X - 1' pt.Y);                                          // 05052008AJM - Allowing for breaking lines in chart                                          if (Points[1] != null) {                                              String LineSize = getLineSize(rpt' iCol' 1);                                              int intLineSize = 1;                                              switch (LineSize)                                              {                                                  case "Small": intLineSize = 1;                                                      break;                                                  case "Regular": intLineSize = 2;                                                      break;                                                  case "Large": intLineSize = 3;                                                      break;                                                  case "Extra Large": intLineSize = 4;                                                      break;                                                  case "Super Size": intLineSize = 5;                                                      break;                                              }                                                DrawLineBetweenPoints(g' rpt' GetSeriesBrush(rpt' iRow' iCol)' Points'intLineSize);                                          }                                      }                                        //Add a metafilecomment to use as a tooltip GJL 26092008                                      if (_showToolTips)                                      {                                          String val = "ToolTip:" + tooltipVal.ToString(_tooltipYFormat) + "|X:" + (int)(p.X - 5) + "|Y:" + (int)(p.Y - 5) + "|W:10|H:10";                                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                                      }                                                                              LastPoints[iCol] = p;                                  }                              }                          }                      }  				}  			}
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawPlotAreaPlain,The following statement contains a magic number: for (int iRow=1; iRow <= CategoryCount; iRow++)  			{  				int barLoc=(int) (Layout.PlotArea.Left + (iRow-1) * ((double) (Layout.PlotArea.Width) / CategoryCount));    				barLoc += _GapSize;	// space before series                  lineLoc = barLoc + widthBar * ColumnCount / 2;                  for (int z = 0; z < 2; z++)                   {                      for (int iCol = 1; iCol <= SeriesCount; iCol++)                      {                          /* This for loop has been modified to select if the column should                           * be drawn based on the Plot type of the column                           * 05122007AJM */                          if (GetPlotType(rpt' iCol' iRow).ToUpper() != "LINE")                          {                              if (z == 0)                              {                                  double v = this.GetDataValue(rpt' iRow' iCol);                                  double tooltipVal = v;                                  if (GetYAxis(rpt' iCol' iRow).ToUpper() != "LEFT")                                  {                                      //Scale the Y data...                                      v /= ScaleFactor;                                  }                                    if (v.CompareTo(double.NaN) == 0)                                      v = min;                                  int h = (int)(((Math.Min(v' max) - min) / (max - min)) * maxBarHeight);                                    DrawColumnBar(rpt' g' GetSeriesBrush(rpt' iRow' iCol)'                                      new System.Drawing.Rectangle(barLoc' Layout.PlotArea.Top + (maxBarHeight - h)' widthBar' h)' iRow' iCol);                                    //Add a metafilecomment to use as a tooltip GJL 26092008                                  if (_showToolTips)                                  {                                      String val = "ToolTip:" + tooltipVal.ToString(_tooltipYFormat) + "|X:" + barLoc + "|Y:" + (int)(Layout.PlotArea.Top + (maxBarHeight - h)) + "|W:" + widthBar + "|H:" + h;                                      g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                                  }                                                                       barLoc += widthBar;                              }                          }                          else //This is a line type plot                          {                              if (z == 1)                              {                                  double v = this.GetDataValue(rpt' iRow' iCol);                                  double tooltipVal = v;                                  if (GetYAxis(rpt' iCol' iRow).ToUpper() != "LEFT")                                  {                                      //Scale the Y data...                                      v /= ScaleFactor;                                  }                                    DrawPoint = true;                                    if (v.CompareTo(double.NaN) == 0)                                  {                                      //don't draw null                                          DrawPoint = false;                                      //insert empty point                                          LastPoints[iCol] = null;                                     }                                  if (DrawPoint)                                  {                                      int h = (int)(((Math.Min(v' max) - min) / (max - min)) * maxBarHeight);                                        System.Drawing.Rectangle r = new System.Drawing.Rectangle(lineLoc' Layout.PlotArea.Top + (maxBarHeight - h)' widthBar' h);                                        Point p = new Point(r.Left' r.Top);                                      if (LastPoints[iCol - 1] == null)                                          LastPoints[iCol - 1] = p;                                      bool DrawMarker = getNoMarkerVal(rpt' iCol' 1) == false;                                      DrawDataPoint(rpt' g' new Point(p.X' p.Y - 14)' iRow' iCol);  // todo: 14 is arbitrary                                      if (DrawMarker) { DrawLegendLineMarker(g' GetSeriesBrush(rpt' iRow' iCol)' new Pen(GetSeriesBrush(rpt' iRow' iCol))' SeriesMarker[iCol - 1]' p.X - 5' p.Y - 5' 10);}                                                                                                               if (LastPoints.ContainsKey(iCol) )                                      {                                          Point[] Points = new Point[2];                                          Points[0] = p;                                          Point pt = (Point)LastPoints[iCol];                                          Points[1] = new Point(pt.X - 1' pt.Y);                                          // 05052008AJM - Allowing for breaking lines in chart                                          if (Points[1] != null) {                                              String LineSize = getLineSize(rpt' iCol' 1);                                              int intLineSize = 1;                                              switch (LineSize)                                              {                                                  case "Small": intLineSize = 1;                                                      break;                                                  case "Regular": intLineSize = 2;                                                      break;                                                  case "Large": intLineSize = 3;                                                      break;                                                  case "Extra Large": intLineSize = 4;                                                      break;                                                  case "Super Size": intLineSize = 5;                                                      break;                                              }                                                DrawLineBetweenPoints(g' rpt' GetSeriesBrush(rpt' iRow' iCol)' Points'intLineSize);                                          }                                      }                                        //Add a metafilecomment to use as a tooltip GJL 26092008                                      if (_showToolTips)                                      {                                          String val = "ToolTip:" + tooltipVal.ToString(_tooltipYFormat) + "|X:" + (int)(p.X - 5) + "|Y:" + (int)(p.Y - 5) + "|W:10|H:10";                                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                                      }                                                                              LastPoints[iCol] = p;                                  }                              }                          }                      }  				}  			}
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawLegendLineMarker,The following statement contains a magic number: switch (marker)              {                  case ChartMarkerEnum.Bubble:                  case ChartMarkerEnum.Circle:                      g.FillEllipse(b' x' y' mSize' mSize);                      break;                  case ChartMarkerEnum.Square:                      g.FillRectangle(b' x' y' mSize' mSize);                      break;                  case ChartMarkerEnum.Plus:                                                           p2 = new Pen(b' 2.0f);                      g.DrawLine(p2' new Point(x + (mSize + 1) / 2' y)' new Point(x + (mSize + 1) / 2' y + mSize));                      //g.DrawLine(p2' new Point(x + (mSize + 1) / 2' y + (mSize + 1) / 2)' new Point(x + mSize' y + (mSize + 1) / 2));                      break;                  case ChartMarkerEnum.Diamond:                      points = new PointF[5];                      points[0] = points[4] = new PointF(x + (mSize + 1) / 2' y);	// starting and ending point                      points[1] = new PointF(x' y + (mSize + 1) / 2);                      points[2] = new PointF(x + (mSize + 1) / 2' y + mSize);                      points[3] = new PointF(x + mSize' y + (mSize + 1) / 2);                      g.FillPolygon(b' points);                      break;                  case ChartMarkerEnum.Triangle:                      points = new PointF[4];                      points[0] = points[3] = new PointF(x + (mSize + 1) / 2' y);	// starting and ending point                      points[1] = new PointF(x' y + mSize);                      points[2] = new PointF(x + mSize' y + mSize);                      g.FillPolygon(b' points);                      break;                  case ChartMarkerEnum.X:                      p2 = new Pen(b' 2.0f);                      g.DrawLine(p2' new Point(x' y)' new Point(x + mSize' y + mSize));                      g.DrawLine(p2' new Point(x' y + mSize)' new Point(x + mSize' y));                      break;              }
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawLegendLineMarker,The following statement contains a magic number: switch (marker)              {                  case ChartMarkerEnum.Bubble:                  case ChartMarkerEnum.Circle:                      g.FillEllipse(b' x' y' mSize' mSize);                      break;                  case ChartMarkerEnum.Square:                      g.FillRectangle(b' x' y' mSize' mSize);                      break;                  case ChartMarkerEnum.Plus:                                                           p2 = new Pen(b' 2.0f);                      g.DrawLine(p2' new Point(x + (mSize + 1) / 2' y)' new Point(x + (mSize + 1) / 2' y + mSize));                      //g.DrawLine(p2' new Point(x + (mSize + 1) / 2' y + (mSize + 1) / 2)' new Point(x + mSize' y + (mSize + 1) / 2));                      break;                  case ChartMarkerEnum.Diamond:                      points = new PointF[5];                      points[0] = points[4] = new PointF(x + (mSize + 1) / 2' y);	// starting and ending point                      points[1] = new PointF(x' y + (mSize + 1) / 2);                      points[2] = new PointF(x + (mSize + 1) / 2' y + mSize);                      points[3] = new PointF(x + mSize' y + (mSize + 1) / 2);                      g.FillPolygon(b' points);                      break;                  case ChartMarkerEnum.Triangle:                      points = new PointF[4];                      points[0] = points[3] = new PointF(x + (mSize + 1) / 2' y);	// starting and ending point                      points[1] = new PointF(x' y + mSize);                      points[2] = new PointF(x + mSize' y + mSize);                      g.FillPolygon(b' points);                      break;                  case ChartMarkerEnum.X:                      p2 = new Pen(b' 2.0f);                      g.DrawLine(p2' new Point(x' y)' new Point(x + mSize' y + mSize));                      g.DrawLine(p2' new Point(x' y + mSize)' new Point(x + mSize' y));                      break;              }
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawLegendLineMarker,The following statement contains a magic number: switch (marker)              {                  case ChartMarkerEnum.Bubble:                  case ChartMarkerEnum.Circle:                      g.FillEllipse(b' x' y' mSize' mSize);                      break;                  case ChartMarkerEnum.Square:                      g.FillRectangle(b' x' y' mSize' mSize);                      break;                  case ChartMarkerEnum.Plus:                                                           p2 = new Pen(b' 2.0f);                      g.DrawLine(p2' new Point(x + (mSize + 1) / 2' y)' new Point(x + (mSize + 1) / 2' y + mSize));                      //g.DrawLine(p2' new Point(x + (mSize + 1) / 2' y + (mSize + 1) / 2)' new Point(x + mSize' y + (mSize + 1) / 2));                      break;                  case ChartMarkerEnum.Diamond:                      points = new PointF[5];                      points[0] = points[4] = new PointF(x + (mSize + 1) / 2' y);	// starting and ending point                      points[1] = new PointF(x' y + (mSize + 1) / 2);                      points[2] = new PointF(x + (mSize + 1) / 2' y + mSize);                      points[3] = new PointF(x + mSize' y + (mSize + 1) / 2);                      g.FillPolygon(b' points);                      break;                  case ChartMarkerEnum.Triangle:                      points = new PointF[4];                      points[0] = points[3] = new PointF(x + (mSize + 1) / 2' y);	// starting and ending point                      points[1] = new PointF(x' y + mSize);                      points[2] = new PointF(x + mSize' y + mSize);                      g.FillPolygon(b' points);                      break;                  case ChartMarkerEnum.X:                      p2 = new Pen(b' 2.0f);                      g.DrawLine(p2' new Point(x' y)' new Point(x + mSize' y + mSize));                      g.DrawLine(p2' new Point(x' y + mSize)' new Point(x + mSize' y));                      break;              }
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawLegendLineMarker,The following statement contains a magic number: switch (marker)              {                  case ChartMarkerEnum.Bubble:                  case ChartMarkerEnum.Circle:                      g.FillEllipse(b' x' y' mSize' mSize);                      break;                  case ChartMarkerEnum.Square:                      g.FillRectangle(b' x' y' mSize' mSize);                      break;                  case ChartMarkerEnum.Plus:                                                           p2 = new Pen(b' 2.0f);                      g.DrawLine(p2' new Point(x + (mSize + 1) / 2' y)' new Point(x + (mSize + 1) / 2' y + mSize));                      //g.DrawLine(p2' new Point(x + (mSize + 1) / 2' y + (mSize + 1) / 2)' new Point(x + mSize' y + (mSize + 1) / 2));                      break;                  case ChartMarkerEnum.Diamond:                      points = new PointF[5];                      points[0] = points[4] = new PointF(x + (mSize + 1) / 2' y);	// starting and ending point                      points[1] = new PointF(x' y + (mSize + 1) / 2);                      points[2] = new PointF(x + (mSize + 1) / 2' y + mSize);                      points[3] = new PointF(x + mSize' y + (mSize + 1) / 2);                      g.FillPolygon(b' points);                      break;                  case ChartMarkerEnum.Triangle:                      points = new PointF[4];                      points[0] = points[3] = new PointF(x + (mSize + 1) / 2' y);	// starting and ending point                      points[1] = new PointF(x' y + mSize);                      points[2] = new PointF(x + mSize' y + mSize);                      g.FillPolygon(b' points);                      break;                  case ChartMarkerEnum.X:                      p2 = new Pen(b' 2.0f);                      g.DrawLine(p2' new Point(x' y)' new Point(x + mSize' y + mSize));                      g.DrawLine(p2' new Point(x' y + mSize)' new Point(x + mSize' y));                      break;              }
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawLegendLineMarker,The following statement contains a magic number: switch (marker)              {                  case ChartMarkerEnum.Bubble:                  case ChartMarkerEnum.Circle:                      g.FillEllipse(b' x' y' mSize' mSize);                      break;                  case ChartMarkerEnum.Square:                      g.FillRectangle(b' x' y' mSize' mSize);                      break;                  case ChartMarkerEnum.Plus:                                                           p2 = new Pen(b' 2.0f);                      g.DrawLine(p2' new Point(x + (mSize + 1) / 2' y)' new Point(x + (mSize + 1) / 2' y + mSize));                      //g.DrawLine(p2' new Point(x + (mSize + 1) / 2' y + (mSize + 1) / 2)' new Point(x + mSize' y + (mSize + 1) / 2));                      break;                  case ChartMarkerEnum.Diamond:                      points = new PointF[5];                      points[0] = points[4] = new PointF(x + (mSize + 1) / 2' y);	// starting and ending point                      points[1] = new PointF(x' y + (mSize + 1) / 2);                      points[2] = new PointF(x + (mSize + 1) / 2' y + mSize);                      points[3] = new PointF(x + mSize' y + (mSize + 1) / 2);                      g.FillPolygon(b' points);                      break;                  case ChartMarkerEnum.Triangle:                      points = new PointF[4];                      points[0] = points[3] = new PointF(x + (mSize + 1) / 2' y);	// starting and ending point                      points[1] = new PointF(x' y + mSize);                      points[2] = new PointF(x + mSize' y + mSize);                      g.FillPolygon(b' points);                      break;                  case ChartMarkerEnum.X:                      p2 = new Pen(b' 2.0f);                      g.DrawLine(p2' new Point(x' y)' new Point(x + mSize' y + mSize));                      g.DrawLine(p2' new Point(x' y + mSize)' new Point(x + mSize' y));                      break;              }
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawLegendLineMarker,The following statement contains a magic number: switch (marker)              {                  case ChartMarkerEnum.Bubble:                  case ChartMarkerEnum.Circle:                      g.FillEllipse(b' x' y' mSize' mSize);                      break;                  case ChartMarkerEnum.Square:                      g.FillRectangle(b' x' y' mSize' mSize);                      break;                  case ChartMarkerEnum.Plus:                                                           p2 = new Pen(b' 2.0f);                      g.DrawLine(p2' new Point(x + (mSize + 1) / 2' y)' new Point(x + (mSize + 1) / 2' y + mSize));                      //g.DrawLine(p2' new Point(x + (mSize + 1) / 2' y + (mSize + 1) / 2)' new Point(x + mSize' y + (mSize + 1) / 2));                      break;                  case ChartMarkerEnum.Diamond:                      points = new PointF[5];                      points[0] = points[4] = new PointF(x + (mSize + 1) / 2' y);	// starting and ending point                      points[1] = new PointF(x' y + (mSize + 1) / 2);                      points[2] = new PointF(x + (mSize + 1) / 2' y + mSize);                      points[3] = new PointF(x + mSize' y + (mSize + 1) / 2);                      g.FillPolygon(b' points);                      break;                  case ChartMarkerEnum.Triangle:                      points = new PointF[4];                      points[0] = points[3] = new PointF(x + (mSize + 1) / 2' y);	// starting and ending point                      points[1] = new PointF(x' y + mSize);                      points[2] = new PointF(x + mSize' y + mSize);                      g.FillPolygon(b' points);                      break;                  case ChartMarkerEnum.X:                      p2 = new Pen(b' 2.0f);                      g.DrawLine(p2' new Point(x' y)' new Point(x + mSize' y + mSize));                      g.DrawLine(p2' new Point(x' y + mSize)' new Point(x + mSize' y));                      break;              }
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawLegendLineMarker,The following statement contains a magic number: switch (marker)              {                  case ChartMarkerEnum.Bubble:                  case ChartMarkerEnum.Circle:                      g.FillEllipse(b' x' y' mSize' mSize);                      break;                  case ChartMarkerEnum.Square:                      g.FillRectangle(b' x' y' mSize' mSize);                      break;                  case ChartMarkerEnum.Plus:                                                           p2 = new Pen(b' 2.0f);                      g.DrawLine(p2' new Point(x + (mSize + 1) / 2' y)' new Point(x + (mSize + 1) / 2' y + mSize));                      //g.DrawLine(p2' new Point(x + (mSize + 1) / 2' y + (mSize + 1) / 2)' new Point(x + mSize' y + (mSize + 1) / 2));                      break;                  case ChartMarkerEnum.Diamond:                      points = new PointF[5];                      points[0] = points[4] = new PointF(x + (mSize + 1) / 2' y);	// starting and ending point                      points[1] = new PointF(x' y + (mSize + 1) / 2);                      points[2] = new PointF(x + (mSize + 1) / 2' y + mSize);                      points[3] = new PointF(x + mSize' y + (mSize + 1) / 2);                      g.FillPolygon(b' points);                      break;                  case ChartMarkerEnum.Triangle:                      points = new PointF[4];                      points[0] = points[3] = new PointF(x + (mSize + 1) / 2' y);	// starting and ending point                      points[1] = new PointF(x' y + mSize);                      points[2] = new PointF(x + mSize' y + mSize);                      g.FillPolygon(b' points);                      break;                  case ChartMarkerEnum.X:                      p2 = new Pen(b' 2.0f);                      g.DrawLine(p2' new Point(x' y)' new Point(x + mSize' y + mSize));                      g.DrawLine(p2' new Point(x' y + mSize)' new Point(x + mSize' y));                      break;              }
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawLegendLineMarker,The following statement contains a magic number: switch (marker)              {                  case ChartMarkerEnum.Bubble:                  case ChartMarkerEnum.Circle:                      g.FillEllipse(b' x' y' mSize' mSize);                      break;                  case ChartMarkerEnum.Square:                      g.FillRectangle(b' x' y' mSize' mSize);                      break;                  case ChartMarkerEnum.Plus:                                                           p2 = new Pen(b' 2.0f);                      g.DrawLine(p2' new Point(x + (mSize + 1) / 2' y)' new Point(x + (mSize + 1) / 2' y + mSize));                      //g.DrawLine(p2' new Point(x + (mSize + 1) / 2' y + (mSize + 1) / 2)' new Point(x + mSize' y + (mSize + 1) / 2));                      break;                  case ChartMarkerEnum.Diamond:                      points = new PointF[5];                      points[0] = points[4] = new PointF(x + (mSize + 1) / 2' y);	// starting and ending point                      points[1] = new PointF(x' y + (mSize + 1) / 2);                      points[2] = new PointF(x + (mSize + 1) / 2' y + mSize);                      points[3] = new PointF(x + mSize' y + (mSize + 1) / 2);                      g.FillPolygon(b' points);                      break;                  case ChartMarkerEnum.Triangle:                      points = new PointF[4];                      points[0] = points[3] = new PointF(x + (mSize + 1) / 2' y);	// starting and ending point                      points[1] = new PointF(x' y + mSize);                      points[2] = new PointF(x + mSize' y + mSize);                      g.FillPolygon(b' points);                      break;                  case ChartMarkerEnum.X:                      p2 = new Pen(b' 2.0f);                      g.DrawLine(p2' new Point(x' y)' new Point(x + mSize' y + mSize));                      g.DrawLine(p2' new Point(x' y + mSize)' new Point(x + mSize' y));                      break;              }
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawLegendLineMarker,The following statement contains a magic number: switch (marker)              {                  case ChartMarkerEnum.Bubble:                  case ChartMarkerEnum.Circle:                      g.FillEllipse(b' x' y' mSize' mSize);                      break;                  case ChartMarkerEnum.Square:                      g.FillRectangle(b' x' y' mSize' mSize);                      break;                  case ChartMarkerEnum.Plus:                                                           p2 = new Pen(b' 2.0f);                      g.DrawLine(p2' new Point(x + (mSize + 1) / 2' y)' new Point(x + (mSize + 1) / 2' y + mSize));                      //g.DrawLine(p2' new Point(x + (mSize + 1) / 2' y + (mSize + 1) / 2)' new Point(x + mSize' y + (mSize + 1) / 2));                      break;                  case ChartMarkerEnum.Diamond:                      points = new PointF[5];                      points[0] = points[4] = new PointF(x + (mSize + 1) / 2' y);	// starting and ending point                      points[1] = new PointF(x' y + (mSize + 1) / 2);                      points[2] = new PointF(x + (mSize + 1) / 2' y + mSize);                      points[3] = new PointF(x + mSize' y + (mSize + 1) / 2);                      g.FillPolygon(b' points);                      break;                  case ChartMarkerEnum.Triangle:                      points = new PointF[4];                      points[0] = points[3] = new PointF(x + (mSize + 1) / 2' y);	// starting and ending point                      points[1] = new PointF(x' y + mSize);                      points[2] = new PointF(x + mSize' y + mSize);                      g.FillPolygon(b' points);                      break;                  case ChartMarkerEnum.X:                      p2 = new Pen(b' 2.0f);                      g.DrawLine(p2' new Point(x' y)' new Point(x + mSize' y + mSize));                      g.DrawLine(p2' new Point(x' y + mSize)' new Point(x + mSize' y));                      break;              }
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawLegendLineMarker,The following statement contains a magic number: switch (marker)              {                  case ChartMarkerEnum.Bubble:                  case ChartMarkerEnum.Circle:                      g.FillEllipse(b' x' y' mSize' mSize);                      break;                  case ChartMarkerEnum.Square:                      g.FillRectangle(b' x' y' mSize' mSize);                      break;                  case ChartMarkerEnum.Plus:                                                           p2 = new Pen(b' 2.0f);                      g.DrawLine(p2' new Point(x + (mSize + 1) / 2' y)' new Point(x + (mSize + 1) / 2' y + mSize));                      //g.DrawLine(p2' new Point(x + (mSize + 1) / 2' y + (mSize + 1) / 2)' new Point(x + mSize' y + (mSize + 1) / 2));                      break;                  case ChartMarkerEnum.Diamond:                      points = new PointF[5];                      points[0] = points[4] = new PointF(x + (mSize + 1) / 2' y);	// starting and ending point                      points[1] = new PointF(x' y + (mSize + 1) / 2);                      points[2] = new PointF(x + (mSize + 1) / 2' y + mSize);                      points[3] = new PointF(x + mSize' y + (mSize + 1) / 2);                      g.FillPolygon(b' points);                      break;                  case ChartMarkerEnum.Triangle:                      points = new PointF[4];                      points[0] = points[3] = new PointF(x + (mSize + 1) / 2' y);	// starting and ending point                      points[1] = new PointF(x' y + mSize);                      points[2] = new PointF(x + mSize' y + mSize);                      g.FillPolygon(b' points);                      break;                  case ChartMarkerEnum.X:                      p2 = new Pen(b' 2.0f);                      g.DrawLine(p2' new Point(x' y)' new Point(x + mSize' y + mSize));                      g.DrawLine(p2' new Point(x' y + mSize)' new Point(x + mSize' y));                      break;              }
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawLegendLineMarker,The following statement contains a magic number: switch (marker)              {                  case ChartMarkerEnum.Bubble:                  case ChartMarkerEnum.Circle:                      g.FillEllipse(b' x' y' mSize' mSize);                      break;                  case ChartMarkerEnum.Square:                      g.FillRectangle(b' x' y' mSize' mSize);                      break;                  case ChartMarkerEnum.Plus:                                                           p2 = new Pen(b' 2.0f);                      g.DrawLine(p2' new Point(x + (mSize + 1) / 2' y)' new Point(x + (mSize + 1) / 2' y + mSize));                      //g.DrawLine(p2' new Point(x + (mSize + 1) / 2' y + (mSize + 1) / 2)' new Point(x + mSize' y + (mSize + 1) / 2));                      break;                  case ChartMarkerEnum.Diamond:                      points = new PointF[5];                      points[0] = points[4] = new PointF(x + (mSize + 1) / 2' y);	// starting and ending point                      points[1] = new PointF(x' y + (mSize + 1) / 2);                      points[2] = new PointF(x + (mSize + 1) / 2' y + mSize);                      points[3] = new PointF(x + mSize' y + (mSize + 1) / 2);                      g.FillPolygon(b' points);                      break;                  case ChartMarkerEnum.Triangle:                      points = new PointF[4];                      points[0] = points[3] = new PointF(x + (mSize + 1) / 2' y);	// starting and ending point                      points[1] = new PointF(x' y + mSize);                      points[2] = new PointF(x + mSize' y + mSize);                      g.FillPolygon(b' points);                      break;                  case ChartMarkerEnum.X:                      p2 = new Pen(b' 2.0f);                      g.DrawLine(p2' new Point(x' y)' new Point(x + mSize' y + mSize));                      g.DrawLine(p2' new Point(x' y + mSize)' new Point(x + mSize' y));                      break;              }
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawLegendLineMarker,The following statement contains a magic number: switch (marker)              {                  case ChartMarkerEnum.Bubble:                  case ChartMarkerEnum.Circle:                      g.FillEllipse(b' x' y' mSize' mSize);                      break;                  case ChartMarkerEnum.Square:                      g.FillRectangle(b' x' y' mSize' mSize);                      break;                  case ChartMarkerEnum.Plus:                                                           p2 = new Pen(b' 2.0f);                      g.DrawLine(p2' new Point(x + (mSize + 1) / 2' y)' new Point(x + (mSize + 1) / 2' y + mSize));                      //g.DrawLine(p2' new Point(x + (mSize + 1) / 2' y + (mSize + 1) / 2)' new Point(x + mSize' y + (mSize + 1) / 2));                      break;                  case ChartMarkerEnum.Diamond:                      points = new PointF[5];                      points[0] = points[4] = new PointF(x + (mSize + 1) / 2' y);	// starting and ending point                      points[1] = new PointF(x' y + (mSize + 1) / 2);                      points[2] = new PointF(x + (mSize + 1) / 2' y + mSize);                      points[3] = new PointF(x + mSize' y + (mSize + 1) / 2);                      g.FillPolygon(b' points);                      break;                  case ChartMarkerEnum.Triangle:                      points = new PointF[4];                      points[0] = points[3] = new PointF(x + (mSize + 1) / 2' y);	// starting and ending point                      points[1] = new PointF(x' y + mSize);                      points[2] = new PointF(x + mSize' y + mSize);                      g.FillPolygon(b' points);                      break;                  case ChartMarkerEnum.X:                      p2 = new Pen(b' 2.0f);                      g.DrawLine(p2' new Point(x' y)' new Point(x + mSize' y + mSize));                      g.DrawLine(p2' new Point(x' y + mSize)' new Point(x + mSize' y));                      break;              }
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawLegendLineMarker,The following statement contains a magic number: switch (marker)              {                  case ChartMarkerEnum.Bubble:                  case ChartMarkerEnum.Circle:                      g.FillEllipse(b' x' y' mSize' mSize);                      break;                  case ChartMarkerEnum.Square:                      g.FillRectangle(b' x' y' mSize' mSize);                      break;                  case ChartMarkerEnum.Plus:                                                           p2 = new Pen(b' 2.0f);                      g.DrawLine(p2' new Point(x + (mSize + 1) / 2' y)' new Point(x + (mSize + 1) / 2' y + mSize));                      //g.DrawLine(p2' new Point(x + (mSize + 1) / 2' y + (mSize + 1) / 2)' new Point(x + mSize' y + (mSize + 1) / 2));                      break;                  case ChartMarkerEnum.Diamond:                      points = new PointF[5];                      points[0] = points[4] = new PointF(x + (mSize + 1) / 2' y);	// starting and ending point                      points[1] = new PointF(x' y + (mSize + 1) / 2);                      points[2] = new PointF(x + (mSize + 1) / 2' y + mSize);                      points[3] = new PointF(x + mSize' y + (mSize + 1) / 2);                      g.FillPolygon(b' points);                      break;                  case ChartMarkerEnum.Triangle:                      points = new PointF[4];                      points[0] = points[3] = new PointF(x + (mSize + 1) / 2' y);	// starting and ending point                      points[1] = new PointF(x' y + mSize);                      points[2] = new PointF(x + mSize' y + mSize);                      g.FillPolygon(b' points);                      break;                  case ChartMarkerEnum.X:                      p2 = new Pen(b' 2.0f);                      g.DrawLine(p2' new Point(x' y)' new Point(x + mSize' y + mSize));                      g.DrawLine(p2' new Point(x' y + mSize)' new Point(x + mSize' y));                      break;              }
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawLegendLineMarker,The following statement contains a magic number: switch (marker)              {                  case ChartMarkerEnum.Bubble:                  case ChartMarkerEnum.Circle:                      g.FillEllipse(b' x' y' mSize' mSize);                      break;                  case ChartMarkerEnum.Square:                      g.FillRectangle(b' x' y' mSize' mSize);                      break;                  case ChartMarkerEnum.Plus:                                                           p2 = new Pen(b' 2.0f);                      g.DrawLine(p2' new Point(x + (mSize + 1) / 2' y)' new Point(x + (mSize + 1) / 2' y + mSize));                      //g.DrawLine(p2' new Point(x + (mSize + 1) / 2' y + (mSize + 1) / 2)' new Point(x + mSize' y + (mSize + 1) / 2));                      break;                  case ChartMarkerEnum.Diamond:                      points = new PointF[5];                      points[0] = points[4] = new PointF(x + (mSize + 1) / 2' y);	// starting and ending point                      points[1] = new PointF(x' y + (mSize + 1) / 2);                      points[2] = new PointF(x + (mSize + 1) / 2' y + mSize);                      points[3] = new PointF(x + mSize' y + (mSize + 1) / 2);                      g.FillPolygon(b' points);                      break;                  case ChartMarkerEnum.Triangle:                      points = new PointF[4];                      points[0] = points[3] = new PointF(x + (mSize + 1) / 2' y);	// starting and ending point                      points[1] = new PointF(x' y + mSize);                      points[2] = new PointF(x + mSize' y + mSize);                      g.FillPolygon(b' points);                      break;                  case ChartMarkerEnum.X:                      p2 = new Pen(b' 2.0f);                      g.DrawLine(p2' new Point(x' y)' new Point(x + mSize' y + mSize));                      g.DrawLine(p2' new Point(x' y + mSize)' new Point(x + mSize' y));                      break;              }
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawLineBetweenPoints,The following statement contains a magic number: DrawLineBetweenPoints(g' rpt' brush' points' 2);
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawLineBetweenPoints,The following statement contains a magic number: try              {                  if (brush.GetType() == typeof(System.Drawing.Drawing2D.HatchBrush))                  {                      System.Drawing.Drawing2D.HatchBrush tmpBrush = (System.Drawing.Drawing2D.HatchBrush)brush;                      p = new Pen(new SolidBrush(tmpBrush.ForegroundColor)' intLineSize); //1.5F);    // todo - use line from style ????                  }                  else                  {                      p = new Pen(brush' intLineSize);                  }                    if ((ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.Smooth && points.Length > 2)                      g.DrawCurve(p' points' 0.5F);                  else                      g.DrawLines(p' points);              }              finally              {                  if (p != null)                      p.Dispose();              }
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawPlotAreaStacked,The following statement contains a magic number: int gapsNeeded = CategoryCount * 2;
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawCategoryAxis,The following statement contains a magic number: for (int iRow=1; iRow <= CategoryCount; iRow++)  			{  				object v = this.GetCategoryValue(rpt' iRow' out tc);                  //make sure we are dealing with datetime type                  if (date)                  {                      CurrentDate = (DateTime)v;                                                  }                  int drawLoc=(int) (rect.Left + (iRow-1) * ((double) rect.Width / catCount));                   				// Draw the category text                  int skip = 0;  				if (a.Visible && !a.Month)  //18052008WRP only show category labels if not month scale  				{  					System.Drawing.Rectangle drawRect;                      Size size = Size.Empty;                        if (mustSize)                      {	// Area chart - value is centered under the tick mark                          if (s != null)                          {                              size = s.MeasureString(rpt' g' v' TypeCode.Double' null' int.MaxValue);                          }                          else                          {                              size = Style.MeasureStringDefaults(rpt' g' v' TypeCode.Double' null' int.MaxValue);                          }                      }    					if (ChartDefn.Type == ChartTypeEnum.Area)  					{	// Area chart - value is centered under the tick mark  						drawRect =   								new System.Drawing.Rectangle(drawLoc - size.Width/2' rect.Top+tickSize' size.Width' size.Height);  					}  					else	// Column/Line charts are just centered in the region.  						drawRect = new System.Drawing.Rectangle(drawLoc' rect.Top+tickSize' drawWidth' rect.Height-tSize.Height);                        if (mustSize && drawRect.Width < size.Width)                      {                          skip = (int) (size.Width / drawWidth);                          drawRect.Width = size.Width;                      }    					if (s == null)  						Style.DrawStringDefaults(g' v' drawRect);  					else  						s.DrawString(rpt' g' v' tc' null' drawRect);  				}                    //09052008WRP Draw major gridlines and place category labels for months scale                   if (a.Month && date && a.Visible)                  {                        if (CurrentDate.Month != OldDate.Month)                      {                          TempDate = CurrentDate;                          DrawCategoryAxisGrid(rpt' g' a.MajorGridLines' new Point(drawLoc' rect.Top)' new Point(drawLoc' plotTop)); //Don't overdraw the Y axis on the first gridline                          CurrentDate = CurrentDate.AddMonths(OldDate.Month - CurrentDate.Month); // get previous category month value                          string MonthString = CurrentDate.ToString("MMMM");                          Size lSize = DrawCategoryTitleMeasure(rpt' g' MonthString's);                          int catlabelLoc = (int)((drawLoc - PreviousLocation) / 2) + PreviousLocation - lSize.Width / 2;                          DrawCategoryLabel(rpt' g' MonthString' a.Style' new System.Drawing.Rectangle(catlabelLoc' rect.Top - (lSize.Height - 25)' lSize.Width' lSize.Height));                          PreviousLocation = drawLoc;                          OldDate = TempDate;                                               }                  }                  if ((MajorGrid != 0) && ((iRow-1) % MajorGrid == 0) && !(a.Month))                  //if (((iRow - 1) % ((int)a.MajorInterval.EvaluateDouble(rpt' this.ChartRow.RowNumber)) == 0) && !(a.Month))                   {                      DrawCategoryAxisGrid(rpt' g' a.MajorGridLines' new Point(drawLoc' rect.Top)' new Point(drawLoc' plotTop));                  }  				// Draw the Major Tick Marks (if necessary)  				DrawCategoryAxisTick(g' true' a.MajorTickMarks' new Point(drawLoc' rect.Top));                  iRow += skip;  			}
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawCategoryAxis,The following statement contains a magic number: for (int iRow=1; iRow <= CategoryCount; iRow++)  			{  				object v = this.GetCategoryValue(rpt' iRow' out tc);                  //make sure we are dealing with datetime type                  if (date)                  {                      CurrentDate = (DateTime)v;                                                  }                  int drawLoc=(int) (rect.Left + (iRow-1) * ((double) rect.Width / catCount));                   				// Draw the category text                  int skip = 0;  				if (a.Visible && !a.Month)  //18052008WRP only show category labels if not month scale  				{  					System.Drawing.Rectangle drawRect;                      Size size = Size.Empty;                        if (mustSize)                      {	// Area chart - value is centered under the tick mark                          if (s != null)                          {                              size = s.MeasureString(rpt' g' v' TypeCode.Double' null' int.MaxValue);                          }                          else                          {                              size = Style.MeasureStringDefaults(rpt' g' v' TypeCode.Double' null' int.MaxValue);                          }                      }    					if (ChartDefn.Type == ChartTypeEnum.Area)  					{	// Area chart - value is centered under the tick mark  						drawRect =   								new System.Drawing.Rectangle(drawLoc - size.Width/2' rect.Top+tickSize' size.Width' size.Height);  					}  					else	// Column/Line charts are just centered in the region.  						drawRect = new System.Drawing.Rectangle(drawLoc' rect.Top+tickSize' drawWidth' rect.Height-tSize.Height);                        if (mustSize && drawRect.Width < size.Width)                      {                          skip = (int) (size.Width / drawWidth);                          drawRect.Width = size.Width;                      }    					if (s == null)  						Style.DrawStringDefaults(g' v' drawRect);  					else  						s.DrawString(rpt' g' v' tc' null' drawRect);  				}                    //09052008WRP Draw major gridlines and place category labels for months scale                   if (a.Month && date && a.Visible)                  {                        if (CurrentDate.Month != OldDate.Month)                      {                          TempDate = CurrentDate;                          DrawCategoryAxisGrid(rpt' g' a.MajorGridLines' new Point(drawLoc' rect.Top)' new Point(drawLoc' plotTop)); //Don't overdraw the Y axis on the first gridline                          CurrentDate = CurrentDate.AddMonths(OldDate.Month - CurrentDate.Month); // get previous category month value                          string MonthString = CurrentDate.ToString("MMMM");                          Size lSize = DrawCategoryTitleMeasure(rpt' g' MonthString's);                          int catlabelLoc = (int)((drawLoc - PreviousLocation) / 2) + PreviousLocation - lSize.Width / 2;                          DrawCategoryLabel(rpt' g' MonthString' a.Style' new System.Drawing.Rectangle(catlabelLoc' rect.Top - (lSize.Height - 25)' lSize.Width' lSize.Height));                          PreviousLocation = drawLoc;                          OldDate = TempDate;                                               }                  }                  if ((MajorGrid != 0) && ((iRow-1) % MajorGrid == 0) && !(a.Month))                  //if (((iRow - 1) % ((int)a.MajorInterval.EvaluateDouble(rpt' this.ChartRow.RowNumber)) == 0) && !(a.Month))                   {                      DrawCategoryAxisGrid(rpt' g' a.MajorGridLines' new Point(drawLoc' rect.Top)' new Point(drawLoc' plotTop));                  }  				// Draw the Major Tick Marks (if necessary)  				DrawCategoryAxisTick(g' true' a.MajorTickMarks' new Point(drawLoc' rect.Top));                  iRow += skip;  			}
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawCategoryAxis,The following statement contains a magic number: for (int iRow=1; iRow <= CategoryCount; iRow++)  			{  				object v = this.GetCategoryValue(rpt' iRow' out tc);                  //make sure we are dealing with datetime type                  if (date)                  {                      CurrentDate = (DateTime)v;                                                  }                  int drawLoc=(int) (rect.Left + (iRow-1) * ((double) rect.Width / catCount));                   				// Draw the category text                  int skip = 0;  				if (a.Visible && !a.Month)  //18052008WRP only show category labels if not month scale  				{  					System.Drawing.Rectangle drawRect;                      Size size = Size.Empty;                        if (mustSize)                      {	// Area chart - value is centered under the tick mark                          if (s != null)                          {                              size = s.MeasureString(rpt' g' v' TypeCode.Double' null' int.MaxValue);                          }                          else                          {                              size = Style.MeasureStringDefaults(rpt' g' v' TypeCode.Double' null' int.MaxValue);                          }                      }    					if (ChartDefn.Type == ChartTypeEnum.Area)  					{	// Area chart - value is centered under the tick mark  						drawRect =   								new System.Drawing.Rectangle(drawLoc - size.Width/2' rect.Top+tickSize' size.Width' size.Height);  					}  					else	// Column/Line charts are just centered in the region.  						drawRect = new System.Drawing.Rectangle(drawLoc' rect.Top+tickSize' drawWidth' rect.Height-tSize.Height);                        if (mustSize && drawRect.Width < size.Width)                      {                          skip = (int) (size.Width / drawWidth);                          drawRect.Width = size.Width;                      }    					if (s == null)  						Style.DrawStringDefaults(g' v' drawRect);  					else  						s.DrawString(rpt' g' v' tc' null' drawRect);  				}                    //09052008WRP Draw major gridlines and place category labels for months scale                   if (a.Month && date && a.Visible)                  {                        if (CurrentDate.Month != OldDate.Month)                      {                          TempDate = CurrentDate;                          DrawCategoryAxisGrid(rpt' g' a.MajorGridLines' new Point(drawLoc' rect.Top)' new Point(drawLoc' plotTop)); //Don't overdraw the Y axis on the first gridline                          CurrentDate = CurrentDate.AddMonths(OldDate.Month - CurrentDate.Month); // get previous category month value                          string MonthString = CurrentDate.ToString("MMMM");                          Size lSize = DrawCategoryTitleMeasure(rpt' g' MonthString's);                          int catlabelLoc = (int)((drawLoc - PreviousLocation) / 2) + PreviousLocation - lSize.Width / 2;                          DrawCategoryLabel(rpt' g' MonthString' a.Style' new System.Drawing.Rectangle(catlabelLoc' rect.Top - (lSize.Height - 25)' lSize.Width' lSize.Height));                          PreviousLocation = drawLoc;                          OldDate = TempDate;                                               }                  }                  if ((MajorGrid != 0) && ((iRow-1) % MajorGrid == 0) && !(a.Month))                  //if (((iRow - 1) % ((int)a.MajorInterval.EvaluateDouble(rpt' this.ChartRow.RowNumber)) == 0) && !(a.Month))                   {                      DrawCategoryAxisGrid(rpt' g' a.MajorGridLines' new Point(drawLoc' rect.Top)' new Point(drawLoc' plotTop));                  }  				// Draw the Major Tick Marks (if necessary)  				DrawCategoryAxisTick(g' true' a.MajorTickMarks' new Point(drawLoc' rect.Top));                  iRow += skip;  			}
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawCategoryAxis,The following statement contains a magic number: for (int iRow=1; iRow <= CategoryCount; iRow++)  			{  				object v = this.GetCategoryValue(rpt' iRow' out tc);                  //make sure we are dealing with datetime type                  if (date)                  {                      CurrentDate = (DateTime)v;                                                  }                  int drawLoc=(int) (rect.Left + (iRow-1) * ((double) rect.Width / catCount));                   				// Draw the category text                  int skip = 0;  				if (a.Visible && !a.Month)  //18052008WRP only show category labels if not month scale  				{  					System.Drawing.Rectangle drawRect;                      Size size = Size.Empty;                        if (mustSize)                      {	// Area chart - value is centered under the tick mark                          if (s != null)                          {                              size = s.MeasureString(rpt' g' v' TypeCode.Double' null' int.MaxValue);                          }                          else                          {                              size = Style.MeasureStringDefaults(rpt' g' v' TypeCode.Double' null' int.MaxValue);                          }                      }    					if (ChartDefn.Type == ChartTypeEnum.Area)  					{	// Area chart - value is centered under the tick mark  						drawRect =   								new System.Drawing.Rectangle(drawLoc - size.Width/2' rect.Top+tickSize' size.Width' size.Height);  					}  					else	// Column/Line charts are just centered in the region.  						drawRect = new System.Drawing.Rectangle(drawLoc' rect.Top+tickSize' drawWidth' rect.Height-tSize.Height);                        if (mustSize && drawRect.Width < size.Width)                      {                          skip = (int) (size.Width / drawWidth);                          drawRect.Width = size.Width;                      }    					if (s == null)  						Style.DrawStringDefaults(g' v' drawRect);  					else  						s.DrawString(rpt' g' v' tc' null' drawRect);  				}                    //09052008WRP Draw major gridlines and place category labels for months scale                   if (a.Month && date && a.Visible)                  {                        if (CurrentDate.Month != OldDate.Month)                      {                          TempDate = CurrentDate;                          DrawCategoryAxisGrid(rpt' g' a.MajorGridLines' new Point(drawLoc' rect.Top)' new Point(drawLoc' plotTop)); //Don't overdraw the Y axis on the first gridline                          CurrentDate = CurrentDate.AddMonths(OldDate.Month - CurrentDate.Month); // get previous category month value                          string MonthString = CurrentDate.ToString("MMMM");                          Size lSize = DrawCategoryTitleMeasure(rpt' g' MonthString's);                          int catlabelLoc = (int)((drawLoc - PreviousLocation) / 2) + PreviousLocation - lSize.Width / 2;                          DrawCategoryLabel(rpt' g' MonthString' a.Style' new System.Drawing.Rectangle(catlabelLoc' rect.Top - (lSize.Height - 25)' lSize.Width' lSize.Height));                          PreviousLocation = drawLoc;                          OldDate = TempDate;                                               }                  }                  if ((MajorGrid != 0) && ((iRow-1) % MajorGrid == 0) && !(a.Month))                  //if (((iRow - 1) % ((int)a.MajorInterval.EvaluateDouble(rpt' this.ChartRow.RowNumber)) == 0) && !(a.Month))                   {                      DrawCategoryAxisGrid(rpt' g' a.MajorGridLines' new Point(drawLoc' rect.Top)' new Point(drawLoc' plotTop));                  }  				// Draw the Major Tick Marks (if necessary)  				DrawCategoryAxisTick(g' true' a.MajorTickMarks' new Point(drawLoc' rect.Top));                  iRow += skip;  			}
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawCategoryAxis,The following statement contains a magic number: if (a.Month && date && a.Visible)// 16052008WRP draw last category label for months scale              {                  string MonthString = OldDate.ToString("MMMM");                  Size lSize = DrawCategoryTitleMeasure(rpt' g' MonthString's);                  int catlabelLoc = (int)((rect.Right - PreviousLocation) / 2) + PreviousLocation - lSize.Width / 2;                  DrawCategoryLabel(rpt' g' MonthString' a.Style' new System.Drawing.Rectangle(catlabelLoc' rect.Top - (lSize.Height - 25)' lSize.Width' lSize.Height));              }
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawCategoryAxis,The following statement contains a magic number: if (a.Month && date && a.Visible)// 16052008WRP draw last category label for months scale              {                  string MonthString = OldDate.ToString("MMMM");                  Size lSize = DrawCategoryTitleMeasure(rpt' g' MonthString's);                  int catlabelLoc = (int)((rect.Right - PreviousLocation) / 2) + PreviousLocation - lSize.Width / 2;                  DrawCategoryLabel(rpt' g' MonthString' a.Style' new System.Drawing.Rectangle(catlabelLoc' rect.Top - (lSize.Height - 25)' lSize.Width' lSize.Height));              }
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawCategoryAxis,The following statement contains a magic number: if (a.Month && date && a.Visible)// 16052008WRP draw last category label for months scale              {                  string MonthString = OldDate.ToString("MMMM");                  Size lSize = DrawCategoryTitleMeasure(rpt' g' MonthString's);                  int catlabelLoc = (int)((rect.Right - PreviousLocation) / 2) + PreviousLocation - lSize.Width / 2;                  DrawCategoryLabel(rpt' g' MonthString' a.Style' new System.Drawing.Rectangle(catlabelLoc' rect.Top - (lSize.Height - 25)' lSize.Width' lSize.Height));              }
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawColumnBar,The following statement contains a magic number: rect = new System.Drawing.Rectangle(rect.Left + 2' rect.Top' rect.Width -3' rect.Height);
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawColumnBar,The following statement contains a magic number: rect = new System.Drawing.Rectangle(rect.Left + 2' rect.Top' rect.Width -3' rect.Height);
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawColumnBar,The following statement contains a magic number: if ((ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.Stacked ||                  (ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.PercentStacked)  			{  				DrawDataPoint(rpt' g' rect' iRow' iCol);  			}  			else  			{  				Point p;  				p = new Point(rect.Left' rect.Top - 14); // todo: 14 is arbitrary  				DrawDataPoint(rpt' g' p' iRow' iCol);  			}
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawValueAxis,The following statement contains a magic number: for (int i=0; i < intervalCount+1; i++)	   			{  				int h = (int) (((Math.Min(v'max)-min) / (max-min)) * rect.Height);  				if (h < 0)		// this is really some form of error  				{  					v += incr;  					continue;  				}    				if (!a.Visible)  				{  					// nothing to do  				}  				else if (s != null)  				{  					Size size = s.MeasureString(rpt' g' v' TypeCode.Double' null' int.MaxValue);  					System.Drawing.Rectangle vRect =   						new System.Drawing.Rectangle(rect.Left+tSize.Width' rect.Top + rect.Height - h - size.Height/2' rect.Width-tSize.Width' size.Height);  					s.DrawString(rpt' g' v' TypeCode.Double' null' vRect);  				}  				else  				{  					Size size = Style.MeasureStringDefaults(rpt' g' v' TypeCode.Double' null' int.MaxValue);  					System.Drawing.Rectangle vRect =   						new System.Drawing.Rectangle(rect.Left+tSize.Width' rect.Top + rect.Height - h - size.Height/2' rect.Width-tSize.Width' size.Height);  					Style.DrawStringDefaults(g' v' vRect);  				}    				DrawValueAxisGrid(rpt' g' a.MajorGridLines' new Point(plotLeft' rect.Top + rect.Height - h)' new Point(plotRight' rect.Top + rect.Height - h));  				DrawValueAxisTick(rpt' g' true' a.MajorTickMarks' a.MajorGridLines' new Point(plotLeft' rect.Top + rect.Height - h));    				v += incr;  			}
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawValueAxis,The following statement contains a magic number: for (int i=0; i < intervalCount+1; i++)	   			{  				int h = (int) (((Math.Min(v'max)-min) / (max-min)) * rect.Height);  				if (h < 0)		// this is really some form of error  				{  					v += incr;  					continue;  				}    				if (!a.Visible)  				{  					// nothing to do  				}  				else if (s != null)  				{  					Size size = s.MeasureString(rpt' g' v' TypeCode.Double' null' int.MaxValue);  					System.Drawing.Rectangle vRect =   						new System.Drawing.Rectangle(rect.Left+tSize.Width' rect.Top + rect.Height - h - size.Height/2' rect.Width-tSize.Width' size.Height);  					s.DrawString(rpt' g' v' TypeCode.Double' null' vRect);  				}  				else  				{  					Size size = Style.MeasureStringDefaults(rpt' g' v' TypeCode.Double' null' int.MaxValue);  					System.Drawing.Rectangle vRect =   						new System.Drawing.Rectangle(rect.Left+tSize.Width' rect.Top + rect.Height - h - size.Height/2' rect.Width-tSize.Width' size.Height);  					Style.DrawStringDefaults(g' v' vRect);  				}    				DrawValueAxisGrid(rpt' g' a.MajorGridLines' new Point(plotLeft' rect.Top + rect.Height - h)' new Point(plotRight' rect.Top + rect.Height - h));  				DrawValueAxisTick(rpt' g' true' a.MajorTickMarks' a.MajorGridLines' new Point(plotLeft' rect.Top + rect.Height - h));    				v += incr;  			}
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,Draw2ndValueAxis,The following statement contains a magic number: GetMaxMinDataValue(rpt' out thisMax' out thisMin' 0' 2);
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,Draw2ndValueAxis,The following statement contains a magic number: _gridIncrs = 10;
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,Draw2ndValueAxis,The following statement contains a magic number: double logPow = Math.Pow(10' log) * Math.Sign(thisMax);
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,Draw2ndValueAxis,The following statement contains a magic number: double logDig = (int)(incr / logPow + .5);
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,Draw2ndValueAxis,The following statement contains a magic number: if (logDig > 5.0)                  logDig = 10.0;              else if (logDig > 2.0)                  logDig = 5.0;              else if (logDig > 1.0)                  logDig = 2.0;
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,Draw2ndValueAxis,The following statement contains a magic number: if (logDig > 5.0)                  logDig = 10.0;              else if (logDig > 2.0)                  logDig = 5.0;              else if (logDig > 1.0)                  logDig = 2.0;
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,Draw2ndValueAxis,The following statement contains a magic number: if (logDig > 5.0)                  logDig = 10.0;              else if (logDig > 2.0)                  logDig = 5.0;              else if (logDig > 1.0)                  logDig = 2.0;
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,Draw2ndValueAxis,The following statement contains a magic number: if (logDig > 5.0)                  logDig = 10.0;              else if (logDig > 2.0)                  logDig = 5.0;              else if (logDig > 1.0)                  logDig = 2.0;
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,Draw2ndValueAxis,The following statement contains a magic number: if (logDig > 5.0)                  logDig = 10.0;              else if (logDig > 2.0)                  logDig = 5.0;              else if (logDig > 1.0)                  logDig = 2.0;
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,Draw2ndValueAxis,The following statement contains a magic number: thisMax = (int)(logDig * logPow * _gridIncrs + 0.5);
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,Draw2ndValueAxis,The following statement contains a magic number: if (tmpMax > thisMax - ((thisMax / _gridIncrs) * .5))              {                    thisMax += (thisMax / _gridIncrs);                  _gridIncrs++;              }
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,Draw2ndValueAxis,The following statement contains a magic number: for (int i = 0; i < _gridIncrs + 1; i++)              {                  int h = (int)(((Math.Min(v' thisMax) - thisMin) / (thisMax - thisMin)) * rect.Height);                  if (h < 0)		// this is really some form of error                  {                      v += incr;                      continue;                  }                  if (!a.Visible)                  {                      // nothing to do                  }                  else if (s != null)                  {                      Size size = s.MeasureString(rpt' g' v' TypeCode.Double' null' int.MaxValue);                      System.Drawing.Rectangle vRect =                          new System.Drawing.Rectangle(rect.Left - (int)(tSize.Width * .5)' rect.Top + rect.Height - h - size.Height / 2' rect.Width - tSize.Width' size.Height);                      s.DrawString(rpt' g' v' TypeCode.Double' null' vRect);                  }                  else                  {                      Size size = Style.MeasureStringDefaults(rpt' g' v' TypeCode.Double' null' int.MaxValue);                      System.Drawing.Rectangle vRect =                          new System.Drawing.Rectangle(rect.Left - (int)(tSize.Width * .5)' rect.Top + rect.Height - h - size.Height / 2' rect.Width - tSize.Width * 2' size.Height);                      Style.DrawStringDefaults(g' v' vRect);                  }                              v += incr;                    DrawValueAxisTick(rpt' g' true' a.MajorTickMarks' a.MajorGridLines' new Point(plotRight - (AxisTickMarkMajorLen / 2)' rect.Top + rect.Height - h));                }
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,Draw2ndValueAxis,The following statement contains a magic number: for (int i = 0; i < _gridIncrs + 1; i++)              {                  int h = (int)(((Math.Min(v' thisMax) - thisMin) / (thisMax - thisMin)) * rect.Height);                  if (h < 0)		// this is really some form of error                  {                      v += incr;                      continue;                  }                  if (!a.Visible)                  {                      // nothing to do                  }                  else if (s != null)                  {                      Size size = s.MeasureString(rpt' g' v' TypeCode.Double' null' int.MaxValue);                      System.Drawing.Rectangle vRect =                          new System.Drawing.Rectangle(rect.Left - (int)(tSize.Width * .5)' rect.Top + rect.Height - h - size.Height / 2' rect.Width - tSize.Width' size.Height);                      s.DrawString(rpt' g' v' TypeCode.Double' null' vRect);                  }                  else                  {                      Size size = Style.MeasureStringDefaults(rpt' g' v' TypeCode.Double' null' int.MaxValue);                      System.Drawing.Rectangle vRect =                          new System.Drawing.Rectangle(rect.Left - (int)(tSize.Width * .5)' rect.Top + rect.Height - h - size.Height / 2' rect.Width - tSize.Width * 2' size.Height);                      Style.DrawStringDefaults(g' v' vRect);                  }                              v += incr;                    DrawValueAxisTick(rpt' g' true' a.MajorTickMarks' a.MajorGridLines' new Point(plotRight - (AxisTickMarkMajorLen / 2)' rect.Top + rect.Height - h));                }
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,Draw2ndValueAxis,The following statement contains a magic number: for (int i = 0; i < _gridIncrs + 1; i++)              {                  int h = (int)(((Math.Min(v' thisMax) - thisMin) / (thisMax - thisMin)) * rect.Height);                  if (h < 0)		// this is really some form of error                  {                      v += incr;                      continue;                  }                  if (!a.Visible)                  {                      // nothing to do                  }                  else if (s != null)                  {                      Size size = s.MeasureString(rpt' g' v' TypeCode.Double' null' int.MaxValue);                      System.Drawing.Rectangle vRect =                          new System.Drawing.Rectangle(rect.Left - (int)(tSize.Width * .5)' rect.Top + rect.Height - h - size.Height / 2' rect.Width - tSize.Width' size.Height);                      s.DrawString(rpt' g' v' TypeCode.Double' null' vRect);                  }                  else                  {                      Size size = Style.MeasureStringDefaults(rpt' g' v' TypeCode.Double' null' int.MaxValue);                      System.Drawing.Rectangle vRect =                          new System.Drawing.Rectangle(rect.Left - (int)(tSize.Width * .5)' rect.Top + rect.Height - h - size.Height / 2' rect.Width - tSize.Width * 2' size.Height);                      Style.DrawStringDefaults(g' v' vRect);                  }                              v += incr;                    DrawValueAxisTick(rpt' g' true' a.MajorTickMarks' a.MajorGridLines' new Point(plotRight - (AxisTickMarkMajorLen / 2)' rect.Top + rect.Height - h));                }
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,Draw2ndValueAxis,The following statement contains a magic number: for (int i = 0; i < _gridIncrs + 1; i++)              {                  int h = (int)(((Math.Min(v' thisMax) - thisMin) / (thisMax - thisMin)) * rect.Height);                  if (h < 0)		// this is really some form of error                  {                      v += incr;                      continue;                  }                  if (!a.Visible)                  {                      // nothing to do                  }                  else if (s != null)                  {                      Size size = s.MeasureString(rpt' g' v' TypeCode.Double' null' int.MaxValue);                      System.Drawing.Rectangle vRect =                          new System.Drawing.Rectangle(rect.Left - (int)(tSize.Width * .5)' rect.Top + rect.Height - h - size.Height / 2' rect.Width - tSize.Width' size.Height);                      s.DrawString(rpt' g' v' TypeCode.Double' null' vRect);                  }                  else                  {                      Size size = Style.MeasureStringDefaults(rpt' g' v' TypeCode.Double' null' int.MaxValue);                      System.Drawing.Rectangle vRect =                          new System.Drawing.Rectangle(rect.Left - (int)(tSize.Width * .5)' rect.Top + rect.Height - h - size.Height / 2' rect.Width - tSize.Width * 2' size.Height);                      Style.DrawStringDefaults(g' v' vRect);                  }                              v += incr;                    DrawValueAxisTick(rpt' g' true' a.MajorTickMarks' a.MajorGridLines' new Point(plotRight - (AxisTickMarkMajorLen / 2)' rect.Top + rect.Height - h));                }
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,Draw2ndValueAxis,The following statement contains a magic number: for (int i = 0; i < _gridIncrs + 1; i++)              {                  int h = (int)(((Math.Min(v' thisMax) - thisMin) / (thisMax - thisMin)) * rect.Height);                  if (h < 0)		// this is really some form of error                  {                      v += incr;                      continue;                  }                  if (!a.Visible)                  {                      // nothing to do                  }                  else if (s != null)                  {                      Size size = s.MeasureString(rpt' g' v' TypeCode.Double' null' int.MaxValue);                      System.Drawing.Rectangle vRect =                          new System.Drawing.Rectangle(rect.Left - (int)(tSize.Width * .5)' rect.Top + rect.Height - h - size.Height / 2' rect.Width - tSize.Width' size.Height);                      s.DrawString(rpt' g' v' TypeCode.Double' null' vRect);                  }                  else                  {                      Size size = Style.MeasureStringDefaults(rpt' g' v' TypeCode.Double' null' int.MaxValue);                      System.Drawing.Rectangle vRect =                          new System.Drawing.Rectangle(rect.Left - (int)(tSize.Width * .5)' rect.Top + rect.Height - h - size.Height / 2' rect.Width - tSize.Width * 2' size.Height);                      Style.DrawStringDefaults(g' v' vRect);                  }                              v += incr;                    DrawValueAxisTick(rpt' g' true' a.MajorTickMarks' a.MajorGridLines' new Point(plotRight - (AxisTickMarkMajorLen / 2)' rect.Top + rect.Height - h));                }
Magic Number,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,Draw2ndValueAxis,The following statement contains a magic number: for (int i = 0; i < _gridIncrs + 1; i++)              {                  int h = (int)(((Math.Min(v' thisMax) - thisMin) / (thisMax - thisMin)) * rect.Height);                  if (h < 0)		// this is really some form of error                  {                      v += incr;                      continue;                  }                  if (!a.Visible)                  {                      // nothing to do                  }                  else if (s != null)                  {                      Size size = s.MeasureString(rpt' g' v' TypeCode.Double' null' int.MaxValue);                      System.Drawing.Rectangle vRect =                          new System.Drawing.Rectangle(rect.Left - (int)(tSize.Width * .5)' rect.Top + rect.Height - h - size.Height / 2' rect.Width - tSize.Width' size.Height);                      s.DrawString(rpt' g' v' TypeCode.Double' null' vRect);                  }                  else                  {                      Size size = Style.MeasureStringDefaults(rpt' g' v' TypeCode.Double' null' int.MaxValue);                      System.Drawing.Rectangle vRect =                          new System.Drawing.Rectangle(rect.Left - (int)(tSize.Width * .5)' rect.Top + rect.Height - h - size.Height / 2' rect.Width - tSize.Width * 2' size.Height);                      Style.DrawStringDefaults(g' v' vRect);                  }                              v += incr;                    DrawValueAxisTick(rpt' g' true' a.MajorTickMarks' a.MajorGridLines' new Point(plotRight - (AxisTickMarkMajorLen / 2)' rect.Top + rect.Height - h));                }
Magic Number,fyiReporting.RDL,ChartData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartData.cs,ChartData,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "ChartSeries":  						cs = new ChartSeries(r' this' xNodeLoop);  						break;  					default:	  						cs=null;		// don't know what this is  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown ChartData element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  				if (cs != null)  					_Items.Add(cs);  			}
Magic Number,fyiReporting.RDL,ChartData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartData.cs,ChartData,The following statement contains a magic number: if (_Items.Count == 0)  				OwnerReport.rl.LogError(8' "For ChartData at least one ChartSeries is required.");  			else                  _Items.TrimExcess();
Magic Number,fyiReporting.RDL,ChartElementOutput,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartElementOutput.cs,GetStyle,The following statement contains a magic number: switch (s)  			{		  				case "Output":  					ceo = ChartElementOutputEnum.Output;  					break;  				case "NoOutput":  					ceo = ChartElementOutputEnum.NoOutput;  					break;  				default:		  					rl.LogError(4' "Unknown ChartElementOutput '" + s + "'.  Output assumed.");  					ceo = ChartElementOutputEnum.Output;  					break;  			}
Magic Number,fyiReporting.RDL,ChartExpression,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartExpression.cs,ChartExpression,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{                      //case "Value":                      //    _Value = new Expression(r' this' xNodeLoop' ExpressionType.Variant);                      //    break;                        case "DataValues":                          _Values = new DataValues(r' p' xNodeLoop);                          break;                      case "DataPoint":  						_DataPoint = (DataPoint) this.OwnerReport.LUDynamicNames[xNodeLoop.InnerText];  						break;                      case "ChartLabel":                          _ChartLabel = new Expression(OwnerReport' this' xNodeLoop' ExpressionType.Variant);                          break;                      // 05122007AJM & GJL Added to store PlotType                      case "PlotType":                          _PlotType = new Expression(OwnerReport' this' xNodeLoop' ExpressionType.Variant);                          break;                          //140208 GJL Added for left/Right YAxis Support                      case "YAxis":                          _YAxis = new Expression(OwnerReport' this' xNodeLoop' ExpressionType.String);                          break;                      case "NoMarker":                      case "fyi:NoMarker":                          _NoMarker = new Expression(OwnerReport' this' xNodeLoop' ExpressionType.String);                          break;                      case "LineSize":                      case "fyi:LineSize":                          _LineSize = new Expression(OwnerReport' this' xNodeLoop' ExpressionType.String);                          break;                      case "fyi:Color":                      case "Color":                      case "Colour":                          _Colour = new Expression(OwnerReport' this' xNodeLoop' ExpressionType.String);                          break;  					default:  						if (ReportItemElement(xNodeLoop))	// try at ReportItem level  							break;  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown Chart element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,ChartGridLines,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartGridLines.cs,ChartGridLines,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "ShowGridLines":  						_ShowGridLines = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "Style":  						_Style = new Style(r' this' xNodeLoop);  						break;  					default:	// TODO  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown ChartGridLines element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,DrawPlotAreaArea,The following statement contains a magic number: for (int iCol=1; iCol <= SeriesCount; iCol++)  			{  				for (int iRow=1; iRow <= CategoryCount; iRow++)  				{  					double v = this.GetDataValue(rpt' iRow' iCol);    					int x = (int) (Layout.PlotArea.Left + (iRow-1) * widthCat);  					int y = (int) (((Math.Min(v'max)-min) / (max-min)) * maxPointHeight);  					Point p = new Point(x' Layout.PlotArea.Top + (maxPointHeight -  y));  					saveP[iRow-1] = p;                      DrawLinePoint(rpt' g' GetSeriesBrush(rpt' iRow' iCol)' ChartMarkerEnum.None' p' iRow' iCol);                        //Add a metafilecomment to use as a tooltip GJL 26092008                      if (_showToolTips)                      {                          String val = "ToolTip:" + v.ToString(_tooltipYFormat) + "|X:" + (int)(p.X - 5) + "|Y:" + (int)(p.Y - 5) + "|W:" + 10 + "|H:" + 10;                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                      }  				}                  DrawAreaBetweenPoints(g' GetSeriesBrush(rpt' 1' iCol)' saveP' null);  			}
Magic Number,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,DrawPlotAreaArea,The following statement contains a magic number: for (int iCol=1; iCol <= SeriesCount; iCol++)  			{  				for (int iRow=1; iRow <= CategoryCount; iRow++)  				{  					double v = this.GetDataValue(rpt' iRow' iCol);    					int x = (int) (Layout.PlotArea.Left + (iRow-1) * widthCat);  					int y = (int) (((Math.Min(v'max)-min) / (max-min)) * maxPointHeight);  					Point p = new Point(x' Layout.PlotArea.Top + (maxPointHeight -  y));  					saveP[iRow-1] = p;                      DrawLinePoint(rpt' g' GetSeriesBrush(rpt' iRow' iCol)' ChartMarkerEnum.None' p' iRow' iCol);                        //Add a metafilecomment to use as a tooltip GJL 26092008                      if (_showToolTips)                      {                          String val = "ToolTip:" + v.ToString(_tooltipYFormat) + "|X:" + (int)(p.X - 5) + "|Y:" + (int)(p.Y - 5) + "|W:" + 10 + "|H:" + 10;                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                      }  				}                  DrawAreaBetweenPoints(g' GetSeriesBrush(rpt' 1' iCol)' saveP' null);  			}
Magic Number,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,DrawPlotAreaArea,The following statement contains a magic number: for (int iCol=1; iCol <= SeriesCount; iCol++)  			{  				for (int iRow=1; iRow <= CategoryCount; iRow++)  				{  					double v = this.GetDataValue(rpt' iRow' iCol);    					int x = (int) (Layout.PlotArea.Left + (iRow-1) * widthCat);  					int y = (int) (((Math.Min(v'max)-min) / (max-min)) * maxPointHeight);  					Point p = new Point(x' Layout.PlotArea.Top + (maxPointHeight -  y));  					saveP[iRow-1] = p;                      DrawLinePoint(rpt' g' GetSeriesBrush(rpt' iRow' iCol)' ChartMarkerEnum.None' p' iRow' iCol);                        //Add a metafilecomment to use as a tooltip GJL 26092008                      if (_showToolTips)                      {                          String val = "ToolTip:" + v.ToString(_tooltipYFormat) + "|X:" + (int)(p.X - 5) + "|Y:" + (int)(p.Y - 5) + "|W:" + 10 + "|H:" + 10;                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                      }  				}                  DrawAreaBetweenPoints(g' GetSeriesBrush(rpt' 1' iCol)' saveP' null);  			}
Magic Number,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,DrawPlotAreaArea,The following statement contains a magic number: for (int iCol=1; iCol <= SeriesCount; iCol++)  			{  				for (int iRow=1; iRow <= CategoryCount; iRow++)  				{  					double v = this.GetDataValue(rpt' iRow' iCol);    					int x = (int) (Layout.PlotArea.Left + (iRow-1) * widthCat);  					int y = (int) (((Math.Min(v'max)-min) / (max-min)) * maxPointHeight);  					Point p = new Point(x' Layout.PlotArea.Top + (maxPointHeight -  y));  					saveP[iRow-1] = p;                      DrawLinePoint(rpt' g' GetSeriesBrush(rpt' iRow' iCol)' ChartMarkerEnum.None' p' iRow' iCol);                        //Add a metafilecomment to use as a tooltip GJL 26092008                      if (_showToolTips)                      {                          String val = "ToolTip:" + v.ToString(_tooltipYFormat) + "|X:" + (int)(p.X - 5) + "|Y:" + (int)(p.Y - 5) + "|W:" + 10 + "|H:" + 10;                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                      }  				}                  DrawAreaBetweenPoints(g' GetSeriesBrush(rpt' 1' iCol)' saveP' null);  			}
Magic Number,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,DrawPlotAreaAreaPercentStacked,The following statement contains a magic number: for (int iCol=1; iCol <= SeriesCount; iCol++)  			{  				for (int iRow=1; iRow <= CategoryCount; iRow++)  				{  					double v = this.GetDataValue(rpt' iRow' iCol);    					int x = (int) (Layout.PlotArea.Left + (iRow-1) * widthCat);  					int y = (int) ((Math.Min(v'max) / max) * maxPointHeight);  					Point p = new Point(x' Layout.PlotArea.Top + (maxPointHeight -  y));  					saveP[iRow-1] = saveAllP[iRow-1' iCol-1];                      DrawLinePoint(rpt' g' GetSeriesBrush(rpt' iRow' iCol)' ChartMarkerEnum.None' p' iRow' iCol);                        //Add a metafilecomment to use as a tooltip GJL 26092008                      if (_showToolTips)                      {                          String val = "ToolTip:" + v.ToString(_tooltipYFormat) + "|X:" + (int)(p.X - 5) + "|Y:" + (int)(p.Y - 5) + "|W:" + 10 + "|H:" + 10;                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                      }  				}                  DrawAreaBetweenPoints(g' GetSeriesBrush(rpt' 1' iCol)' saveP' iCol == 1 ? null : priorSaveP);  				// Save prior point values  				for (int i=0; i < CategoryCount; i++)  					priorSaveP[i] = saveP[i];  			}
Magic Number,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,DrawPlotAreaAreaPercentStacked,The following statement contains a magic number: for (int iCol=1; iCol <= SeriesCount; iCol++)  			{  				for (int iRow=1; iRow <= CategoryCount; iRow++)  				{  					double v = this.GetDataValue(rpt' iRow' iCol);    					int x = (int) (Layout.PlotArea.Left + (iRow-1) * widthCat);  					int y = (int) ((Math.Min(v'max) / max) * maxPointHeight);  					Point p = new Point(x' Layout.PlotArea.Top + (maxPointHeight -  y));  					saveP[iRow-1] = saveAllP[iRow-1' iCol-1];                      DrawLinePoint(rpt' g' GetSeriesBrush(rpt' iRow' iCol)' ChartMarkerEnum.None' p' iRow' iCol);                        //Add a metafilecomment to use as a tooltip GJL 26092008                      if (_showToolTips)                      {                          String val = "ToolTip:" + v.ToString(_tooltipYFormat) + "|X:" + (int)(p.X - 5) + "|Y:" + (int)(p.Y - 5) + "|W:" + 10 + "|H:" + 10;                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                      }  				}                  DrawAreaBetweenPoints(g' GetSeriesBrush(rpt' 1' iCol)' saveP' iCol == 1 ? null : priorSaveP);  				// Save prior point values  				for (int i=0; i < CategoryCount; i++)  					priorSaveP[i] = saveP[i];  			}
Magic Number,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,DrawPlotAreaAreaPercentStacked,The following statement contains a magic number: for (int iCol=1; iCol <= SeriesCount; iCol++)  			{  				for (int iRow=1; iRow <= CategoryCount; iRow++)  				{  					double v = this.GetDataValue(rpt' iRow' iCol);    					int x = (int) (Layout.PlotArea.Left + (iRow-1) * widthCat);  					int y = (int) ((Math.Min(v'max) / max) * maxPointHeight);  					Point p = new Point(x' Layout.PlotArea.Top + (maxPointHeight -  y));  					saveP[iRow-1] = saveAllP[iRow-1' iCol-1];                      DrawLinePoint(rpt' g' GetSeriesBrush(rpt' iRow' iCol)' ChartMarkerEnum.None' p' iRow' iCol);                        //Add a metafilecomment to use as a tooltip GJL 26092008                      if (_showToolTips)                      {                          String val = "ToolTip:" + v.ToString(_tooltipYFormat) + "|X:" + (int)(p.X - 5) + "|Y:" + (int)(p.Y - 5) + "|W:" + 10 + "|H:" + 10;                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                      }  				}                  DrawAreaBetweenPoints(g' GetSeriesBrush(rpt' 1' iCol)' saveP' iCol == 1 ? null : priorSaveP);  				// Save prior point values  				for (int i=0; i < CategoryCount; i++)  					priorSaveP[i] = saveP[i];  			}
Magic Number,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,DrawPlotAreaAreaPercentStacked,The following statement contains a magic number: for (int iCol=1; iCol <= SeriesCount; iCol++)  			{  				for (int iRow=1; iRow <= CategoryCount; iRow++)  				{  					double v = this.GetDataValue(rpt' iRow' iCol);    					int x = (int) (Layout.PlotArea.Left + (iRow-1) * widthCat);  					int y = (int) ((Math.Min(v'max) / max) * maxPointHeight);  					Point p = new Point(x' Layout.PlotArea.Top + (maxPointHeight -  y));  					saveP[iRow-1] = saveAllP[iRow-1' iCol-1];                      DrawLinePoint(rpt' g' GetSeriesBrush(rpt' iRow' iCol)' ChartMarkerEnum.None' p' iRow' iCol);                        //Add a metafilecomment to use as a tooltip GJL 26092008                      if (_showToolTips)                      {                          String val = "ToolTip:" + v.ToString(_tooltipYFormat) + "|X:" + (int)(p.X - 5) + "|Y:" + (int)(p.Y - 5) + "|W:" + 10 + "|H:" + 10;                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                      }  				}                  DrawAreaBetweenPoints(g' GetSeriesBrush(rpt' 1' iCol)' saveP' iCol == 1 ? null : priorSaveP);  				// Save prior point values  				for (int i=0; i < CategoryCount; i++)  					priorSaveP[i] = saveP[i];  			}
Magic Number,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,DrawPlotAreaAreaStacked,The following statement contains a magic number: for (int iCol=1; iCol <= SeriesCount; iCol++)  			{  				for (int iRow=1; iRow <= CategoryCount; iRow++)  				{  					double v = this.GetDataValue(rpt' iRow' iCol);    					int x = (int) (Layout.PlotArea.Left + (iRow-1) * widthCat);  					int y = (int) (((Math.Min(v'max)-min) / (max-min)) * maxPointHeight);  					Point p = new Point(x' Layout.PlotArea.Top + (maxPointHeight -  y));  					saveP[iRow-1] = saveAllP[iRow-1' iCol-1];                      DrawLinePoint(rpt' g' GetSeriesBrush(rpt' iRow' iCol)' ChartMarkerEnum.None' p' iRow' iCol);                      //Add a metafilecomment to use as a tooltip GJL 26092008                      if (_showToolTips)                      {                          String val = "ToolTip:" + v.ToString(_tooltipYFormat) + "|X:" + (int)(saveP[iRow - 1].X - 5) + "|Y:" + (int)(saveP[iRow - 1].Y - 5) + "|W:" + 10 + "|H:" + 10;                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                      }                        				}                  DrawAreaBetweenPoints(g' GetSeriesBrush(rpt' 1' iCol)' saveP' iCol == 1 ? null : priorSaveP);  				// Save prior point values  				for (int i=0; i < CategoryCount; i++)  					priorSaveP[i] = saveP[i];  			}
Magic Number,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,DrawPlotAreaAreaStacked,The following statement contains a magic number: for (int iCol=1; iCol <= SeriesCount; iCol++)  			{  				for (int iRow=1; iRow <= CategoryCount; iRow++)  				{  					double v = this.GetDataValue(rpt' iRow' iCol);    					int x = (int) (Layout.PlotArea.Left + (iRow-1) * widthCat);  					int y = (int) (((Math.Min(v'max)-min) / (max-min)) * maxPointHeight);  					Point p = new Point(x' Layout.PlotArea.Top + (maxPointHeight -  y));  					saveP[iRow-1] = saveAllP[iRow-1' iCol-1];                      DrawLinePoint(rpt' g' GetSeriesBrush(rpt' iRow' iCol)' ChartMarkerEnum.None' p' iRow' iCol);                      //Add a metafilecomment to use as a tooltip GJL 26092008                      if (_showToolTips)                      {                          String val = "ToolTip:" + v.ToString(_tooltipYFormat) + "|X:" + (int)(saveP[iRow - 1].X - 5) + "|Y:" + (int)(saveP[iRow - 1].Y - 5) + "|W:" + 10 + "|H:" + 10;                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                      }                        				}                  DrawAreaBetweenPoints(g' GetSeriesBrush(rpt' 1' iCol)' saveP' iCol == 1 ? null : priorSaveP);  				// Save prior point values  				for (int i=0; i < CategoryCount; i++)  					priorSaveP[i] = saveP[i];  			}
Magic Number,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,DrawPlotAreaAreaStacked,The following statement contains a magic number: for (int iCol=1; iCol <= SeriesCount; iCol++)  			{  				for (int iRow=1; iRow <= CategoryCount; iRow++)  				{  					double v = this.GetDataValue(rpt' iRow' iCol);    					int x = (int) (Layout.PlotArea.Left + (iRow-1) * widthCat);  					int y = (int) (((Math.Min(v'max)-min) / (max-min)) * maxPointHeight);  					Point p = new Point(x' Layout.PlotArea.Top + (maxPointHeight -  y));  					saveP[iRow-1] = saveAllP[iRow-1' iCol-1];                      DrawLinePoint(rpt' g' GetSeriesBrush(rpt' iRow' iCol)' ChartMarkerEnum.None' p' iRow' iCol);                      //Add a metafilecomment to use as a tooltip GJL 26092008                      if (_showToolTips)                      {                          String val = "ToolTip:" + v.ToString(_tooltipYFormat) + "|X:" + (int)(saveP[iRow - 1].X - 5) + "|Y:" + (int)(saveP[iRow - 1].Y - 5) + "|W:" + 10 + "|H:" + 10;                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                      }                        				}                  DrawAreaBetweenPoints(g' GetSeriesBrush(rpt' 1' iCol)' saveP' iCol == 1 ? null : priorSaveP);  				// Save prior point values  				for (int i=0; i < CategoryCount; i++)  					priorSaveP[i] = saveP[i];  			}
Magic Number,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,DrawPlotAreaAreaStacked,The following statement contains a magic number: for (int iCol=1; iCol <= SeriesCount; iCol++)  			{  				for (int iRow=1; iRow <= CategoryCount; iRow++)  				{  					double v = this.GetDataValue(rpt' iRow' iCol);    					int x = (int) (Layout.PlotArea.Left + (iRow-1) * widthCat);  					int y = (int) (((Math.Min(v'max)-min) / (max-min)) * maxPointHeight);  					Point p = new Point(x' Layout.PlotArea.Top + (maxPointHeight -  y));  					saveP[iRow-1] = saveAllP[iRow-1' iCol-1];                      DrawLinePoint(rpt' g' GetSeriesBrush(rpt' iRow' iCol)' ChartMarkerEnum.None' p' iRow' iCol);                      //Add a metafilecomment to use as a tooltip GJL 26092008                      if (_showToolTips)                      {                          String val = "ToolTip:" + v.ToString(_tooltipYFormat) + "|X:" + (int)(saveP[iRow - 1].X - 5) + "|Y:" + (int)(saveP[iRow - 1].Y - 5) + "|W:" + 10 + "|H:" + 10;                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                      }                        				}                  DrawAreaBetweenPoints(g' GetSeriesBrush(rpt' 1' iCol)' saveP' iCol == 1 ? null : priorSaveP);  				// Save prior point values  				for (int i=0; i < CategoryCount; i++)  					priorSaveP[i] = saveP[i];  			}
Magic Number,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,DrawPlotAreaLine,The following statement contains a magic number: for (int iCol=1; iCol <= SeriesCount; iCol++)  			{  				for (int iRow=1; iRow <= CategoryCount; iRow++)  				{  					double v = this.GetDataValue(rpt' iRow' iCol);    					int x = (int) (Layout.PlotArea.Left + (iRow-1) * widthCat + widthCat/2 );  					int y = (int) (((Math.Min(v'max)-min) / (max-min)) * maxPointHeight);  					Point p = new Point(x' Layout.PlotArea.Top + (maxPointHeight -  y));  					saveP[iRow-1] = p;                      bool DrawPoint = getNoMarkerVal(rpt' iCol' 1) == false;                      //dont draw the point if I say not to!                      if (DrawPoint) { DrawLinePoint(rpt' g' GetSeriesBrush(rpt' iRow' iCol)' SeriesMarker[iCol - 1]' p' iRow' iCol); }                        //Add a metafilecomment to use as a tooltip GJL 26092008                      if (_showToolTips)                      {                          String val = "ToolTip:" + v.ToString(_tooltipYFormat) + "|X:" + (int)(p.X - 5) + "|Y:" + (int)(p.Y - 5) + "|W:" + 10 + "|H:" + 10;                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                      }                    				}                    String LineSize = getLineSize(rpt' iCol' 1);                  int intLineSize = 2;                  switch (LineSize)                  {                      case "Small": intLineSize = 1;                          break;                      case "Regular": intLineSize = 2;                          break;                      case "Large": intLineSize = 3;                          break;                      case "Extra Large": intLineSize = 4;                          break;                      case "Super Size": intLineSize = 5;                          break;                  }                  DrawLineBetweenPoints(g' rpt' GetSeriesBrush(rpt' 1' iCol)' saveP' intLineSize);  			}
Magic Number,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,DrawPlotAreaLine,The following statement contains a magic number: for (int iCol=1; iCol <= SeriesCount; iCol++)  			{  				for (int iRow=1; iRow <= CategoryCount; iRow++)  				{  					double v = this.GetDataValue(rpt' iRow' iCol);    					int x = (int) (Layout.PlotArea.Left + (iRow-1) * widthCat + widthCat/2 );  					int y = (int) (((Math.Min(v'max)-min) / (max-min)) * maxPointHeight);  					Point p = new Point(x' Layout.PlotArea.Top + (maxPointHeight -  y));  					saveP[iRow-1] = p;                      bool DrawPoint = getNoMarkerVal(rpt' iCol' 1) == false;                      //dont draw the point if I say not to!                      if (DrawPoint) { DrawLinePoint(rpt' g' GetSeriesBrush(rpt' iRow' iCol)' SeriesMarker[iCol - 1]' p' iRow' iCol); }                        //Add a metafilecomment to use as a tooltip GJL 26092008                      if (_showToolTips)                      {                          String val = "ToolTip:" + v.ToString(_tooltipYFormat) + "|X:" + (int)(p.X - 5) + "|Y:" + (int)(p.Y - 5) + "|W:" + 10 + "|H:" + 10;                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                      }                    				}                    String LineSize = getLineSize(rpt' iCol' 1);                  int intLineSize = 2;                  switch (LineSize)                  {                      case "Small": intLineSize = 1;                          break;                      case "Regular": intLineSize = 2;                          break;                      case "Large": intLineSize = 3;                          break;                      case "Extra Large": intLineSize = 4;                          break;                      case "Super Size": intLineSize = 5;                          break;                  }                  DrawLineBetweenPoints(g' rpt' GetSeriesBrush(rpt' 1' iCol)' saveP' intLineSize);  			}
Magic Number,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,DrawPlotAreaLine,The following statement contains a magic number: for (int iCol=1; iCol <= SeriesCount; iCol++)  			{  				for (int iRow=1; iRow <= CategoryCount; iRow++)  				{  					double v = this.GetDataValue(rpt' iRow' iCol);    					int x = (int) (Layout.PlotArea.Left + (iRow-1) * widthCat + widthCat/2 );  					int y = (int) (((Math.Min(v'max)-min) / (max-min)) * maxPointHeight);  					Point p = new Point(x' Layout.PlotArea.Top + (maxPointHeight -  y));  					saveP[iRow-1] = p;                      bool DrawPoint = getNoMarkerVal(rpt' iCol' 1) == false;                      //dont draw the point if I say not to!                      if (DrawPoint) { DrawLinePoint(rpt' g' GetSeriesBrush(rpt' iRow' iCol)' SeriesMarker[iCol - 1]' p' iRow' iCol); }                        //Add a metafilecomment to use as a tooltip GJL 26092008                      if (_showToolTips)                      {                          String val = "ToolTip:" + v.ToString(_tooltipYFormat) + "|X:" + (int)(p.X - 5) + "|Y:" + (int)(p.Y - 5) + "|W:" + 10 + "|H:" + 10;                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                      }                    				}                    String LineSize = getLineSize(rpt' iCol' 1);                  int intLineSize = 2;                  switch (LineSize)                  {                      case "Small": intLineSize = 1;                          break;                      case "Regular": intLineSize = 2;                          break;                      case "Large": intLineSize = 3;                          break;                      case "Extra Large": intLineSize = 4;                          break;                      case "Super Size": intLineSize = 5;                          break;                  }                  DrawLineBetweenPoints(g' rpt' GetSeriesBrush(rpt' 1' iCol)' saveP' intLineSize);  			}
Magic Number,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,DrawPlotAreaLine,The following statement contains a magic number: for (int iCol=1; iCol <= SeriesCount; iCol++)  			{  				for (int iRow=1; iRow <= CategoryCount; iRow++)  				{  					double v = this.GetDataValue(rpt' iRow' iCol);    					int x = (int) (Layout.PlotArea.Left + (iRow-1) * widthCat + widthCat/2 );  					int y = (int) (((Math.Min(v'max)-min) / (max-min)) * maxPointHeight);  					Point p = new Point(x' Layout.PlotArea.Top + (maxPointHeight -  y));  					saveP[iRow-1] = p;                      bool DrawPoint = getNoMarkerVal(rpt' iCol' 1) == false;                      //dont draw the point if I say not to!                      if (DrawPoint) { DrawLinePoint(rpt' g' GetSeriesBrush(rpt' iRow' iCol)' SeriesMarker[iCol - 1]' p' iRow' iCol); }                        //Add a metafilecomment to use as a tooltip GJL 26092008                      if (_showToolTips)                      {                          String val = "ToolTip:" + v.ToString(_tooltipYFormat) + "|X:" + (int)(p.X - 5) + "|Y:" + (int)(p.Y - 5) + "|W:" + 10 + "|H:" + 10;                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                      }                    				}                    String LineSize = getLineSize(rpt' iCol' 1);                  int intLineSize = 2;                  switch (LineSize)                  {                      case "Small": intLineSize = 1;                          break;                      case "Regular": intLineSize = 2;                          break;                      case "Large": intLineSize = 3;                          break;                      case "Extra Large": intLineSize = 4;                          break;                      case "Super Size": intLineSize = 5;                          break;                  }                  DrawLineBetweenPoints(g' rpt' GetSeriesBrush(rpt' 1' iCol)' saveP' intLineSize);  			}
Magic Number,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,DrawPlotAreaLine,The following statement contains a magic number: for (int iCol=1; iCol <= SeriesCount; iCol++)  			{  				for (int iRow=1; iRow <= CategoryCount; iRow++)  				{  					double v = this.GetDataValue(rpt' iRow' iCol);    					int x = (int) (Layout.PlotArea.Left + (iRow-1) * widthCat + widthCat/2 );  					int y = (int) (((Math.Min(v'max)-min) / (max-min)) * maxPointHeight);  					Point p = new Point(x' Layout.PlotArea.Top + (maxPointHeight -  y));  					saveP[iRow-1] = p;                      bool DrawPoint = getNoMarkerVal(rpt' iCol' 1) == false;                      //dont draw the point if I say not to!                      if (DrawPoint) { DrawLinePoint(rpt' g' GetSeriesBrush(rpt' iRow' iCol)' SeriesMarker[iCol - 1]' p' iRow' iCol); }                        //Add a metafilecomment to use as a tooltip GJL 26092008                      if (_showToolTips)                      {                          String val = "ToolTip:" + v.ToString(_tooltipYFormat) + "|X:" + (int)(p.X - 5) + "|Y:" + (int)(p.Y - 5) + "|W:" + 10 + "|H:" + 10;                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                      }                    				}                    String LineSize = getLineSize(rpt' iCol' 1);                  int intLineSize = 2;                  switch (LineSize)                  {                      case "Small": intLineSize = 1;                          break;                      case "Regular": intLineSize = 2;                          break;                      case "Large": intLineSize = 3;                          break;                      case "Extra Large": intLineSize = 4;                          break;                      case "Super Size": intLineSize = 5;                          break;                  }                  DrawLineBetweenPoints(g' rpt' GetSeriesBrush(rpt' 1' iCol)' saveP' intLineSize);  			}
Magic Number,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,DrawPlotAreaLine,The following statement contains a magic number: for (int iCol=1; iCol <= SeriesCount; iCol++)  			{  				for (int iRow=1; iRow <= CategoryCount; iRow++)  				{  					double v = this.GetDataValue(rpt' iRow' iCol);    					int x = (int) (Layout.PlotArea.Left + (iRow-1) * widthCat + widthCat/2 );  					int y = (int) (((Math.Min(v'max)-min) / (max-min)) * maxPointHeight);  					Point p = new Point(x' Layout.PlotArea.Top + (maxPointHeight -  y));  					saveP[iRow-1] = p;                      bool DrawPoint = getNoMarkerVal(rpt' iCol' 1) == false;                      //dont draw the point if I say not to!                      if (DrawPoint) { DrawLinePoint(rpt' g' GetSeriesBrush(rpt' iRow' iCol)' SeriesMarker[iCol - 1]' p' iRow' iCol); }                        //Add a metafilecomment to use as a tooltip GJL 26092008                      if (_showToolTips)                      {                          String val = "ToolTip:" + v.ToString(_tooltipYFormat) + "|X:" + (int)(p.X - 5) + "|Y:" + (int)(p.Y - 5) + "|W:" + 10 + "|H:" + 10;                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                      }                    				}                    String LineSize = getLineSize(rpt' iCol' 1);                  int intLineSize = 2;                  switch (LineSize)                  {                      case "Small": intLineSize = 1;                          break;                      case "Regular": intLineSize = 2;                          break;                      case "Large": intLineSize = 3;                          break;                      case "Extra Large": intLineSize = 4;                          break;                      case "Super Size": intLineSize = 5;                          break;                  }                  DrawLineBetweenPoints(g' rpt' GetSeriesBrush(rpt' 1' iCol)' saveP' intLineSize);  			}
Magic Number,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,DrawPlotAreaLine,The following statement contains a magic number: for (int iCol=1; iCol <= SeriesCount; iCol++)  			{  				for (int iRow=1; iRow <= CategoryCount; iRow++)  				{  					double v = this.GetDataValue(rpt' iRow' iCol);    					int x = (int) (Layout.PlotArea.Left + (iRow-1) * widthCat + widthCat/2 );  					int y = (int) (((Math.Min(v'max)-min) / (max-min)) * maxPointHeight);  					Point p = new Point(x' Layout.PlotArea.Top + (maxPointHeight -  y));  					saveP[iRow-1] = p;                      bool DrawPoint = getNoMarkerVal(rpt' iCol' 1) == false;                      //dont draw the point if I say not to!                      if (DrawPoint) { DrawLinePoint(rpt' g' GetSeriesBrush(rpt' iRow' iCol)' SeriesMarker[iCol - 1]' p' iRow' iCol); }                        //Add a metafilecomment to use as a tooltip GJL 26092008                      if (_showToolTips)                      {                          String val = "ToolTip:" + v.ToString(_tooltipYFormat) + "|X:" + (int)(p.X - 5) + "|Y:" + (int)(p.Y - 5) + "|W:" + 10 + "|H:" + 10;                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                      }                    				}                    String LineSize = getLineSize(rpt' iCol' 1);                  int intLineSize = 2;                  switch (LineSize)                  {                      case "Small": intLineSize = 1;                          break;                      case "Regular": intLineSize = 2;                          break;                      case "Large": intLineSize = 3;                          break;                      case "Extra Large": intLineSize = 4;                          break;                      case "Super Size": intLineSize = 5;                          break;                  }                  DrawLineBetweenPoints(g' rpt' GetSeriesBrush(rpt' 1' iCol)' saveP' intLineSize);  			}
Magic Number,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,DrawPlotAreaLine,The following statement contains a magic number: for (int iCol=1; iCol <= SeriesCount; iCol++)  			{  				for (int iRow=1; iRow <= CategoryCount; iRow++)  				{  					double v = this.GetDataValue(rpt' iRow' iCol);    					int x = (int) (Layout.PlotArea.Left + (iRow-1) * widthCat + widthCat/2 );  					int y = (int) (((Math.Min(v'max)-min) / (max-min)) * maxPointHeight);  					Point p = new Point(x' Layout.PlotArea.Top + (maxPointHeight -  y));  					saveP[iRow-1] = p;                      bool DrawPoint = getNoMarkerVal(rpt' iCol' 1) == false;                      //dont draw the point if I say not to!                      if (DrawPoint) { DrawLinePoint(rpt' g' GetSeriesBrush(rpt' iRow' iCol)' SeriesMarker[iCol - 1]' p' iRow' iCol); }                        //Add a metafilecomment to use as a tooltip GJL 26092008                      if (_showToolTips)                      {                          String val = "ToolTip:" + v.ToString(_tooltipYFormat) + "|X:" + (int)(p.X - 5) + "|Y:" + (int)(p.Y - 5) + "|W:" + 10 + "|H:" + 10;                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                      }                    				}                    String LineSize = getLineSize(rpt' iCol' 1);                  int intLineSize = 2;                  switch (LineSize)                  {                      case "Small": intLineSize = 1;                          break;                      case "Regular": intLineSize = 2;                          break;                      case "Large": intLineSize = 3;                          break;                      case "Extra Large": intLineSize = 4;                          break;                      case "Super Size": intLineSize = 5;                          break;                  }                  DrawLineBetweenPoints(g' rpt' GetSeriesBrush(rpt' 1' iCol)' saveP' intLineSize);  			}
Magic Number,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,DrawPlotAreaLine,The following statement contains a magic number: for (int iCol=1; iCol <= SeriesCount; iCol++)  			{  				for (int iRow=1; iRow <= CategoryCount; iRow++)  				{  					double v = this.GetDataValue(rpt' iRow' iCol);    					int x = (int) (Layout.PlotArea.Left + (iRow-1) * widthCat + widthCat/2 );  					int y = (int) (((Math.Min(v'max)-min) / (max-min)) * maxPointHeight);  					Point p = new Point(x' Layout.PlotArea.Top + (maxPointHeight -  y));  					saveP[iRow-1] = p;                      bool DrawPoint = getNoMarkerVal(rpt' iCol' 1) == false;                      //dont draw the point if I say not to!                      if (DrawPoint) { DrawLinePoint(rpt' g' GetSeriesBrush(rpt' iRow' iCol)' SeriesMarker[iCol - 1]' p' iRow' iCol); }                        //Add a metafilecomment to use as a tooltip GJL 26092008                      if (_showToolTips)                      {                          String val = "ToolTip:" + v.ToString(_tooltipYFormat) + "|X:" + (int)(p.X - 5) + "|Y:" + (int)(p.Y - 5) + "|W:" + 10 + "|H:" + 10;                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                      }                    				}                    String LineSize = getLineSize(rpt' iCol' 1);                  int intLineSize = 2;                  switch (LineSize)                  {                      case "Small": intLineSize = 1;                          break;                      case "Regular": intLineSize = 2;                          break;                      case "Large": intLineSize = 3;                          break;                      case "Extra Large": intLineSize = 4;                          break;                      case "Super Size": intLineSize = 5;                          break;                  }                  DrawLineBetweenPoints(g' rpt' GetSeriesBrush(rpt' 1' iCol)' saveP' intLineSize);  			}
Magic Number,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,DrawPlotAreaLine,The following statement contains a magic number: for (int iCol=1; iCol <= SeriesCount; iCol++)  			{  				for (int iRow=1; iRow <= CategoryCount; iRow++)  				{  					double v = this.GetDataValue(rpt' iRow' iCol);    					int x = (int) (Layout.PlotArea.Left + (iRow-1) * widthCat + widthCat/2 );  					int y = (int) (((Math.Min(v'max)-min) / (max-min)) * maxPointHeight);  					Point p = new Point(x' Layout.PlotArea.Top + (maxPointHeight -  y));  					saveP[iRow-1] = p;                      bool DrawPoint = getNoMarkerVal(rpt' iCol' 1) == false;                      //dont draw the point if I say not to!                      if (DrawPoint) { DrawLinePoint(rpt' g' GetSeriesBrush(rpt' iRow' iCol)' SeriesMarker[iCol - 1]' p' iRow' iCol); }                        //Add a metafilecomment to use as a tooltip GJL 26092008                      if (_showToolTips)                      {                          String val = "ToolTip:" + v.ToString(_tooltipYFormat) + "|X:" + (int)(p.X - 5) + "|Y:" + (int)(p.Y - 5) + "|W:" + 10 + "|H:" + 10;                          g.AddMetafileComment(new System.Text.ASCIIEncoding().GetBytes(val));                      }                    				}                    String LineSize = getLineSize(rpt' iCol' 1);                  int intLineSize = 2;                  switch (LineSize)                  {                      case "Small": intLineSize = 1;                          break;                      case "Regular": intLineSize = 2;                          break;                      case "Large": intLineSize = 3;                          break;                      case "Extra Large": intLineSize = 4;                          break;                      case "Super Size": intLineSize = 5;                          break;                  }                  DrawLineBetweenPoints(g' rpt' GetSeriesBrush(rpt' 1' iCol)' saveP' intLineSize);  			}
Magic Number,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,DrawAreaBetweenPoints,The following statement contains a magic number: try  			{  				p = new Pen(brush' 1);    // todo - use line from style ????  				g.DrawLines(p' points);  				PointF[] poly;  				if (previous == null)  				{	// The bottom is the bottom of the chart  					poly = new PointF[points.Length + 3];  					int i=0;  					foreach (Point pt in points)  					{  						poly[i++] = pt;  					}  					poly[i++] = new PointF(points[points.Length-1].X' Layout.PlotArea.Bottom);  					poly[i++] = new PointF(points[0].X' Layout.PlotArea.Bottom);  					poly[i] = new PointF(points[0].X' points[0].Y);   				}  				else  				{	// The bottom is the previous line  					poly = new PointF[points.Length * 2 + 1];  					int i=0;  					foreach (Point pt in points)  					{  						poly[i] = pt;  						poly[points.Length+i] = previous[previous.Length - 1 - i];  						i++;  					}  					poly[poly.Length-1] = poly[0];  				}  				g.FillPolygon(brush' poly);  			}  			finally  			{  				if (p != null)  					p.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,DrawAreaBetweenPoints,The following statement contains a magic number: try  			{  				p = new Pen(brush' 1);    // todo - use line from style ????  				g.DrawLines(p' points);  				PointF[] poly;  				if (previous == null)  				{	// The bottom is the bottom of the chart  					poly = new PointF[points.Length + 3];  					int i=0;  					foreach (Point pt in points)  					{  						poly[i++] = pt;  					}  					poly[i++] = new PointF(points[points.Length-1].X' Layout.PlotArea.Bottom);  					poly[i++] = new PointF(points[0].X' Layout.PlotArea.Bottom);  					poly[i] = new PointF(points[0].X' points[0].Y);   				}  				else  				{	// The bottom is the previous line  					poly = new PointF[points.Length * 2 + 1];  					int i=0;  					foreach (Point pt in points)  					{  						poly[i] = pt;  						poly[points.Length+i] = previous[previous.Length - 1 - i];  						i++;  					}  					poly[poly.Length-1] = poly[0];  				}  				g.FillPolygon(brush' poly);  			}  			finally  			{  				if (p != null)  					p.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,DrawLineBetweenPoints,The following statement contains a magic number: DrawLineBetweenPoints(g' rpt' brush' points' 2);
Magic Number,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,DrawLineBetweenPoints,The following statement contains a magic number: try              {                  // 20022008 AJM GJL - Added thicker lines                      p = new Pen(brush' intLineSize);    // todo - use line from style ????                      if ((ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.Smooth && points.Length > 2)                      g.DrawCurve(p' points' 0.5F);                  else                      g.DrawLines(p' points);              }              finally              {                  if (p != null)                      p.Dispose();              }
Magic Number,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,DrawLinePoint,The following statement contains a magic number: try  			{  				pen = new Pen(brush);  				// 20022008 AJM GJL - Added bigger points  				DrawLegendMarker(g' brush' pen' marker' p.X-5' p.Y-5' 10);  				DrawDataPoint(rpt' g' new Point(p.X-5' p.Y+5)' iRow' iCol);  			}  			finally  			{  				if (pen != null)  					pen.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,DrawLinePoint,The following statement contains a magic number: try  			{  				pen = new Pen(brush);  				// 20022008 AJM GJL - Added bigger points  				DrawLegendMarker(g' brush' pen' marker' p.X-5' p.Y-5' 10);  				DrawDataPoint(rpt' g' new Point(p.X-5' p.Y+5)' iRow' iCol);  			}  			finally  			{  				if (pen != null)  					pen.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,DrawLinePoint,The following statement contains a magic number: try  			{  				pen = new Pen(brush);  				// 20022008 AJM GJL - Added bigger points  				DrawLegendMarker(g' brush' pen' marker' p.X-5' p.Y-5' 10);  				DrawDataPoint(rpt' g' new Point(p.X-5' p.Y+5)' iRow' iCol);  			}  			finally  			{  				if (pen != null)  					pen.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,DrawLinePoint,The following statement contains a magic number: try  			{  				pen = new Pen(brush);  				// 20022008 AJM GJL - Added bigger points  				DrawLegendMarker(g' brush' pen' marker' p.X-5' p.Y-5' 10);  				DrawDataPoint(rpt' g' new Point(p.X-5' p.Y+5)' iRow' iCol);  			}  			finally  			{  				if (pen != null)  					pen.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,DrawLinePoint,The following statement contains a magic number: try  			{  				pen = new Pen(brush);  				// 20022008 AJM GJL - Added bigger points  				DrawLegendMarker(g' brush' pen' marker' p.X-5' p.Y-5' 10);  				DrawDataPoint(rpt' g' new Point(p.X-5' p.Y+5)' iRow' iCol);  			}  			finally  			{  				if (pen != null)  					pen.Dispose();  			}
Magic Number,fyiReporting.RDL,ChartPalette,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartPalette.cs,GetStyle,The following statement contains a magic number: switch (s)  			{		  				case "Default":  					p = ChartPaletteEnum.Default;  					break;  				case "EarthTones":  					p = ChartPaletteEnum.EarthTones;  					break;  				case "Excel":  					p = ChartPaletteEnum.Excel;  					break;  				case "GrayScale":  					p = ChartPaletteEnum.GrayScale;  					break;  				case "Light":  					p = ChartPaletteEnum.Light;  					break;  				case "Pastel":  					p = ChartPaletteEnum.Pastel;  					break;  				case "SemiTransparent":  					p = ChartPaletteEnum.SemiTransparent;  					break;                  case "Patterned": //GJL                      p = ChartPaletteEnum.Patterned;                      break;                  case "PatternedBlack": //GJL                      p = ChartPaletteEnum.PatternedBlack;                      break;                  case "Custom":                      p = ChartPaletteEnum.Custom;                      break;  				default:		  					rl.LogError(4' "Unknown ChartPalette '" + s + "'.  Default assumed.");  					p = ChartPaletteEnum.Default;  					break;  			}
Magic Number,fyiReporting.RDL,ChartPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartPie.cs,DrawPlotAreaDoughnut,The following statement contains a magic number: int doughWidth = maxPieSize / 4 / CategoryCount;
Magic Number,fyiReporting.RDL,ChartPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartPie.cs,DrawPlotAreaDoughnut,The following statement contains a magic number: if (doughWidth < 2)  				doughWidth = 2;
Magic Number,fyiReporting.RDL,ChartPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartPie.cs,DrawPlotAreaDoughnut,The following statement contains a magic number: if (doughWidth < 2)  				doughWidth = 2;
Magic Number,fyiReporting.RDL,ChartPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartPie.cs,DrawPlotAreaDoughnut,The following statement contains a magic number: int left = Layout.PlotArea.Left + (maxPieSize == widthPie? 0: (widthPie - maxPieSize) / 2);
Magic Number,fyiReporting.RDL,ChartPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartPie.cs,DrawPlotAreaDoughnut,The following statement contains a magic number: int top =   Layout.PlotArea.Top + (maxPieSize == maxHeight? 0: (maxHeight - maxPieSize) / 2);
Magic Number,fyiReporting.RDL,ChartPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartPie.cs,DrawPlotAreaDoughnut,The following statement contains a magic number: for (int iRow=1; iRow <= CategoryCount; iRow++)  			{  				pieLocX= left + ((iRow-1) * doughWidth);  				pieLocY= top + ((iRow-1) * doughWidth);    				double total=0;		// sum up for this category  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					total += this.GetDataValue(rpt' iRow' iCol);  				}    				// Pie size decreases as we go in  				startAngle=0.0f;  				pieSize = maxPieSize - ((iRow - 1) * doughWidth * 2);  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					double v = this.GetDataValue(rpt' iRow' iCol);  					endAngle = (float) (startAngle + v / total * 360);                        DrawPie(g' rpt' GetSeriesBrush(rpt' iRow' iCol)'   						new System.Drawing.Rectangle(pieLocX' pieLocY' pieSize' pieSize)' iRow' iCol' startAngle' endAngle);    					startAngle = endAngle;  				}  			}
Magic Number,fyiReporting.RDL,ChartPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartPie.cs,DrawPlotAreaDoughnut,The following statement contains a magic number: for (int iRow=1; iRow <= CategoryCount; iRow++)  			{  				pieLocX= left + ((iRow-1) * doughWidth);  				pieLocY= top + ((iRow-1) * doughWidth);    				double total=0;		// sum up for this category  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					total += this.GetDataValue(rpt' iRow' iCol);  				}    				// Pie size decreases as we go in  				startAngle=0.0f;  				pieSize = maxPieSize - ((iRow - 1) * doughWidth * 2);  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					double v = this.GetDataValue(rpt' iRow' iCol);  					endAngle = (float) (startAngle + v / total * 360);                        DrawPie(g' rpt' GetSeriesBrush(rpt' iRow' iCol)'   						new System.Drawing.Rectangle(pieLocX' pieLocY' pieSize' pieSize)' iRow' iCol' startAngle' endAngle);    					startAngle = endAngle;  				}  			}
Magic Number,fyiReporting.RDL,ChartPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartPie.cs,DrawPlotAreaDoughnut,The following statement contains a magic number: pieSize = maxPieSize - (CategoryCount * doughWidth * 2);
Magic Number,fyiReporting.RDL,ChartPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartPie.cs,DrawPlotAreaPie,The following statement contains a magic number: int gapSize=13;
Magic Number,fyiReporting.RDL,ChartPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartPie.cs,DrawPlotAreaPie,The following statement contains a magic number: int pieLocY = Layout.PlotArea.Top + (maxHeight - maxPieSize) / 2;
Magic Number,fyiReporting.RDL,ChartPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartPie.cs,DrawPlotAreaPie,The following statement contains a magic number: for (int iRow=1; iRow <= CategoryCount; iRow++)  			{  				int pieLocX=(int) (Layout.PlotArea.Left + (iRow-1) * ((double) (Layout.PlotArea.Width) / CategoryCount));    				pieLocX += gapSize;	// space before series  				double total=0;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					total += this.GetDataValue(rpt' iRow' iCol);  				}    				// Pie size is a ratio of the area of the pies (not the diameter)  				startAngle=0.0f;  				int pieSize = (int) (2 * Math.Sqrt(Math.PI * ((maxPieSize/2) * (maxPieSize/2) * total/maxCategory) / Math.PI));  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					double v = this.GetDataValue(rpt' iRow' iCol);  					endAngle = (float) (startAngle + v / total * 360);                        DrawPie(g' rpt' GetSeriesBrush(rpt' iRow' iCol)'   						new System.Drawing.Rectangle(pieLocX' pieLocY' pieSize' pieSize)' iRow' iCol' startAngle' endAngle);    					startAngle = endAngle;  				}  			}
Magic Number,fyiReporting.RDL,ChartPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartPie.cs,DrawPlotAreaPie,The following statement contains a magic number: for (int iRow=1; iRow <= CategoryCount; iRow++)  			{  				int pieLocX=(int) (Layout.PlotArea.Left + (iRow-1) * ((double) (Layout.PlotArea.Width) / CategoryCount));    				pieLocX += gapSize;	// space before series  				double total=0;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					total += this.GetDataValue(rpt' iRow' iCol);  				}    				// Pie size is a ratio of the area of the pies (not the diameter)  				startAngle=0.0f;  				int pieSize = (int) (2 * Math.Sqrt(Math.PI * ((maxPieSize/2) * (maxPieSize/2) * total/maxCategory) / Math.PI));  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					double v = this.GetDataValue(rpt' iRow' iCol);  					endAngle = (float) (startAngle + v / total * 360);                        DrawPie(g' rpt' GetSeriesBrush(rpt' iRow' iCol)'   						new System.Drawing.Rectangle(pieLocX' pieLocY' pieSize' pieSize)' iRow' iCol' startAngle' endAngle);    					startAngle = endAngle;  				}  			}
Magic Number,fyiReporting.RDL,ChartPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartPie.cs,DrawPlotAreaPie,The following statement contains a magic number: for (int iRow=1; iRow <= CategoryCount; iRow++)  			{  				int pieLocX=(int) (Layout.PlotArea.Left + (iRow-1) * ((double) (Layout.PlotArea.Width) / CategoryCount));    				pieLocX += gapSize;	// space before series  				double total=0;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					total += this.GetDataValue(rpt' iRow' iCol);  				}    				// Pie size is a ratio of the area of the pies (not the diameter)  				startAngle=0.0f;  				int pieSize = (int) (2 * Math.Sqrt(Math.PI * ((maxPieSize/2) * (maxPieSize/2) * total/maxCategory) / Math.PI));  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					double v = this.GetDataValue(rpt' iRow' iCol);  					endAngle = (float) (startAngle + v / total * 360);                        DrawPie(g' rpt' GetSeriesBrush(rpt' iRow' iCol)'   						new System.Drawing.Rectangle(pieLocX' pieLocY' pieSize' pieSize)' iRow' iCol' startAngle' endAngle);    					startAngle = endAngle;  				}  			}
Magic Number,fyiReporting.RDL,ChartPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartPie.cs,DrawPlotAreaPie,The following statement contains a magic number: for (int iRow=1; iRow <= CategoryCount; iRow++)  			{  				int pieLocX=(int) (Layout.PlotArea.Left + (iRow-1) * ((double) (Layout.PlotArea.Width) / CategoryCount));    				pieLocX += gapSize;	// space before series  				double total=0;  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					total += this.GetDataValue(rpt' iRow' iCol);  				}    				// Pie size is a ratio of the area of the pies (not the diameter)  				startAngle=0.0f;  				int pieSize = (int) (2 * Math.Sqrt(Math.PI * ((maxPieSize/2) * (maxPieSize/2) * total/maxCategory) / Math.PI));  				for (int iCol=1; iCol <= SeriesCount; iCol++)  				{  					double v = this.GetDataValue(rpt' iRow' iCol);  					endAngle = (float) (startAngle + v / total * 360);                        DrawPie(g' rpt' GetSeriesBrush(rpt' iRow' iCol)'   						new System.Drawing.Rectangle(pieLocX' pieLocY' pieSize' pieSize)' iRow' iCol' startAngle' endAngle);    					startAngle = endAngle;  				}  			}
Magic Number,fyiReporting.RDL,ChartPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartPie.cs,DrawPie,The following statement contains a magic number: if ((ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.Exploded)  			{  				// Need to adjust the rectangle   				int side = (int) (rect.Width * .75);	// side needs to be smaller to account for exploded pies  				int offset = (int) (side * .1);			//  we add a little to the left and top  				int adjX' adjY;  				adjX = adjY = (int) (side * .1);    				float midAngle = startAngle + (endAngle - startAngle)/2;    				if (midAngle < 90)  				{  				}  				else if (midAngle < 180)  				{  					adjX = -adjX;  				}  				else if (midAngle < 270)  				{  					adjX = adjY = -adjX;  				}  				else  				{  					adjY = - adjY;  				}  				rect = new System.Drawing.Rectangle(rect.Left + adjX + offset' rect.Top + adjY + offset' side' side);  			}
Magic Number,fyiReporting.RDL,ChartPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartPie.cs,DrawPie,The following statement contains a magic number: if ((ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.Exploded)  			{  				// Need to adjust the rectangle   				int side = (int) (rect.Width * .75);	// side needs to be smaller to account for exploded pies  				int offset = (int) (side * .1);			//  we add a little to the left and top  				int adjX' adjY;  				adjX = adjY = (int) (side * .1);    				float midAngle = startAngle + (endAngle - startAngle)/2;    				if (midAngle < 90)  				{  				}  				else if (midAngle < 180)  				{  					adjX = -adjX;  				}  				else if (midAngle < 270)  				{  					adjX = adjY = -adjX;  				}  				else  				{  					adjY = - adjY;  				}  				rect = new System.Drawing.Rectangle(rect.Left + adjX + offset' rect.Top + adjY + offset' side' side);  			}
Magic Number,fyiReporting.RDL,ChartPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartPie.cs,DrawPie,The following statement contains a magic number: if ((ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.Exploded)  			{  				// Need to adjust the rectangle   				int side = (int) (rect.Width * .75);	// side needs to be smaller to account for exploded pies  				int offset = (int) (side * .1);			//  we add a little to the left and top  				int adjX' adjY;  				adjX = adjY = (int) (side * .1);    				float midAngle = startAngle + (endAngle - startAngle)/2;    				if (midAngle < 90)  				{  				}  				else if (midAngle < 180)  				{  					adjX = -adjX;  				}  				else if (midAngle < 270)  				{  					adjX = adjY = -adjX;  				}  				else  				{  					adjY = - adjY;  				}  				rect = new System.Drawing.Rectangle(rect.Left + adjX + offset' rect.Top + adjY + offset' side' side);  			}
Magic Number,fyiReporting.RDL,ChartPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartPie.cs,DrawPie,The following statement contains a magic number: if ((ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.Exploded)  			{  				// Need to adjust the rectangle   				int side = (int) (rect.Width * .75);	// side needs to be smaller to account for exploded pies  				int offset = (int) (side * .1);			//  we add a little to the left and top  				int adjX' adjY;  				adjX = adjY = (int) (side * .1);    				float midAngle = startAngle + (endAngle - startAngle)/2;    				if (midAngle < 90)  				{  				}  				else if (midAngle < 180)  				{  					adjX = -adjX;  				}  				else if (midAngle < 270)  				{  					adjX = adjY = -adjX;  				}  				else  				{  					adjY = - adjY;  				}  				rect = new System.Drawing.Rectangle(rect.Left + adjX + offset' rect.Top + adjY + offset' side' side);  			}
Magic Number,fyiReporting.RDL,ChartPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartPie.cs,DrawPie,The following statement contains a magic number: if ((ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.Exploded)  			{  				// Need to adjust the rectangle   				int side = (int) (rect.Width * .75);	// side needs to be smaller to account for exploded pies  				int offset = (int) (side * .1);			//  we add a little to the left and top  				int adjX' adjY;  				adjX = adjY = (int) (side * .1);    				float midAngle = startAngle + (endAngle - startAngle)/2;    				if (midAngle < 90)  				{  				}  				else if (midAngle < 180)  				{  					adjX = -adjX;  				}  				else if (midAngle < 270)  				{  					adjX = adjY = -adjX;  				}  				else  				{  					adjY = - adjY;  				}  				rect = new System.Drawing.Rectangle(rect.Left + adjX + offset' rect.Top + adjY + offset' side' side);  			}
Magic Number,fyiReporting.RDL,ChartPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartPie.cs,DrawPie,The following statement contains a magic number: if ((ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.Exploded)  			{  				// Need to adjust the rectangle   				int side = (int) (rect.Width * .75);	// side needs to be smaller to account for exploded pies  				int offset = (int) (side * .1);			//  we add a little to the left and top  				int adjX' adjY;  				adjX = adjY = (int) (side * .1);    				float midAngle = startAngle + (endAngle - startAngle)/2;    				if (midAngle < 90)  				{  				}  				else if (midAngle < 180)  				{  					adjX = -adjX;  				}  				else if (midAngle < 270)  				{  					adjX = adjY = -adjX;  				}  				else  				{  					adjY = - adjY;  				}  				rect = new System.Drawing.Rectangle(rect.Left + adjX + offset' rect.Top + adjY + offset' side' side);  			}
Magic Number,fyiReporting.RDL,ChartPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartPie.cs,DrawPie,The following statement contains a magic number: if ((ChartSubTypeEnum)Enum.Parse(typeof(ChartSubTypeEnum)' _ChartDefn.Subtype.EvaluateString(rpt' _row)) == ChartSubTypeEnum.Exploded)  			{  				// Need to adjust the rectangle   				int side = (int) (rect.Width * .75);	// side needs to be smaller to account for exploded pies  				int offset = (int) (side * .1);			//  we add a little to the left and top  				int adjX' adjY;  				adjX = adjY = (int) (side * .1);    				float midAngle = startAngle + (endAngle - startAngle)/2;    				if (midAngle < 90)  				{  				}  				else if (midAngle < 180)  				{  					adjX = -adjX;  				}  				else if (midAngle < 270)  				{  					adjX = adjY = -adjX;  				}  				else  				{  					adjY = - adjY;  				}  				rect = new System.Drawing.Rectangle(rect.Left + adjX + offset' rect.Top + adjY + offset' side' side);  			}
Magic Number,fyiReporting.RDL,ChartSeries,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartSeries.cs,ChartSeries,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "DataPoints":  						_Datapoints = new DataPoints(r' this' xNodeLoop);  						break;  					case "PlotType":  						_PlotType = fyiReporting.RDL.PlotType.GetStyle(xNodeLoop.InnerText' OwnerReport.rl);  						break;                      case "YAxis":                      case "fyi:YAxis":                          _YAxis = xNodeLoop.InnerText;                          break;                      case "NoMarker":                      case "fyi:NoMarker":                          _NoMarker = Boolean.Parse(xNodeLoop.InnerText);                          break;                      case "LineSize":                      case "fyi:LineSize":                          _LineSize = xNodeLoop.InnerText;                          break;                      case "fyi:Color":                      case "Color":                      case "Colour":                          _Colour = xNodeLoop.InnerText;                          break;  					default:	  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown ChartSeries element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,ChartSeries,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartSeries.cs,ChartSeries,The following statement contains a magic number: if (_Datapoints == null)  				OwnerReport.rl.LogError(8' "ChartSeries requires the DataPoints element.");
Magic Number,fyiReporting.RDL,ChartSubType,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartSubType.cs,GetStyle,The following statement contains a magic number: switch (s)  			{		  				case "Plain":  					st = ChartSubTypeEnum.Plain;  					break;  				case "Stacked":  					st = ChartSubTypeEnum.Stacked;  					break;  				case "PercentStacked":  					st = ChartSubTypeEnum.PercentStacked;  					break;  				case "Smooth":  					st = ChartSubTypeEnum.Smooth;  					break;  				case "Exploded":  					st = ChartSubTypeEnum.Exploded;  					break;  				case "Line":  					st = ChartSubTypeEnum.Line;  					break;  				case "SmoothLine":  					st = ChartSubTypeEnum.SmoothLine;  					break;  				case "HighLowClose":  					st = ChartSubTypeEnum.HighLowClose;  					break;  				case "OpenHighLowClose":  					st = ChartSubTypeEnum.OpenHighLowClose;  					break;  				case "Candlestick":  					st = ChartSubTypeEnum.Candlestick;  					break;  				default:		  					rl.LogError(4' "Unknown ChartSubType '" + s + "'.  Plain assumed.");  					st = ChartSubTypeEnum.Plain;  					break;  			}
Magic Number,fyiReporting.RDL,Classes,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Classes.cs,Classes,The following statement contains a magic number: if (_Items.Count == 0)  				OwnerReport.rl.LogError(8' "For Classes at least one Class is required.");  			else                  _Items.TrimExcess();
Magic Number,fyiReporting.RDL,Code,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Code.cs,GetAssembly,The following statement contains a magic number: if(cr.Errors.Count > 0)  			{  				StringBuilder err = new StringBuilder(string.Format("Code element has {0} error(s).  Line numbers are relative to Code element."' cr.Errors.Count));  				foreach (CompilerError ce in cr.Errors)  				{  					string l;  					if (ce.Line >= 1 && ce.Line <= lines.Count)  						l = lines[ce.Line - 1] as string;  					else  						l = "Unknown";  					err.AppendFormat("\r\nLine {0} '{1}' : {2} {3}"' ce.Line - 5' l' ce.ErrorNumber' ce.ErrorText);  				}  				this.OwnerReport.rl.LogError(4' err.ToString());  				return null;  			}
Magic Number,fyiReporting.RDL,Code,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Code.cs,GetAssembly,The following statement contains a magic number: if(cr.Errors.Count > 0)  			{  				StringBuilder err = new StringBuilder(string.Format("Code element has {0} error(s).  Line numbers are relative to Code element."' cr.Errors.Count));  				foreach (CompilerError ce in cr.Errors)  				{  					string l;  					if (ce.Line >= 1 && ce.Line <= lines.Count)  						l = lines[ce.Line - 1] as string;  					else  						l = "Unknown";  					err.AppendFormat("\r\nLine {0} '{1}' : {2} {3}"' ce.Line - 5' l' ce.ErrorNumber' ce.ErrorText);  				}  				this.OwnerReport.rl.LogError(4' err.ToString());  				return null;  			}
Magic Number,fyiReporting.RDL,Code,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Code.cs,CodeType,The following statement contains a magic number: try  			{  				object instance = _Assembly.CreateInstance("fyiReporting.vbgen." + this._Classname' false);   				t = instance.GetType();  			}  			catch (Exception e)  			{  				OwnerReport.rl.LogError(4'   					string.Format("Unable to load instance of Code\r\n{0}"' e.Message));  			}
Magic Number,fyiReporting.RDL,Code,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Code.cs,Load,The following statement contains a magic number: if (wc.Instance == null)  			{  				string e = String.Format("Unable to create instance of local code class.\r\n{0}"' err);  				if (rpt == null)  					OwnerReport.rl.LogError(4' e);  				else  					rpt.rl.LogError(4' e);  				wc.bCreateFailed = true;  			}
Magic Number,fyiReporting.RDL,Code,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Code.cs,Load,The following statement contains a magic number: if (wc.Instance == null)  			{  				string e = String.Format("Unable to create instance of local code class.\r\n{0}"' err);  				if (rpt == null)  					OwnerReport.rl.LogError(4' e);  				else  					rpt.rl.LogError(4' e);  				wc.bCreateFailed = true;  			}
Magic Number,fyiReporting.RDL,CodeModule,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\CodeModule.cs,LoadedAssembly,The following statement contains a magic number: if (_LoadedAssembly == null)  			{  				try  				{  					_LoadedAssembly = XmlUtil.AssemblyLoadFrom(_CodeModule);  				}  				catch (Exception e)  				{  					OwnerReport.rl.LogError(4' String.Format("CodeModule {0} failed to load.  {1}"'  						_CodeModule' e.Message));  					bLoadFailed = true;  				}  			}
Magic Number,fyiReporting.RDL,CodeModules,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\CodeModules.cs,CodeModules,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				if (xNodeLoop.Name == "CodeModule")  				{  					CodeModule cm = new CodeModule(r' this' xNodeLoop);  					_Items.Add(cm);  				}  				else  				{  					// don't know this element - log it  					OwnerReport.rl.LogError(4' "Unknown CodeModules element '" + xNodeLoop.Name + "' ignored.");  				}  			}
Magic Number,fyiReporting.RDL,CodeModules,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\CodeModules.cs,CodeModules,The following statement contains a magic number: if (_Items.Count == 0)  				OwnerReport.rl.LogError(8' "For CodeModules at least one CodeModule is required.");  			else                  _Items.TrimExcess();
Magic Number,fyiReporting.RDL,ColumnGrouping,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ColumnGrouping.cs,ColumnGrouping,The following statement contains a magic number: if (_Height == null)  				OwnerReport.rl.LogError(8' "ColumnGrouping requires the Height element to be specified.");
Magic Number,fyiReporting.RDL,ColumnGrouping,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ColumnGrouping.cs,ColumnGrouping,The following statement contains a magic number: if ((_DynamicColumns != null && _StaticColumns != null) ||  				(_DynamicColumns == null && _StaticColumns == null))  				OwnerReport.rl.LogError(8' "ColumnGrouping requires either the DynamicColumns element or StaticColumns element but not both.");
Magic Number,fyiReporting.RDL,ColumnGroupings,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ColumnGroupings.cs,ColumnGroupings,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "ColumnGrouping":  						g = new ColumnGrouping(r' this' xNodeLoop);  						break;  					default:	  						g=null;		// don't know what this is  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown ColumnGroupings element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  				if (g != null)  					_Items.Add(g);  			}
Magic Number,fyiReporting.RDL,ColumnGroupings,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ColumnGroupings.cs,ColumnGroupings,The following statement contains a magic number: if (_Items.Count == 0)  				OwnerReport.rl.LogError(8' "For ColumnGroups at least one ColumnGrouping is required.");  			else  			{                  _Items.TrimExcess();  				_StaticCount = GetStaticCount();  			}
Magic Number,fyiReporting.RDL,ConnectionProperties,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ConnectionProperties.cs,ConnectionProperties,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "DataProvider":  						_DataProvider = xNodeLoop.InnerText;  						break;  					case "ConnectString":  					_ConnectString = String.IsNullOrWhiteSpace (r.OverwriteConnectionString)   						? new Expression(r' this' xNodeLoop' ExpressionType.String)  						: new Expression(r' this' r.OverwriteConnectionString' ExpressionType.String);  						break;  					case "IntegratedSecurity":  						_IntegratedSecurity = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "Prompt":  						_Prompt = xNodeLoop.InnerText;  						break;  					default:  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown ConnectionProperties element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,ConnectionProperties,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ConnectionProperties.cs,ConnectionProperties,The following statement contains a magic number: if (_DataProvider == null)  				OwnerReport.rl.LogError(8' "ConnectionProperties DataProvider is required.");
Magic Number,fyiReporting.RDL,ConnectionProperties,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ConnectionProperties.cs,ConnectionProperties,The following statement contains a magic number: if (_ConnectString == null)  				OwnerReport.rl.LogError(8' "ConnectionProperties ConnectString is required.");
Magic Number,fyiReporting.RDL,ChartMap,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMap.cs,DrawMap,The following statement contains a magic number: if (file != null)                  mp = MapData.Create(file);              else              {                  rpt.rl.LogError(4' string.Format("Map Subtype file {0} not found."' mapfile));                                  mp = new MapData();         // we'll at least put up something; but it won't be right              }
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,ReadXmlPoints,The following statement contains a magic number: PointF[] pa = new PointF[pts.Length / 2];
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,ReadXmlText,The following statement contains a magic number: float fontsize = 8;
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,ReadXmlText,The following statement contains a magic number: while (xr.Read())              {                  if (!xr.IsStartElement())                  {                      if (xr.NodeType == XmlNodeType.EndElement && xr.Name == "Text")                          break;                      continue;                  }                    switch (xr.Name)                  {                      case "Location":                          PointF[] pfa = ReadXmlPoints(xr);                          location = pfa[0];                          break;                      case "Value":                          val = xr.ReadString();                          break;                      case "FontFamily":                          family = xr.ReadString();                          break;                      case "FontSize":                          temp = xr.ReadString();                          try                          {                              fontsize = float.Parse(temp' NumberFormatInfo.InvariantInfo);                          }                          catch                          {                              fontsize = 8;                          }                          break;                      case "FontWeight":                          temp = xr.ReadString();                          bBold = temp.ToLower() == "bold";                          break;                      case "FontStyle":                          temp = xr.ReadString();                          bItalic = temp.ToLower() == "italic";                          break;                      case "TextDecoration":                          temp = xr.ReadString();                          switch (temp.ToLower())                          {                              case "underline":                                  bUnderline = true;                                  break;                              case "linethrough":                                  bUnderline = true;                                  break;                          }                          break;                  }              }
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(338' 104)' new PointF(339' 111)' new PointF(344' 111)' new PointF(344' 109) }' new string[] { "de" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(338' 104)' new PointF(339' 111)' new PointF(344' 111)' new PointF(344' 109) }' new string[] { "de" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(338' 104)' new PointF(339' 111)' new PointF(344' 111)' new PointF(344' 109) }' new string[] { "de" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(338' 104)' new PointF(339' 111)' new PointF(344' 111)' new PointF(344' 109) }' new string[] { "de" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(338' 104)' new PointF(339' 111)' new PointF(344' 111)' new PointF(344' 109) }' new string[] { "de" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(338' 104)' new PointF(339' 111)' new PointF(344' 111)' new PointF(344' 109) }' new string[] { "de" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(338' 104)' new PointF(339' 111)' new PointF(344' 111)' new PointF(344' 109) }' new string[] { "de" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(338' 104)' new PointF(339' 111)' new PointF(344' 111)' new PointF(344' 109) }' new string[] { "de" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(312' 106)' new PointF(335' 102)' new PointF(332' 112)' new PointF(323' 105) }' new string[] { "md" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(312' 106)' new PointF(335' 102)' new PointF(332' 112)' new PointF(323' 105) }' new string[] { "md" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(312' 106)' new PointF(335' 102)' new PointF(332' 112)' new PointF(323' 105) }' new string[] { "md" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(312' 106)' new PointF(335' 102)' new PointF(332' 112)' new PointF(323' 105) }' new string[] { "md" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(312' 106)' new PointF(335' 102)' new PointF(332' 112)' new PointF(323' 105) }' new string[] { "md" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(312' 106)' new PointF(335' 102)' new PointF(332' 112)' new PointF(323' 105) }' new string[] { "md" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(312' 106)' new PointF(335' 102)' new PointF(332' 112)' new PointF(323' 105) }' new string[] { "md" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(312' 106)' new PointF(335' 102)' new PointF(332' 112)' new PointF(323' 105) }' new string[] { "md" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(355' 46)' new PointF(358' 29)' new PointF(364' 26)' new PointF(367' 25)' new PointF(371' 35)' new PointF(378' 44)' new PointF(372' 50)' new PointF(369' 48)' new PointF(368' 54)' new PointF(360' 64) }' new string[] { "me" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(355' 46)' new PointF(358' 29)' new PointF(364' 26)' new PointF(367' 25)' new PointF(371' 35)' new PointF(378' 44)' new PointF(372' 50)' new PointF(369' 48)' new PointF(368' 54)' new PointF(360' 64) }' new string[] { "me" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(355' 46)' new PointF(358' 29)' new PointF(364' 26)' new PointF(367' 25)' new PointF(371' 35)' new PointF(378' 44)' new PointF(372' 50)' new PointF(369' 48)' new PointF(368' 54)' new PointF(360' 64) }' new string[] { "me" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(355' 46)' new PointF(358' 29)' new PointF(364' 26)' new PointF(367' 25)' new PointF(371' 35)' new PointF(378' 44)' new PointF(372' 50)' new PointF(369' 48)' new PointF(368' 54)' new PointF(360' 64) }' new string[] { "me" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(355' 46)' new PointF(358' 29)' new PointF(364' 26)' new PointF(367' 25)' new PointF(371' 35)' new PointF(378' 44)' new PointF(372' 50)' new PointF(369' 48)' new PointF(368' 54)' new PointF(360' 64) }' new string[] { "me" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(355' 46)' new PointF(358' 29)' new PointF(364' 26)' new PointF(367' 25)' new PointF(371' 35)' new PointF(378' 44)' new PointF(372' 50)' new PointF(369' 48)' new PointF(368' 54)' new PointF(360' 64) }' new string[] { "me" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(355' 46)' new PointF(358' 29)' new PointF(364' 26)' new PointF(367' 25)' new PointF(371' 35)' new PointF(378' 44)' new PointF(372' 50)' new PointF(369' 48)' new PointF(368' 54)' new PointF(360' 64) }' new string[] { "me" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(355' 46)' new PointF(358' 29)' new PointF(364' 26)' new PointF(367' 25)' new PointF(371' 35)' new PointF(378' 44)' new PointF(372' 50)' new PointF(369' 48)' new PointF(368' 54)' new PointF(360' 64) }' new string[] { "me" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(355' 46)' new PointF(358' 29)' new PointF(364' 26)' new PointF(367' 25)' new PointF(371' 35)' new PointF(378' 44)' new PointF(372' 50)' new PointF(369' 48)' new PointF(368' 54)' new PointF(360' 64) }' new string[] { "me" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(355' 46)' new PointF(358' 29)' new PointF(364' 26)' new PointF(367' 25)' new PointF(371' 35)' new PointF(378' 44)' new PointF(372' 50)' new PointF(369' 48)' new PointF(368' 54)' new PointF(360' 64) }' new string[] { "me" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(355' 46)' new PointF(358' 29)' new PointF(364' 26)' new PointF(367' 25)' new PointF(371' 35)' new PointF(378' 44)' new PointF(372' 50)' new PointF(369' 48)' new PointF(368' 54)' new PointF(360' 64) }' new string[] { "me" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(355' 46)' new PointF(358' 29)' new PointF(364' 26)' new PointF(367' 25)' new PointF(371' 35)' new PointF(378' 44)' new PointF(372' 50)' new PointF(369' 48)' new PointF(368' 54)' new PointF(360' 64) }' new string[] { "me" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(355' 46)' new PointF(358' 29)' new PointF(364' 26)' new PointF(367' 25)' new PointF(371' 35)' new PointF(378' 44)' new PointF(372' 50)' new PointF(369' 48)' new PointF(368' 54)' new PointF(360' 64) }' new string[] { "me" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(355' 46)' new PointF(358' 29)' new PointF(364' 26)' new PointF(367' 25)' new PointF(371' 35)' new PointF(378' 44)' new PointF(372' 50)' new PointF(369' 48)' new PointF(368' 54)' new PointF(360' 64) }' new string[] { "me" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(355' 46)' new PointF(358' 29)' new PointF(364' 26)' new PointF(367' 25)' new PointF(371' 35)' new PointF(378' 44)' new PointF(372' 50)' new PointF(369' 48)' new PointF(368' 54)' new PointF(360' 64) }' new string[] { "me" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(355' 46)' new PointF(358' 29)' new PointF(364' 26)' new PointF(367' 25)' new PointF(371' 35)' new PointF(378' 44)' new PointF(372' 50)' new PointF(369' 48)' new PointF(368' 54)' new PointF(360' 64) }' new string[] { "me" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(355' 46)' new PointF(358' 29)' new PointF(364' 26)' new PointF(367' 25)' new PointF(371' 35)' new PointF(378' 44)' new PointF(372' 50)' new PointF(369' 48)' new PointF(368' 54)' new PointF(360' 64) }' new string[] { "me" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(355' 46)' new PointF(358' 29)' new PointF(364' 26)' new PointF(367' 25)' new PointF(371' 35)' new PointF(378' 44)' new PointF(372' 50)' new PointF(369' 48)' new PointF(368' 54)' new PointF(360' 64) }' new string[] { "me" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(355' 46)' new PointF(358' 29)' new PointF(364' 26)' new PointF(367' 25)' new PointF(371' 35)' new PointF(378' 44)' new PointF(372' 50)' new PointF(369' 48)' new PointF(368' 54)' new PointF(360' 64) }' new string[] { "me" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(355' 46)' new PointF(358' 29)' new PointF(364' 26)' new PointF(367' 25)' new PointF(371' 35)' new PointF(378' 44)' new PointF(372' 50)' new PointF(369' 48)' new PointF(368' 54)' new PointF(360' 64) }' new string[] { "me" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(352' 49)' new PointF(360' 65)' new PointF(359' 67)' new PointF(351' 67) }' new string[] { "nh" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(352' 49)' new PointF(360' 65)' new PointF(359' 67)' new PointF(351' 67) }' new string[] { "nh" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(352' 49)' new PointF(360' 65)' new PointF(359' 67)' new PointF(351' 67) }' new string[] { "nh" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(352' 49)' new PointF(360' 65)' new PointF(359' 67)' new PointF(351' 67) }' new string[] { "nh" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(352' 49)' new PointF(360' 65)' new PointF(359' 67)' new PointF(351' 67) }' new string[] { "nh" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(352' 49)' new PointF(360' 65)' new PointF(359' 67)' new PointF(351' 67) }' new string[] { "nh" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(352' 49)' new PointF(360' 65)' new PointF(359' 67)' new PointF(351' 67) }' new string[] { "nh" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(352' 49)' new PointF(360' 65)' new PointF(359' 67)' new PointF(351' 67) }' new string[] { "nh" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(358' 76)' new PointF(360' 77)' new PointF(360' 80)' new PointF(359' 80) }' new string[] { "ri" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(358' 76)' new PointF(360' 77)' new PointF(360' 80)' new PointF(359' 80) }' new string[] { "ri" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(358' 76)' new PointF(360' 77)' new PointF(360' 80)' new PointF(359' 80) }' new string[] { "ri" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(358' 76)' new PointF(360' 77)' new PointF(360' 80)' new PointF(359' 80) }' new string[] { "ri" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(358' 76)' new PointF(360' 77)' new PointF(360' 80)' new PointF(359' 80) }' new string[] { "ri" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(358' 76)' new PointF(360' 77)' new PointF(360' 80)' new PointF(359' 80) }' new string[] { "ri" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(358' 76)' new PointF(360' 77)' new PointF(360' 80)' new PointF(359' 80) }' new string[] { "ri" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(358' 76)' new PointF(360' 77)' new PointF(360' 80)' new PointF(359' 80) }' new string[] { "ri" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(348' 78)' new PointF(361' 77)' new PointF(357' 81)' new PointF(349' 85) }' new string[] { "ct" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(348' 78)' new PointF(361' 77)' new PointF(357' 81)' new PointF(349' 85) }' new string[] { "ct" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(348' 78)' new PointF(361' 77)' new PointF(357' 81)' new PointF(349' 85) }' new string[] { "ct" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(348' 78)' new PointF(361' 77)' new PointF(357' 81)' new PointF(349' 85) }' new string[] { "ct" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(348' 78)' new PointF(361' 77)' new PointF(357' 81)' new PointF(349' 85) }' new string[] { "ct" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(348' 78)' new PointF(361' 77)' new PointF(357' 81)' new PointF(349' 85) }' new string[] { "ct" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(348' 78)' new PointF(361' 77)' new PointF(357' 81)' new PointF(349' 85) }' new string[] { "ct" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(348' 78)' new PointF(361' 77)' new PointF(357' 81)' new PointF(349' 85) }' new string[] { "ct" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(348' 72)' new PointF(360' 68)' new PointF(361' 72)' new PointF(364' 74)' new PointF(367' 73)' new PointF(367' 76)' new PointF(365' 77)' new PointF(362' 78)' new PointF(361' 74)' new PointF(348' 77) }' new string[] { "ma" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(348' 72)' new PointF(360' 68)' new PointF(361' 72)' new PointF(364' 74)' new PointF(367' 73)' new PointF(367' 76)' new PointF(365' 77)' new PointF(362' 78)' new PointF(361' 74)' new PointF(348' 77) }' new string[] { "ma" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(348' 72)' new PointF(360' 68)' new PointF(361' 72)' new PointF(364' 74)' new PointF(367' 73)' new PointF(367' 76)' new PointF(365' 77)' new PointF(362' 78)' new PointF(361' 74)' new PointF(348' 77) }' new string[] { "ma" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(348' 72)' new PointF(360' 68)' new PointF(361' 72)' new PointF(364' 74)' new PointF(367' 73)' new PointF(367' 76)' new PointF(365' 77)' new PointF(362' 78)' new PointF(361' 74)' new PointF(348' 77) }' new string[] { "ma" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(348' 72)' new PointF(360' 68)' new PointF(361' 72)' new PointF(364' 74)' new PointF(367' 73)' new PointF(367' 76)' new PointF(365' 77)' new PointF(362' 78)' new PointF(361' 74)' new PointF(348' 77) }' new string[] { "ma" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(348' 72)' new PointF(360' 68)' new PointF(361' 72)' new PointF(364' 74)' new PointF(367' 73)' new PointF(367' 76)' new PointF(365' 77)' new PointF(362' 78)' new PointF(361' 74)' new PointF(348' 77) }' new string[] { "ma" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(348' 72)' new PointF(360' 68)' new PointF(361' 72)' new PointF(364' 74)' new PointF(367' 73)' new PointF(367' 76)' new PointF(365' 77)' new PointF(362' 78)' new PointF(361' 74)' new PointF(348' 77) }' new string[] { "ma" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(348' 72)' new PointF(360' 68)' new PointF(361' 72)' new PointF(364' 74)' new PointF(367' 73)' new PointF(367' 76)' new PointF(365' 77)' new PointF(362' 78)' new PointF(361' 74)' new PointF(348' 77) }' new string[] { "ma" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(348' 72)' new PointF(360' 68)' new PointF(361' 72)' new PointF(364' 74)' new PointF(367' 73)' new PointF(367' 76)' new PointF(365' 77)' new PointF(362' 78)' new PointF(361' 74)' new PointF(348' 77) }' new string[] { "ma" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(348' 72)' new PointF(360' 68)' new PointF(361' 72)' new PointF(364' 74)' new PointF(367' 73)' new PointF(367' 76)' new PointF(365' 77)' new PointF(362' 78)' new PointF(361' 74)' new PointF(348' 77) }' new string[] { "ma" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(348' 72)' new PointF(360' 68)' new PointF(361' 72)' new PointF(364' 74)' new PointF(367' 73)' new PointF(367' 76)' new PointF(365' 77)' new PointF(362' 78)' new PointF(361' 74)' new PointF(348' 77) }' new string[] { "ma" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(348' 72)' new PointF(360' 68)' new PointF(361' 72)' new PointF(364' 74)' new PointF(367' 73)' new PointF(367' 76)' new PointF(365' 77)' new PointF(362' 78)' new PointF(361' 74)' new PointF(348' 77) }' new string[] { "ma" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(348' 72)' new PointF(360' 68)' new PointF(361' 72)' new PointF(364' 74)' new PointF(367' 73)' new PointF(367' 76)' new PointF(365' 77)' new PointF(362' 78)' new PointF(361' 74)' new PointF(348' 77) }' new string[] { "ma" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(348' 72)' new PointF(360' 68)' new PointF(361' 72)' new PointF(364' 74)' new PointF(367' 73)' new PointF(367' 76)' new PointF(365' 77)' new PointF(362' 78)' new PointF(361' 74)' new PointF(348' 77) }' new string[] { "ma" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(348' 72)' new PointF(360' 68)' new PointF(361' 72)' new PointF(364' 74)' new PointF(367' 73)' new PointF(367' 76)' new PointF(365' 77)' new PointF(362' 78)' new PointF(361' 74)' new PointF(348' 77) }' new string[] { "ma" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(348' 72)' new PointF(360' 68)' new PointF(361' 72)' new PointF(364' 74)' new PointF(367' 73)' new PointF(367' 76)' new PointF(365' 77)' new PointF(362' 78)' new PointF(361' 74)' new PointF(348' 77) }' new string[] { "ma" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(348' 72)' new PointF(360' 68)' new PointF(361' 72)' new PointF(364' 74)' new PointF(367' 73)' new PointF(367' 76)' new PointF(365' 77)' new PointF(362' 78)' new PointF(361' 74)' new PointF(348' 77) }' new string[] { "ma" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(348' 72)' new PointF(360' 68)' new PointF(361' 72)' new PointF(364' 74)' new PointF(367' 73)' new PointF(367' 76)' new PointF(365' 77)' new PointF(362' 78)' new PointF(361' 74)' new PointF(348' 77) }' new string[] { "ma" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(348' 72)' new PointF(360' 68)' new PointF(361' 72)' new PointF(364' 74)' new PointF(367' 73)' new PointF(367' 76)' new PointF(365' 77)' new PointF(362' 78)' new PointF(361' 74)' new PointF(348' 77) }' new string[] { "ma" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(348' 72)' new PointF(360' 68)' new PointF(361' 72)' new PointF(364' 74)' new PointF(367' 73)' new PointF(367' 76)' new PointF(365' 77)' new PointF(362' 78)' new PointF(361' 74)' new PointF(348' 77) }' new string[] { "ma" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(343' 53)' new PointF(352' 50)' new PointF(350' 70)' new PointF(347' 69) }' new string[] { "vt" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(343' 53)' new PointF(352' 50)' new PointF(350' 70)' new PointF(347' 69) }' new string[] { "vt" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(343' 53)' new PointF(352' 50)' new PointF(350' 70)' new PointF(347' 69) }' new string[] { "vt" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(343' 53)' new PointF(352' 50)' new PointF(350' 70)' new PointF(347' 69) }' new string[] { "vt" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(343' 53)' new PointF(352' 50)' new PointF(350' 70)' new PointF(347' 69) }' new string[] { "vt" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(343' 53)' new PointF(352' 50)' new PointF(350' 70)' new PointF(347' 69) }' new string[] { "vt" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(343' 53)' new PointF(352' 50)' new PointF(350' 70)' new PointF(347' 69) }' new string[] { "vt" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(343' 53)' new PointF(352' 50)' new PointF(350' 70)' new PointF(347' 69) }' new string[] { "vt" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(308' 86)' new PointF(312' 80)' new PointF(312' 75)' new PointF(324' 72)' new PointF(326' 68)' new PointF(326' 63)' new PointF(334' 54)' new PointF(341' 54)' new PointF(347' 71)' new PointF(347' 85)' new PointF(341' 85)' new PointF(336' 81) }' new string[] { "ny" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(308' 86)' new PointF(312' 80)' new PointF(312' 75)' new PointF(324' 72)' new PointF(326' 68)' new PointF(326' 63)' new PointF(334' 54)' new PointF(341' 54)' new PointF(347' 71)' new PointF(347' 85)' new PointF(341' 85)' new PointF(336' 81) }' new string[] { "ny" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(308' 86)' new PointF(312' 80)' new PointF(312' 75)' new PointF(324' 72)' new PointF(326' 68)' new PointF(326' 63)' new PointF(334' 54)' new PointF(341' 54)' new PointF(347' 71)' new PointF(347' 85)' new PointF(341' 85)' new PointF(336' 81) }' new string[] { "ny" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(308' 86)' new PointF(312' 80)' new PointF(312' 75)' new PointF(324' 72)' new PointF(326' 68)' new PointF(326' 63)' new PointF(334' 54)' new PointF(341' 54)' new PointF(347' 71)' new PointF(347' 85)' new PointF(341' 85)' new PointF(336' 81) }' new string[] { "ny" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(308' 86)' new PointF(312' 80)' new PointF(312' 75)' new PointF(324' 72)' new PointF(326' 68)' new PointF(326' 63)' new PointF(334' 54)' new PointF(341' 54)' new PointF(347' 71)' new PointF(347' 85)' new PointF(341' 85)' new PointF(336' 81) }' new string[] { "ny" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(308' 86)' new PointF(312' 80)' new PointF(312' 75)' new PointF(324' 72)' new PointF(326' 68)' new PointF(326' 63)' new PointF(334' 54)' new PointF(341' 54)' new PointF(347' 71)' new PointF(347' 85)' new PointF(341' 85)' new PointF(336' 81) }' new string[] { "ny" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(308' 86)' new PointF(312' 80)' new PointF(312' 75)' new PointF(324' 72)' new PointF(326' 68)' new PointF(326' 63)' new PointF(334' 54)' new PointF(341' 54)' new PointF(347' 71)' new PointF(347' 85)' new PointF(341' 85)' new PointF(336' 81) }' new string[] { "ny" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(308' 86)' new PointF(312' 80)' new PointF(312' 75)' new PointF(324' 72)' new PointF(326' 68)' new PointF(326' 63)' new PointF(334' 54)' new PointF(341' 54)' new PointF(347' 71)' new PointF(347' 85)' new PointF(341' 85)' new PointF(336' 81) }' new string[] { "ny" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(308' 86)' new PointF(312' 80)' new PointF(312' 75)' new PointF(324' 72)' new PointF(326' 68)' new PointF(326' 63)' new PointF(334' 54)' new PointF(341' 54)' new PointF(347' 71)' new PointF(347' 85)' new PointF(341' 85)' new PointF(336' 81) }' new string[] { "ny" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(308' 86)' new PointF(312' 80)' new PointF(312' 75)' new PointF(324' 72)' new PointF(326' 68)' new PointF(326' 63)' new PointF(334' 54)' new PointF(341' 54)' new PointF(347' 71)' new PointF(347' 85)' new PointF(341' 85)' new PointF(336' 81) }' new string[] { "ny" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(308' 86)' new PointF(312' 80)' new PointF(312' 75)' new PointF(324' 72)' new PointF(326' 68)' new PointF(326' 63)' new PointF(334' 54)' new PointF(341' 54)' new PointF(347' 71)' new PointF(347' 85)' new PointF(341' 85)' new PointF(336' 81) }' new string[] { "ny" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(308' 86)' new PointF(312' 80)' new PointF(312' 75)' new PointF(324' 72)' new PointF(326' 68)' new PointF(326' 63)' new PointF(334' 54)' new PointF(341' 54)' new PointF(347' 71)' new PointF(347' 85)' new PointF(341' 85)' new PointF(336' 81) }' new string[] { "ny" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(308' 86)' new PointF(312' 80)' new PointF(312' 75)' new PointF(324' 72)' new PointF(326' 68)' new PointF(326' 63)' new PointF(334' 54)' new PointF(341' 54)' new PointF(347' 71)' new PointF(347' 85)' new PointF(341' 85)' new PointF(336' 81) }' new string[] { "ny" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(308' 86)' new PointF(312' 80)' new PointF(312' 75)' new PointF(324' 72)' new PointF(326' 68)' new PointF(326' 63)' new PointF(334' 54)' new PointF(341' 54)' new PointF(347' 71)' new PointF(347' 85)' new PointF(341' 85)' new PointF(336' 81) }' new string[] { "ny" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(308' 86)' new PointF(312' 80)' new PointF(312' 75)' new PointF(324' 72)' new PointF(326' 68)' new PointF(326' 63)' new PointF(334' 54)' new PointF(341' 54)' new PointF(347' 71)' new PointF(347' 85)' new PointF(341' 85)' new PointF(336' 81) }' new string[] { "ny" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(308' 86)' new PointF(312' 80)' new PointF(312' 75)' new PointF(324' 72)' new PointF(326' 68)' new PointF(326' 63)' new PointF(334' 54)' new PointF(341' 54)' new PointF(347' 71)' new PointF(347' 85)' new PointF(341' 85)' new PointF(336' 81) }' new string[] { "ny" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(308' 86)' new PointF(312' 80)' new PointF(312' 75)' new PointF(324' 72)' new PointF(326' 68)' new PointF(326' 63)' new PointF(334' 54)' new PointF(341' 54)' new PointF(347' 71)' new PointF(347' 85)' new PointF(341' 85)' new PointF(336' 81) }' new string[] { "ny" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(308' 86)' new PointF(312' 80)' new PointF(312' 75)' new PointF(324' 72)' new PointF(326' 68)' new PointF(326' 63)' new PointF(334' 54)' new PointF(341' 54)' new PointF(347' 71)' new PointF(347' 85)' new PointF(341' 85)' new PointF(336' 81) }' new string[] { "ny" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(308' 86)' new PointF(312' 80)' new PointF(312' 75)' new PointF(324' 72)' new PointF(326' 68)' new PointF(326' 63)' new PointF(334' 54)' new PointF(341' 54)' new PointF(347' 71)' new PointF(347' 85)' new PointF(341' 85)' new PointF(336' 81) }' new string[] { "ny" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(308' 86)' new PointF(312' 80)' new PointF(312' 75)' new PointF(324' 72)' new PointF(326' 68)' new PointF(326' 63)' new PointF(334' 54)' new PointF(341' 54)' new PointF(347' 71)' new PointF(347' 85)' new PointF(341' 85)' new PointF(336' 81) }' new string[] { "ny" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(308' 86)' new PointF(312' 80)' new PointF(312' 75)' new PointF(324' 72)' new PointF(326' 68)' new PointF(326' 63)' new PointF(334' 54)' new PointF(341' 54)' new PointF(347' 71)' new PointF(347' 85)' new PointF(341' 85)' new PointF(336' 81) }' new string[] { "ny" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(308' 86)' new PointF(312' 80)' new PointF(312' 75)' new PointF(324' 72)' new PointF(326' 68)' new PointF(326' 63)' new PointF(334' 54)' new PointF(341' 54)' new PointF(347' 71)' new PointF(347' 85)' new PointF(341' 85)' new PointF(336' 81) }' new string[] { "ny" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(308' 86)' new PointF(312' 80)' new PointF(312' 75)' new PointF(324' 72)' new PointF(326' 68)' new PointF(326' 63)' new PointF(334' 54)' new PointF(341' 54)' new PointF(347' 71)' new PointF(347' 85)' new PointF(341' 85)' new PointF(336' 81) }' new string[] { "ny" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(308' 86)' new PointF(312' 80)' new PointF(312' 75)' new PointF(324' 72)' new PointF(326' 68)' new PointF(326' 63)' new PointF(334' 54)' new PointF(341' 54)' new PointF(347' 71)' new PointF(347' 85)' new PointF(341' 85)' new PointF(336' 81) }' new string[] { "ny" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(340' 86)' new PointF(346' 86)' new PointF(347' 96)' new PointF(344' 104)' new PointF(338' 100)' new PointF(343' 96)' new PointF(340' 92) }' new string[] { "nj" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(340' 86)' new PointF(346' 86)' new PointF(347' 96)' new PointF(344' 104)' new PointF(338' 100)' new PointF(343' 96)' new PointF(340' 92) }' new string[] { "nj" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(340' 86)' new PointF(346' 86)' new PointF(347' 96)' new PointF(344' 104)' new PointF(338' 100)' new PointF(343' 96)' new PointF(340' 92) }' new string[] { "nj" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(340' 86)' new PointF(346' 86)' new PointF(347' 96)' new PointF(344' 104)' new PointF(338' 100)' new PointF(343' 96)' new PointF(340' 92) }' new string[] { "nj" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(340' 86)' new PointF(346' 86)' new PointF(347' 96)' new PointF(344' 104)' new PointF(338' 100)' new PointF(343' 96)' new PointF(340' 92) }' new string[] { "nj" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(340' 86)' new PointF(346' 86)' new PointF(347' 96)' new PointF(344' 104)' new PointF(338' 100)' new PointF(343' 96)' new PointF(340' 92) }' new string[] { "nj" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(340' 86)' new PointF(346' 86)' new PointF(347' 96)' new PointF(344' 104)' new PointF(338' 100)' new PointF(343' 96)' new PointF(340' 92) }' new string[] { "nj" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(340' 86)' new PointF(346' 86)' new PointF(347' 96)' new PointF(344' 104)' new PointF(338' 100)' new PointF(343' 96)' new PointF(340' 92) }' new string[] { "nj" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(340' 86)' new PointF(346' 86)' new PointF(347' 96)' new PointF(344' 104)' new PointF(338' 100)' new PointF(343' 96)' new PointF(340' 92) }' new string[] { "nj" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(340' 86)' new PointF(346' 86)' new PointF(347' 96)' new PointF(344' 104)' new PointF(338' 100)' new PointF(343' 96)' new PointF(340' 92) }' new string[] { "nj" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(340' 86)' new PointF(346' 86)' new PointF(347' 96)' new PointF(344' 104)' new PointF(338' 100)' new PointF(343' 96)' new PointF(340' 92) }' new string[] { "nj" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(340' 86)' new PointF(346' 86)' new PointF(347' 96)' new PointF(344' 104)' new PointF(338' 100)' new PointF(343' 96)' new PointF(340' 92) }' new string[] { "nj" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(340' 86)' new PointF(346' 86)' new PointF(347' 96)' new PointF(344' 104)' new PointF(338' 100)' new PointF(343' 96)' new PointF(340' 92) }' new string[] { "nj" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(340' 86)' new PointF(346' 86)' new PointF(347' 96)' new PointF(344' 104)' new PointF(338' 100)' new PointF(343' 96)' new PointF(340' 92) }' new string[] { "nj" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(304' 88)' new PointF(336' 81)' new PointF(339' 86)' new PointF(339' 91)' new PointF(341' 94)' new PointF(339' 100)' new PointF(306' 106) }' new string[] { "pa" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(304' 88)' new PointF(336' 81)' new PointF(339' 86)' new PointF(339' 91)' new PointF(341' 94)' new PointF(339' 100)' new PointF(306' 106) }' new string[] { "pa" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(304' 88)' new PointF(336' 81)' new PointF(339' 86)' new PointF(339' 91)' new PointF(341' 94)' new PointF(339' 100)' new PointF(306' 106) }' new string[] { "pa" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(304' 88)' new PointF(336' 81)' new PointF(339' 86)' new PointF(339' 91)' new PointF(341' 94)' new PointF(339' 100)' new PointF(306' 106) }' new string[] { "pa" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(304' 88)' new PointF(336' 81)' new PointF(339' 86)' new PointF(339' 91)' new PointF(341' 94)' new PointF(339' 100)' new PointF(306' 106) }' new string[] { "pa" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(304' 88)' new PointF(336' 81)' new PointF(339' 86)' new PointF(339' 91)' new PointF(341' 94)' new PointF(339' 100)' new PointF(306' 106) }' new string[] { "pa" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(304' 88)' new PointF(336' 81)' new PointF(339' 86)' new PointF(339' 91)' new PointF(341' 94)' new PointF(339' 100)' new PointF(306' 106) }' new string[] { "pa" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(304' 88)' new PointF(336' 81)' new PointF(339' 86)' new PointF(339' 91)' new PointF(341' 94)' new PointF(339' 100)' new PointF(306' 106) }' new string[] { "pa" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(304' 88)' new PointF(336' 81)' new PointF(339' 86)' new PointF(339' 91)' new PointF(341' 94)' new PointF(339' 100)' new PointF(306' 106) }' new string[] { "pa" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(304' 88)' new PointF(336' 81)' new PointF(339' 86)' new PointF(339' 91)' new PointF(341' 94)' new PointF(339' 100)' new PointF(306' 106) }' new string[] { "pa" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(304' 88)' new PointF(336' 81)' new PointF(339' 86)' new PointF(339' 91)' new PointF(341' 94)' new PointF(339' 100)' new PointF(306' 106) }' new string[] { "pa" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(304' 88)' new PointF(336' 81)' new PointF(339' 86)' new PointF(339' 91)' new PointF(341' 94)' new PointF(339' 100)' new PointF(306' 106) }' new string[] { "pa" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(304' 88)' new PointF(336' 81)' new PointF(339' 86)' new PointF(339' 91)' new PointF(341' 94)' new PointF(339' 100)' new PointF(306' 106) }' new string[] { "pa" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(304' 88)' new PointF(336' 81)' new PointF(339' 86)' new PointF(339' 91)' new PointF(341' 94)' new PointF(339' 100)' new PointF(306' 106) }' new string[] { "pa" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(305' 107)' new PointF(312' 107)' new PointF(315' 109)' new PointF(320' 106)' new PointF(321' 107)' new PointF(310' 124)' new PointF(302' 127)' new PointF(300' 125)' new PointF(295' 119) }' new string[] { "wv" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(305' 107)' new PointF(312' 107)' new PointF(315' 109)' new PointF(320' 106)' new PointF(321' 107)' new PointF(310' 124)' new PointF(302' 127)' new PointF(300' 125)' new PointF(295' 119) }' new string[] { "wv" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(305' 107)' new PointF(312' 107)' new PointF(315' 109)' new PointF(320' 106)' new PointF(321' 107)' new PointF(310' 124)' new PointF(302' 127)' new PointF(300' 125)' new PointF(295' 119) }' new string[] { "wv" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(305' 107)' new PointF(312' 107)' new PointF(315' 109)' new PointF(320' 106)' new PointF(321' 107)' new PointF(310' 124)' new PointF(302' 127)' new PointF(300' 125)' new PointF(295' 119) }' new string[] { "wv" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(305' 107)' new PointF(312' 107)' new PointF(315' 109)' new PointF(320' 106)' new PointF(321' 107)' new PointF(310' 124)' new PointF(302' 127)' new PointF(300' 125)' new PointF(295' 119) }' new string[] { "wv" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(305' 107)' new PointF(312' 107)' new PointF(315' 109)' new PointF(320' 106)' new PointF(321' 107)' new PointF(310' 124)' new PointF(302' 127)' new PointF(300' 125)' new PointF(295' 119) }' new string[] { "wv" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(305' 107)' new PointF(312' 107)' new PointF(315' 109)' new PointF(320' 106)' new PointF(321' 107)' new PointF(310' 124)' new PointF(302' 127)' new PointF(300' 125)' new PointF(295' 119) }' new string[] { "wv" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(305' 107)' new PointF(312' 107)' new PointF(315' 109)' new PointF(320' 106)' new PointF(321' 107)' new PointF(310' 124)' new PointF(302' 127)' new PointF(300' 125)' new PointF(295' 119) }' new string[] { "wv" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(305' 107)' new PointF(312' 107)' new PointF(315' 109)' new PointF(320' 106)' new PointF(321' 107)' new PointF(310' 124)' new PointF(302' 127)' new PointF(300' 125)' new PointF(295' 119) }' new string[] { "wv" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(305' 107)' new PointF(312' 107)' new PointF(315' 109)' new PointF(320' 106)' new PointF(321' 107)' new PointF(310' 124)' new PointF(302' 127)' new PointF(300' 125)' new PointF(295' 119) }' new string[] { "wv" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(305' 107)' new PointF(312' 107)' new PointF(315' 109)' new PointF(320' 106)' new PointF(321' 107)' new PointF(310' 124)' new PointF(302' 127)' new PointF(300' 125)' new PointF(295' 119) }' new string[] { "wv" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(305' 107)' new PointF(312' 107)' new PointF(315' 109)' new PointF(320' 106)' new PointF(321' 107)' new PointF(310' 124)' new PointF(302' 127)' new PointF(300' 125)' new PointF(295' 119) }' new string[] { "wv" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(305' 107)' new PointF(312' 107)' new PointF(315' 109)' new PointF(320' 106)' new PointF(321' 107)' new PointF(310' 124)' new PointF(302' 127)' new PointF(300' 125)' new PointF(295' 119) }' new string[] { "wv" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(305' 107)' new PointF(312' 107)' new PointF(315' 109)' new PointF(320' 106)' new PointF(321' 107)' new PointF(310' 124)' new PointF(302' 127)' new PointF(300' 125)' new PointF(295' 119) }' new string[] { "wv" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(305' 107)' new PointF(312' 107)' new PointF(315' 109)' new PointF(320' 106)' new PointF(321' 107)' new PointF(310' 124)' new PointF(302' 127)' new PointF(300' 125)' new PointF(295' 119) }' new string[] { "wv" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(305' 107)' new PointF(312' 107)' new PointF(315' 109)' new PointF(320' 106)' new PointF(321' 107)' new PointF(310' 124)' new PointF(302' 127)' new PointF(300' 125)' new PointF(295' 119) }' new string[] { "wv" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(305' 107)' new PointF(312' 107)' new PointF(315' 109)' new PointF(320' 106)' new PointF(321' 107)' new PointF(310' 124)' new PointF(302' 127)' new PointF(300' 125)' new PointF(295' 119) }' new string[] { "wv" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(305' 107)' new PointF(312' 107)' new PointF(315' 109)' new PointF(320' 106)' new PointF(321' 107)' new PointF(310' 124)' new PointF(302' 127)' new PointF(300' 125)' new PointF(295' 119) }' new string[] { "wv" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(295' 136)' new PointF(338' 126)' new PointF(339' 119)' new PointF(328' 110)' new PointF(323' 107)' new PointF(316' 115)' new PointF(309' 126)' new PointF(302' 129)' new PointF(295' 132) }' new string[] { "va" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(295' 136)' new PointF(338' 126)' new PointF(339' 119)' new PointF(328' 110)' new PointF(323' 107)' new PointF(316' 115)' new PointF(309' 126)' new PointF(302' 129)' new PointF(295' 132) }' new string[] { "va" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(295' 136)' new PointF(338' 126)' new PointF(339' 119)' new PointF(328' 110)' new PointF(323' 107)' new PointF(316' 115)' new PointF(309' 126)' new PointF(302' 129)' new PointF(295' 132) }' new string[] { "va" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(295' 136)' new PointF(338' 126)' new PointF(339' 119)' new PointF(328' 110)' new PointF(323' 107)' new PointF(316' 115)' new PointF(309' 126)' new PointF(302' 129)' new PointF(295' 132) }' new string[] { "va" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(295' 136)' new PointF(338' 126)' new PointF(339' 119)' new PointF(328' 110)' new PointF(323' 107)' new PointF(316' 115)' new PointF(309' 126)' new PointF(302' 129)' new PointF(295' 132) }' new string[] { "va" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(295' 136)' new PointF(338' 126)' new PointF(339' 119)' new PointF(328' 110)' new PointF(323' 107)' new PointF(316' 115)' new PointF(309' 126)' new PointF(302' 129)' new PointF(295' 132) }' new string[] { "va" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(295' 136)' new PointF(338' 126)' new PointF(339' 119)' new PointF(328' 110)' new PointF(323' 107)' new PointF(316' 115)' new PointF(309' 126)' new PointF(302' 129)' new PointF(295' 132) }' new string[] { "va" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(295' 136)' new PointF(338' 126)' new PointF(339' 119)' new PointF(328' 110)' new PointF(323' 107)' new PointF(316' 115)' new PointF(309' 126)' new PointF(302' 129)' new PointF(295' 132) }' new string[] { "va" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(295' 136)' new PointF(338' 126)' new PointF(339' 119)' new PointF(328' 110)' new PointF(323' 107)' new PointF(316' 115)' new PointF(309' 126)' new PointF(302' 129)' new PointF(295' 132) }' new string[] { "va" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(295' 136)' new PointF(338' 126)' new PointF(339' 119)' new PointF(328' 110)' new PointF(323' 107)' new PointF(316' 115)' new PointF(309' 126)' new PointF(302' 129)' new PointF(295' 132) }' new string[] { "va" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(295' 136)' new PointF(338' 126)' new PointF(339' 119)' new PointF(328' 110)' new PointF(323' 107)' new PointF(316' 115)' new PointF(309' 126)' new PointF(302' 129)' new PointF(295' 132) }' new string[] { "va" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(295' 136)' new PointF(338' 126)' new PointF(339' 119)' new PointF(328' 110)' new PointF(323' 107)' new PointF(316' 115)' new PointF(309' 126)' new PointF(302' 129)' new PointF(295' 132) }' new string[] { "va" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(295' 136)' new PointF(338' 126)' new PointF(339' 119)' new PointF(328' 110)' new PointF(323' 107)' new PointF(316' 115)' new PointF(309' 126)' new PointF(302' 129)' new PointF(295' 132) }' new string[] { "va" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(295' 136)' new PointF(338' 126)' new PointF(339' 119)' new PointF(328' 110)' new PointF(323' 107)' new PointF(316' 115)' new PointF(309' 126)' new PointF(302' 129)' new PointF(295' 132) }' new string[] { "va" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(295' 136)' new PointF(338' 126)' new PointF(339' 119)' new PointF(328' 110)' new PointF(323' 107)' new PointF(316' 115)' new PointF(309' 126)' new PointF(302' 129)' new PointF(295' 132) }' new string[] { "va" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(295' 136)' new PointF(338' 126)' new PointF(339' 119)' new PointF(328' 110)' new PointF(323' 107)' new PointF(316' 115)' new PointF(309' 126)' new PointF(302' 129)' new PointF(295' 132) }' new string[] { "va" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(295' 136)' new PointF(338' 126)' new PointF(339' 119)' new PointF(328' 110)' new PointF(323' 107)' new PointF(316' 115)' new PointF(309' 126)' new PointF(302' 129)' new PointF(295' 132) }' new string[] { "va" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(295' 136)' new PointF(338' 126)' new PointF(339' 119)' new PointF(328' 110)' new PointF(323' 107)' new PointF(316' 115)' new PointF(309' 126)' new PointF(302' 129)' new PointF(295' 132) }' new string[] { "va" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(304' 135)' new PointF(334' 129)' new PointF(343' 131)' new PointF(345' 137)' new PointF(330' 152)' new PointF(319' 147)' new PointF(312' 146)' new PointF(305' 145)' new PointF(298' 147)' new PointF(289' 150) }' new string[] { "nc" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(304' 135)' new PointF(334' 129)' new PointF(343' 131)' new PointF(345' 137)' new PointF(330' 152)' new PointF(319' 147)' new PointF(312' 146)' new PointF(305' 145)' new PointF(298' 147)' new PointF(289' 150) }' new string[] { "nc" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(304' 135)' new PointF(334' 129)' new PointF(343' 131)' new PointF(345' 137)' new PointF(330' 152)' new PointF(319' 147)' new PointF(312' 146)' new PointF(305' 145)' new PointF(298' 147)' new PointF(289' 150) }' new string[] { "nc" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(304' 135)' new PointF(334' 129)' new PointF(343' 131)' new PointF(345' 137)' new PointF(330' 152)' new PointF(319' 147)' new PointF(312' 146)' new PointF(305' 145)' new PointF(298' 147)' new PointF(289' 150) }' new string[] { "nc" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(304' 135)' new PointF(334' 129)' new PointF(343' 131)' new PointF(345' 137)' new PointF(330' 152)' new PointF(319' 147)' new PointF(312' 146)' new PointF(305' 145)' new PointF(298' 147)' new PointF(289' 150) }' new string[] { "nc" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(304' 135)' new PointF(334' 129)' new PointF(343' 131)' new PointF(345' 137)' new PointF(330' 152)' new PointF(319' 147)' new PointF(312' 146)' new PointF(305' 145)' new PointF(298' 147)' new PointF(289' 150) }' new string[] { "nc" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(304' 135)' new PointF(334' 129)' new PointF(343' 131)' new PointF(345' 137)' new PointF(330' 152)' new PointF(319' 147)' new PointF(312' 146)' new PointF(305' 145)' new PointF(298' 147)' new PointF(289' 150) }' new string[] { "nc" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(304' 135)' new PointF(334' 129)' new PointF(343' 131)' new PointF(345' 137)' new PointF(330' 152)' new PointF(319' 147)' new PointF(312' 146)' new PointF(305' 145)' new PointF(298' 147)' new PointF(289' 150) }' new string[] { "nc" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(304' 135)' new PointF(334' 129)' new PointF(343' 131)' new PointF(345' 137)' new PointF(330' 152)' new PointF(319' 147)' new PointF(312' 146)' new PointF(305' 145)' new PointF(298' 147)' new PointF(289' 150) }' new string[] { "nc" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(304' 135)' new PointF(334' 129)' new PointF(343' 131)' new PointF(345' 137)' new PointF(330' 152)' new PointF(319' 147)' new PointF(312' 146)' new PointF(305' 145)' new PointF(298' 147)' new PointF(289' 150) }' new string[] { "nc" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(304' 135)' new PointF(334' 129)' new PointF(343' 131)' new PointF(345' 137)' new PointF(330' 152)' new PointF(319' 147)' new PointF(312' 146)' new PointF(305' 145)' new PointF(298' 147)' new PointF(289' 150) }' new string[] { "nc" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(304' 135)' new PointF(334' 129)' new PointF(343' 131)' new PointF(345' 137)' new PointF(330' 152)' new PointF(319' 147)' new PointF(312' 146)' new PointF(305' 145)' new PointF(298' 147)' new PointF(289' 150) }' new string[] { "nc" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(304' 135)' new PointF(334' 129)' new PointF(343' 131)' new PointF(345' 137)' new PointF(330' 152)' new PointF(319' 147)' new PointF(312' 146)' new PointF(305' 145)' new PointF(298' 147)' new PointF(289' 150) }' new string[] { "nc" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(304' 135)' new PointF(334' 129)' new PointF(343' 131)' new PointF(345' 137)' new PointF(330' 152)' new PointF(319' 147)' new PointF(312' 146)' new PointF(305' 145)' new PointF(298' 147)' new PointF(289' 150) }' new string[] { "nc" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(304' 135)' new PointF(334' 129)' new PointF(343' 131)' new PointF(345' 137)' new PointF(330' 152)' new PointF(319' 147)' new PointF(312' 146)' new PointF(305' 145)' new PointF(298' 147)' new PointF(289' 150) }' new string[] { "nc" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(304' 135)' new PointF(334' 129)' new PointF(343' 131)' new PointF(345' 137)' new PointF(330' 152)' new PointF(319' 147)' new PointF(312' 146)' new PointF(305' 145)' new PointF(298' 147)' new PointF(289' 150) }' new string[] { "nc" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(304' 135)' new PointF(334' 129)' new PointF(343' 131)' new PointF(345' 137)' new PointF(330' 152)' new PointF(319' 147)' new PointF(312' 146)' new PointF(305' 145)' new PointF(298' 147)' new PointF(289' 150) }' new string[] { "nc" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(304' 135)' new PointF(334' 129)' new PointF(343' 131)' new PointF(345' 137)' new PointF(330' 152)' new PointF(319' 147)' new PointF(312' 146)' new PointF(305' 145)' new PointF(298' 147)' new PointF(289' 150) }' new string[] { "nc" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(304' 135)' new PointF(334' 129)' new PointF(343' 131)' new PointF(345' 137)' new PointF(330' 152)' new PointF(319' 147)' new PointF(312' 146)' new PointF(305' 145)' new PointF(298' 147)' new PointF(289' 150) }' new string[] { "nc" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(304' 135)' new PointF(334' 129)' new PointF(343' 131)' new PointF(345' 137)' new PointF(330' 152)' new PointF(319' 147)' new PointF(312' 146)' new PointF(305' 145)' new PointF(298' 147)' new PointF(289' 150) }' new string[] { "nc" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(296' 150)' new PointF(303' 147)' new PointF(310' 146)' new PointF(312' 148)' new PointF(319' 148)' new PointF(328' 154)' new PointF(315' 170) }' new string[] { "sc" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(296' 150)' new PointF(303' 147)' new PointF(310' 146)' new PointF(312' 148)' new PointF(319' 148)' new PointF(328' 154)' new PointF(315' 170) }' new string[] { "sc" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(296' 150)' new PointF(303' 147)' new PointF(310' 146)' new PointF(312' 148)' new PointF(319' 148)' new PointF(328' 154)' new PointF(315' 170) }' new string[] { "sc" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(296' 150)' new PointF(303' 147)' new PointF(310' 146)' new PointF(312' 148)' new PointF(319' 148)' new PointF(328' 154)' new PointF(315' 170) }' new string[] { "sc" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(296' 150)' new PointF(303' 147)' new PointF(310' 146)' new PointF(312' 148)' new PointF(319' 148)' new PointF(328' 154)' new PointF(315' 170) }' new string[] { "sc" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(296' 150)' new PointF(303' 147)' new PointF(310' 146)' new PointF(312' 148)' new PointF(319' 148)' new PointF(328' 154)' new PointF(315' 170) }' new string[] { "sc" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(296' 150)' new PointF(303' 147)' new PointF(310' 146)' new PointF(312' 148)' new PointF(319' 148)' new PointF(328' 154)' new PointF(315' 170) }' new string[] { "sc" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(296' 150)' new PointF(303' 147)' new PointF(310' 146)' new PointF(312' 148)' new PointF(319' 148)' new PointF(328' 154)' new PointF(315' 170) }' new string[] { "sc" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(296' 150)' new PointF(303' 147)' new PointF(310' 146)' new PointF(312' 148)' new PointF(319' 148)' new PointF(328' 154)' new PointF(315' 170) }' new string[] { "sc" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(296' 150)' new PointF(303' 147)' new PointF(310' 146)' new PointF(312' 148)' new PointF(319' 148)' new PointF(328' 154)' new PointF(315' 170) }' new string[] { "sc" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(296' 150)' new PointF(303' 147)' new PointF(310' 146)' new PointF(312' 148)' new PointF(319' 148)' new PointF(328' 154)' new PointF(315' 170) }' new string[] { "sc" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(296' 150)' new PointF(303' 147)' new PointF(310' 146)' new PointF(312' 148)' new PointF(319' 148)' new PointF(328' 154)' new PointF(315' 170) }' new string[] { "sc" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(296' 150)' new PointF(303' 147)' new PointF(310' 146)' new PointF(312' 148)' new PointF(319' 148)' new PointF(328' 154)' new PointF(315' 170) }' new string[] { "sc" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(296' 150)' new PointF(303' 147)' new PointF(310' 146)' new PointF(312' 148)' new PointF(319' 148)' new PointF(328' 154)' new PointF(315' 170) }' new string[] { "sc" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(280' 94)' new PointF(287' 93)' new PointF(290' 94)' new PointF(303' 88)' new PointF(305' 105)' new PointF(295' 119)' new PointF(281' 115)' new PointF(277' 94)' new PointF(283' 93) }' new string[] { "oh" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(280' 94)' new PointF(287' 93)' new PointF(290' 94)' new PointF(303' 88)' new PointF(305' 105)' new PointF(295' 119)' new PointF(281' 115)' new PointF(277' 94)' new PointF(283' 93) }' new string[] { "oh" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(280' 94)' new PointF(287' 93)' new PointF(290' 94)' new PointF(303' 88)' new PointF(305' 105)' new PointF(295' 119)' new PointF(281' 115)' new PointF(277' 94)' new PointF(283' 93) }' new string[] { "oh" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(280' 94)' new PointF(287' 93)' new PointF(290' 94)' new PointF(303' 88)' new PointF(305' 105)' new PointF(295' 119)' new PointF(281' 115)' new PointF(277' 94)' new PointF(283' 93) }' new string[] { "oh" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(280' 94)' new PointF(287' 93)' new PointF(290' 94)' new PointF(303' 88)' new PointF(305' 105)' new PointF(295' 119)' new PointF(281' 115)' new PointF(277' 94)' new PointF(283' 93) }' new string[] { "oh" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(280' 94)' new PointF(287' 93)' new PointF(290' 94)' new PointF(303' 88)' new PointF(305' 105)' new PointF(295' 119)' new PointF(281' 115)' new PointF(277' 94)' new PointF(283' 93) }' new string[] { "oh" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(280' 94)' new PointF(287' 93)' new PointF(290' 94)' new PointF(303' 88)' new PointF(305' 105)' new PointF(295' 119)' new PointF(281' 115)' new PointF(277' 94)' new PointF(283' 93) }' new string[] { "oh" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(280' 94)' new PointF(287' 93)' new PointF(290' 94)' new PointF(303' 88)' new PointF(305' 105)' new PointF(295' 119)' new PointF(281' 115)' new PointF(277' 94)' new PointF(283' 93) }' new string[] { "oh" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(280' 94)' new PointF(287' 93)' new PointF(290' 94)' new PointF(303' 88)' new PointF(305' 105)' new PointF(295' 119)' new PointF(281' 115)' new PointF(277' 94)' new PointF(283' 93) }' new string[] { "oh" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(280' 94)' new PointF(287' 93)' new PointF(290' 94)' new PointF(303' 88)' new PointF(305' 105)' new PointF(295' 119)' new PointF(281' 115)' new PointF(277' 94)' new PointF(283' 93) }' new string[] { "oh" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(280' 94)' new PointF(287' 93)' new PointF(290' 94)' new PointF(303' 88)' new PointF(305' 105)' new PointF(295' 119)' new PointF(281' 115)' new PointF(277' 94)' new PointF(283' 93) }' new string[] { "oh" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(280' 94)' new PointF(287' 93)' new PointF(290' 94)' new PointF(303' 88)' new PointF(305' 105)' new PointF(295' 119)' new PointF(281' 115)' new PointF(277' 94)' new PointF(283' 93) }' new string[] { "oh" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(280' 94)' new PointF(287' 93)' new PointF(290' 94)' new PointF(303' 88)' new PointF(305' 105)' new PointF(295' 119)' new PointF(281' 115)' new PointF(277' 94)' new PointF(283' 93) }' new string[] { "oh" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(280' 94)' new PointF(287' 93)' new PointF(290' 94)' new PointF(303' 88)' new PointF(305' 105)' new PointF(295' 119)' new PointF(281' 115)' new PointF(277' 94)' new PointF(283' 93) }' new string[] { "oh" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(280' 94)' new PointF(287' 93)' new PointF(290' 94)' new PointF(303' 88)' new PointF(305' 105)' new PointF(295' 119)' new PointF(281' 115)' new PointF(277' 94)' new PointF(283' 93) }' new string[] { "oh" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(280' 94)' new PointF(287' 93)' new PointF(290' 94)' new PointF(303' 88)' new PointF(305' 105)' new PointF(295' 119)' new PointF(281' 115)' new PointF(277' 94)' new PointF(283' 93) }' new string[] { "oh" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(280' 94)' new PointF(287' 93)' new PointF(290' 94)' new PointF(303' 88)' new PointF(305' 105)' new PointF(295' 119)' new PointF(281' 115)' new PointF(277' 94)' new PointF(283' 93) }' new string[] { "oh" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(280' 94)' new PointF(287' 93)' new PointF(290' 94)' new PointF(303' 88)' new PointF(305' 105)' new PointF(295' 119)' new PointF(281' 115)' new PointF(277' 94)' new PointF(283' 93) }' new string[] { "oh" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(267' 188)' new PointF(313' 188)' new PointF(331' 219)' new PointF(328' 230)' new PointF(321' 231)' new PointF(313' 219)' new PointF(305' 201)' new PointF(295' 192)' new PointF(283' 195)' new PointF(280' 192)' new PointF(270' 191) }' new string[] { "fl" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(267' 188)' new PointF(313' 188)' new PointF(331' 219)' new PointF(328' 230)' new PointF(321' 231)' new PointF(313' 219)' new PointF(305' 201)' new PointF(295' 192)' new PointF(283' 195)' new PointF(280' 192)' new PointF(270' 191) }' new string[] { "fl" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(267' 188)' new PointF(313' 188)' new PointF(331' 219)' new PointF(328' 230)' new PointF(321' 231)' new PointF(313' 219)' new PointF(305' 201)' new PointF(295' 192)' new PointF(283' 195)' new PointF(280' 192)' new PointF(270' 191) }' new string[] { "fl" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(267' 188)' new PointF(313' 188)' new PointF(331' 219)' new PointF(328' 230)' new PointF(321' 231)' new PointF(313' 219)' new PointF(305' 201)' new PointF(295' 192)' new PointF(283' 195)' new PointF(280' 192)' new PointF(270' 191) }' new string[] { "fl" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(267' 188)' new PointF(313' 188)' new PointF(331' 219)' new PointF(328' 230)' new PointF(321' 231)' new PointF(313' 219)' new PointF(305' 201)' new PointF(295' 192)' new PointF(283' 195)' new PointF(280' 192)' new PointF(270' 191) }' new string[] { "fl" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(267' 188)' new PointF(313' 188)' new PointF(331' 219)' new PointF(328' 230)' new PointF(321' 231)' new PointF(313' 219)' new PointF(305' 201)' new PointF(295' 192)' new PointF(283' 195)' new PointF(280' 192)' new PointF(270' 191) }' new string[] { "fl" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(267' 188)' new PointF(313' 188)' new PointF(331' 219)' new PointF(328' 230)' new PointF(321' 231)' new PointF(313' 219)' new PointF(305' 201)' new PointF(295' 192)' new PointF(283' 195)' new PointF(280' 192)' new PointF(270' 191) }' new string[] { "fl" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(267' 188)' new PointF(313' 188)' new PointF(331' 219)' new PointF(328' 230)' new PointF(321' 231)' new PointF(313' 219)' new PointF(305' 201)' new PointF(295' 192)' new PointF(283' 195)' new PointF(280' 192)' new PointF(270' 191) }' new string[] { "fl" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(267' 188)' new PointF(313' 188)' new PointF(331' 219)' new PointF(328' 230)' new PointF(321' 231)' new PointF(313' 219)' new PointF(305' 201)' new PointF(295' 192)' new PointF(283' 195)' new PointF(280' 192)' new PointF(270' 191) }' new string[] { "fl" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(267' 188)' new PointF(313' 188)' new PointF(331' 219)' new PointF(328' 230)' new PointF(321' 231)' new PointF(313' 219)' new PointF(305' 201)' new PointF(295' 192)' new PointF(283' 195)' new PointF(280' 192)' new PointF(270' 191) }' new string[] { "fl" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(267' 188)' new PointF(313' 188)' new PointF(331' 219)' new PointF(328' 230)' new PointF(321' 231)' new PointF(313' 219)' new PointF(305' 201)' new PointF(295' 192)' new PointF(283' 195)' new PointF(280' 192)' new PointF(270' 191) }' new string[] { "fl" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(267' 188)' new PointF(313' 188)' new PointF(331' 219)' new PointF(328' 230)' new PointF(321' 231)' new PointF(313' 219)' new PointF(305' 201)' new PointF(295' 192)' new PointF(283' 195)' new PointF(280' 192)' new PointF(270' 191) }' new string[] { "fl" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(267' 188)' new PointF(313' 188)' new PointF(331' 219)' new PointF(328' 230)' new PointF(321' 231)' new PointF(313' 219)' new PointF(305' 201)' new PointF(295' 192)' new PointF(283' 195)' new PointF(280' 192)' new PointF(270' 191) }' new string[] { "fl" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(267' 188)' new PointF(313' 188)' new PointF(331' 219)' new PointF(328' 230)' new PointF(321' 231)' new PointF(313' 219)' new PointF(305' 201)' new PointF(295' 192)' new PointF(283' 195)' new PointF(280' 192)' new PointF(270' 191) }' new string[] { "fl" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(267' 188)' new PointF(313' 188)' new PointF(331' 219)' new PointF(328' 230)' new PointF(321' 231)' new PointF(313' 219)' new PointF(305' 201)' new PointF(295' 192)' new PointF(283' 195)' new PointF(280' 192)' new PointF(270' 191) }' new string[] { "fl" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(267' 188)' new PointF(313' 188)' new PointF(331' 219)' new PointF(328' 230)' new PointF(321' 231)' new PointF(313' 219)' new PointF(305' 201)' new PointF(295' 192)' new PointF(283' 195)' new PointF(280' 192)' new PointF(270' 191) }' new string[] { "fl" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(267' 188)' new PointF(313' 188)' new PointF(331' 219)' new PointF(328' 230)' new PointF(321' 231)' new PointF(313' 219)' new PointF(305' 201)' new PointF(295' 192)' new PointF(283' 195)' new PointF(280' 192)' new PointF(270' 191) }' new string[] { "fl" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(267' 188)' new PointF(313' 188)' new PointF(331' 219)' new PointF(328' 230)' new PointF(321' 231)' new PointF(313' 219)' new PointF(305' 201)' new PointF(295' 192)' new PointF(283' 195)' new PointF(280' 192)' new PointF(270' 191) }' new string[] { "fl" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(267' 188)' new PointF(313' 188)' new PointF(331' 219)' new PointF(328' 230)' new PointF(321' 231)' new PointF(313' 219)' new PointF(305' 201)' new PointF(295' 192)' new PointF(283' 195)' new PointF(280' 192)' new PointF(270' 191) }' new string[] { "fl" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(267' 188)' new PointF(313' 188)' new PointF(331' 219)' new PointF(328' 230)' new PointF(321' 231)' new PointF(313' 219)' new PointF(305' 201)' new PointF(295' 192)' new PointF(283' 195)' new PointF(280' 192)' new PointF(270' 191) }' new string[] { "fl" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(267' 188)' new PointF(313' 188)' new PointF(331' 219)' new PointF(328' 230)' new PointF(321' 231)' new PointF(313' 219)' new PointF(305' 201)' new PointF(295' 192)' new PointF(283' 195)' new PointF(280' 192)' new PointF(270' 191) }' new string[] { "fl" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(267' 188)' new PointF(313' 188)' new PointF(331' 219)' new PointF(328' 230)' new PointF(321' 231)' new PointF(313' 219)' new PointF(305' 201)' new PointF(295' 192)' new PointF(283' 195)' new PointF(280' 192)' new PointF(270' 191) }' new string[] { "fl" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(279' 152)' new PointF(294' 150)' new PointF(313' 170)' new PointF(311' 186)' new PointF(307' 186)' new PointF(287' 183) }' new string[] { "ga" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(279' 152)' new PointF(294' 150)' new PointF(313' 170)' new PointF(311' 186)' new PointF(307' 186)' new PointF(287' 183) }' new string[] { "ga" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(279' 152)' new PointF(294' 150)' new PointF(313' 170)' new PointF(311' 186)' new PointF(307' 186)' new PointF(287' 183) }' new string[] { "ga" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(279' 152)' new PointF(294' 150)' new PointF(313' 170)' new PointF(311' 186)' new PointF(307' 186)' new PointF(287' 183) }' new string[] { "ga" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(279' 152)' new PointF(294' 150)' new PointF(313' 170)' new PointF(311' 186)' new PointF(307' 186)' new PointF(287' 183) }' new string[] { "ga" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(279' 152)' new PointF(294' 150)' new PointF(313' 170)' new PointF(311' 186)' new PointF(307' 186)' new PointF(287' 183) }' new string[] { "ga" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(279' 152)' new PointF(294' 150)' new PointF(313' 170)' new PointF(311' 186)' new PointF(307' 186)' new PointF(287' 183) }' new string[] { "ga" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(279' 152)' new PointF(294' 150)' new PointF(313' 170)' new PointF(311' 186)' new PointF(307' 186)' new PointF(287' 183) }' new string[] { "ga" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(279' 152)' new PointF(294' 150)' new PointF(313' 170)' new PointF(311' 186)' new PointF(307' 186)' new PointF(287' 183) }' new string[] { "ga" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(279' 152)' new PointF(294' 150)' new PointF(313' 170)' new PointF(311' 186)' new PointF(307' 186)' new PointF(287' 183) }' new string[] { "ga" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(279' 152)' new PointF(294' 150)' new PointF(313' 170)' new PointF(311' 186)' new PointF(307' 186)' new PointF(287' 183) }' new string[] { "ga" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(279' 152)' new PointF(294' 150)' new PointF(313' 170)' new PointF(311' 186)' new PointF(307' 186)' new PointF(287' 183) }' new string[] { "ga" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(261' 154)' new PointF(277' 152)' new PointF(285' 185)' new PointF(267' 187)' new PointF(269' 192)' new PointF(263' 192) }' new string[] { "al" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(261' 154)' new PointF(277' 152)' new PointF(285' 185)' new PointF(267' 187)' new PointF(269' 192)' new PointF(263' 192) }' new string[] { "al" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(261' 154)' new PointF(277' 152)' new PointF(285' 185)' new PointF(267' 187)' new PointF(269' 192)' new PointF(263' 192) }' new string[] { "al" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(261' 154)' new PointF(277' 152)' new PointF(285' 185)' new PointF(267' 187)' new PointF(269' 192)' new PointF(263' 192) }' new string[] { "al" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(261' 154)' new PointF(277' 152)' new PointF(285' 185)' new PointF(267' 187)' new PointF(269' 192)' new PointF(263' 192) }' new string[] { "al" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(261' 154)' new PointF(277' 152)' new PointF(285' 185)' new PointF(267' 187)' new PointF(269' 192)' new PointF(263' 192) }' new string[] { "al" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(261' 154)' new PointF(277' 152)' new PointF(285' 185)' new PointF(267' 187)' new PointF(269' 192)' new PointF(263' 192) }' new string[] { "al" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(261' 154)' new PointF(277' 152)' new PointF(285' 185)' new PointF(267' 187)' new PointF(269' 192)' new PointF(263' 192) }' new string[] { "al" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(261' 154)' new PointF(277' 152)' new PointF(285' 185)' new PointF(267' 187)' new PointF(269' 192)' new PointF(263' 192) }' new string[] { "al" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(261' 154)' new PointF(277' 152)' new PointF(285' 185)' new PointF(267' 187)' new PointF(269' 192)' new PointF(263' 192) }' new string[] { "al" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(261' 154)' new PointF(277' 152)' new PointF(285' 185)' new PointF(267' 187)' new PointF(269' 192)' new PointF(263' 192) }' new string[] { "al" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(261' 154)' new PointF(277' 152)' new PointF(285' 185)' new PointF(267' 187)' new PointF(269' 192)' new PointF(263' 192) }' new string[] { "al" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(246' 156)' new PointF(260' 155)' new PointF(260' 191)' new PointF(251' 192)' new PointF(250' 188)' new PointF(237' 187)' new PointF(242' 175)' new PointF(240' 169) }' new string[] { "ms" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(246' 156)' new PointF(260' 155)' new PointF(260' 191)' new PointF(251' 192)' new PointF(250' 188)' new PointF(237' 187)' new PointF(242' 175)' new PointF(240' 169) }' new string[] { "ms" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(246' 156)' new PointF(260' 155)' new PointF(260' 191)' new PointF(251' 192)' new PointF(250' 188)' new PointF(237' 187)' new PointF(242' 175)' new PointF(240' 169) }' new string[] { "ms" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(246' 156)' new PointF(260' 155)' new PointF(260' 191)' new PointF(251' 192)' new PointF(250' 188)' new PointF(237' 187)' new PointF(242' 175)' new PointF(240' 169) }' new string[] { "ms" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(246' 156)' new PointF(260' 155)' new PointF(260' 191)' new PointF(251' 192)' new PointF(250' 188)' new PointF(237' 187)' new PointF(242' 175)' new PointF(240' 169) }' new string[] { "ms" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(246' 156)' new PointF(260' 155)' new PointF(260' 191)' new PointF(251' 192)' new PointF(250' 188)' new PointF(237' 187)' new PointF(242' 175)' new PointF(240' 169) }' new string[] { "ms" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(246' 156)' new PointF(260' 155)' new PointF(260' 191)' new PointF(251' 192)' new PointF(250' 188)' new PointF(237' 187)' new PointF(242' 175)' new PointF(240' 169) }' new string[] { "ms" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(246' 156)' new PointF(260' 155)' new PointF(260' 191)' new PointF(251' 192)' new PointF(250' 188)' new PointF(237' 187)' new PointF(242' 175)' new PointF(240' 169) }' new string[] { "ms" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(246' 156)' new PointF(260' 155)' new PointF(260' 191)' new PointF(251' 192)' new PointF(250' 188)' new PointF(237' 187)' new PointF(242' 175)' new PointF(240' 169) }' new string[] { "ms" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(246' 156)' new PointF(260' 155)' new PointF(260' 191)' new PointF(251' 192)' new PointF(250' 188)' new PointF(237' 187)' new PointF(242' 175)' new PointF(240' 169) }' new string[] { "ms" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(246' 156)' new PointF(260' 155)' new PointF(260' 191)' new PointF(251' 192)' new PointF(250' 188)' new PointF(237' 187)' new PointF(242' 175)' new PointF(240' 169) }' new string[] { "ms" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(246' 156)' new PointF(260' 155)' new PointF(260' 191)' new PointF(251' 192)' new PointF(250' 188)' new PointF(237' 187)' new PointF(242' 175)' new PointF(240' 169) }' new string[] { "ms" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(246' 156)' new PointF(260' 155)' new PointF(260' 191)' new PointF(251' 192)' new PointF(250' 188)' new PointF(237' 187)' new PointF(242' 175)' new PointF(240' 169) }' new string[] { "ms" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(246' 156)' new PointF(260' 155)' new PointF(260' 191)' new PointF(251' 192)' new PointF(250' 188)' new PointF(237' 187)' new PointF(242' 175)' new PointF(240' 169) }' new string[] { "ms" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(246' 156)' new PointF(260' 155)' new PointF(260' 191)' new PointF(251' 192)' new PointF(250' 188)' new PointF(237' 187)' new PointF(242' 175)' new PointF(240' 169) }' new string[] { "ms" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(246' 156)' new PointF(260' 155)' new PointF(260' 191)' new PointF(251' 192)' new PointF(250' 188)' new PointF(237' 187)' new PointF(242' 175)' new PointF(240' 169) }' new string[] { "ms" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(250' 143)' new PointF(302' 135)' new PointF(286' 150)' new PointF(246' 155) }' new string[] { "tn" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(250' 143)' new PointF(302' 135)' new PointF(286' 150)' new PointF(246' 155) }' new string[] { "tn" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(250' 143)' new PointF(302' 135)' new PointF(286' 150)' new PointF(246' 155) }' new string[] { "tn" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(250' 143)' new PointF(302' 135)' new PointF(286' 150)' new PointF(246' 155) }' new string[] { "tn" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(250' 143)' new PointF(302' 135)' new PointF(286' 150)' new PointF(246' 155) }' new string[] { "tn" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(250' 143)' new PointF(302' 135)' new PointF(286' 150)' new PointF(246' 155) }' new string[] { "tn" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(250' 143)' new PointF(302' 135)' new PointF(286' 150)' new PointF(246' 155) }' new string[] { "tn" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(250' 143)' new PointF(302' 135)' new PointF(286' 150)' new PointF(246' 155) }' new string[] { "tn" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(250' 140)' new PointF(291' 135)' new PointF(298' 126)' new PointF(295' 120)' new PointF(279' 116)' new PointF(271' 126)' new PointF(262' 129) }' new string[] { "ky" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(250' 140)' new PointF(291' 135)' new PointF(298' 126)' new PointF(295' 120)' new PointF(279' 116)' new PointF(271' 126)' new PointF(262' 129) }' new string[] { "ky" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(250' 140)' new PointF(291' 135)' new PointF(298' 126)' new PointF(295' 120)' new PointF(279' 116)' new PointF(271' 126)' new PointF(262' 129) }' new string[] { "ky" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(250' 140)' new PointF(291' 135)' new PointF(298' 126)' new PointF(295' 120)' new PointF(279' 116)' new PointF(271' 126)' new PointF(262' 129) }' new string[] { "ky" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(250' 140)' new PointF(291' 135)' new PointF(298' 126)' new PointF(295' 120)' new PointF(279' 116)' new PointF(271' 126)' new PointF(262' 129) }' new string[] { "ky" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(250' 140)' new PointF(291' 135)' new PointF(298' 126)' new PointF(295' 120)' new PointF(279' 116)' new PointF(271' 126)' new PointF(262' 129) }' new string[] { "ky" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(250' 140)' new PointF(291' 135)' new PointF(298' 126)' new PointF(295' 120)' new PointF(279' 116)' new PointF(271' 126)' new PointF(262' 129) }' new string[] { "ky" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(250' 140)' new PointF(291' 135)' new PointF(298' 126)' new PointF(295' 120)' new PointF(279' 116)' new PointF(271' 126)' new PointF(262' 129) }' new string[] { "ky" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(250' 140)' new PointF(291' 135)' new PointF(298' 126)' new PointF(295' 120)' new PointF(279' 116)' new PointF(271' 126)' new PointF(262' 129) }' new string[] { "ky" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(250' 140)' new PointF(291' 135)' new PointF(298' 126)' new PointF(295' 120)' new PointF(279' 116)' new PointF(271' 126)' new PointF(262' 129) }' new string[] { "ky" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(250' 140)' new PointF(291' 135)' new PointF(298' 126)' new PointF(295' 120)' new PointF(279' 116)' new PointF(271' 126)' new PointF(262' 129) }' new string[] { "ky" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(250' 140)' new PointF(291' 135)' new PointF(298' 126)' new PointF(295' 120)' new PointF(279' 116)' new PointF(271' 126)' new PointF(262' 129) }' new string[] { "ky" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(250' 140)' new PointF(291' 135)' new PointF(298' 126)' new PointF(295' 120)' new PointF(279' 116)' new PointF(271' 126)' new PointF(262' 129) }' new string[] { "ky" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(250' 140)' new PointF(291' 135)' new PointF(298' 126)' new PointF(295' 120)' new PointF(279' 116)' new PointF(271' 126)' new PointF(262' 129) }' new string[] { "ky" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(260' 96)' new PointF(275' 95)' new PointF(278' 118)' new PointF(259' 129) }' new string[] { "in" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(260' 96)' new PointF(275' 95)' new PointF(278' 118)' new PointF(259' 129) }' new string[] { "in" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(260' 96)' new PointF(275' 95)' new PointF(278' 118)' new PointF(259' 129) }' new string[] { "in" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(260' 96)' new PointF(275' 95)' new PointF(278' 118)' new PointF(259' 129) }' new string[] { "in" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(260' 96)' new PointF(275' 95)' new PointF(278' 118)' new PointF(259' 129) }' new string[] { "in" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(260' 96)' new PointF(275' 95)' new PointF(278' 118)' new PointF(259' 129) }' new string[] { "in" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(260' 96)' new PointF(275' 95)' new PointF(278' 118)' new PointF(259' 129) }' new string[] { "in" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(260' 96)' new PointF(275' 95)' new PointF(278' 118)' new PointF(259' 129) }' new string[] { "in" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(240' 91)' new PointF(257' 91)' new PointF(258' 97)' new PointF(258' 127)' new PointF(252' 136)' new PointF(235' 110) }' new string[] { "il" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(240' 91)' new PointF(257' 91)' new PointF(258' 97)' new PointF(258' 127)' new PointF(252' 136)' new PointF(235' 110) }' new string[] { "il" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(240' 91)' new PointF(257' 91)' new PointF(258' 97)' new PointF(258' 127)' new PointF(252' 136)' new PointF(235' 110) }' new string[] { "il" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(240' 91)' new PointF(257' 91)' new PointF(258' 97)' new PointF(258' 127)' new PointF(252' 136)' new PointF(235' 110) }' new string[] { "il" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(240' 91)' new PointF(257' 91)' new PointF(258' 97)' new PointF(258' 127)' new PointF(252' 136)' new PointF(235' 110) }' new string[] { "il" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(240' 91)' new PointF(257' 91)' new PointF(258' 97)' new PointF(258' 127)' new PointF(252' 136)' new PointF(235' 110) }' new string[] { "il" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(240' 91)' new PointF(257' 91)' new PointF(258' 97)' new PointF(258' 127)' new PointF(252' 136)' new PointF(235' 110) }' new string[] { "il" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(240' 91)' new PointF(257' 91)' new PointF(258' 97)' new PointF(258' 127)' new PointF(252' 136)' new PointF(235' 110) }' new string[] { "il" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(240' 91)' new PointF(257' 91)' new PointF(258' 97)' new PointF(258' 127)' new PointF(252' 136)' new PointF(235' 110) }' new string[] { "il" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(240' 91)' new PointF(257' 91)' new PointF(258' 97)' new PointF(258' 127)' new PointF(252' 136)' new PointF(235' 110) }' new string[] { "il" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(240' 91)' new PointF(257' 91)' new PointF(258' 97)' new PointF(258' 127)' new PointF(252' 136)' new PointF(235' 110) }' new string[] { "il" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(240' 91)' new PointF(257' 91)' new PointF(258' 97)' new PointF(258' 127)' new PointF(252' 136)' new PointF(235' 110) }' new string[] { "il" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(239' 56)' new PointF(251' 48)' new PointF(258' 53)' new PointF(269' 53)' new PointF(276' 56)' new PointF(280' 61)' new PointF(281' 77)' new PointF(287' 75)' new PointF(288' 83)' new PointF(284' 91)' new PointF(264' 94)' new PointF(268' 85)' new PointF(265' 73)' new PointF(269' 67)' new PointF(272' 60)' new PointF(272' 57)' new PointF(260' 60)' new PointF(256' 64) }' new string[] { "mi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(239' 56)' new PointF(251' 48)' new PointF(258' 53)' new PointF(269' 53)' new PointF(276' 56)' new PointF(280' 61)' new PointF(281' 77)' new PointF(287' 75)' new PointF(288' 83)' new PointF(284' 91)' new PointF(264' 94)' new PointF(268' 85)' new PointF(265' 73)' new PointF(269' 67)' new PointF(272' 60)' new PointF(272' 57)' new PointF(260' 60)' new PointF(256' 64) }' new string[] { "mi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(239' 56)' new PointF(251' 48)' new PointF(258' 53)' new PointF(269' 53)' new PointF(276' 56)' new PointF(280' 61)' new PointF(281' 77)' new PointF(287' 75)' new PointF(288' 83)' new PointF(284' 91)' new PointF(264' 94)' new PointF(268' 85)' new PointF(265' 73)' new PointF(269' 67)' new PointF(272' 60)' new PointF(272' 57)' new PointF(260' 60)' new PointF(256' 64) }' new string[] { "mi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(239' 56)' new PointF(251' 48)' new PointF(258' 53)' new PointF(269' 53)' new PointF(276' 56)' new PointF(280' 61)' new PointF(281' 77)' new PointF(287' 75)' new PointF(288' 83)' new PointF(284' 91)' new PointF(264' 94)' new PointF(268' 85)' new PointF(265' 73)' new PointF(269' 67)' new PointF(272' 60)' new PointF(272' 57)' new PointF(260' 60)' new PointF(256' 64) }' new string[] { "mi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(239' 56)' new PointF(251' 48)' new PointF(258' 53)' new PointF(269' 53)' new PointF(276' 56)' new PointF(280' 61)' new PointF(281' 77)' new PointF(287' 75)' new PointF(288' 83)' new PointF(284' 91)' new PointF(264' 94)' new PointF(268' 85)' new PointF(265' 73)' new PointF(269' 67)' new PointF(272' 60)' new PointF(272' 57)' new PointF(260' 60)' new PointF(256' 64) }' new string[] { "mi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(239' 56)' new PointF(251' 48)' new PointF(258' 53)' new PointF(269' 53)' new PointF(276' 56)' new PointF(280' 61)' new PointF(281' 77)' new PointF(287' 75)' new PointF(288' 83)' new PointF(284' 91)' new PointF(264' 94)' new PointF(268' 85)' new PointF(265' 73)' new PointF(269' 67)' new PointF(272' 60)' new PointF(272' 57)' new PointF(260' 60)' new PointF(256' 64) }' new string[] { "mi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(239' 56)' new PointF(251' 48)' new PointF(258' 53)' new PointF(269' 53)' new PointF(276' 56)' new PointF(280' 61)' new PointF(281' 77)' new PointF(287' 75)' new PointF(288' 83)' new PointF(284' 91)' new PointF(264' 94)' new PointF(268' 85)' new PointF(265' 73)' new PointF(269' 67)' new PointF(272' 60)' new PointF(272' 57)' new PointF(260' 60)' new PointF(256' 64) }' new string[] { "mi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(239' 56)' new PointF(251' 48)' new PointF(258' 53)' new PointF(269' 53)' new PointF(276' 56)' new PointF(280' 61)' new PointF(281' 77)' new PointF(287' 75)' new PointF(288' 83)' new PointF(284' 91)' new PointF(264' 94)' new PointF(268' 85)' new PointF(265' 73)' new PointF(269' 67)' new PointF(272' 60)' new PointF(272' 57)' new PointF(260' 60)' new PointF(256' 64) }' new string[] { "mi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(239' 56)' new PointF(251' 48)' new PointF(258' 53)' new PointF(269' 53)' new PointF(276' 56)' new PointF(280' 61)' new PointF(281' 77)' new PointF(287' 75)' new PointF(288' 83)' new PointF(284' 91)' new PointF(264' 94)' new PointF(268' 85)' new PointF(265' 73)' new PointF(269' 67)' new PointF(272' 60)' new PointF(272' 57)' new PointF(260' 60)' new PointF(256' 64) }' new string[] { "mi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(239' 56)' new PointF(251' 48)' new PointF(258' 53)' new PointF(269' 53)' new PointF(276' 56)' new PointF(280' 61)' new PointF(281' 77)' new PointF(287' 75)' new PointF(288' 83)' new PointF(284' 91)' new PointF(264' 94)' new PointF(268' 85)' new PointF(265' 73)' new PointF(269' 67)' new PointF(272' 60)' new PointF(272' 57)' new PointF(260' 60)' new PointF(256' 64) }' new string[] { "mi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(239' 56)' new PointF(251' 48)' new PointF(258' 53)' new PointF(269' 53)' new PointF(276' 56)' new PointF(280' 61)' new PointF(281' 77)' new PointF(287' 75)' new PointF(288' 83)' new PointF(284' 91)' new PointF(264' 94)' new PointF(268' 85)' new PointF(265' 73)' new PointF(269' 67)' new PointF(272' 60)' new PointF(272' 57)' new PointF(260' 60)' new PointF(256' 64) }' new string[] { "mi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(239' 56)' new PointF(251' 48)' new PointF(258' 53)' new PointF(269' 53)' new PointF(276' 56)' new PointF(280' 61)' new PointF(281' 77)' new PointF(287' 75)' new PointF(288' 83)' new PointF(284' 91)' new PointF(264' 94)' new PointF(268' 85)' new PointF(265' 73)' new PointF(269' 67)' new PointF(272' 60)' new PointF(272' 57)' new PointF(260' 60)' new PointF(256' 64) }' new string[] { "mi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(239' 56)' new PointF(251' 48)' new PointF(258' 53)' new PointF(269' 53)' new PointF(276' 56)' new PointF(280' 61)' new PointF(281' 77)' new PointF(287' 75)' new PointF(288' 83)' new PointF(284' 91)' new PointF(264' 94)' new PointF(268' 85)' new PointF(265' 73)' new PointF(269' 67)' new PointF(272' 60)' new PointF(272' 57)' new PointF(260' 60)' new PointF(256' 64) }' new string[] { "mi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(239' 56)' new PointF(251' 48)' new PointF(258' 53)' new PointF(269' 53)' new PointF(276' 56)' new PointF(280' 61)' new PointF(281' 77)' new PointF(287' 75)' new PointF(288' 83)' new PointF(284' 91)' new PointF(264' 94)' new PointF(268' 85)' new PointF(265' 73)' new PointF(269' 67)' new PointF(272' 60)' new PointF(272' 57)' new PointF(260' 60)' new PointF(256' 64) }' new string[] { "mi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(239' 56)' new PointF(251' 48)' new PointF(258' 53)' new PointF(269' 53)' new PointF(276' 56)' new PointF(280' 61)' new PointF(281' 77)' new PointF(287' 75)' new PointF(288' 83)' new PointF(284' 91)' new PointF(264' 94)' new PointF(268' 85)' new PointF(265' 73)' new PointF(269' 67)' new PointF(272' 60)' new PointF(272' 57)' new PointF(260' 60)' new PointF(256' 64) }' new string[] { "mi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(239' 56)' new PointF(251' 48)' new PointF(258' 53)' new PointF(269' 53)' new PointF(276' 56)' new PointF(280' 61)' new PointF(281' 77)' new PointF(287' 75)' new PointF(288' 83)' new PointF(284' 91)' new PointF(264' 94)' new PointF(268' 85)' new PointF(265' 73)' new PointF(269' 67)' new PointF(272' 60)' new PointF(272' 57)' new PointF(260' 60)' new PointF(256' 64) }' new string[] { "mi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(239' 56)' new PointF(251' 48)' new PointF(258' 53)' new PointF(269' 53)' new PointF(276' 56)' new PointF(280' 61)' new PointF(281' 77)' new PointF(287' 75)' new PointF(288' 83)' new PointF(284' 91)' new PointF(264' 94)' new PointF(268' 85)' new PointF(265' 73)' new PointF(269' 67)' new PointF(272' 60)' new PointF(272' 57)' new PointF(260' 60)' new PointF(256' 64) }' new string[] { "mi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(239' 56)' new PointF(251' 48)' new PointF(258' 53)' new PointF(269' 53)' new PointF(276' 56)' new PointF(280' 61)' new PointF(281' 77)' new PointF(287' 75)' new PointF(288' 83)' new PointF(284' 91)' new PointF(264' 94)' new PointF(268' 85)' new PointF(265' 73)' new PointF(269' 67)' new PointF(272' 60)' new PointF(272' 57)' new PointF(260' 60)' new PointF(256' 64) }' new string[] { "mi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(239' 56)' new PointF(251' 48)' new PointF(258' 53)' new PointF(269' 53)' new PointF(276' 56)' new PointF(280' 61)' new PointF(281' 77)' new PointF(287' 75)' new PointF(288' 83)' new PointF(284' 91)' new PointF(264' 94)' new PointF(268' 85)' new PointF(265' 73)' new PointF(269' 67)' new PointF(272' 60)' new PointF(272' 57)' new PointF(260' 60)' new PointF(256' 64) }' new string[] { "mi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(239' 56)' new PointF(251' 48)' new PointF(258' 53)' new PointF(269' 53)' new PointF(276' 56)' new PointF(280' 61)' new PointF(281' 77)' new PointF(287' 75)' new PointF(288' 83)' new PointF(284' 91)' new PointF(264' 94)' new PointF(268' 85)' new PointF(265' 73)' new PointF(269' 67)' new PointF(272' 60)' new PointF(272' 57)' new PointF(260' 60)' new PointF(256' 64) }' new string[] { "mi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(239' 56)' new PointF(251' 48)' new PointF(258' 53)' new PointF(269' 53)' new PointF(276' 56)' new PointF(280' 61)' new PointF(281' 77)' new PointF(287' 75)' new PointF(288' 83)' new PointF(284' 91)' new PointF(264' 94)' new PointF(268' 85)' new PointF(265' 73)' new PointF(269' 67)' new PointF(272' 60)' new PointF(272' 57)' new PointF(260' 60)' new PointF(256' 64) }' new string[] { "mi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(239' 56)' new PointF(251' 48)' new PointF(258' 53)' new PointF(269' 53)' new PointF(276' 56)' new PointF(280' 61)' new PointF(281' 77)' new PointF(287' 75)' new PointF(288' 83)' new PointF(284' 91)' new PointF(264' 94)' new PointF(268' 85)' new PointF(265' 73)' new PointF(269' 67)' new PointF(272' 60)' new PointF(272' 57)' new PointF(260' 60)' new PointF(256' 64) }' new string[] { "mi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(239' 56)' new PointF(251' 48)' new PointF(258' 53)' new PointF(269' 53)' new PointF(276' 56)' new PointF(280' 61)' new PointF(281' 77)' new PointF(287' 75)' new PointF(288' 83)' new PointF(284' 91)' new PointF(264' 94)' new PointF(268' 85)' new PointF(265' 73)' new PointF(269' 67)' new PointF(272' 60)' new PointF(272' 57)' new PointF(260' 60)' new PointF(256' 64) }' new string[] { "mi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(239' 56)' new PointF(251' 48)' new PointF(258' 53)' new PointF(269' 53)' new PointF(276' 56)' new PointF(280' 61)' new PointF(281' 77)' new PointF(287' 75)' new PointF(288' 83)' new PointF(284' 91)' new PointF(264' 94)' new PointF(268' 85)' new PointF(265' 73)' new PointF(269' 67)' new PointF(272' 60)' new PointF(272' 57)' new PointF(260' 60)' new PointF(256' 64) }' new string[] { "mi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(239' 56)' new PointF(251' 48)' new PointF(258' 53)' new PointF(269' 53)' new PointF(276' 56)' new PointF(280' 61)' new PointF(281' 77)' new PointF(287' 75)' new PointF(288' 83)' new PointF(284' 91)' new PointF(264' 94)' new PointF(268' 85)' new PointF(265' 73)' new PointF(269' 67)' new PointF(272' 60)' new PointF(272' 57)' new PointF(260' 60)' new PointF(256' 64) }' new string[] { "mi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(239' 56)' new PointF(251' 48)' new PointF(258' 53)' new PointF(269' 53)' new PointF(276' 56)' new PointF(280' 61)' new PointF(281' 77)' new PointF(287' 75)' new PointF(288' 83)' new PointF(284' 91)' new PointF(264' 94)' new PointF(268' 85)' new PointF(265' 73)' new PointF(269' 67)' new PointF(272' 60)' new PointF(272' 57)' new PointF(260' 60)' new PointF(256' 64) }' new string[] { "mi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(239' 56)' new PointF(251' 48)' new PointF(258' 53)' new PointF(269' 53)' new PointF(276' 56)' new PointF(280' 61)' new PointF(281' 77)' new PointF(287' 75)' new PointF(288' 83)' new PointF(284' 91)' new PointF(264' 94)' new PointF(268' 85)' new PointF(265' 73)' new PointF(269' 67)' new PointF(272' 60)' new PointF(272' 57)' new PointF(260' 60)' new PointF(256' 64) }' new string[] { "mi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(239' 56)' new PointF(251' 48)' new PointF(258' 53)' new PointF(269' 53)' new PointF(276' 56)' new PointF(280' 61)' new PointF(281' 77)' new PointF(287' 75)' new PointF(288' 83)' new PointF(284' 91)' new PointF(264' 94)' new PointF(268' 85)' new PointF(265' 73)' new PointF(269' 67)' new PointF(272' 60)' new PointF(272' 57)' new PointF(260' 60)' new PointF(256' 64) }' new string[] { "mi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(239' 56)' new PointF(251' 48)' new PointF(258' 53)' new PointF(269' 53)' new PointF(276' 56)' new PointF(280' 61)' new PointF(281' 77)' new PointF(287' 75)' new PointF(288' 83)' new PointF(284' 91)' new PointF(264' 94)' new PointF(268' 85)' new PointF(265' 73)' new PointF(269' 67)' new PointF(272' 60)' new PointF(272' 57)' new PointF(260' 60)' new PointF(256' 64) }' new string[] { "mi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(239' 56)' new PointF(251' 48)' new PointF(258' 53)' new PointF(269' 53)' new PointF(276' 56)' new PointF(280' 61)' new PointF(281' 77)' new PointF(287' 75)' new PointF(288' 83)' new PointF(284' 91)' new PointF(264' 94)' new PointF(268' 85)' new PointF(265' 73)' new PointF(269' 67)' new PointF(272' 60)' new PointF(272' 57)' new PointF(260' 60)' new PointF(256' 64) }' new string[] { "mi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(239' 56)' new PointF(251' 48)' new PointF(258' 53)' new PointF(269' 53)' new PointF(276' 56)' new PointF(280' 61)' new PointF(281' 77)' new PointF(287' 75)' new PointF(288' 83)' new PointF(284' 91)' new PointF(264' 94)' new PointF(268' 85)' new PointF(265' 73)' new PointF(269' 67)' new PointF(272' 60)' new PointF(272' 57)' new PointF(260' 60)' new PointF(256' 64) }' new string[] { "mi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(239' 56)' new PointF(251' 48)' new PointF(258' 53)' new PointF(269' 53)' new PointF(276' 56)' new PointF(280' 61)' new PointF(281' 77)' new PointF(287' 75)' new PointF(288' 83)' new PointF(284' 91)' new PointF(264' 94)' new PointF(268' 85)' new PointF(265' 73)' new PointF(269' 67)' new PointF(272' 60)' new PointF(272' 57)' new PointF(260' 60)' new PointF(256' 64) }' new string[] { "mi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(239' 56)' new PointF(251' 48)' new PointF(258' 53)' new PointF(269' 53)' new PointF(276' 56)' new PointF(280' 61)' new PointF(281' 77)' new PointF(287' 75)' new PointF(288' 83)' new PointF(284' 91)' new PointF(264' 94)' new PointF(268' 85)' new PointF(265' 73)' new PointF(269' 67)' new PointF(272' 60)' new PointF(272' 57)' new PointF(260' 60)' new PointF(256' 64) }' new string[] { "mi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(239' 56)' new PointF(251' 48)' new PointF(258' 53)' new PointF(269' 53)' new PointF(276' 56)' new PointF(280' 61)' new PointF(281' 77)' new PointF(287' 75)' new PointF(288' 83)' new PointF(284' 91)' new PointF(264' 94)' new PointF(268' 85)' new PointF(265' 73)' new PointF(269' 67)' new PointF(272' 60)' new PointF(272' 57)' new PointF(260' 60)' new PointF(256' 64) }' new string[] { "mi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(239' 56)' new PointF(251' 48)' new PointF(258' 53)' new PointF(269' 53)' new PointF(276' 56)' new PointF(280' 61)' new PointF(281' 77)' new PointF(287' 75)' new PointF(288' 83)' new PointF(284' 91)' new PointF(264' 94)' new PointF(268' 85)' new PointF(265' 73)' new PointF(269' 67)' new PointF(272' 60)' new PointF(272' 57)' new PointF(260' 60)' new PointF(256' 64) }' new string[] { "mi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(239' 56)' new PointF(251' 48)' new PointF(258' 53)' new PointF(269' 53)' new PointF(276' 56)' new PointF(280' 61)' new PointF(281' 77)' new PointF(287' 75)' new PointF(288' 83)' new PointF(284' 91)' new PointF(264' 94)' new PointF(268' 85)' new PointF(265' 73)' new PointF(269' 67)' new PointF(272' 60)' new PointF(272' 57)' new PointF(260' 60)' new PointF(256' 64) }' new string[] { "mi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(229' 56)' new PointF(235' 54)' new PointF(253' 63)' new PointF(256' 70)' new PointF(255' 90)' new PointF(238' 87)' new PointF(235' 81)' new PointF(227' 72)' new PointF(224' 64) }' new string[] { "wi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(229' 56)' new PointF(235' 54)' new PointF(253' 63)' new PointF(256' 70)' new PointF(255' 90)' new PointF(238' 87)' new PointF(235' 81)' new PointF(227' 72)' new PointF(224' 64) }' new string[] { "wi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(229' 56)' new PointF(235' 54)' new PointF(253' 63)' new PointF(256' 70)' new PointF(255' 90)' new PointF(238' 87)' new PointF(235' 81)' new PointF(227' 72)' new PointF(224' 64) }' new string[] { "wi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(229' 56)' new PointF(235' 54)' new PointF(253' 63)' new PointF(256' 70)' new PointF(255' 90)' new PointF(238' 87)' new PointF(235' 81)' new PointF(227' 72)' new PointF(224' 64) }' new string[] { "wi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(229' 56)' new PointF(235' 54)' new PointF(253' 63)' new PointF(256' 70)' new PointF(255' 90)' new PointF(238' 87)' new PointF(235' 81)' new PointF(227' 72)' new PointF(224' 64) }' new string[] { "wi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(229' 56)' new PointF(235' 54)' new PointF(253' 63)' new PointF(256' 70)' new PointF(255' 90)' new PointF(238' 87)' new PointF(235' 81)' new PointF(227' 72)' new PointF(224' 64) }' new string[] { "wi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(229' 56)' new PointF(235' 54)' new PointF(253' 63)' new PointF(256' 70)' new PointF(255' 90)' new PointF(238' 87)' new PointF(235' 81)' new PointF(227' 72)' new PointF(224' 64) }' new string[] { "wi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(229' 56)' new PointF(235' 54)' new PointF(253' 63)' new PointF(256' 70)' new PointF(255' 90)' new PointF(238' 87)' new PointF(235' 81)' new PointF(227' 72)' new PointF(224' 64) }' new string[] { "wi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(229' 56)' new PointF(235' 54)' new PointF(253' 63)' new PointF(256' 70)' new PointF(255' 90)' new PointF(238' 87)' new PointF(235' 81)' new PointF(227' 72)' new PointF(224' 64) }' new string[] { "wi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(229' 56)' new PointF(235' 54)' new PointF(253' 63)' new PointF(256' 70)' new PointF(255' 90)' new PointF(238' 87)' new PointF(235' 81)' new PointF(227' 72)' new PointF(224' 64) }' new string[] { "wi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(229' 56)' new PointF(235' 54)' new PointF(253' 63)' new PointF(256' 70)' new PointF(255' 90)' new PointF(238' 87)' new PointF(235' 81)' new PointF(227' 72)' new PointF(224' 64) }' new string[] { "wi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(229' 56)' new PointF(235' 54)' new PointF(253' 63)' new PointF(256' 70)' new PointF(255' 90)' new PointF(238' 87)' new PointF(235' 81)' new PointF(227' 72)' new PointF(224' 64) }' new string[] { "wi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(229' 56)' new PointF(235' 54)' new PointF(253' 63)' new PointF(256' 70)' new PointF(255' 90)' new PointF(238' 87)' new PointF(235' 81)' new PointF(227' 72)' new PointF(224' 64) }' new string[] { "wi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(229' 56)' new PointF(235' 54)' new PointF(253' 63)' new PointF(256' 70)' new PointF(255' 90)' new PointF(238' 87)' new PointF(235' 81)' new PointF(227' 72)' new PointF(224' 64) }' new string[] { "wi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(229' 56)' new PointF(235' 54)' new PointF(253' 63)' new PointF(256' 70)' new PointF(255' 90)' new PointF(238' 87)' new PointF(235' 81)' new PointF(227' 72)' new PointF(224' 64) }' new string[] { "wi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(229' 56)' new PointF(235' 54)' new PointF(253' 63)' new PointF(256' 70)' new PointF(255' 90)' new PointF(238' 87)' new PointF(235' 81)' new PointF(227' 72)' new PointF(224' 64) }' new string[] { "wi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(229' 56)' new PointF(235' 54)' new PointF(253' 63)' new PointF(256' 70)' new PointF(255' 90)' new PointF(238' 87)' new PointF(235' 81)' new PointF(227' 72)' new PointF(224' 64) }' new string[] { "wi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(229' 56)' new PointF(235' 54)' new PointF(253' 63)' new PointF(256' 70)' new PointF(255' 90)' new PointF(238' 87)' new PointF(235' 81)' new PointF(227' 72)' new PointF(224' 64) }' new string[] { "wi" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(219' 173)' new PointF(239' 174)' new PointF(236' 188)' new PointF(251' 190)' new PointF(251' 194)' new PointF(251' 200)' new PointF(246' 203)' new PointF(235' 199)' new PointF(232' 201)' new PointF(223' 199)' new PointF(223' 189) }' new string[] { "la" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(219' 173)' new PointF(239' 174)' new PointF(236' 188)' new PointF(251' 190)' new PointF(251' 194)' new PointF(251' 200)' new PointF(246' 203)' new PointF(235' 199)' new PointF(232' 201)' new PointF(223' 199)' new PointF(223' 189) }' new string[] { "la" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(219' 173)' new PointF(239' 174)' new PointF(236' 188)' new PointF(251' 190)' new PointF(251' 194)' new PointF(251' 200)' new PointF(246' 203)' new PointF(235' 199)' new PointF(232' 201)' new PointF(223' 199)' new PointF(223' 189) }' new string[] { "la" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(219' 173)' new PointF(239' 174)' new PointF(236' 188)' new PointF(251' 190)' new PointF(251' 194)' new PointF(251' 200)' new PointF(246' 203)' new PointF(235' 199)' new PointF(232' 201)' new PointF(223' 199)' new PointF(223' 189) }' new string[] { "la" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(219' 173)' new PointF(239' 174)' new PointF(236' 188)' new PointF(251' 190)' new PointF(251' 194)' new PointF(251' 200)' new PointF(246' 203)' new PointF(235' 199)' new PointF(232' 201)' new PointF(223' 199)' new PointF(223' 189) }' new string[] { "la" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(219' 173)' new PointF(239' 174)' new PointF(236' 188)' new PointF(251' 190)' new PointF(251' 194)' new PointF(251' 200)' new PointF(246' 203)' new PointF(235' 199)' new PointF(232' 201)' new PointF(223' 199)' new PointF(223' 189) }' new string[] { "la" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(219' 173)' new PointF(239' 174)' new PointF(236' 188)' new PointF(251' 190)' new PointF(251' 194)' new PointF(251' 200)' new PointF(246' 203)' new PointF(235' 199)' new PointF(232' 201)' new PointF(223' 199)' new PointF(223' 189) }' new string[] { "la" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(219' 173)' new PointF(239' 174)' new PointF(236' 188)' new PointF(251' 190)' new PointF(251' 194)' new PointF(251' 200)' new PointF(246' 203)' new PointF(235' 199)' new PointF(232' 201)' new PointF(223' 199)' new PointF(223' 189) }' new string[] { "la" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(219' 173)' new PointF(239' 174)' new PointF(236' 188)' new PointF(251' 190)' new PointF(251' 194)' new PointF(251' 200)' new PointF(246' 203)' new PointF(235' 199)' new PointF(232' 201)' new PointF(223' 199)' new PointF(223' 189) }' new string[] { "la" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(219' 173)' new PointF(239' 174)' new PointF(236' 188)' new PointF(251' 190)' new PointF(251' 194)' new PointF(251' 200)' new PointF(246' 203)' new PointF(235' 199)' new PointF(232' 201)' new PointF(223' 199)' new PointF(223' 189) }' new string[] { "la" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(219' 173)' new PointF(239' 174)' new PointF(236' 188)' new PointF(251' 190)' new PointF(251' 194)' new PointF(251' 200)' new PointF(246' 203)' new PointF(235' 199)' new PointF(232' 201)' new PointF(223' 199)' new PointF(223' 189) }' new string[] { "la" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(219' 173)' new PointF(239' 174)' new PointF(236' 188)' new PointF(251' 190)' new PointF(251' 194)' new PointF(251' 200)' new PointF(246' 203)' new PointF(235' 199)' new PointF(232' 201)' new PointF(223' 199)' new PointF(223' 189) }' new string[] { "la" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(219' 173)' new PointF(239' 174)' new PointF(236' 188)' new PointF(251' 190)' new PointF(251' 194)' new PointF(251' 200)' new PointF(246' 203)' new PointF(235' 199)' new PointF(232' 201)' new PointF(223' 199)' new PointF(223' 189) }' new string[] { "la" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(219' 173)' new PointF(239' 174)' new PointF(236' 188)' new PointF(251' 190)' new PointF(251' 194)' new PointF(251' 200)' new PointF(246' 203)' new PointF(235' 199)' new PointF(232' 201)' new PointF(223' 199)' new PointF(223' 189) }' new string[] { "la" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(219' 173)' new PointF(239' 174)' new PointF(236' 188)' new PointF(251' 190)' new PointF(251' 194)' new PointF(251' 200)' new PointF(246' 203)' new PointF(235' 199)' new PointF(232' 201)' new PointF(223' 199)' new PointF(223' 189) }' new string[] { "la" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(219' 173)' new PointF(239' 174)' new PointF(236' 188)' new PointF(251' 190)' new PointF(251' 194)' new PointF(251' 200)' new PointF(246' 203)' new PointF(235' 199)' new PointF(232' 201)' new PointF(223' 199)' new PointF(223' 189) }' new string[] { "la" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(219' 173)' new PointF(239' 174)' new PointF(236' 188)' new PointF(251' 190)' new PointF(251' 194)' new PointF(251' 200)' new PointF(246' 203)' new PointF(235' 199)' new PointF(232' 201)' new PointF(223' 199)' new PointF(223' 189) }' new string[] { "la" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(219' 173)' new PointF(239' 174)' new PointF(236' 188)' new PointF(251' 190)' new PointF(251' 194)' new PointF(251' 200)' new PointF(246' 203)' new PointF(235' 199)' new PointF(232' 201)' new PointF(223' 199)' new PointF(223' 189) }' new string[] { "la" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(219' 173)' new PointF(239' 174)' new PointF(236' 188)' new PointF(251' 190)' new PointF(251' 194)' new PointF(251' 200)' new PointF(246' 203)' new PointF(235' 199)' new PointF(232' 201)' new PointF(223' 199)' new PointF(223' 189) }' new string[] { "la" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(219' 173)' new PointF(239' 174)' new PointF(236' 188)' new PointF(251' 190)' new PointF(251' 194)' new PointF(251' 200)' new PointF(246' 203)' new PointF(235' 199)' new PointF(232' 201)' new PointF(223' 199)' new PointF(223' 189) }' new string[] { "la" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(219' 173)' new PointF(239' 174)' new PointF(236' 188)' new PointF(251' 190)' new PointF(251' 194)' new PointF(251' 200)' new PointF(246' 203)' new PointF(235' 199)' new PointF(232' 201)' new PointF(223' 199)' new PointF(223' 189) }' new string[] { "la" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(219' 173)' new PointF(239' 174)' new PointF(236' 188)' new PointF(251' 190)' new PointF(251' 194)' new PointF(251' 200)' new PointF(246' 203)' new PointF(235' 199)' new PointF(232' 201)' new PointF(223' 199)' new PointF(223' 189) }' new string[] { "la" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(216' 145)' new PointF(244' 143)' new PointF(245' 149)' new PointF(238' 172)' new PointF(219' 168) }' new string[] { "ar" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(216' 145)' new PointF(244' 143)' new PointF(245' 149)' new PointF(238' 172)' new PointF(219' 168) }' new string[] { "ar" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(216' 145)' new PointF(244' 143)' new PointF(245' 149)' new PointF(238' 172)' new PointF(219' 168) }' new string[] { "ar" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(216' 145)' new PointF(244' 143)' new PointF(245' 149)' new PointF(238' 172)' new PointF(219' 168) }' new string[] { "ar" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(216' 145)' new PointF(244' 143)' new PointF(245' 149)' new PointF(238' 172)' new PointF(219' 168) }' new string[] { "ar" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(216' 145)' new PointF(244' 143)' new PointF(245' 149)' new PointF(238' 172)' new PointF(219' 168) }' new string[] { "ar" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(216' 145)' new PointF(244' 143)' new PointF(245' 149)' new PointF(238' 172)' new PointF(219' 168) }' new string[] { "ar" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(216' 145)' new PointF(244' 143)' new PointF(245' 149)' new PointF(238' 172)' new PointF(219' 168) }' new string[] { "ar" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(216' 145)' new PointF(244' 143)' new PointF(245' 149)' new PointF(238' 172)' new PointF(219' 168) }' new string[] { "ar" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(216' 145)' new PointF(244' 143)' new PointF(245' 149)' new PointF(238' 172)' new PointF(219' 168) }' new string[] { "ar" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(208' 110)' new PointF(233' 108)' new PointF(250' 136)' new PointF(247' 145)' new PointF(243' 141)' new PointF(215' 144)' new PointF(216' 121) }' new string[] { "mo" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(208' 110)' new PointF(233' 108)' new PointF(250' 136)' new PointF(247' 145)' new PointF(243' 141)' new PointF(215' 144)' new PointF(216' 121) }' new string[] { "mo" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(208' 110)' new PointF(233' 108)' new PointF(250' 136)' new PointF(247' 145)' new PointF(243' 141)' new PointF(215' 144)' new PointF(216' 121) }' new string[] { "mo" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(208' 110)' new PointF(233' 108)' new PointF(250' 136)' new PointF(247' 145)' new PointF(243' 141)' new PointF(215' 144)' new PointF(216' 121) }' new string[] { "mo" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(208' 110)' new PointF(233' 108)' new PointF(250' 136)' new PointF(247' 145)' new PointF(243' 141)' new PointF(215' 144)' new PointF(216' 121) }' new string[] { "mo" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(208' 110)' new PointF(233' 108)' new PointF(250' 136)' new PointF(247' 145)' new PointF(243' 141)' new PointF(215' 144)' new PointF(216' 121) }' new string[] { "mo" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(208' 110)' new PointF(233' 108)' new PointF(250' 136)' new PointF(247' 145)' new PointF(243' 141)' new PointF(215' 144)' new PointF(216' 121) }' new string[] { "mo" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(208' 110)' new PointF(233' 108)' new PointF(250' 136)' new PointF(247' 145)' new PointF(243' 141)' new PointF(215' 144)' new PointF(216' 121) }' new string[] { "mo" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(208' 110)' new PointF(233' 108)' new PointF(250' 136)' new PointF(247' 145)' new PointF(243' 141)' new PointF(215' 144)' new PointF(216' 121) }' new string[] { "mo" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(208' 110)' new PointF(233' 108)' new PointF(250' 136)' new PointF(247' 145)' new PointF(243' 141)' new PointF(215' 144)' new PointF(216' 121) }' new string[] { "mo" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(208' 110)' new PointF(233' 108)' new PointF(250' 136)' new PointF(247' 145)' new PointF(243' 141)' new PointF(215' 144)' new PointF(216' 121) }' new string[] { "mo" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(208' 110)' new PointF(233' 108)' new PointF(250' 136)' new PointF(247' 145)' new PointF(243' 141)' new PointF(215' 144)' new PointF(216' 121) }' new string[] { "mo" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(208' 110)' new PointF(233' 108)' new PointF(250' 136)' new PointF(247' 145)' new PointF(243' 141)' new PointF(215' 144)' new PointF(216' 121) }' new string[] { "mo" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(208' 110)' new PointF(233' 108)' new PointF(250' 136)' new PointF(247' 145)' new PointF(243' 141)' new PointF(215' 144)' new PointF(216' 121) }' new string[] { "mo" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(202' 84)' new PointF(236' 84)' new PointF(237' 91)' new PointF(240' 95)' new PointF(235' 107)' new PointF(209' 108) }' new string[] { "ia" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(202' 84)' new PointF(236' 84)' new PointF(237' 91)' new PointF(240' 95)' new PointF(235' 107)' new PointF(209' 108) }' new string[] { "ia" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(202' 84)' new PointF(236' 84)' new PointF(237' 91)' new PointF(240' 95)' new PointF(235' 107)' new PointF(209' 108) }' new string[] { "ia" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(202' 84)' new PointF(236' 84)' new PointF(237' 91)' new PointF(240' 95)' new PointF(235' 107)' new PointF(209' 108) }' new string[] { "ia" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(202' 84)' new PointF(236' 84)' new PointF(237' 91)' new PointF(240' 95)' new PointF(235' 107)' new PointF(209' 108) }' new string[] { "ia" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(202' 84)' new PointF(236' 84)' new PointF(237' 91)' new PointF(240' 95)' new PointF(235' 107)' new PointF(209' 108) }' new string[] { "ia" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(202' 84)' new PointF(236' 84)' new PointF(237' 91)' new PointF(240' 95)' new PointF(235' 107)' new PointF(209' 108) }' new string[] { "ia" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(202' 84)' new PointF(236' 84)' new PointF(237' 91)' new PointF(240' 95)' new PointF(235' 107)' new PointF(209' 108) }' new string[] { "ia" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(202' 84)' new PointF(236' 84)' new PointF(237' 91)' new PointF(240' 95)' new PointF(235' 107)' new PointF(209' 108) }' new string[] { "ia" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(202' 84)' new PointF(236' 84)' new PointF(237' 91)' new PointF(240' 95)' new PointF(235' 107)' new PointF(209' 108) }' new string[] { "ia" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(202' 84)' new PointF(236' 84)' new PointF(237' 91)' new PointF(240' 95)' new PointF(235' 107)' new PointF(209' 108) }' new string[] { "ia" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(202' 84)' new PointF(236' 84)' new PointF(237' 91)' new PointF(240' 95)' new PointF(235' 107)' new PointF(209' 108) }' new string[] { "ia" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(200' 37)' new PointF(210' 35)' new PointF(241' 43)' new PointF(227' 56)' new PointF(225' 64)' new PointF(224' 72)' new PointF(234' 82)' new PointF(203' 83) }' new string[] { "mn" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(200' 37)' new PointF(210' 35)' new PointF(241' 43)' new PointF(227' 56)' new PointF(225' 64)' new PointF(224' 72)' new PointF(234' 82)' new PointF(203' 83) }' new string[] { "mn" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(200' 37)' new PointF(210' 35)' new PointF(241' 43)' new PointF(227' 56)' new PointF(225' 64)' new PointF(224' 72)' new PointF(234' 82)' new PointF(203' 83) }' new string[] { "mn" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(200' 37)' new PointF(210' 35)' new PointF(241' 43)' new PointF(227' 56)' new PointF(225' 64)' new PointF(224' 72)' new PointF(234' 82)' new PointF(203' 83) }' new string[] { "mn" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(200' 37)' new PointF(210' 35)' new PointF(241' 43)' new PointF(227' 56)' new PointF(225' 64)' new PointF(224' 72)' new PointF(234' 82)' new PointF(203' 83) }' new string[] { "mn" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(200' 37)' new PointF(210' 35)' new PointF(241' 43)' new PointF(227' 56)' new PointF(225' 64)' new PointF(224' 72)' new PointF(234' 82)' new PointF(203' 83) }' new string[] { "mn" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(200' 37)' new PointF(210' 35)' new PointF(241' 43)' new PointF(227' 56)' new PointF(225' 64)' new PointF(224' 72)' new PointF(234' 82)' new PointF(203' 83) }' new string[] { "mn" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(200' 37)' new PointF(210' 35)' new PointF(241' 43)' new PointF(227' 56)' new PointF(225' 64)' new PointF(224' 72)' new PointF(234' 82)' new PointF(203' 83) }' new string[] { "mn" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(200' 37)' new PointF(210' 35)' new PointF(241' 43)' new PointF(227' 56)' new PointF(225' 64)' new PointF(224' 72)' new PointF(234' 82)' new PointF(203' 83) }' new string[] { "mn" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(200' 37)' new PointF(210' 35)' new PointF(241' 43)' new PointF(227' 56)' new PointF(225' 64)' new PointF(224' 72)' new PointF(234' 82)' new PointF(203' 83) }' new string[] { "mn" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(200' 37)' new PointF(210' 35)' new PointF(241' 43)' new PointF(227' 56)' new PointF(225' 64)' new PointF(224' 72)' new PointF(234' 82)' new PointF(203' 83) }' new string[] { "mn" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(200' 37)' new PointF(210' 35)' new PointF(241' 43)' new PointF(227' 56)' new PointF(225' 64)' new PointF(224' 72)' new PointF(234' 82)' new PointF(203' 83) }' new string[] { "mn" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(200' 37)' new PointF(210' 35)' new PointF(241' 43)' new PointF(227' 56)' new PointF(225' 64)' new PointF(224' 72)' new PointF(234' 82)' new PointF(203' 83) }' new string[] { "mn" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(200' 37)' new PointF(210' 35)' new PointF(241' 43)' new PointF(227' 56)' new PointF(225' 64)' new PointF(224' 72)' new PointF(234' 82)' new PointF(203' 83) }' new string[] { "mn" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(200' 37)' new PointF(210' 35)' new PointF(241' 43)' new PointF(227' 56)' new PointF(225' 64)' new PointF(224' 72)' new PointF(234' 82)' new PointF(203' 83) }' new string[] { "mn" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(200' 37)' new PointF(210' 35)' new PointF(241' 43)' new PointF(227' 56)' new PointF(225' 64)' new PointF(224' 72)' new PointF(234' 82)' new PointF(203' 83) }' new string[] { "mn" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(159' 142)' new PointF(177' 144)' new PointF(175' 160)' new PointF(190' 166)' new PointF(217' 170)' new PointF(222' 199)' new PointF(195' 216)' new PointF(194' 233)' new PointF(179' 227)' new PointF(166' 202)' new PointF(156' 199)' new PointF(150' 206)' new PointF(140' 199)' new PointF(139' 192)' new PointF(128' 178)' new PointF(153' 181) }' new string[] { "tx" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(159' 142)' new PointF(177' 144)' new PointF(175' 160)' new PointF(190' 166)' new PointF(217' 170)' new PointF(222' 199)' new PointF(195' 216)' new PointF(194' 233)' new PointF(179' 227)' new PointF(166' 202)' new PointF(156' 199)' new PointF(150' 206)' new PointF(140' 199)' new PointF(139' 192)' new PointF(128' 178)' new PointF(153' 181) }' new string[] { "tx" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(159' 142)' new PointF(177' 144)' new PointF(175' 160)' new PointF(190' 166)' new PointF(217' 170)' new PointF(222' 199)' new PointF(195' 216)' new PointF(194' 233)' new PointF(179' 227)' new PointF(166' 202)' new PointF(156' 199)' new PointF(150' 206)' new PointF(140' 199)' new PointF(139' 192)' new PointF(128' 178)' new PointF(153' 181) }' new string[] { "tx" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(159' 142)' new PointF(177' 144)' new PointF(175' 160)' new PointF(190' 166)' new PointF(217' 170)' new PointF(222' 199)' new PointF(195' 216)' new PointF(194' 233)' new PointF(179' 227)' new PointF(166' 202)' new PointF(156' 199)' new PointF(150' 206)' new PointF(140' 199)' new PointF(139' 192)' new PointF(128' 178)' new PointF(153' 181) }' new string[] { "tx" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(159' 142)' new PointF(177' 144)' new PointF(175' 160)' new PointF(190' 166)' new PointF(217' 170)' new PointF(222' 199)' new PointF(195' 216)' new PointF(194' 233)' new PointF(179' 227)' new PointF(166' 202)' new PointF(156' 199)' new PointF(150' 206)' new PointF(140' 199)' new PointF(139' 192)' new PointF(128' 178)' new PointF(153' 181) }' new string[] { "tx" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(159' 142)' new PointF(177' 144)' new PointF(175' 160)' new PointF(190' 166)' new PointF(217' 170)' new PointF(222' 199)' new PointF(195' 216)' new PointF(194' 233)' new PointF(179' 227)' new PointF(166' 202)' new PointF(156' 199)' new PointF(150' 206)' new PointF(140' 199)' new PointF(139' 192)' new PointF(128' 178)' new PointF(153' 181) }' new string[] { "tx" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(159' 142)' new PointF(177' 144)' new PointF(175' 160)' new PointF(190' 166)' new PointF(217' 170)' new PointF(222' 199)' new PointF(195' 216)' new PointF(194' 233)' new PointF(179' 227)' new PointF(166' 202)' new PointF(156' 199)' new PointF(150' 206)' new PointF(140' 199)' new PointF(139' 192)' new PointF(128' 178)' new PointF(153' 181) }' new string[] { "tx" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(159' 142)' new PointF(177' 144)' new PointF(175' 160)' new PointF(190' 166)' new PointF(217' 170)' new PointF(222' 199)' new PointF(195' 216)' new PointF(194' 233)' new PointF(179' 227)' new PointF(166' 202)' new PointF(156' 199)' new PointF(150' 206)' new PointF(140' 199)' new PointF(139' 192)' new PointF(128' 178)' new PointF(153' 181) }' new string[] { "tx" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(159' 142)' new PointF(177' 144)' new PointF(175' 160)' new PointF(190' 166)' new PointF(217' 170)' new PointF(222' 199)' new PointF(195' 216)' new PointF(194' 233)' new PointF(179' 227)' new PointF(166' 202)' new PointF(156' 199)' new PointF(150' 206)' new PointF(140' 199)' new PointF(139' 192)' new PointF(128' 178)' new PointF(153' 181) }' new string[] { "tx" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(159' 142)' new PointF(177' 144)' new PointF(175' 160)' new PointF(190' 166)' new PointF(217' 170)' new PointF(222' 199)' new PointF(195' 216)' new PointF(194' 233)' new PointF(179' 227)' new PointF(166' 202)' new PointF(156' 199)' new PointF(150' 206)' new PointF(140' 199)' new PointF(139' 192)' new PointF(128' 178)' new PointF(153' 181) }' new string[] { "tx" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(159' 142)' new PointF(177' 144)' new PointF(175' 160)' new PointF(190' 166)' new PointF(217' 170)' new PointF(222' 199)' new PointF(195' 216)' new PointF(194' 233)' new PointF(179' 227)' new PointF(166' 202)' new PointF(156' 199)' new PointF(150' 206)' new PointF(140' 199)' new PointF(139' 192)' new PointF(128' 178)' new PointF(153' 181) }' new string[] { "tx" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(159' 142)' new PointF(177' 144)' new PointF(175' 160)' new PointF(190' 166)' new PointF(217' 170)' new PointF(222' 199)' new PointF(195' 216)' new PointF(194' 233)' new PointF(179' 227)' new PointF(166' 202)' new PointF(156' 199)' new PointF(150' 206)' new PointF(140' 199)' new PointF(139' 192)' new PointF(128' 178)' new PointF(153' 181) }' new string[] { "tx" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(159' 142)' new PointF(177' 144)' new PointF(175' 160)' new PointF(190' 166)' new PointF(217' 170)' new PointF(222' 199)' new PointF(195' 216)' new PointF(194' 233)' new PointF(179' 227)' new PointF(166' 202)' new PointF(156' 199)' new PointF(150' 206)' new PointF(140' 199)' new PointF(139' 192)' new PointF(128' 178)' new PointF(153' 181) }' new string[] { "tx" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(159' 142)' new PointF(177' 144)' new PointF(175' 160)' new PointF(190' 166)' new PointF(217' 170)' new PointF(222' 199)' new PointF(195' 216)' new PointF(194' 233)' new PointF(179' 227)' new PointF(166' 202)' new PointF(156' 199)' new PointF(150' 206)' new PointF(140' 199)' new PointF(139' 192)' new PointF(128' 178)' new PointF(153' 181) }' new string[] { "tx" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(159' 142)' new PointF(177' 144)' new PointF(175' 160)' new PointF(190' 166)' new PointF(217' 170)' new PointF(222' 199)' new PointF(195' 216)' new PointF(194' 233)' new PointF(179' 227)' new PointF(166' 202)' new PointF(156' 199)' new PointF(150' 206)' new PointF(140' 199)' new PointF(139' 192)' new PointF(128' 178)' new PointF(153' 181) }' new string[] { "tx" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(159' 142)' new PointF(177' 144)' new PointF(175' 160)' new PointF(190' 166)' new PointF(217' 170)' new PointF(222' 199)' new PointF(195' 216)' new PointF(194' 233)' new PointF(179' 227)' new PointF(166' 202)' new PointF(156' 199)' new PointF(150' 206)' new PointF(140' 199)' new PointF(139' 192)' new PointF(128' 178)' new PointF(153' 181) }' new string[] { "tx" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(159' 142)' new PointF(177' 144)' new PointF(175' 160)' new PointF(190' 166)' new PointF(217' 170)' new PointF(222' 199)' new PointF(195' 216)' new PointF(194' 233)' new PointF(179' 227)' new PointF(166' 202)' new PointF(156' 199)' new PointF(150' 206)' new PointF(140' 199)' new PointF(139' 192)' new PointF(128' 178)' new PointF(153' 181) }' new string[] { "tx" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(159' 142)' new PointF(177' 144)' new PointF(175' 160)' new PointF(190' 166)' new PointF(217' 170)' new PointF(222' 199)' new PointF(195' 216)' new PointF(194' 233)' new PointF(179' 227)' new PointF(166' 202)' new PointF(156' 199)' new PointF(150' 206)' new PointF(140' 199)' new PointF(139' 192)' new PointF(128' 178)' new PointF(153' 181) }' new string[] { "tx" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(159' 142)' new PointF(177' 144)' new PointF(175' 160)' new PointF(190' 166)' new PointF(217' 170)' new PointF(222' 199)' new PointF(195' 216)' new PointF(194' 233)' new PointF(179' 227)' new PointF(166' 202)' new PointF(156' 199)' new PointF(150' 206)' new PointF(140' 199)' new PointF(139' 192)' new PointF(128' 178)' new PointF(153' 181) }' new string[] { "tx" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(159' 142)' new PointF(177' 144)' new PointF(175' 160)' new PointF(190' 166)' new PointF(217' 170)' new PointF(222' 199)' new PointF(195' 216)' new PointF(194' 233)' new PointF(179' 227)' new PointF(166' 202)' new PointF(156' 199)' new PointF(150' 206)' new PointF(140' 199)' new PointF(139' 192)' new PointF(128' 178)' new PointF(153' 181) }' new string[] { "tx" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(159' 142)' new PointF(177' 144)' new PointF(175' 160)' new PointF(190' 166)' new PointF(217' 170)' new PointF(222' 199)' new PointF(195' 216)' new PointF(194' 233)' new PointF(179' 227)' new PointF(166' 202)' new PointF(156' 199)' new PointF(150' 206)' new PointF(140' 199)' new PointF(139' 192)' new PointF(128' 178)' new PointF(153' 181) }' new string[] { "tx" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(159' 142)' new PointF(177' 144)' new PointF(175' 160)' new PointF(190' 166)' new PointF(217' 170)' new PointF(222' 199)' new PointF(195' 216)' new PointF(194' 233)' new PointF(179' 227)' new PointF(166' 202)' new PointF(156' 199)' new PointF(150' 206)' new PointF(140' 199)' new PointF(139' 192)' new PointF(128' 178)' new PointF(153' 181) }' new string[] { "tx" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(159' 142)' new PointF(177' 144)' new PointF(175' 160)' new PointF(190' 166)' new PointF(217' 170)' new PointF(222' 199)' new PointF(195' 216)' new PointF(194' 233)' new PointF(179' 227)' new PointF(166' 202)' new PointF(156' 199)' new PointF(150' 206)' new PointF(140' 199)' new PointF(139' 192)' new PointF(128' 178)' new PointF(153' 181) }' new string[] { "tx" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(159' 142)' new PointF(177' 144)' new PointF(175' 160)' new PointF(190' 166)' new PointF(217' 170)' new PointF(222' 199)' new PointF(195' 216)' new PointF(194' 233)' new PointF(179' 227)' new PointF(166' 202)' new PointF(156' 199)' new PointF(150' 206)' new PointF(140' 199)' new PointF(139' 192)' new PointF(128' 178)' new PointF(153' 181) }' new string[] { "tx" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(159' 142)' new PointF(177' 144)' new PointF(175' 160)' new PointF(190' 166)' new PointF(217' 170)' new PointF(222' 199)' new PointF(195' 216)' new PointF(194' 233)' new PointF(179' 227)' new PointF(166' 202)' new PointF(156' 199)' new PointF(150' 206)' new PointF(140' 199)' new PointF(139' 192)' new PointF(128' 178)' new PointF(153' 181) }' new string[] { "tx" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(159' 142)' new PointF(177' 144)' new PointF(175' 160)' new PointF(190' 166)' new PointF(217' 170)' new PointF(222' 199)' new PointF(195' 216)' new PointF(194' 233)' new PointF(179' 227)' new PointF(166' 202)' new PointF(156' 199)' new PointF(150' 206)' new PointF(140' 199)' new PointF(139' 192)' new PointF(128' 178)' new PointF(153' 181) }' new string[] { "tx" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(159' 142)' new PointF(177' 144)' new PointF(175' 160)' new PointF(190' 166)' new PointF(217' 170)' new PointF(222' 199)' new PointF(195' 216)' new PointF(194' 233)' new PointF(179' 227)' new PointF(166' 202)' new PointF(156' 199)' new PointF(150' 206)' new PointF(140' 199)' new PointF(139' 192)' new PointF(128' 178)' new PointF(153' 181) }' new string[] { "tx" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(159' 142)' new PointF(177' 144)' new PointF(175' 160)' new PointF(190' 166)' new PointF(217' 170)' new PointF(222' 199)' new PointF(195' 216)' new PointF(194' 233)' new PointF(179' 227)' new PointF(166' 202)' new PointF(156' 199)' new PointF(150' 206)' new PointF(140' 199)' new PointF(139' 192)' new PointF(128' 178)' new PointF(153' 181) }' new string[] { "tx" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(159' 142)' new PointF(177' 144)' new PointF(175' 160)' new PointF(190' 166)' new PointF(217' 170)' new PointF(222' 199)' new PointF(195' 216)' new PointF(194' 233)' new PointF(179' 227)' new PointF(166' 202)' new PointF(156' 199)' new PointF(150' 206)' new PointF(140' 199)' new PointF(139' 192)' new PointF(128' 178)' new PointF(153' 181) }' new string[] { "tx" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(159' 142)' new PointF(177' 144)' new PointF(175' 160)' new PointF(190' 166)' new PointF(217' 170)' new PointF(222' 199)' new PointF(195' 216)' new PointF(194' 233)' new PointF(179' 227)' new PointF(166' 202)' new PointF(156' 199)' new PointF(150' 206)' new PointF(140' 199)' new PointF(139' 192)' new PointF(128' 178)' new PointF(153' 181) }' new string[] { "tx" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(159' 142)' new PointF(177' 144)' new PointF(175' 160)' new PointF(190' 166)' new PointF(217' 170)' new PointF(222' 199)' new PointF(195' 216)' new PointF(194' 233)' new PointF(179' 227)' new PointF(166' 202)' new PointF(156' 199)' new PointF(150' 206)' new PointF(140' 199)' new PointF(139' 192)' new PointF(128' 178)' new PointF(153' 181) }' new string[] { "tx" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(159' 142)' new PointF(177' 144)' new PointF(175' 160)' new PointF(190' 166)' new PointF(217' 170)' new PointF(222' 199)' new PointF(195' 216)' new PointF(194' 233)' new PointF(179' 227)' new PointF(166' 202)' new PointF(156' 199)' new PointF(150' 206)' new PointF(140' 199)' new PointF(139' 192)' new PointF(128' 178)' new PointF(153' 181) }' new string[] { "tx" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(157' 138)' new PointF(213' 139)' new PointF(215' 169)' new PointF(206' 165)' new PointF(186' 163)' new PointF(176' 159)' new PointF(176' 143)' new PointF(155' 142) }' new string[] { "ok" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(157' 138)' new PointF(213' 139)' new PointF(215' 169)' new PointF(206' 165)' new PointF(186' 163)' new PointF(176' 159)' new PointF(176' 143)' new PointF(155' 142) }' new string[] { "ok" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(157' 138)' new PointF(213' 139)' new PointF(215' 169)' new PointF(206' 165)' new PointF(186' 163)' new PointF(176' 159)' new PointF(176' 143)' new PointF(155' 142) }' new string[] { "ok" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(157' 138)' new PointF(213' 139)' new PointF(215' 169)' new PointF(206' 165)' new PointF(186' 163)' new PointF(176' 159)' new PointF(176' 143)' new PointF(155' 142) }' new string[] { "ok" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(157' 138)' new PointF(213' 139)' new PointF(215' 169)' new PointF(206' 165)' new PointF(186' 163)' new PointF(176' 159)' new PointF(176' 143)' new PointF(155' 142) }' new string[] { "ok" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(157' 138)' new PointF(213' 139)' new PointF(215' 169)' new PointF(206' 165)' new PointF(186' 163)' new PointF(176' 159)' new PointF(176' 143)' new PointF(155' 142) }' new string[] { "ok" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(157' 138)' new PointF(213' 139)' new PointF(215' 169)' new PointF(206' 165)' new PointF(186' 163)' new PointF(176' 159)' new PointF(176' 143)' new PointF(155' 142) }' new string[] { "ok" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(157' 138)' new PointF(213' 139)' new PointF(215' 169)' new PointF(206' 165)' new PointF(186' 163)' new PointF(176' 159)' new PointF(176' 143)' new PointF(155' 142) }' new string[] { "ok" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(157' 138)' new PointF(213' 139)' new PointF(215' 169)' new PointF(206' 165)' new PointF(186' 163)' new PointF(176' 159)' new PointF(176' 143)' new PointF(155' 142) }' new string[] { "ok" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(157' 138)' new PointF(213' 139)' new PointF(215' 169)' new PointF(206' 165)' new PointF(186' 163)' new PointF(176' 159)' new PointF(176' 143)' new PointF(155' 142) }' new string[] { "ok" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(157' 138)' new PointF(213' 139)' new PointF(215' 169)' new PointF(206' 165)' new PointF(186' 163)' new PointF(176' 159)' new PointF(176' 143)' new PointF(155' 142) }' new string[] { "ok" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(157' 138)' new PointF(213' 139)' new PointF(215' 169)' new PointF(206' 165)' new PointF(186' 163)' new PointF(176' 159)' new PointF(176' 143)' new PointF(155' 142) }' new string[] { "ok" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(157' 138)' new PointF(213' 139)' new PointF(215' 169)' new PointF(206' 165)' new PointF(186' 163)' new PointF(176' 159)' new PointF(176' 143)' new PointF(155' 142) }' new string[] { "ok" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(157' 138)' new PointF(213' 139)' new PointF(215' 169)' new PointF(206' 165)' new PointF(186' 163)' new PointF(176' 159)' new PointF(176' 143)' new PointF(155' 142) }' new string[] { "ok" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(157' 138)' new PointF(213' 139)' new PointF(215' 169)' new PointF(206' 165)' new PointF(186' 163)' new PointF(176' 159)' new PointF(176' 143)' new PointF(155' 142) }' new string[] { "ok" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(157' 138)' new PointF(213' 139)' new PointF(215' 169)' new PointF(206' 165)' new PointF(186' 163)' new PointF(176' 159)' new PointF(176' 143)' new PointF(155' 142) }' new string[] { "ok" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(166' 112)' new PointF(209' 112)' new PointF(214' 122)' new PointF(214' 138)' new PointF(162' 137) }' new string[] { "ks" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(166' 112)' new PointF(209' 112)' new PointF(214' 122)' new PointF(214' 138)' new PointF(162' 137) }' new string[] { "ks" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(166' 112)' new PointF(209' 112)' new PointF(214' 122)' new PointF(214' 138)' new PointF(162' 137) }' new string[] { "ks" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(166' 112)' new PointF(209' 112)' new PointF(214' 122)' new PointF(214' 138)' new PointF(162' 137) }' new string[] { "ks" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(166' 112)' new PointF(209' 112)' new PointF(214' 122)' new PointF(214' 138)' new PointF(162' 137) }' new string[] { "ks" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(166' 112)' new PointF(209' 112)' new PointF(214' 122)' new PointF(214' 138)' new PointF(162' 137) }' new string[] { "ks" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(166' 112)' new PointF(209' 112)' new PointF(214' 122)' new PointF(214' 138)' new PointF(162' 137) }' new string[] { "ks" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(166' 112)' new PointF(209' 112)' new PointF(214' 122)' new PointF(214' 138)' new PointF(162' 137) }' new string[] { "ks" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(166' 112)' new PointF(209' 112)' new PointF(214' 122)' new PointF(214' 138)' new PointF(162' 137) }' new string[] { "ks" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(166' 112)' new PointF(209' 112)' new PointF(214' 122)' new PointF(214' 138)' new PointF(162' 137) }' new string[] { "ks" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(155' 86)' new PointF(202' 90)' new PointF(209' 113)' new PointF(165' 112)' new PointF(165' 103)' new PointF(151' 102) }' new string[] { "ne" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(155' 86)' new PointF(202' 90)' new PointF(209' 113)' new PointF(165' 112)' new PointF(165' 103)' new PointF(151' 102) }' new string[] { "ne" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(155' 86)' new PointF(202' 90)' new PointF(209' 113)' new PointF(165' 112)' new PointF(165' 103)' new PointF(151' 102) }' new string[] { "ne" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(155' 86)' new PointF(202' 90)' new PointF(209' 113)' new PointF(165' 112)' new PointF(165' 103)' new PointF(151' 102) }' new string[] { "ne" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(155' 86)' new PointF(202' 90)' new PointF(209' 113)' new PointF(165' 112)' new PointF(165' 103)' new PointF(151' 102) }' new string[] { "ne" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(155' 86)' new PointF(202' 90)' new PointF(209' 113)' new PointF(165' 112)' new PointF(165' 103)' new PointF(151' 102) }' new string[] { "ne" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(155' 86)' new PointF(202' 90)' new PointF(209' 113)' new PointF(165' 112)' new PointF(165' 103)' new PointF(151' 102) }' new string[] { "ne" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(155' 86)' new PointF(202' 90)' new PointF(209' 113)' new PointF(165' 112)' new PointF(165' 103)' new PointF(151' 102) }' new string[] { "ne" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(155' 86)' new PointF(202' 90)' new PointF(209' 113)' new PointF(165' 112)' new PointF(165' 103)' new PointF(151' 102) }' new string[] { "ne" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(155' 86)' new PointF(202' 90)' new PointF(209' 113)' new PointF(165' 112)' new PointF(165' 103)' new PointF(151' 102) }' new string[] { "ne" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(155' 86)' new PointF(202' 90)' new PointF(209' 113)' new PointF(165' 112)' new PointF(165' 103)' new PointF(151' 102) }' new string[] { "ne" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(155' 86)' new PointF(202' 90)' new PointF(209' 113)' new PointF(165' 112)' new PointF(165' 103)' new PointF(151' 102) }' new string[] { "ne" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(156' 61)' new PointF(200' 62)' new PointF(202' 90)' new PointF(188' 88)' new PointF(154' 85) }' new string[] { "sd" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(156' 61)' new PointF(200' 62)' new PointF(202' 90)' new PointF(188' 88)' new PointF(154' 85) }' new string[] { "sd" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(156' 61)' new PointF(200' 62)' new PointF(202' 90)' new PointF(188' 88)' new PointF(154' 85) }' new string[] { "sd" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(156' 61)' new PointF(200' 62)' new PointF(202' 90)' new PointF(188' 88)' new PointF(154' 85) }' new string[] { "sd" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(156' 61)' new PointF(200' 62)' new PointF(202' 90)' new PointF(188' 88)' new PointF(154' 85) }' new string[] { "sd" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(156' 61)' new PointF(200' 62)' new PointF(202' 90)' new PointF(188' 88)' new PointF(154' 85) }' new string[] { "sd" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(156' 61)' new PointF(200' 62)' new PointF(202' 90)' new PointF(188' 88)' new PointF(154' 85) }' new string[] { "sd" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(156' 61)' new PointF(200' 62)' new PointF(202' 90)' new PointF(188' 88)' new PointF(154' 85) }' new string[] { "sd" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(156' 61)' new PointF(200' 62)' new PointF(202' 90)' new PointF(188' 88)' new PointF(154' 85) }' new string[] { "sd" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(156' 61)' new PointF(200' 62)' new PointF(202' 90)' new PointF(188' 88)' new PointF(154' 85) }' new string[] { "sd" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(159' 34)' new PointF(197' 36)' new PointF(200' 62)' new PointF(158' 60) }' new string[] { "nd" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(159' 34)' new PointF(197' 36)' new PointF(200' 62)' new PointF(158' 60) }' new string[] { "nd" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(159' 34)' new PointF(197' 36)' new PointF(200' 62)' new PointF(158' 60) }' new string[] { "nd" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(159' 34)' new PointF(197' 36)' new PointF(200' 62)' new PointF(158' 60) }' new string[] { "nd" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(159' 34)' new PointF(197' 36)' new PointF(200' 62)' new PointF(158' 60) }' new string[] { "nd" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(159' 34)' new PointF(197' 36)' new PointF(200' 62)' new PointF(158' 60) }' new string[] { "nd" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(159' 34)' new PointF(197' 36)' new PointF(200' 62)' new PointF(158' 60) }' new string[] { "nd" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(159' 34)' new PointF(197' 36)' new PointF(200' 62)' new PointF(158' 60) }' new string[] { "nd" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(121' 100)' new PointF(165' 103)' new PointF(163' 137)' new PointF(116' 134) }' new string[] { "co" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(121' 100)' new PointF(165' 103)' new PointF(163' 137)' new PointF(116' 134) }' new string[] { "co" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(121' 100)' new PointF(165' 103)' new PointF(163' 137)' new PointF(116' 134) }' new string[] { "co" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(121' 100)' new PointF(165' 103)' new PointF(163' 137)' new PointF(116' 134) }' new string[] { "co" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(121' 100)' new PointF(165' 103)' new PointF(163' 137)' new PointF(116' 134) }' new string[] { "co" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(121' 100)' new PointF(165' 103)' new PointF(163' 137)' new PointF(116' 134) }' new string[] { "co" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(121' 100)' new PointF(165' 103)' new PointF(163' 137)' new PointF(116' 134) }' new string[] { "co" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(121' 100)' new PointF(165' 103)' new PointF(163' 137)' new PointF(116' 134) }' new string[] { "co" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(117' 134)' new PointF(157' 137)' new PointF(153' 180)' new PointF(128' 177)' new PointF(125' 180)' new PointF(114' 177)' new PointF(113' 181)' new PointF(111' 181) }' new string[] { "nm" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(117' 134)' new PointF(157' 137)' new PointF(153' 180)' new PointF(128' 177)' new PointF(125' 180)' new PointF(114' 177)' new PointF(113' 181)' new PointF(111' 181) }' new string[] { "nm" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(117' 134)' new PointF(157' 137)' new PointF(153' 180)' new PointF(128' 177)' new PointF(125' 180)' new PointF(114' 177)' new PointF(113' 181)' new PointF(111' 181) }' new string[] { "nm" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(117' 134)' new PointF(157' 137)' new PointF(153' 180)' new PointF(128' 177)' new PointF(125' 180)' new PointF(114' 177)' new PointF(113' 181)' new PointF(111' 181) }' new string[] { "nm" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(117' 134)' new PointF(157' 137)' new PointF(153' 180)' new PointF(128' 177)' new PointF(125' 180)' new PointF(114' 177)' new PointF(113' 181)' new PointF(111' 181) }' new string[] { "nm" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(117' 134)' new PointF(157' 137)' new PointF(153' 180)' new PointF(128' 177)' new PointF(125' 180)' new PointF(114' 177)' new PointF(113' 181)' new PointF(111' 181) }' new string[] { "nm" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(117' 134)' new PointF(157' 137)' new PointF(153' 180)' new PointF(128' 177)' new PointF(125' 180)' new PointF(114' 177)' new PointF(113' 181)' new PointF(111' 181) }' new string[] { "nm" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(117' 134)' new PointF(157' 137)' new PointF(153' 180)' new PointF(128' 177)' new PointF(125' 180)' new PointF(114' 177)' new PointF(113' 181)' new PointF(111' 181) }' new string[] { "nm" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(117' 134)' new PointF(157' 137)' new PointF(153' 180)' new PointF(128' 177)' new PointF(125' 180)' new PointF(114' 177)' new PointF(113' 181)' new PointF(111' 181) }' new string[] { "nm" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(117' 134)' new PointF(157' 137)' new PointF(153' 180)' new PointF(128' 177)' new PointF(125' 180)' new PointF(114' 177)' new PointF(113' 181)' new PointF(111' 181) }' new string[] { "nm" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(117' 134)' new PointF(157' 137)' new PointF(153' 180)' new PointF(128' 177)' new PointF(125' 180)' new PointF(114' 177)' new PointF(113' 181)' new PointF(111' 181) }' new string[] { "nm" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(117' 134)' new PointF(157' 137)' new PointF(153' 180)' new PointF(128' 177)' new PointF(125' 180)' new PointF(114' 177)' new PointF(113' 181)' new PointF(111' 181) }' new string[] { "nm" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(117' 134)' new PointF(157' 137)' new PointF(153' 180)' new PointF(128' 177)' new PointF(125' 180)' new PointF(114' 177)' new PointF(113' 181)' new PointF(111' 181) }' new string[] { "nm" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(117' 134)' new PointF(157' 137)' new PointF(153' 180)' new PointF(128' 177)' new PointF(125' 180)' new PointF(114' 177)' new PointF(113' 181)' new PointF(111' 181) }' new string[] { "nm" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(117' 134)' new PointF(157' 137)' new PointF(153' 180)' new PointF(128' 177)' new PointF(125' 180)' new PointF(114' 177)' new PointF(113' 181)' new PointF(111' 181) }' new string[] { "nm" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(117' 134)' new PointF(157' 137)' new PointF(153' 180)' new PointF(128' 177)' new PointF(125' 180)' new PointF(114' 177)' new PointF(113' 181)' new PointF(111' 181) }' new string[] { "nm" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(83' 128)' new PointF(116' 134)' new PointF(110' 181)' new PointF(70' 163) }' new string[] { "az" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(83' 128)' new PointF(116' 134)' new PointF(110' 181)' new PointF(70' 163) }' new string[] { "az" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(83' 128)' new PointF(116' 134)' new PointF(110' 181)' new PointF(70' 163) }' new string[] { "az" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(83' 128)' new PointF(116' 134)' new PointF(110' 181)' new PointF(70' 163) }' new string[] { "az" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(83' 128)' new PointF(116' 134)' new PointF(110' 181)' new PointF(70' 163) }' new string[] { "az" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(83' 128)' new PointF(116' 134)' new PointF(110' 181)' new PointF(70' 163) }' new string[] { "az" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(83' 128)' new PointF(116' 134)' new PointF(110' 181)' new PointF(70' 163) }' new string[] { "az" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(83' 128)' new PointF(116' 134)' new PointF(110' 181)' new PointF(70' 163) }' new string[] { "az" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(92' 86)' new PointF(109' 88)' new PointF(107' 97)' new PointF(121' 100)' new PointF(115' 134)' new PointF(84' 127) }' new string[] { "ut" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(92' 86)' new PointF(109' 88)' new PointF(107' 97)' new PointF(121' 100)' new PointF(115' 134)' new PointF(84' 127) }' new string[] { "ut" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(92' 86)' new PointF(109' 88)' new PointF(107' 97)' new PointF(121' 100)' new PointF(115' 134)' new PointF(84' 127) }' new string[] { "ut" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(92' 86)' new PointF(109' 88)' new PointF(107' 97)' new PointF(121' 100)' new PointF(115' 134)' new PointF(84' 127) }' new string[] { "ut" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(92' 86)' new PointF(109' 88)' new PointF(107' 97)' new PointF(121' 100)' new PointF(115' 134)' new PointF(84' 127) }' new string[] { "ut" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(92' 86)' new PointF(109' 88)' new PointF(107' 97)' new PointF(121' 100)' new PointF(115' 134)' new PointF(84' 127) }' new string[] { "ut" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(92' 86)' new PointF(109' 88)' new PointF(107' 97)' new PointF(121' 100)' new PointF(115' 134)' new PointF(84' 127) }' new string[] { "ut" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(92' 86)' new PointF(109' 88)' new PointF(107' 97)' new PointF(121' 100)' new PointF(115' 134)' new PointF(84' 127) }' new string[] { "ut" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(92' 86)' new PointF(109' 88)' new PointF(107' 97)' new PointF(121' 100)' new PointF(115' 134)' new PointF(84' 127) }' new string[] { "ut" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(92' 86)' new PointF(109' 88)' new PointF(107' 97)' new PointF(121' 100)' new PointF(115' 134)' new PointF(84' 127) }' new string[] { "ut" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(92' 86)' new PointF(109' 88)' new PointF(107' 97)' new PointF(121' 100)' new PointF(115' 134)' new PointF(84' 127) }' new string[] { "ut" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(92' 86)' new PointF(109' 88)' new PointF(107' 97)' new PointF(121' 100)' new PointF(115' 134)' new PointF(84' 127) }' new string[] { "ut" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(113' 63)' new PointF(155' 69)' new PointF(151' 102)' new PointF(108' 97) }' new string[] { "wy" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(113' 63)' new PointF(155' 69)' new PointF(151' 102)' new PointF(108' 97) }' new string[] { "wy" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(113' 63)' new PointF(155' 69)' new PointF(151' 102)' new PointF(108' 97) }' new string[] { "wy" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(113' 63)' new PointF(155' 69)' new PointF(151' 102)' new PointF(108' 97) }' new string[] { "wy" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(113' 63)' new PointF(155' 69)' new PointF(151' 102)' new PointF(108' 97) }' new string[] { "wy" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(113' 63)' new PointF(155' 69)' new PointF(151' 102)' new PointF(108' 97) }' new string[] { "wy" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(113' 63)' new PointF(155' 69)' new PointF(151' 102)' new PointF(108' 97) }' new string[] { "wy" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(113' 63)' new PointF(155' 69)' new PointF(151' 102)' new PointF(108' 97) }' new string[] { "wy" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(91' 24)' new PointF(159' 35)' new PointF(155' 68)' new PointF(114' 63)' new PointF(112' 65)' new PointF(102' 66) }' new string[] { "mt" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(91' 24)' new PointF(159' 35)' new PointF(155' 68)' new PointF(114' 63)' new PointF(112' 65)' new PointF(102' 66) }' new string[] { "mt" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(91' 24)' new PointF(159' 35)' new PointF(155' 68)' new PointF(114' 63)' new PointF(112' 65)' new PointF(102' 66) }' new string[] { "mt" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(91' 24)' new PointF(159' 35)' new PointF(155' 68)' new PointF(114' 63)' new PointF(112' 65)' new PointF(102' 66) }' new string[] { "mt" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(91' 24)' new PointF(159' 35)' new PointF(155' 68)' new PointF(114' 63)' new PointF(112' 65)' new PointF(102' 66) }' new string[] { "mt" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(91' 24)' new PointF(159' 35)' new PointF(155' 68)' new PointF(114' 63)' new PointF(112' 65)' new PointF(102' 66) }' new string[] { "mt" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(91' 24)' new PointF(159' 35)' new PointF(155' 68)' new PointF(114' 63)' new PointF(112' 65)' new PointF(102' 66) }' new string[] { "mt" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(91' 24)' new PointF(159' 35)' new PointF(155' 68)' new PointF(114' 63)' new PointF(112' 65)' new PointF(102' 66) }' new string[] { "mt" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(91' 24)' new PointF(159' 35)' new PointF(155' 68)' new PointF(114' 63)' new PointF(112' 65)' new PointF(102' 66) }' new string[] { "mt" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(91' 24)' new PointF(159' 35)' new PointF(155' 68)' new PointF(114' 63)' new PointF(112' 65)' new PointF(102' 66) }' new string[] { "mt" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(91' 24)' new PointF(159' 35)' new PointF(155' 68)' new PointF(114' 63)' new PointF(112' 65)' new PointF(102' 66) }' new string[] { "mt" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(91' 24)' new PointF(159' 35)' new PointF(155' 68)' new PointF(114' 63)' new PointF(112' 65)' new PointF(102' 66) }' new string[] { "mt" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(53' 77)' new PointF(91' 86)' new PointF(81' 133)' new PointF(75' 132)' new PointF(73' 141)' new PointF(48' 101) }' new string[] { "nv" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(53' 77)' new PointF(91' 86)' new PointF(81' 133)' new PointF(75' 132)' new PointF(73' 141)' new PointF(48' 101) }' new string[] { "nv" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(53' 77)' new PointF(91' 86)' new PointF(81' 133)' new PointF(75' 132)' new PointF(73' 141)' new PointF(48' 101) }' new string[] { "nv" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(53' 77)' new PointF(91' 86)' new PointF(81' 133)' new PointF(75' 132)' new PointF(73' 141)' new PointF(48' 101) }' new string[] { "nv" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(53' 77)' new PointF(91' 86)' new PointF(81' 133)' new PointF(75' 132)' new PointF(73' 141)' new PointF(48' 101) }' new string[] { "nv" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(53' 77)' new PointF(91' 86)' new PointF(81' 133)' new PointF(75' 132)' new PointF(73' 141)' new PointF(48' 101) }' new string[] { "nv" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(53' 77)' new PointF(91' 86)' new PointF(81' 133)' new PointF(75' 132)' new PointF(73' 141)' new PointF(48' 101) }' new string[] { "nv" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(53' 77)' new PointF(91' 86)' new PointF(81' 133)' new PointF(75' 132)' new PointF(73' 141)' new PointF(48' 101) }' new string[] { "nv" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(53' 77)' new PointF(91' 86)' new PointF(81' 133)' new PointF(75' 132)' new PointF(73' 141)' new PointF(48' 101) }' new string[] { "nv" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(53' 77)' new PointF(91' 86)' new PointF(81' 133)' new PointF(75' 132)' new PointF(73' 141)' new PointF(48' 101) }' new string[] { "nv" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(53' 77)' new PointF(91' 86)' new PointF(81' 133)' new PointF(75' 132)' new PointF(73' 141)' new PointF(48' 101) }' new string[] { "nv" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(53' 77)' new PointF(91' 86)' new PointF(81' 133)' new PointF(75' 132)' new PointF(73' 141)' new PointF(48' 101) }' new string[] { "nv" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(86' 23)' new PointF(90' 23)' new PointF(89' 34)' new PointF(95' 46)' new PointF(93' 55)' new PointF(97' 55)' new PointF(101' 66)' new PointF(112' 65)' new PointF(108' 88)' new PointF(73' 81) }' new string[] { "id" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(86' 23)' new PointF(90' 23)' new PointF(89' 34)' new PointF(95' 46)' new PointF(93' 55)' new PointF(97' 55)' new PointF(101' 66)' new PointF(112' 65)' new PointF(108' 88)' new PointF(73' 81) }' new string[] { "id" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(86' 23)' new PointF(90' 23)' new PointF(89' 34)' new PointF(95' 46)' new PointF(93' 55)' new PointF(97' 55)' new PointF(101' 66)' new PointF(112' 65)' new PointF(108' 88)' new PointF(73' 81) }' new string[] { "id" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(86' 23)' new PointF(90' 23)' new PointF(89' 34)' new PointF(95' 46)' new PointF(93' 55)' new PointF(97' 55)' new PointF(101' 66)' new PointF(112' 65)' new PointF(108' 88)' new PointF(73' 81) }' new string[] { "id" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(86' 23)' new PointF(90' 23)' new PointF(89' 34)' new PointF(95' 46)' new PointF(93' 55)' new PointF(97' 55)' new PointF(101' 66)' new PointF(112' 65)' new PointF(108' 88)' new PointF(73' 81) }' new string[] { "id" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(86' 23)' new PointF(90' 23)' new PointF(89' 34)' new PointF(95' 46)' new PointF(93' 55)' new PointF(97' 55)' new PointF(101' 66)' new PointF(112' 65)' new PointF(108' 88)' new PointF(73' 81) }' new string[] { "id" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(86' 23)' new PointF(90' 23)' new PointF(89' 34)' new PointF(95' 46)' new PointF(93' 55)' new PointF(97' 55)' new PointF(101' 66)' new PointF(112' 65)' new PointF(108' 88)' new PointF(73' 81) }' new string[] { "id" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(86' 23)' new PointF(90' 23)' new PointF(89' 34)' new PointF(95' 46)' new PointF(93' 55)' new PointF(97' 55)' new PointF(101' 66)' new PointF(112' 65)' new PointF(108' 88)' new PointF(73' 81) }' new string[] { "id" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(86' 23)' new PointF(90' 23)' new PointF(89' 34)' new PointF(95' 46)' new PointF(93' 55)' new PointF(97' 55)' new PointF(101' 66)' new PointF(112' 65)' new PointF(108' 88)' new PointF(73' 81) }' new string[] { "id" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(86' 23)' new PointF(90' 23)' new PointF(89' 34)' new PointF(95' 46)' new PointF(93' 55)' new PointF(97' 55)' new PointF(101' 66)' new PointF(112' 65)' new PointF(108' 88)' new PointF(73' 81) }' new string[] { "id" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(86' 23)' new PointF(90' 23)' new PointF(89' 34)' new PointF(95' 46)' new PointF(93' 55)' new PointF(97' 55)' new PointF(101' 66)' new PointF(112' 65)' new PointF(108' 88)' new PointF(73' 81) }' new string[] { "id" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(86' 23)' new PointF(90' 23)' new PointF(89' 34)' new PointF(95' 46)' new PointF(93' 55)' new PointF(97' 55)' new PointF(101' 66)' new PointF(112' 65)' new PointF(108' 88)' new PointF(73' 81) }' new string[] { "id" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(86' 23)' new PointF(90' 23)' new PointF(89' 34)' new PointF(95' 46)' new PointF(93' 55)' new PointF(97' 55)' new PointF(101' 66)' new PointF(112' 65)' new PointF(108' 88)' new PointF(73' 81) }' new string[] { "id" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(86' 23)' new PointF(90' 23)' new PointF(89' 34)' new PointF(95' 46)' new PointF(93' 55)' new PointF(97' 55)' new PointF(101' 66)' new PointF(112' 65)' new PointF(108' 88)' new PointF(73' 81) }' new string[] { "id" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(86' 23)' new PointF(90' 23)' new PointF(89' 34)' new PointF(95' 46)' new PointF(93' 55)' new PointF(97' 55)' new PointF(101' 66)' new PointF(112' 65)' new PointF(108' 88)' new PointF(73' 81) }' new string[] { "id" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(86' 23)' new PointF(90' 23)' new PointF(89' 34)' new PointF(95' 46)' new PointF(93' 55)' new PointF(97' 55)' new PointF(101' 66)' new PointF(112' 65)' new PointF(108' 88)' new PointF(73' 81) }' new string[] { "id" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(86' 23)' new PointF(90' 23)' new PointF(89' 34)' new PointF(95' 46)' new PointF(93' 55)' new PointF(97' 55)' new PointF(101' 66)' new PointF(112' 65)' new PointF(108' 88)' new PointF(73' 81) }' new string[] { "id" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(86' 23)' new PointF(90' 23)' new PointF(89' 34)' new PointF(95' 46)' new PointF(93' 55)' new PointF(97' 55)' new PointF(101' 66)' new PointF(112' 65)' new PointF(108' 88)' new PointF(73' 81) }' new string[] { "id" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(86' 23)' new PointF(90' 23)' new PointF(89' 34)' new PointF(95' 46)' new PointF(93' 55)' new PointF(97' 55)' new PointF(101' 66)' new PointF(112' 65)' new PointF(108' 88)' new PointF(73' 81) }' new string[] { "id" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(86' 23)' new PointF(90' 23)' new PointF(89' 34)' new PointF(95' 46)' new PointF(93' 55)' new PointF(97' 55)' new PointF(101' 66)' new PointF(112' 65)' new PointF(108' 88)' new PointF(73' 81) }' new string[] { "id" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(29' 69)' new PointF(53' 76)' new PointF(47' 101)' new PointF(75' 144)' new PointF(76' 149)' new PointF(69' 162)' new PointF(51' 159)' new PointF(48' 147)' new PointF(42' 143)' new PointF(32' 136)' new PointF(32' 131)' new PointF(29' 117)' new PointF(28' 108)' new PointF(33' 105)' new PointF(27' 103)' new PointF(22' 91)' new PointF(22' 81) }' new string[] { "ca" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(29' 69)' new PointF(53' 76)' new PointF(47' 101)' new PointF(75' 144)' new PointF(76' 149)' new PointF(69' 162)' new PointF(51' 159)' new PointF(48' 147)' new PointF(42' 143)' new PointF(32' 136)' new PointF(32' 131)' new PointF(29' 117)' new PointF(28' 108)' new PointF(33' 105)' new PointF(27' 103)' new PointF(22' 91)' new PointF(22' 81) }' new string[] { "ca" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(29' 69)' new PointF(53' 76)' new PointF(47' 101)' new PointF(75' 144)' new PointF(76' 149)' new PointF(69' 162)' new PointF(51' 159)' new PointF(48' 147)' new PointF(42' 143)' new PointF(32' 136)' new PointF(32' 131)' new PointF(29' 117)' new PointF(28' 108)' new PointF(33' 105)' new PointF(27' 103)' new PointF(22' 91)' new PointF(22' 81) }' new string[] { "ca" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(29' 69)' new PointF(53' 76)' new PointF(47' 101)' new PointF(75' 144)' new PointF(76' 149)' new PointF(69' 162)' new PointF(51' 159)' new PointF(48' 147)' new PointF(42' 143)' new PointF(32' 136)' new PointF(32' 131)' new PointF(29' 117)' new PointF(28' 108)' new PointF(33' 105)' new PointF(27' 103)' new PointF(22' 91)' new PointF(22' 81) }' new string[] { "ca" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(29' 69)' new PointF(53' 76)' new PointF(47' 101)' new PointF(75' 144)' new PointF(76' 149)' new PointF(69' 162)' new PointF(51' 159)' new PointF(48' 147)' new PointF(42' 143)' new PointF(32' 136)' new PointF(32' 131)' new PointF(29' 117)' new PointF(28' 108)' new PointF(33' 105)' new PointF(27' 103)' new PointF(22' 91)' new PointF(22' 81) }' new string[] { "ca" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(29' 69)' new PointF(53' 76)' new PointF(47' 101)' new PointF(75' 144)' new PointF(76' 149)' new PointF(69' 162)' new PointF(51' 159)' new PointF(48' 147)' new PointF(42' 143)' new PointF(32' 136)' new PointF(32' 131)' new PointF(29' 117)' new PointF(28' 108)' new PointF(33' 105)' new PointF(27' 103)' new PointF(22' 91)' new PointF(22' 81) }' new string[] { "ca" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(29' 69)' new PointF(53' 76)' new PointF(47' 101)' new PointF(75' 144)' new PointF(76' 149)' new PointF(69' 162)' new PointF(51' 159)' new PointF(48' 147)' new PointF(42' 143)' new PointF(32' 136)' new PointF(32' 131)' new PointF(29' 117)' new PointF(28' 108)' new PointF(33' 105)' new PointF(27' 103)' new PointF(22' 91)' new PointF(22' 81) }' new string[] { "ca" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(29' 69)' new PointF(53' 76)' new PointF(47' 101)' new PointF(75' 144)' new PointF(76' 149)' new PointF(69' 162)' new PointF(51' 159)' new PointF(48' 147)' new PointF(42' 143)' new PointF(32' 136)' new PointF(32' 131)' new PointF(29' 117)' new PointF(28' 108)' new PointF(33' 105)' new PointF(27' 103)' new PointF(22' 91)' new PointF(22' 81) }' new string[] { "ca" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(29' 69)' new PointF(53' 76)' new PointF(47' 101)' new PointF(75' 144)' new PointF(76' 149)' new PointF(69' 162)' new PointF(51' 159)' new PointF(48' 147)' new PointF(42' 143)' new PointF(32' 136)' new PointF(32' 131)' new PointF(29' 117)' new PointF(28' 108)' new PointF(33' 105)' new PointF(27' 103)' new PointF(22' 91)' new PointF(22' 81) }' new string[] { "ca" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(29' 69)' new PointF(53' 76)' new PointF(47' 101)' new PointF(75' 144)' new PointF(76' 149)' new PointF(69' 162)' new PointF(51' 159)' new PointF(48' 147)' new PointF(42' 143)' new PointF(32' 136)' new PointF(32' 131)' new PointF(29' 117)' new PointF(28' 108)' new PointF(33' 105)' new PointF(27' 103)' new PointF(22' 91)' new PointF(22' 81) }' new string[] { "ca" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(29' 69)' new PointF(53' 76)' new PointF(47' 101)' new PointF(75' 144)' new PointF(76' 149)' new PointF(69' 162)' new PointF(51' 159)' new PointF(48' 147)' new PointF(42' 143)' new PointF(32' 136)' new PointF(32' 131)' new PointF(29' 117)' new PointF(28' 108)' new PointF(33' 105)' new PointF(27' 103)' new PointF(22' 91)' new PointF(22' 81) }' new string[] { "ca" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(29' 69)' new PointF(53' 76)' new PointF(47' 101)' new PointF(75' 144)' new PointF(76' 149)' new PointF(69' 162)' new PointF(51' 159)' new PointF(48' 147)' new PointF(42' 143)' new PointF(32' 136)' new PointF(32' 131)' new PointF(29' 117)' new PointF(28' 108)' new PointF(33' 105)' new PointF(27' 103)' new PointF(22' 91)' new PointF(22' 81) }' new string[] { "ca" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(29' 69)' new PointF(53' 76)' new PointF(47' 101)' new PointF(75' 144)' new PointF(76' 149)' new PointF(69' 162)' new PointF(51' 159)' new PointF(48' 147)' new PointF(42' 143)' new PointF(32' 136)' new PointF(32' 131)' new PointF(29' 117)' new PointF(28' 108)' new PointF(33' 105)' new PointF(27' 103)' new PointF(22' 91)' new PointF(22' 81) }' new string[] { "ca" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(29' 69)' new PointF(53' 76)' new PointF(47' 101)' new PointF(75' 144)' new PointF(76' 149)' new PointF(69' 162)' new PointF(51' 159)' new PointF(48' 147)' new PointF(42' 143)' new PointF(32' 136)' new PointF(32' 131)' new PointF(29' 117)' new PointF(28' 108)' new PointF(33' 105)' new PointF(27' 103)' new PointF(22' 91)' new PointF(22' 81) }' new string[] { "ca" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(29' 69)' new PointF(53' 76)' new PointF(47' 101)' new PointF(75' 144)' new PointF(76' 149)' new PointF(69' 162)' new PointF(51' 159)' new PointF(48' 147)' new PointF(42' 143)' new PointF(32' 136)' new PointF(32' 131)' new PointF(29' 117)' new PointF(28' 108)' new PointF(33' 105)' new PointF(27' 103)' new PointF(22' 91)' new PointF(22' 81) }' new string[] { "ca" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(29' 69)' new PointF(53' 76)' new PointF(47' 101)' new PointF(75' 144)' new PointF(76' 149)' new PointF(69' 162)' new PointF(51' 159)' new PointF(48' 147)' new PointF(42' 143)' new PointF(32' 136)' new PointF(32' 131)' new PointF(29' 117)' new PointF(28' 108)' new PointF(33' 105)' new PointF(27' 103)' new PointF(22' 91)' new PointF(22' 81) }' new string[] { "ca" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(29' 69)' new PointF(53' 76)' new PointF(47' 101)' new PointF(75' 144)' new PointF(76' 149)' new PointF(69' 162)' new PointF(51' 159)' new PointF(48' 147)' new PointF(42' 143)' new PointF(32' 136)' new PointF(32' 131)' new PointF(29' 117)' new PointF(28' 108)' new PointF(33' 105)' new PointF(27' 103)' new PointF(22' 91)' new PointF(22' 81) }' new string[] { "ca" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(29' 69)' new PointF(53' 76)' new PointF(47' 101)' new PointF(75' 144)' new PointF(76' 149)' new PointF(69' 162)' new PointF(51' 159)' new PointF(48' 147)' new PointF(42' 143)' new PointF(32' 136)' new PointF(32' 131)' new PointF(29' 117)' new PointF(28' 108)' new PointF(33' 105)' new PointF(27' 103)' new PointF(22' 91)' new PointF(22' 81) }' new string[] { "ca" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(29' 69)' new PointF(53' 76)' new PointF(47' 101)' new PointF(75' 144)' new PointF(76' 149)' new PointF(69' 162)' new PointF(51' 159)' new PointF(48' 147)' new PointF(42' 143)' new PointF(32' 136)' new PointF(32' 131)' new PointF(29' 117)' new PointF(28' 108)' new PointF(33' 105)' new PointF(27' 103)' new PointF(22' 91)' new PointF(22' 81) }' new string[] { "ca" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(29' 69)' new PointF(53' 76)' new PointF(47' 101)' new PointF(75' 144)' new PointF(76' 149)' new PointF(69' 162)' new PointF(51' 159)' new PointF(48' 147)' new PointF(42' 143)' new PointF(32' 136)' new PointF(32' 131)' new PointF(29' 117)' new PointF(28' 108)' new PointF(33' 105)' new PointF(27' 103)' new PointF(22' 91)' new PointF(22' 81) }' new string[] { "ca" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(29' 69)' new PointF(53' 76)' new PointF(47' 101)' new PointF(75' 144)' new PointF(76' 149)' new PointF(69' 162)' new PointF(51' 159)' new PointF(48' 147)' new PointF(42' 143)' new PointF(32' 136)' new PointF(32' 131)' new PointF(29' 117)' new PointF(28' 108)' new PointF(33' 105)' new PointF(27' 103)' new PointF(22' 91)' new PointF(22' 81) }' new string[] { "ca" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(29' 69)' new PointF(53' 76)' new PointF(47' 101)' new PointF(75' 144)' new PointF(76' 149)' new PointF(69' 162)' new PointF(51' 159)' new PointF(48' 147)' new PointF(42' 143)' new PointF(32' 136)' new PointF(32' 131)' new PointF(29' 117)' new PointF(28' 108)' new PointF(33' 105)' new PointF(27' 103)' new PointF(22' 91)' new PointF(22' 81) }' new string[] { "ca" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(29' 69)' new PointF(53' 76)' new PointF(47' 101)' new PointF(75' 144)' new PointF(76' 149)' new PointF(69' 162)' new PointF(51' 159)' new PointF(48' 147)' new PointF(42' 143)' new PointF(32' 136)' new PointF(32' 131)' new PointF(29' 117)' new PointF(28' 108)' new PointF(33' 105)' new PointF(27' 103)' new PointF(22' 91)' new PointF(22' 81) }' new string[] { "ca" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(29' 69)' new PointF(53' 76)' new PointF(47' 101)' new PointF(75' 144)' new PointF(76' 149)' new PointF(69' 162)' new PointF(51' 159)' new PointF(48' 147)' new PointF(42' 143)' new PointF(32' 136)' new PointF(32' 131)' new PointF(29' 117)' new PointF(28' 108)' new PointF(33' 105)' new PointF(27' 103)' new PointF(22' 91)' new PointF(22' 81) }' new string[] { "ca" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(29' 69)' new PointF(53' 76)' new PointF(47' 101)' new PointF(75' 144)' new PointF(76' 149)' new PointF(69' 162)' new PointF(51' 159)' new PointF(48' 147)' new PointF(42' 143)' new PointF(32' 136)' new PointF(32' 131)' new PointF(29' 117)' new PointF(28' 108)' new PointF(33' 105)' new PointF(27' 103)' new PointF(22' 91)' new PointF(22' 81) }' new string[] { "ca" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(29' 69)' new PointF(53' 76)' new PointF(47' 101)' new PointF(75' 144)' new PointF(76' 149)' new PointF(69' 162)' new PointF(51' 159)' new PointF(48' 147)' new PointF(42' 143)' new PointF(32' 136)' new PointF(32' 131)' new PointF(29' 117)' new PointF(28' 108)' new PointF(33' 105)' new PointF(27' 103)' new PointF(22' 91)' new PointF(22' 81) }' new string[] { "ca" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(29' 69)' new PointF(53' 76)' new PointF(47' 101)' new PointF(75' 144)' new PointF(76' 149)' new PointF(69' 162)' new PointF(51' 159)' new PointF(48' 147)' new PointF(42' 143)' new PointF(32' 136)' new PointF(32' 131)' new PointF(29' 117)' new PointF(28' 108)' new PointF(33' 105)' new PointF(27' 103)' new PointF(22' 91)' new PointF(22' 81) }' new string[] { "ca" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(29' 69)' new PointF(53' 76)' new PointF(47' 101)' new PointF(75' 144)' new PointF(76' 149)' new PointF(69' 162)' new PointF(51' 159)' new PointF(48' 147)' new PointF(42' 143)' new PointF(32' 136)' new PointF(32' 131)' new PointF(29' 117)' new PointF(28' 108)' new PointF(33' 105)' new PointF(27' 103)' new PointF(22' 91)' new PointF(22' 81) }' new string[] { "ca" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(29' 69)' new PointF(53' 76)' new PointF(47' 101)' new PointF(75' 144)' new PointF(76' 149)' new PointF(69' 162)' new PointF(51' 159)' new PointF(48' 147)' new PointF(42' 143)' new PointF(32' 136)' new PointF(32' 131)' new PointF(29' 117)' new PointF(28' 108)' new PointF(33' 105)' new PointF(27' 103)' new PointF(22' 91)' new PointF(22' 81) }' new string[] { "ca" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(29' 69)' new PointF(53' 76)' new PointF(47' 101)' new PointF(75' 144)' new PointF(76' 149)' new PointF(69' 162)' new PointF(51' 159)' new PointF(48' 147)' new PointF(42' 143)' new PointF(32' 136)' new PointF(32' 131)' new PointF(29' 117)' new PointF(28' 108)' new PointF(33' 105)' new PointF(27' 103)' new PointF(22' 91)' new PointF(22' 81) }' new string[] { "ca" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(29' 69)' new PointF(53' 76)' new PointF(47' 101)' new PointF(75' 144)' new PointF(76' 149)' new PointF(69' 162)' new PointF(51' 159)' new PointF(48' 147)' new PointF(42' 143)' new PointF(32' 136)' new PointF(32' 131)' new PointF(29' 117)' new PointF(28' 108)' new PointF(33' 105)' new PointF(27' 103)' new PointF(22' 91)' new PointF(22' 81) }' new string[] { "ca" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(29' 69)' new PointF(53' 76)' new PointF(47' 101)' new PointF(75' 144)' new PointF(76' 149)' new PointF(69' 162)' new PointF(51' 159)' new PointF(48' 147)' new PointF(42' 143)' new PointF(32' 136)' new PointF(32' 131)' new PointF(29' 117)' new PointF(28' 108)' new PointF(33' 105)' new PointF(27' 103)' new PointF(22' 91)' new PointF(22' 81) }' new string[] { "ca" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(29' 69)' new PointF(53' 76)' new PointF(47' 101)' new PointF(75' 144)' new PointF(76' 149)' new PointF(69' 162)' new PointF(51' 159)' new PointF(48' 147)' new PointF(42' 143)' new PointF(32' 136)' new PointF(32' 131)' new PointF(29' 117)' new PointF(28' 108)' new PointF(33' 105)' new PointF(27' 103)' new PointF(22' 91)' new PointF(22' 81) }' new string[] { "ca" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(29' 69)' new PointF(53' 76)' new PointF(47' 101)' new PointF(75' 144)' new PointF(76' 149)' new PointF(69' 162)' new PointF(51' 159)' new PointF(48' 147)' new PointF(42' 143)' new PointF(32' 136)' new PointF(32' 131)' new PointF(29' 117)' new PointF(28' 108)' new PointF(33' 105)' new PointF(27' 103)' new PointF(22' 91)' new PointF(22' 81) }' new string[] { "ca" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(39' 36)' new PointF(27' 69)' new PointF(72' 80)' new PointF(76' 62)' new PointF(73' 62)' new PointF(81' 52)' new PointF(79' 47)' new PointF(48' 44) }' new string[] { "or" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(39' 36)' new PointF(27' 69)' new PointF(72' 80)' new PointF(76' 62)' new PointF(73' 62)' new PointF(81' 52)' new PointF(79' 47)' new PointF(48' 44) }' new string[] { "or" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(39' 36)' new PointF(27' 69)' new PointF(72' 80)' new PointF(76' 62)' new PointF(73' 62)' new PointF(81' 52)' new PointF(79' 47)' new PointF(48' 44) }' new string[] { "or" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(39' 36)' new PointF(27' 69)' new PointF(72' 80)' new PointF(76' 62)' new PointF(73' 62)' new PointF(81' 52)' new PointF(79' 47)' new PointF(48' 44) }' new string[] { "or" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(39' 36)' new PointF(27' 69)' new PointF(72' 80)' new PointF(76' 62)' new PointF(73' 62)' new PointF(81' 52)' new PointF(79' 47)' new PointF(48' 44) }' new string[] { "or" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(39' 36)' new PointF(27' 69)' new PointF(72' 80)' new PointF(76' 62)' new PointF(73' 62)' new PointF(81' 52)' new PointF(79' 47)' new PointF(48' 44) }' new string[] { "or" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(39' 36)' new PointF(27' 69)' new PointF(72' 80)' new PointF(76' 62)' new PointF(73' 62)' new PointF(81' 52)' new PointF(79' 47)' new PointF(48' 44) }' new string[] { "or" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(39' 36)' new PointF(27' 69)' new PointF(72' 80)' new PointF(76' 62)' new PointF(73' 62)' new PointF(81' 52)' new PointF(79' 47)' new PointF(48' 44) }' new string[] { "or" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(39' 36)' new PointF(27' 69)' new PointF(72' 80)' new PointF(76' 62)' new PointF(73' 62)' new PointF(81' 52)' new PointF(79' 47)' new PointF(48' 44) }' new string[] { "or" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(39' 36)' new PointF(27' 69)' new PointF(72' 80)' new PointF(76' 62)' new PointF(73' 62)' new PointF(81' 52)' new PointF(79' 47)' new PointF(48' 44) }' new string[] { "or" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(39' 36)' new PointF(27' 69)' new PointF(72' 80)' new PointF(76' 62)' new PointF(73' 62)' new PointF(81' 52)' new PointF(79' 47)' new PointF(48' 44) }' new string[] { "or" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(39' 36)' new PointF(27' 69)' new PointF(72' 80)' new PointF(76' 62)' new PointF(73' 62)' new PointF(81' 52)' new PointF(79' 47)' new PointF(48' 44) }' new string[] { "or" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(39' 36)' new PointF(27' 69)' new PointF(72' 80)' new PointF(76' 62)' new PointF(73' 62)' new PointF(81' 52)' new PointF(79' 47)' new PointF(48' 44) }' new string[] { "or" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(39' 36)' new PointF(27' 69)' new PointF(72' 80)' new PointF(76' 62)' new PointF(73' 62)' new PointF(81' 52)' new PointF(79' 47)' new PointF(48' 44) }' new string[] { "or" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(39' 36)' new PointF(27' 69)' new PointF(72' 80)' new PointF(76' 62)' new PointF(73' 62)' new PointF(81' 52)' new PointF(79' 47)' new PointF(48' 44) }' new string[] { "or" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(39' 36)' new PointF(27' 69)' new PointF(72' 80)' new PointF(76' 62)' new PointF(73' 62)' new PointF(81' 52)' new PointF(79' 47)' new PointF(48' 44) }' new string[] { "or" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(53' 14)' new PointF(54' 24)' new PointF(49' 29)' new PointF(46' 27)' new PointF(48' 24)' new PointF(50' 21)' new PointF(43' 16)' new PointF(40' 34)' new PointF(45' 37)' new PointF(47' 43)' new PointF(79' 46)' new PointF(85' 22)' new PointF(53'14) }' new string[] { "wa" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(53' 14)' new PointF(54' 24)' new PointF(49' 29)' new PointF(46' 27)' new PointF(48' 24)' new PointF(50' 21)' new PointF(43' 16)' new PointF(40' 34)' new PointF(45' 37)' new PointF(47' 43)' new PointF(79' 46)' new PointF(85' 22)' new PointF(53'14) }' new string[] { "wa" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(53' 14)' new PointF(54' 24)' new PointF(49' 29)' new PointF(46' 27)' new PointF(48' 24)' new PointF(50' 21)' new PointF(43' 16)' new PointF(40' 34)' new PointF(45' 37)' new PointF(47' 43)' new PointF(79' 46)' new PointF(85' 22)' new PointF(53'14) }' new string[] { "wa" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(53' 14)' new PointF(54' 24)' new PointF(49' 29)' new PointF(46' 27)' new PointF(48' 24)' new PointF(50' 21)' new PointF(43' 16)' new PointF(40' 34)' new PointF(45' 37)' new PointF(47' 43)' new PointF(79' 46)' new PointF(85' 22)' new PointF(53'14) }' new string[] { "wa" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(53' 14)' new PointF(54' 24)' new PointF(49' 29)' new PointF(46' 27)' new PointF(48' 24)' new PointF(50' 21)' new PointF(43' 16)' new PointF(40' 34)' new PointF(45' 37)' new PointF(47' 43)' new PointF(79' 46)' new PointF(85' 22)' new PointF(53'14) }' new string[] { "wa" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(53' 14)' new PointF(54' 24)' new PointF(49' 29)' new PointF(46' 27)' new PointF(48' 24)' new PointF(50' 21)' new PointF(43' 16)' new PointF(40' 34)' new PointF(45' 37)' new PointF(47' 43)' new PointF(79' 46)' new PointF(85' 22)' new PointF(53'14) }' new string[] { "wa" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(53' 14)' new PointF(54' 24)' new PointF(49' 29)' new PointF(46' 27)' new PointF(48' 24)' new PointF(50' 21)' new PointF(43' 16)' new PointF(40' 34)' new PointF(45' 37)' new PointF(47' 43)' new PointF(79' 46)' new PointF(85' 22)' new PointF(53'14) }' new string[] { "wa" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(53' 14)' new PointF(54' 24)' new PointF(49' 29)' new PointF(46' 27)' new PointF(48' 24)' new PointF(50' 21)' new PointF(43' 16)' new PointF(40' 34)' new PointF(45' 37)' new PointF(47' 43)' new PointF(79' 46)' new PointF(85' 22)' new PointF(53'14) }' new string[] { "wa" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(53' 14)' new PointF(54' 24)' new PointF(49' 29)' new PointF(46' 27)' new PointF(48' 24)' new PointF(50' 21)' new PointF(43' 16)' new PointF(40' 34)' new PointF(45' 37)' new PointF(47' 43)' new PointF(79' 46)' new PointF(85' 22)' new PointF(53'14) }' new string[] { "wa" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(53' 14)' new PointF(54' 24)' new PointF(49' 29)' new PointF(46' 27)' new PointF(48' 24)' new PointF(50' 21)' new PointF(43' 16)' new PointF(40' 34)' new PointF(45' 37)' new PointF(47' 43)' new PointF(79' 46)' new PointF(85' 22)' new PointF(53'14) }' new string[] { "wa" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(53' 14)' new PointF(54' 24)' new PointF(49' 29)' new PointF(46' 27)' new PointF(48' 24)' new PointF(50' 21)' new PointF(43' 16)' new PointF(40' 34)' new PointF(45' 37)' new PointF(47' 43)' new PointF(79' 46)' new PointF(85' 22)' new PointF(53'14) }' new string[] { "wa" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(53' 14)' new PointF(54' 24)' new PointF(49' 29)' new PointF(46' 27)' new PointF(48' 24)' new PointF(50' 21)' new PointF(43' 16)' new PointF(40' 34)' new PointF(45' 37)' new PointF(47' 43)' new PointF(79' 46)' new PointF(85' 22)' new PointF(53'14) }' new string[] { "wa" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(53' 14)' new PointF(54' 24)' new PointF(49' 29)' new PointF(46' 27)' new PointF(48' 24)' new PointF(50' 21)' new PointF(43' 16)' new PointF(40' 34)' new PointF(45' 37)' new PointF(47' 43)' new PointF(79' 46)' new PointF(85' 22)' new PointF(53'14) }' new string[] { "wa" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(53' 14)' new PointF(54' 24)' new PointF(49' 29)' new PointF(46' 27)' new PointF(48' 24)' new PointF(50' 21)' new PointF(43' 16)' new PointF(40' 34)' new PointF(45' 37)' new PointF(47' 43)' new PointF(79' 46)' new PointF(85' 22)' new PointF(53'14) }' new string[] { "wa" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(53' 14)' new PointF(54' 24)' new PointF(49' 29)' new PointF(46' 27)' new PointF(48' 24)' new PointF(50' 21)' new PointF(43' 16)' new PointF(40' 34)' new PointF(45' 37)' new PointF(47' 43)' new PointF(79' 46)' new PointF(85' 22)' new PointF(53'14) }' new string[] { "wa" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(53' 14)' new PointF(54' 24)' new PointF(49' 29)' new PointF(46' 27)' new PointF(48' 24)' new PointF(50' 21)' new PointF(43' 16)' new PointF(40' 34)' new PointF(45' 37)' new PointF(47' 43)' new PointF(79' 46)' new PointF(85' 22)' new PointF(53'14) }' new string[] { "wa" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(53' 14)' new PointF(54' 24)' new PointF(49' 29)' new PointF(46' 27)' new PointF(48' 24)' new PointF(50' 21)' new PointF(43' 16)' new PointF(40' 34)' new PointF(45' 37)' new PointF(47' 43)' new PointF(79' 46)' new PointF(85' 22)' new PointF(53'14) }' new string[] { "wa" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(53' 14)' new PointF(54' 24)' new PointF(49' 29)' new PointF(46' 27)' new PointF(48' 24)' new PointF(50' 21)' new PointF(43' 16)' new PointF(40' 34)' new PointF(45' 37)' new PointF(47' 43)' new PointF(79' 46)' new PointF(85' 22)' new PointF(53'14) }' new string[] { "wa" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(53' 14)' new PointF(54' 24)' new PointF(49' 29)' new PointF(46' 27)' new PointF(48' 24)' new PointF(50' 21)' new PointF(43' 16)' new PointF(40' 34)' new PointF(45' 37)' new PointF(47' 43)' new PointF(79' 46)' new PointF(85' 22)' new PointF(53'14) }' new string[] { "wa" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(53' 14)' new PointF(54' 24)' new PointF(49' 29)' new PointF(46' 27)' new PointF(48' 24)' new PointF(50' 21)' new PointF(43' 16)' new PointF(40' 34)' new PointF(45' 37)' new PointF(47' 43)' new PointF(79' 46)' new PointF(85' 22)' new PointF(53'14) }' new string[] { "wa" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(53' 14)' new PointF(54' 24)' new PointF(49' 29)' new PointF(46' 27)' new PointF(48' 24)' new PointF(50' 21)' new PointF(43' 16)' new PointF(40' 34)' new PointF(45' 37)' new PointF(47' 43)' new PointF(79' 46)' new PointF(85' 22)' new PointF(53'14) }' new string[] { "wa" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(53' 14)' new PointF(54' 24)' new PointF(49' 29)' new PointF(46' 27)' new PointF(48' 24)' new PointF(50' 21)' new PointF(43' 16)' new PointF(40' 34)' new PointF(45' 37)' new PointF(47' 43)' new PointF(79' 46)' new PointF(85' 22)' new PointF(53'14) }' new string[] { "wa" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(53' 14)' new PointF(54' 24)' new PointF(49' 29)' new PointF(46' 27)' new PointF(48' 24)' new PointF(50' 21)' new PointF(43' 16)' new PointF(40' 34)' new PointF(45' 37)' new PointF(47' 43)' new PointF(79' 46)' new PointF(85' 22)' new PointF(53'14) }' new string[] { "wa" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(53' 14)' new PointF(54' 24)' new PointF(49' 29)' new PointF(46' 27)' new PointF(48' 24)' new PointF(50' 21)' new PointF(43' 16)' new PointF(40' 34)' new PointF(45' 37)' new PointF(47' 43)' new PointF(79' 46)' new PointF(85' 22)' new PointF(53'14) }' new string[] { "wa" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(53' 14)' new PointF(54' 24)' new PointF(49' 29)' new PointF(46' 27)' new PointF(48' 24)' new PointF(50' 21)' new PointF(43' 16)' new PointF(40' 34)' new PointF(45' 37)' new PointF(47' 43)' new PointF(79' 46)' new PointF(85' 22)' new PointF(53'14) }' new string[] { "wa" });
Magic Number,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,MapData,The following statement contains a magic number: AddPolygon(new PointF[] { new PointF(53' 14)' new PointF(54' 24)' new PointF(49' 29)' new PointF(46' 27)' new PointF(48' 24)' new PointF(50' 21)' new PointF(43' 16)' new PointF(40' 34)' new PointF(45' 37)' new PointF(47' 43)' new PointF(79' 46)' new PointF(85' 22)' new PointF(53'14) }' new string[] { "wa" });
Magic Number,fyiReporting.RDL,MapText,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,GetFont,The following statement contains a magic number: float size = (float)Math.Max(FontSize * scale' .25);
Magic Number,fyiReporting.RDL,DynamicExpression,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DynamicExpression.cs,DoParse,The following statement contains a magic number: try   			{  				_Expr = p.Parse(lu' _Source);  			}  			catch (Exception e)  			{  				_Expr = new ConstantError(e.Message);  				// Invalid expression  				rpt.rl.LogError(8' ErrorText(e.Message));  			}
Magic Number,fyiReporting.RDL,DynamicExpression,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DynamicExpression.cs,DoParse,The following statement contains a magic number: try  			{  				_Expr = _Expr.ConstantOptimization();  			}  			catch(Exception ex)  			{  				rpt.rl.LogError(4' "Expression:" + _Source + "\r\nConstant Optimization exception:\r\n" + ex.Message + "\r\nStack trace:\r\n" + ex.StackTrace );  			}
Magic Number,fyiReporting.RDL,DynamicExpression,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DynamicExpression.cs,Evaluate,The following statement contains a magic number: try   			{  				return _Expr.Evaluate(rpt' row);  			}  			catch (Exception e)  			{  				string err;  				if (e.InnerException != null)  					err = String.Format("Exception evaluating {0}.  {1}.  {2}"' _Source' e.Message' e.InnerException.Message);  				else  					err = String.Format("Exception evaluating {0}.  {1}"' _Source' e.Message);    				ReportError(rpt' 4' err);  				return null;  			}
Magic Number,fyiReporting.RDL,DynamicExpression,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DynamicExpression.cs,EvaluateString,The following statement contains a magic number: try   			{  				return _Expr.EvaluateString(rpt' row);  			}  			catch (Exception e)  			{	  				string err = String.Format("Exception evaluating {0}.  {1}"' _Source' e.Message);  				ReportError(rpt' 4' err);  				return null;  			}
Magic Number,fyiReporting.RDL,DynamicExpression,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DynamicExpression.cs,EvaluateDouble,The following statement contains a magic number: try   			{  				return _Expr.EvaluateDouble(rpt' row);  			}  			catch (Exception e)  			{	  				string err = String.Format("Exception evaluating {0}.  {1}"' _Source' e.Message);  				ReportError(rpt' 4' err);  				return double.NaN;  			}
Magic Number,fyiReporting.RDL,DynamicExpression,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DynamicExpression.cs,EvaluateDecimal,The following statement contains a magic number: try   			{  				return _Expr.EvaluateDecimal(rpt' row);  			}  			catch (Exception e)  			{	  				string err = String.Format("Exception evaluating {0}.  {1}"' _Source' e.Message);  				ReportError(rpt' 4' err);  				return decimal.MinValue;  			}
Magic Number,fyiReporting.RDL,DynamicExpression,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DynamicExpression.cs,EvaluateInt32,The following statement contains a magic number: try              {                  return _Expr.EvaluateInt32(rpt' row);              }              catch (Exception e)              {                  string err = String.Format("Exception evaluating {0}.  {1}"' _Source' e.Message);                  ReportError(rpt' 4' err);                  return int.MinValue;              }
Magic Number,fyiReporting.RDL,DynamicExpression,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DynamicExpression.cs,EvaluateDateTime,The following statement contains a magic number: try   			{  				return _Expr.EvaluateDateTime(rpt' row);  			}  			catch (Exception e)  			{	  				string err = String.Format("Exception evaluating {0}.  {1}"' _Source' e.Message);  				ReportError(rpt' 4' err);  				return DateTime.MinValue;  			}
Magic Number,fyiReporting.RDL,DynamicExpression,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DynamicExpression.cs,EvaluateBoolean,The following statement contains a magic number: try   			{  				return _Expr.EvaluateBoolean(rpt' row);  			}  			catch (Exception e)  			{	  				string err = String.Format("Exception evaluating {0}.  {1}"' _Source' e.Message);  				ReportError(rpt' 4' err);  				return false;  			}
Magic Number,fyiReporting.RDL,Corner,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Corner.cs,Corner,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "ReportItems":  						_ReportItems = new ReportItems(r' this' xNodeLoop);  						break;	  					default:	  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown Corner element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,CustomReportItem,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\CustomReportItem.cs,CustomReportItem,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Type":  						_Type = xNodeLoop.InnerText;  						break;  					case "ReportItems":         // Version 1 of the specification  						ris = new ReportItems(r' this' xNodeLoop);                          bVersion2 = false;  						break;                      case "AltReportItem":       // Verstion 2 of the specification                          ris = new ReportItems(r' this' xNodeLoop);                          break;                      case "CustomProperties":                          _Properties = CustomProperties(xNodeLoop);                          break;  					default:  						if (ReportItemElement(xNodeLoop))	// try at ReportItem level  							break;   						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown CustomReportItem element " + xNodeLoop.Name + " ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,CustomReportItem,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\CustomReportItem.cs,CustomReportItem,The following statement contains a magic number: if (bVersion2 && ris != null)              {  			    if (ris.Items.Count != 1)  				    OwnerReport.rl.LogError(8' "Only one element is allowed within an AltReportItem.");              }
Magic Number,fyiReporting.RDL,CustomReportItem,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\CustomReportItem.cs,CustomReportItem,The following statement contains a magic number: if (_Type == null)  				OwnerReport.rl.LogError(8' "CustomReportItem requires the Type element.");
Magic Number,fyiReporting.RDL,CustomReportItem,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\CustomReportItem.cs,FinalPass,The following statement contains a magic number: try              {                  cri = RdlEngineConfig.CreateCustomReportItem(_Type);              }              catch (Exception ex)              {   // Not an error since we'll simply use the ReportItems                  OwnerReport.rl.LogError(4' string.Format("CustomReportItem load of {0} failed: {1}"'                       _Type' ex.Message));              }              finally              {                  if (cri != null)                      cri.Dispose();              }
Magic Number,fyiReporting.RDL,CustomReportItem,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\CustomReportItem.cs,Run,The following statement contains a magic number: try              {                  cri = RdlEngineConfig.CreateCustomReportItem(_Type);                }              catch (Exception ex)              {                  rpt.rl.LogError(8' string.Format("Exception in CustomReportItem handling.\n{0}\n{1}"' ex.Message' ex.StackTrace));              }              finally              {                  if (cri != null)                      cri.Dispose();              }
Magic Number,fyiReporting.RDL,CustomReportItem,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\CustomReportItem.cs,RunPage,The following statement contains a magic number: try              {                  cri = RdlEngineConfig.CreateCustomReportItem(_Type);                  SetProperties(pgs.Report' row' cri);                                    int width = WidthCalc(rpt' pgs.G) -                       (Style == null? 0 :                          (Style.EvalPaddingLeftPx(rpt' row) + Style.EvalPaddingRightPx(rpt' row)));                  int height = RSize.PixelsFromPoints(this.HeightOrOwnerHeight) -                      (Style == null? 0 :                          (Style.EvalPaddingTopPx(rpt' row) + Style.EvalPaddingBottomPx(rpt' row)));                  bm = new Bitmap(width' height);                  cri.DrawImage(ref bm);                    MemoryStream ostrm = new MemoryStream();                  // 06122007AJM Changed to use high quality JPEG encoding                  //bm.Save(ostrm' IMAGEFORMAT);	// generate a jpeg   TODO: get png to work with pdf                  System.Drawing.Imaging.ImageCodecInfo[] info;                  info = ImageCodecInfo.GetImageEncoders();                  EncoderParameters encoderParameters;                  encoderParameters = new EncoderParameters(1);                  // 20022008 AJM GJL - Using centralised image quality                  encoderParameters.Param[0] = new EncoderParameter(Encoder.Quality' ImageQualityManager.CustomImageQuality);                  System.Drawing.Imaging.ImageCodecInfo codec = null;                  for (int i = 0; i < info.Length; i++)                  {                      if (info[i].FormatDescription == "JPEG")                      {                          codec = info[i];                          break;                      }                  }                  bm.Save(ostrm' codec' encoderParameters);                    byte[] ba = ostrm.ToArray();                  ostrm.Close();                  PageImage pi = new PageImage(IMAGEFORMAT' ba' width' height);	// Create an image                  pi.Sizing = ImageSizingEnum.Clip;  //                RunPageRegionBegin(pgs);                    SetPagePositionAndStyle(rpt' pi' row);                    if (pgs.CurrentPage.YOffset + pi.Y + pi.H >= pgs.BottomOfPage && !pgs.CurrentPage.IsEmpty())                  {	// force page break if it doesn't fit on the page                      pgs.NextOrNew();                      pgs.CurrentPage.YOffset = OwnerReport.TopOfPage;                      if (this.YParents != null)                          pi.Y = 0;                  }                    p = pgs.CurrentPage;                    p.AddObject(pi);	// Put image onto the current page      //              RunPageRegionEnd(pgs);  // I don't know why we need move offset after draw. If we do it' barcode if it first in list all text shifted.  // If it broken something' write to Gankov  /*                if (!this.PageBreakAtEnd && !IsTableOrMatrixCell(rpt))                  {                      float newY = pi.Y + pi.H;                      p.YOffset += newY;	// bump the y location                  } */                  SetPagePositionEnd(pgs' pi.Y + pi.H);              }              catch (Exception ex)              {                  rpt.rl.LogError(8' string.Format("Exception in CustomReportItem handling: {0}"' ex.Message));              }              finally              {                  if (cri != null)                      cri.Dispose();              }
Magic Number,fyiReporting.RDL,CustomReportItem,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\CustomReportItem.cs,SetProperties,The following statement contains a magic number: foreach (CustomProperty cp in _Properties)              {                  string name = cp.Name.EvaluateString(rpt' row);                  object val = cp.Value.Evaluate(rpt' row);                  try { dict.Add(name' val); }                  catch                  {                      rpt.rl.LogError(4' string.Format("Property {0} has already been set.  New value {1} ignored."' name' val));                  }              }
Magic Number,fyiReporting.RDL,CustomReportItem,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\CustomReportItem.cs,CustomProperties,The following statement contains a magic number: foreach (XmlNode xNodeLoop in xNode.ChildNodes)              {                  switch (xNodeLoop.Name)                  {                      case "CustomProperty":                          CustomProperty cp = CustomProperty(xNodeLoop);                          if (cp != null)                              cps.Add(cp);                          break;                      default:                          OwnerReport.rl.LogError(4' "Unknown CustomProperties element " + xNodeLoop.Name + " ignored.");                          break;                  }              }
Magic Number,fyiReporting.RDL,CustomReportItem,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\CustomReportItem.cs,CustomProperty,The following statement contains a magic number: foreach (XmlNode xNodeLoop in xNode.ChildNodes)              {                  switch (xNodeLoop.Name)                  {                      case "Name":                          name = new Expression(OwnerReport' this' xNodeLoop' ExpressionType.String);                          break;                      case "Value":                          val = new Expression(OwnerReport' this' xNodeLoop' ExpressionType.Variant);                          break;                      default:                          OwnerReport.rl.LogError(4' "Unknown CustomProperty element " + xNodeLoop.Name + " ignored.");                          break;                  }              }
Magic Number,fyiReporting.RDL,CustomReportItem,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\CustomReportItem.cs,CustomProperty,The following statement contains a magic number: if (name == null || val == null)                  OwnerReport.rl.LogError(8' "CustomProperty requires the Name and Value element.");              else              {                  cp = new CustomProperty(name' val);              }
Magic Number,fyiReporting.RDL,DataElementOutput,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataElementOutput.cs,GetStyle,The following statement contains a magic number: switch (s)  			{		  				case "Output":  					rs = DataElementOutputEnum.Output;  					break;  				case "NoOutput":  					rs = DataElementOutputEnum.NoOutput;  					break;  				case "ContentsOnly":  					rs = DataElementOutputEnum.ContentsOnly;  					break;  				case "Auto":  					rs = DataElementOutputEnum.Auto;  					break;  				default:		                      if (rl != null)  					    rl.LogError(4' "Unknown DataElementOutput '" + s + "'.  Auto assumed.");  					rs = DataElementOutputEnum.Auto;  					break;  			}
Magic Number,fyiReporting.RDL,DataElementStyle,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataElementStyle.cs,GetStyle,The following statement contains a magic number: switch (s)  			{		  				case "Auto":  					rs = DataElementStyleEnum.Auto;  					break;  				case "AttributeNormal":  					rs = DataElementStyleEnum.AttributeNormal;  					break;  				case "ElementNormal":  					rs = DataElementStyleEnum.ElementNormal;  					break;  				default:		                      if (rl != null)  					    rl.LogError(4' "Unknown DataElementStyle '" + s + "'.  AttributeNormal assumed.");  					rs = DataElementStyleEnum.AttributeNormal;  				    break;  			}
Magic Number,fyiReporting.RDL,DataInstanceElementOutput,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataInstanceElementOutput.cs,GetStyle,The following statement contains a magic number: switch (s)  			{		  				case "Output":  					rs = DataInstanceElementOutputEnum.Output;  					break;  				case "NoOutput":  					rs = DataInstanceElementOutputEnum.NoOutput;  					break;  				default:		                      if (rl != null)  					    rl.LogError(4' "Unknown DataInstanceElementOutput '" + s + "'.  Output assumed.");  					rs = DataInstanceElementOutputEnum.Output;  					break;  			}
Magic Number,fyiReporting.RDL,DataLabelPosition,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataLabelPosition.cs,GetStyle,The following statement contains a magic number: switch (s)  			{		  				case "Auto":  					dlp = DataLabelPositionEnum.Auto;  					break;  				case "Top":  					dlp = DataLabelPositionEnum.Top;  					break;  				case "TopLeft":  					dlp = DataLabelPositionEnum.TopLeft;  					break;  				case "TopRight":  					dlp = DataLabelPositionEnum.TopRight;  					break;  				case "Left":  					dlp = DataLabelPositionEnum.Left;  					break;  				case "Center":  					dlp = DataLabelPositionEnum.Center;  					break;  				case "Right":  					dlp = DataLabelPositionEnum.Right;  					break;  				case "BottomRight":  					dlp = DataLabelPositionEnum.BottomRight;  					break;  				case "Bottom":  					dlp = DataLabelPositionEnum.Bottom;  					break;  				case "BottomLeft":  					dlp = DataLabelPositionEnum.BottomLeft;  					break;  				default:		  					rl.LogError(4' "Unknown DataLablePosition '" + s + "'.  Auto assumed.");  					dlp = DataLabelPositionEnum.Auto;  					break;  			}
Magic Number,fyiReporting.RDL,DataPoint,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataPoint.cs,DataPoint,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "DataValues":  						_DataValues = new DataValues(r' this' xNodeLoop);  						break;  					case "DataLabel":  						_DataLabel = new DataLabel(r' this' xNodeLoop);  						break;  					case "Action":  						_Action = new Action(r' this' xNodeLoop);  						break;  					case "Style":  						_Style = new Style(r' this' xNodeLoop);  						break;  					case "Marker":  						_Marker = new Marker(r' this' xNodeLoop);  						break;  					case "DataElementName":  						_DataElementName = xNodeLoop.InnerText;  						break;  					case "DataElementOutput":  						_DataElementOutput = fyiReporting.RDL.DataElementOutput.GetStyle(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					default:	  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown DataPoint element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,DataPoint,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataPoint.cs,DataPoint,The following statement contains a magic number: if (_DataValues == null)  				OwnerReport.rl.LogError(8' "DataPoint requires the DataValues element.");
Magic Number,fyiReporting.RDL,DataPoints,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataPoints.cs,DataPoints,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "DataPoint":  						dp = new DataPoint(r' this' xNodeLoop);  						break;  					default:	  						dp=null;		// don't know what this is  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown DataPoints element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  				if (dp != null)  					_Items.Add(dp);  			}
Magic Number,fyiReporting.RDL,DataPoints,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataPoints.cs,DataPoints,The following statement contains a magic number: if (_Items.Count == 0)  				OwnerReport.rl.LogError(8' "For DataPoints at least one DataPoint is required.");  			else                  _Items.TrimExcess();
Magic Number,fyiReporting.RDL,DataRegion,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataRegion.cs,FinalPass,The following statement contains a magic number: if (this.InPageHeaderOrFooter())  				OwnerReport.rl.LogError(8' String.Format("The DataRegion '{0}' is not allowed in a PageHeader or PageFooter"' this.Name == null? "unknown": Name.Nm) );
Magic Number,fyiReporting.RDL,DataRegion,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataRegion.cs,FinalPass,The following statement contains a magic number: if (_ParentDataRegion != null)		// when nested we use the dataset of the parent  			{  				_DataSetDefn = _ParentDataRegion.DataSetDefn;  			}  			else if (_DataSetName != null)  			{  				if (OwnerReport.DataSetsDefn != null)  					_DataSetDefn = (DataSetDefn) OwnerReport.DataSetsDefn.Items[_DataSetName];  				if (_DataSetDefn == null)  				{  					OwnerReport.rl.LogError(8' String.Format("DataSetName '{0}' not specified in DataSets list."' _DataSetName));  				}  			}  			else  			{		// No name but maybe we can default to a single Dataset  				if (_DataSetDefn == null && OwnerReport.DataSetsDefn != null &&  					OwnerReport.DataSetsDefn.Items.Count == 1)  				{  					foreach (DataSetDefn d in OwnerReport.DataSetsDefn.Items.Values)   					{	  						_DataSetDefn = d;  						break;	// since there is only 1 this will obtain it  					}  				}  				if (_DataSetDefn == null)  					OwnerReport.rl.LogError(8' string.Format("{0} must specify a DataSetName."'this.Name == null? "DataRegions": this.Name.Nm));  			}
Magic Number,fyiReporting.RDL,DataRegion,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataRegion.cs,FinalPass,The following statement contains a magic number: if (_ParentDataRegion != null)		// when nested we use the dataset of the parent  			{  				_DataSetDefn = _ParentDataRegion.DataSetDefn;  			}  			else if (_DataSetName != null)  			{  				if (OwnerReport.DataSetsDefn != null)  					_DataSetDefn = (DataSetDefn) OwnerReport.DataSetsDefn.Items[_DataSetName];  				if (_DataSetDefn == null)  				{  					OwnerReport.rl.LogError(8' String.Format("DataSetName '{0}' not specified in DataSets list."' _DataSetName));  				}  			}  			else  			{		// No name but maybe we can default to a single Dataset  				if (_DataSetDefn == null && OwnerReport.DataSetsDefn != null &&  					OwnerReport.DataSetsDefn.Items.Count == 1)  				{  					foreach (DataSetDefn d in OwnerReport.DataSetsDefn.Items.Values)   					{	  						_DataSetDefn = d;  						break;	// since there is only 1 this will obtain it  					}  				}  				if (_DataSetDefn == null)  					OwnerReport.rl.LogError(8' string.Format("{0} must specify a DataSetName."'this.Name == null? "DataRegions": this.Name.Nm));  			}
Magic Number,fyiReporting.RDL,DataRegion,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataRegion.cs,GetFilteredData,The following statement contains a magic number: try  			{  				Rows data;  				if (this._Filters == null)  				{  					if (this._ParentDataRegion == null)  					{  						data = DataSetDefn.Query.GetMyData(rpt);  						return data == null? null: new Rows(rpt' data);	// We need to copy in case DataSet is shared by multiple DataRegions  					}  					else  						return GetNestedData(rpt' row);  				}    				if (this._ParentDataRegion == null)  				{  					data = DataSetDefn.Query.GetMyData(rpt);  					if (data != null)  						data = new Rows(rpt' data);  				}  				else  					data = GetNestedData(rpt' row);    				if (data == null)  					return null;    				List<Row> ar = new List<Row>();  				foreach (Row r in data.Data)  				{  					if (_Filters.Apply(rpt' r))  						ar.Add(r);  				}                  ar.TrimExcess();  				data.Data = ar;  				_Filters.ApplyFinalFilters(rpt' data' true);    				// Adjust the rowcount  				int rCount = 0;  				foreach (Row r in ar)  				{  					r.RowNumber = rCount++;  				}  				return data;  			}  			catch (Exception e)  			{  				this.OwnerReport.rl.LogError(8' e.Message);  				return null;  			}
Magic Number,fyiReporting.RDL,DataRegion,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataRegion.cs,DataRegionFinish,The following statement contains a magic number: if (this.Name != null)  			{  				try  				{  					OwnerReport.LUAggrScope.Add(this.Name.Nm' this);		// add to referenceable regions  				}  				catch // wish duplicate had its own exception  				{  					OwnerReport.rl.LogError(8' "Duplicate name '" + this.Name.Nm + "'.");  				}  			}
Magic Number,fyiReporting.RDL,DataSetDefn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataSetDefn.cs,DataSetDefn,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Fields":  						_Fields = new Fields(r' this' xNodeLoop);  						break;  					case "Query":  						_Query = new Query(r' this' xNodeLoop);  						break;  					case "Rows":	// Extension !!!!!!!!!!!!!!!!!!!!!!!  					case "fyi:Rows":  						_XmlRowData = "<?xml version='1.0' encoding='UTF-8'?><Rows>" + xNodeLoop.InnerXml + "</Rows>";  						foreach(XmlAttribute xA in xNodeLoop.Attributes)  						{  							if (xA.Name == "File")  								_XmlRowFile = xA.Value;  						}  						break;  					case "CaseSensitivity":  						_CaseSensitivity = TrueFalseAuto.GetStyle(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "Collation":  						_Collation = xNodeLoop.InnerText;  						break;  					case "AccentSensitivity":  						_AccentSensitivity = TrueFalseAuto.GetStyle(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "KanatypeSensitivity":  						_KanatypeSensitivity = TrueFalseAuto.GetStyle(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "WidthSensitivity":  						_WidthSensitivity = TrueFalseAuto.GetStyle(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "Filters":  						_Filters = new Filters(r' this' xNodeLoop);  						break;  					default:  						OwnerReport.rl.LogError(4' "Unknown DataSet element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,DataSetDefn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataSetDefn.cs,DataSetDefn,The following statement contains a magic number: if (this.Name != null)  				OwnerReport.LUAggrScope.Add(this.Name.Nm' this);		// add to referenceable TextBoxes  			else  				OwnerReport.rl.LogError(4' "Name attribute must be specified in a DataSet.");
Magic Number,fyiReporting.RDL,DataSetDefn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataSetDefn.cs,DataSetDefn,The following statement contains a magic number: if (_Query == null)  				OwnerReport.rl.LogError(8' "Query element must be specified in a DataSet.");
Magic Number,fyiReporting.RDL,DataSetDefn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataSetDefn.cs,GetDataFile,The following statement contains a magic number: try  			{  				fs = new StreamReader(fullpath);  				d = fs.ReadToEnd();  			}  			catch (FileNotFoundException fe)  			{  				rpt.rl.LogError(4' string.Format("XML data file {0} not found.\n{1}"' fullpath' fe.StackTrace));  				d = null;  			}  			catch (Exception ge)  			{  				rpt.rl.LogError(4' string.Format("XML data file error {0}\n{1}\n{2}"' fullpath' ge.Message' ge.StackTrace));  				d = null;  			}  			finally  			{  				if (fs != null)  					fs.Close();  			}
Magic Number,fyiReporting.RDL,DataSetDefn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataSetDefn.cs,GetDataFile,The following statement contains a magic number: try  			{  				fs = new StreamReader(fullpath);  				d = fs.ReadToEnd();  			}  			catch (FileNotFoundException fe)  			{  				rpt.rl.LogError(4' string.Format("XML data file {0} not found.\n{1}"' fullpath' fe.StackTrace));  				d = null;  			}  			catch (Exception ge)  			{  				rpt.rl.LogError(4' string.Format("XML data file error {0}\n{1}\n{2}"' fullpath' ge.Message' ge.StackTrace));  				d = null;  			}  			finally  			{  				if (fs != null)  					fs.Close();  			}
Magic Number,fyiReporting.RDL,DataSetReference,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataSetReference.cs,DataSetReference,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "DataSetName":  						_DataSetName = xNodeLoop.InnerText;  						break;  					case "ValueField":  						_ValueField = xNodeLoop.InnerText;  						break;  					case "LabelField":  						_LabelField = xNodeLoop.InnerText;  						break;  					default:  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown DataSetReference element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,DataSetReference,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataSetReference.cs,DataSetReference,The following statement contains a magic number: if (_DataSetName == null)  				OwnerReport.rl.LogError(8' "DataSetReference DataSetName is required but not specified.");
Magic Number,fyiReporting.RDL,DataSetReference,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataSetReference.cs,DataSetReference,The following statement contains a magic number: if (_ValueField == null)  				OwnerReport.rl.LogError(8' "DataSetReference ValueField is required but not specified for" + _DataSetName==null? "<unknown name>": _DataSetName);
Magic Number,fyiReporting.RDL,DataSetReference,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataSetReference.cs,FinalPass,The following statement contains a magic number: if (_ds == null)  				OwnerReport.rl.LogError(8' "DataSetReference refers to unknown data set '" + _DataSetName + "'");  			else  			{  				_vField = _ds.Fields[_ValueField];  				if (_vField == null)  					OwnerReport.rl.LogError(8' "ValueField refers to unknown field '" + _ValueField + "'");  				else  				{  					if (_LabelField == null)  						_lField = _vField;  					else  					{  						_lField = _ds.Fields[_LabelField];  						if (_lField == null)  							OwnerReport.rl.LogError(8' "LabelField refers to unknown field '" + _LabelField + "'");  					}  				}  			}
Magic Number,fyiReporting.RDL,DataSetReference,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataSetReference.cs,FinalPass,The following statement contains a magic number: if (_ds == null)  				OwnerReport.rl.LogError(8' "DataSetReference refers to unknown data set '" + _DataSetName + "'");  			else  			{  				_vField = _ds.Fields[_ValueField];  				if (_vField == null)  					OwnerReport.rl.LogError(8' "ValueField refers to unknown field '" + _ValueField + "'");  				else  				{  					if (_LabelField == null)  						_lField = _vField;  					else  					{  						_lField = _ds.Fields[_LabelField];  						if (_lField == null)  							OwnerReport.rl.LogError(8' "LabelField refers to unknown field '" + _LabelField + "'");  					}  				}  			}
Magic Number,fyiReporting.RDL,DataSetReference,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataSetReference.cs,FinalPass,The following statement contains a magic number: if (_ds == null)  				OwnerReport.rl.LogError(8' "DataSetReference refers to unknown data set '" + _DataSetName + "'");  			else  			{  				_vField = _ds.Fields[_ValueField];  				if (_vField == null)  					OwnerReport.rl.LogError(8' "ValueField refers to unknown field '" + _ValueField + "'");  				else  				{  					if (_LabelField == null)  						_lField = _vField;  					else  					{  						_lField = _ds.Fields[_LabelField];  						if (_lField == null)  							OwnerReport.rl.LogError(8' "LabelField refers to unknown field '" + _LabelField + "'");  					}  				}  			}
Magic Number,fyiReporting.RDL,DataSetsDefn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataSetsDefn.cs,DataSetsDefn,The following statement contains a magic number: if (xNode.ChildNodes.Count < 10)  				_Items = new ListDictionary();	// Hashtable is overkill for small lists  			else  				_Items = new Hashtable(xNode.ChildNodes.Count);
Magic Number,fyiReporting.RDL,DataSourceDefn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataSourceDefn.cs,DataSourceDefn,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Transaction":  						_Transaction = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "ConnectionProperties":  						_ConnectionProperties = new ConnectionProperties(r' this' xNodeLoop);  						break;  					case "DataSourceReference":  						_DataSourceReference = xNodeLoop.InnerText;  						break;  					default:  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown DataSource element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,DataSourceDefn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataSourceDefn.cs,DataSourceDefn,The following statement contains a magic number: if (_Name == null)  				OwnerReport.rl.LogError(8' "DataSource Name is required but not specified.");  			else if (_ConnectionProperties == null && _DataSourceReference == null)  				OwnerReport.rl.LogError(8' string.Format("Either ConnectionProperties or DataSourceReference must be specified for DataSource {0}."' this._Name.Nm));  			else if (_ConnectionProperties != null && _DataSourceReference != null)  				OwnerReport.rl.LogError(8' string.Format("Either ConnectionProperties or DataSourceReference must be specified for DataSource {0} but not both."' this._Name.Nm));
Magic Number,fyiReporting.RDL,DataSourceDefn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataSourceDefn.cs,DataSourceDefn,The following statement contains a magic number: if (_Name == null)  				OwnerReport.rl.LogError(8' "DataSource Name is required but not specified.");  			else if (_ConnectionProperties == null && _DataSourceReference == null)  				OwnerReport.rl.LogError(8' string.Format("Either ConnectionProperties or DataSourceReference must be specified for DataSource {0}."' this._Name.Nm));  			else if (_ConnectionProperties != null && _DataSourceReference != null)  				OwnerReport.rl.LogError(8' string.Format("Either ConnectionProperties or DataSourceReference must be specified for DataSource {0} but not both."' this._Name.Nm));
Magic Number,fyiReporting.RDL,DataSourceDefn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataSourceDefn.cs,DataSourceDefn,The following statement contains a magic number: if (_Name == null)  				OwnerReport.rl.LogError(8' "DataSource Name is required but not specified.");  			else if (_ConnectionProperties == null && _DataSourceReference == null)  				OwnerReport.rl.LogError(8' string.Format("Either ConnectionProperties or DataSourceReference must be specified for DataSource {0}."' this._Name.Nm));  			else if (_ConnectionProperties != null && _DataSourceReference != null)  				OwnerReport.rl.LogError(8' string.Format("Either ConnectionProperties or DataSourceReference must be specified for DataSource {0} but not both."' this._Name.Nm));
Magic Number,fyiReporting.RDL,DataSourceDefn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataSourceDefn.cs,ConnectDataSource,The following statement contains a magic number: try   			{  				cn = RdlEngineConfig.GetConnection(_ConnectionProperties.DataProvider'    					_ConnectionProperties.Connectstring(rpt));  				if (cn != null)  				{  					cn.Open();  					rc = true;										     				}  			}  			catch(Exception e)  			{  				string err = string.Format("DataSource '{0}'.\r\n{1}"' _Name'  					e.InnerException == null? e.Message: e.InnerException.Message);  				if (rpt == null)  					OwnerReport.rl.LogError(4' err);	// error occurred during parse phase  				else  					rpt.rl.LogError(4' err);  				if (cn != null)  				{  					cn.Close();  					cn = null;  				}  			}
Magic Number,fyiReporting.RDL,DataSourceDefn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataSourceDefn.cs,ConnectDataSource,The following statement contains a magic number: try   			{  				cn = RdlEngineConfig.GetConnection(_ConnectionProperties.DataProvider'    					_ConnectionProperties.Connectstring(rpt));  				if (cn != null)  				{  					cn.Open();  					rc = true;										     				}  			}  			catch(Exception e)  			{  				string err = string.Format("DataSource '{0}'.\r\n{1}"' _Name'  					e.InnerException == null? e.Message: e.InnerException.Message);  				if (rpt == null)  					OwnerReport.rl.LogError(4' err);	// error occurred during parse phase  				else  					rpt.rl.LogError(4' err);  				if (cn != null)  				{  					cn.Close();  					cn = null;  				}  			}
Magic Number,fyiReporting.RDL,DataSourceDefn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataSourceDefn.cs,ConnectDataSource,The following statement contains a magic number: if (cn != null)  				SetSysConnection(rpt' cn);  			else  			{  				string err = string.Format("Unable to connect to datasource '{0}'."' _Name.Nm);  				if (rpt == null)  					OwnerReport.rl.LogError(4' err);	// error occurred during parse phase  				else  					rpt.rl.LogError(4' err);  			}
Magic Number,fyiReporting.RDL,DataSourceDefn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataSourceDefn.cs,ConnectDataSource,The following statement contains a magic number: if (cn != null)  				SetSysConnection(rpt' cn);  			else  			{  				string err = string.Format("Unable to connect to datasource '{0}'."' _Name.Nm);  				if (rpt == null)  					OwnerReport.rl.LogError(4' err);	// error occurred during parse phase  				else  					rpt.rl.LogError(4' err);  			}
Magic Number,fyiReporting.RDL,DataSourceDefn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataSourceDefn.cs,ConnectDataSourceReference,The following statement contains a magic number: try  			{  				string file;  				string folder = rpt == null? OwnerReport.ParseFolder: rpt.Folder;                  if (folder == null)                  {   // didn't specify folder; check to see if we have a fully formed name                       if (!_DataSourceReference.EndsWith(".dsr"' StringComparison.InvariantCultureIgnoreCase))                          file = _DataSourceReference + ".dsr";                      else                          file = _DataSourceReference;                  }                  else if (_DataSourceReference[0] != Path.DirectorySeparatorChar)                      file = folder + Path.DirectorySeparatorChar + _DataSourceReference + ".dsr";                  else                      file = folder + _DataSourceReference + ".dsr";    				string pswd = OwnerReport.GetDataSourceReferencePassword == null?   									null: OwnerReport.GetDataSourceReferencePassword();  				if (pswd == null)  					throw new Exception(Strings.DataSourceDefn_Error_NoPasswordForDSR);    				string xml = RDL.DataSourceReference.Retrieve(file' pswd);  				XmlDocument xDoc = new XmlDocument();  				xDoc.LoadXml(xml);  				XmlNode xNodeLoop = xDoc.FirstChild;  				  				_ConnectionProperties = new ConnectionProperties(OwnerReport' this' xNodeLoop);  				_ConnectionProperties.FinalPass();  			}  			catch (Exception e)  			{  				OwnerReport.rl.LogError(4' e.Message);  				_ConnectionProperties = null;  			}
Magic Number,fyiReporting.RDL,DataSourceDefn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataSourceDefn.cs,CleanUp,The following statement contains a magic number: try   			{  				cn.Close();  				// cn.Dispose();		// not good for connection pooling  			}  			catch (Exception ex)   			{	// report the error but keep going  				if (rpt != null)  					rpt.rl.LogError(4' string.Format("Error closing connection. {0}"' ex.Message));  				else  					this.OwnerReport.rl.LogError(4' string.Format("Error closing connection. {0}"' ex.Message));  			}
Magic Number,fyiReporting.RDL,DataSourceDefn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataSourceDefn.cs,CleanUp,The following statement contains a magic number: try   			{  				cn.Close();  				// cn.Dispose();		// not good for connection pooling  			}  			catch (Exception ex)   			{	// report the error but keep going  				if (rpt != null)  					rpt.rl.LogError(4' string.Format("Error closing connection. {0}"' ex.Message));  				else  					this.OwnerReport.rl.LogError(4' string.Format("Error closing connection. {0}"' ex.Message));  			}
Magic Number,fyiReporting.RDL,DataSourceReference,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataSourceReference.cs,Create,The following statement contains a magic number: try  			{  				ms = new MemoryStream(1000);	// memory stream to put encrypted data to  				cs = new CryptoStream(ms' rm.CreateEncryptor(key' salt)' CryptoStreamMode.Write);  				byte[] ta = Encoding.UTF8.GetBytes(indata);  				cs.Write(ta' 0' ta.Length);  			}  			finally  			{  				if (cs != null)  					cs.Close();  				if (ms != null)  					ms.Close();  			}
Magic Number,fyiReporting.RDL,DataSourceReference,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataSourceReference.cs,Retrieve,The following statement contains a magic number: try  			{  				ms = new MemoryStream(enc);		// memory stream to read encrypted data from  				ms2 = new MemoryStream();		// decrypted memory stream  				cs = new CryptoStream(ms' rm.CreateDecryptor(key' salt)' CryptoStreamMode.Read);  				byte[] ta = new byte[256];  				int count=0;  				while (true)  				{  					count = cs.Read(ta' 0' ta.Length);  					if (count <= 0)  						break;  					ms2.Write(ta' 0' count);  				}  				ta = ms2.ToArray();  				outdata = Encoding.UTF8.GetString(ta);  			}  			finally  			{  				if (cs != null)  					cs.Close();  				if (ms != null)  					ms.Close();  				if (ms2 != null)  					ms2.Close();  			}
Magic Number,fyiReporting.RDL,DataSourcesDefn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataSourcesDefn.cs,DataSourcesDefn,The following statement contains a magic number: if (_Items.Count == 0)  				OwnerReport.rl.LogError(8' "For DataSources at least one DataSource is required.");
Magic Number,fyiReporting.RDL,DataType,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataType.cs,GetStyle,The following statement contains a magic number: if (s.StartsWith("System."))  				s = s.Substring(7);
Magic Number,fyiReporting.RDL,DataType,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataType.cs,GetStyle,The following statement contains a magic number: switch (s)  			{		  				case "Boolean":  					rs = TypeCode.Boolean;  					break;  				case "DateTime":  					rs = TypeCode.DateTime;  					break;  				case "Decimal":  					rs = TypeCode.Decimal;  					break;                  case "Byte":  				case "Integer":  				case "Int16":  				case "Int32":  					rs = TypeCode.Int32;  					break;     				case "Int64":  					rs = TypeCode.Int64;  					break;                  case "UInt16":                  case "UInt32":                      rs = TypeCode.UInt32;                      break;                  case "UInt64":                      rs = TypeCode.UInt64;                      break;     				case "Float":  				case "Single":  				case "Double":  					rs = TypeCode.Double;  					break;  				case "String":  				case "Char":  					rs = TypeCode.String;  					break;                  case "Object":  				case "TimeSpan":                      rs = TypeCode.Object;  					break;  				default:		// user error  					rs = TypeCode.Object;                      if (r != null)  					    r.rl.LogError(4' string.Format("'{0}' is not a recognized type' assuming System.Object."' s));  					break;  			}
Magic Number,fyiReporting.RDL,DataValue,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataValue.cs,DataValue,The following statement contains a magic number: if (_Value == null)  				OwnerReport.rl.LogError(8' "DataValue requires the Value element.");
Magic Number,fyiReporting.RDL,DataValues,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataValues.cs,DataValues,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "DataValue":  						dv = new DataValue(r' this' xNodeLoop);  						break;  					default:	  						dv=null;		// don't know what this is  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown DataValues element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  				if (dv != null)  					_Items.Add(dv);  			}
Magic Number,fyiReporting.RDL,DataValues,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataValues.cs,DataValues,The following statement contains a magic number: if (_Items.Count == 0)  				OwnerReport.rl.LogError(8' "For DataValues at least one DataValue is required.");  			else                  _Items.TrimExcess();
Magic Number,fyiReporting.RDL,Details,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Details.cs,Details,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "TableRows":  						_TableRows = new TableRows(r' this' xNodeLoop);  						break;  					case "Grouping":  						_Grouping = new Grouping(r' this' xNodeLoop);  						break;  					case "Sorting":  						_Sorting = new Sorting(r' this' xNodeLoop);  						break;  					case "Visibility":  						_Visibility = new Visibility(r' this' xNodeLoop);  						break;  					default:  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown Details element " + xNodeLoop.Name + " ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,Details,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Details.cs,Details,The following statement contains a magic number: if (_TableRows == null)  				OwnerReport.rl.LogError(8' "Details requires the TableRows element.");
Magic Number,fyiReporting.RDL,Drillthrough,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Drillthrough.cs,Drillthrough,The following statement contains a magic number: if (_ReportName == null)  				OwnerReport.rl.LogError(8' "Drillthrough requires the ReportName element.");
Magic Number,fyiReporting.RDL,DrillthroughParameter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DrillthroughParameter.cs,DrillthroughParameter,The following statement contains a magic number: if (_Name == null)  			{	// Name is required for parameters  				OwnerReport.rl.LogError(8' "Parameter Name attribute required.'");  			}
Magic Number,fyiReporting.RDL,DrillthroughParameter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DrillthroughParameter.cs,DrillthroughParameter,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Value":  						_Value = new Expression(r' this' xNodeLoop' ExpressionType.Variant);  						break;  					case "Omit":  						_Omit = new Expression(r' this' xNodeLoop' ExpressionType.Boolean);  						break;  					default:  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown Parameter element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,DrillthroughParameters,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DrillthroughParameters.cs,DrillthroughParameters,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Parameter":  						d = new DrillthroughParameter(r' this' xNodeLoop);  						break;  					default:	  						d=null;		// don't know what this is  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown Parameters element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  				if (d != null)  					_Items.Add(d);  			}
Magic Number,fyiReporting.RDL,DynamicCategories,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DynamicCategories.cs,DynamicCategories,The following statement contains a magic number: if (_Grouping == null)  				OwnerReport.rl.LogError(8' "DynamicCategories requires the Grouping element.");
Magic Number,fyiReporting.RDL,DynamicColumns,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DynamicColumns.cs,DynamicColumns,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Grouping":  						_Grouping = new Grouping(r' this' xNodeLoop);  						break;  					case "Sorting":  						_Sorting = new Sorting(r' this' xNodeLoop);  						break;  					case "Subtotal":  						_Subtotal = new Subtotal(r' this' xNodeLoop);  						break;  					case "ReportItems":  						_ReportItems = new ReportItems(r' this' xNodeLoop);  						break;  					case "Visibility":  						_Visibility = new Visibility(r' this' xNodeLoop);  						break;  					default:  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown DynamicColumn element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,DynamicColumns,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DynamicColumns.cs,DynamicColumns,The following statement contains a magic number: if (_Grouping == null)  				OwnerReport.rl.LogError(8' "DynamicColumns requires the Grouping element.");
Magic Number,fyiReporting.RDL,DynamicColumns,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DynamicColumns.cs,DynamicColumns,The following statement contains a magic number: if (_ReportItems == null || _ReportItems.Items.Count != 1)  				OwnerReport.rl.LogError(8' "DynamicColumns requires the ReportItems element defined with exactly one report item.");
Magic Number,fyiReporting.RDL,DynamicRows,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DynamicRows.cs,DynamicRows,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Grouping":  						_Grouping = new Grouping(r' this' xNodeLoop);  						break;  					case "Sorting":  						_Sorting = new Sorting(r' this' xNodeLoop);  						break;  					case "Subtotal":  						_Subtotal = new Subtotal(r' this' xNodeLoop);  						break;  					case "ReportItems":  						_ReportItems = new ReportItems(r' this' xNodeLoop);  						break;  					case "Visibility":  						_Visibility = new Visibility(r' this' xNodeLoop);  						break;  					default:	  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown DynamicRow element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,DynamicRows,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DynamicRows.cs,DynamicRows,The following statement contains a magic number: if (_Grouping == null)  				OwnerReport.rl.LogError(8' "DynamicRows requires the Grouping element.");
Magic Number,fyiReporting.RDL,DynamicRows,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DynamicRows.cs,DynamicRows,The following statement contains a magic number: if (_ReportItems == null || _ReportItems.Items.Count != 1)  				OwnerReport.rl.LogError(8' "DynamicRows requires the ReportItems element defined with exactly one report item.");
Magic Number,fyiReporting.RDL,DynamicSeries,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DynamicSeries.cs,DynamicSeries,The following statement contains a magic number: if (_Grouping == null)  				OwnerReport.rl.LogError(8' "DynamicSeries requires the Grouping element.");
Magic Number,fyiReporting.RDL,DynamicSeries,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DynamicSeries.cs,DynamicSeries,The following statement contains a magic number: if (_Label == null)  				OwnerReport.rl.LogError(8' "DynamicSeries requires the Label element.");
Magic Number,fyiReporting.RDL,EmbeddedImage,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EmbeddedImage.cs,EmbeddedImage,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "MIMEType":  						_MIMEType = xNodeLoop.InnerText;  						break;  					case "ImageData":  						_ImageData = xNodeLoop.InnerText;  						break;  					default:	  						this.OwnerReport.rl.LogError(4' "Unknown Report element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,EmbeddedImage,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EmbeddedImage.cs,EmbeddedImage,The following statement contains a magic number: if (this.Name == null)  			{  				OwnerReport.rl.LogError(8' "EmbeddedImage Name is required but not specified.");  			}  			else  			{  				try  				{  					OwnerReport.LUEmbeddedImages.Add(this.Name.Nm' this);		// add to referenceable embedded images  				}  				catch		// Duplicate name  				{  					OwnerReport.rl.LogError(4' "Duplicate EmbeddedImage  name '" + this.Name.Nm + "' ignored.");  				}  			}
Magic Number,fyiReporting.RDL,EmbeddedImage,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EmbeddedImage.cs,EmbeddedImage,The following statement contains a magic number: if (this.Name == null)  			{  				OwnerReport.rl.LogError(8' "EmbeddedImage Name is required but not specified.");  			}  			else  			{  				try  				{  					OwnerReport.LUEmbeddedImages.Add(this.Name.Nm' this);		// add to referenceable embedded images  				}  				catch		// Duplicate name  				{  					OwnerReport.rl.LogError(4' "Duplicate EmbeddedImage  name '" + this.Name.Nm + "' ignored.");  				}  			}
Magic Number,fyiReporting.RDL,EmbeddedImage,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EmbeddedImage.cs,EmbeddedImage,The following statement contains a magic number: if (_MIMEType == null)  				OwnerReport.rl.LogError(8' "EmbeddedImage MIMEType is required but not specified for " + (this.Name == null? "'name not specified'": this.Name.Nm));
Magic Number,fyiReporting.RDL,EmbeddedImage,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EmbeddedImage.cs,EmbeddedImage,The following statement contains a magic number: if (_ImageData == null)  				OwnerReport.rl.LogError(8' "EmbeddedImage ImageData is required but not specified for " + (this.Name == null? "'name not specified'": this.Name.Nm));
Magic Number,fyiReporting.RDL,EmbeddedImages,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EmbeddedImages.cs,EmbeddedImages,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				if (xNodeLoop.Name == "EmbeddedImage")  				{  					EmbeddedImage ei = new EmbeddedImage(r' this' xNodeLoop);  					_Items.Add(ei);  				}  				else  					this.OwnerReport.rl.LogError(4' "Unknown Report element '" + xNodeLoop.Name + "' ignored.");  			}
Magic Number,fyiReporting.RDL,EmbeddedImages,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EmbeddedImages.cs,EmbeddedImages,The following statement contains a magic number: if (_Items.Count == 0)  				OwnerReport.rl.LogError(8' "For EmbeddedImages at least one EmbeddedImage is required.");  			else                  _Items.TrimExcess();
Magic Number,fyiReporting.RDL,Comment,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\Comment.cs,Process,The following statement contains a magic number: try              {                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                    Byte[] PrivateData = _br.ReadBytes(RecordData.Length);                  //Ok we should have our private data which I am storing my tooltip value in...                  //now lets interpret it...                              string PData = new System.Text.ASCIIEncoding().GetString(PrivateData);                  //If string starts with "ToolTip" then lets do something with it.. otherwise I don't care about it.                  if (PData.StartsWith("ToolTip"))                  {                      PageRectangle pr = new PageRectangle();                      StyleInfo si = new StyleInfo();                      pr.SI = si;                      //si.BackgroundColor = Color.Blue;// Just a test to see where the tooltip is being drawn                      string[] ttd = PData.Split('|');                      pr.Tooltip = ttd[0].Split(':')[1];                      pr.X = X + Single.Parse(ttd[1].Split(':')[1]) * SCALEFACTOR;                      pr.Y = Y + Single.Parse(ttd[2].Split(':')[1]) * SCALEFACTOR;                      pr.W = Single.Parse(ttd[3].Split(':')[1]) * SCALEFACTOR;                      pr.H = Single.Parse(ttd[4].Split(':')[1]) * SCALEFACTOR;                      items.Add(pr);                  }                  else if (PData.StartsWith("PolyToolTip"))                  {                      PagePolygon pp = new PagePolygon();                      StyleInfo si = new StyleInfo();                      pp.SI = si;                      //si.BackgroundColor = Color.Blue;// Just a test to see where the tooltip is being drawn                      string[] ttd = PData.Split('|');                      PointF[] pts = new PointF[(ttd.Length - 1) / 2];                      pp.Points = pts;                      pp.Tooltip = ttd[0].Split(':')[1];                      for (int i = 0; i < pts.Length; i++)                      {                          pts[i].X = X + Single.Parse(ttd[i*2 +1]) * SCALEFACTOR;                          pts[i].Y = Y + Single.Parse(ttd[i*2 +2]) * SCALEFACTOR;                      }                      items.Add(pp);                  }                  return items;              }                finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                }
Magic Number,fyiReporting.RDL,Comment,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\Comment.cs,Process,The following statement contains a magic number: try              {                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                    Byte[] PrivateData = _br.ReadBytes(RecordData.Length);                  //Ok we should have our private data which I am storing my tooltip value in...                  //now lets interpret it...                              string PData = new System.Text.ASCIIEncoding().GetString(PrivateData);                  //If string starts with "ToolTip" then lets do something with it.. otherwise I don't care about it.                  if (PData.StartsWith("ToolTip"))                  {                      PageRectangle pr = new PageRectangle();                      StyleInfo si = new StyleInfo();                      pr.SI = si;                      //si.BackgroundColor = Color.Blue;// Just a test to see where the tooltip is being drawn                      string[] ttd = PData.Split('|');                      pr.Tooltip = ttd[0].Split(':')[1];                      pr.X = X + Single.Parse(ttd[1].Split(':')[1]) * SCALEFACTOR;                      pr.Y = Y + Single.Parse(ttd[2].Split(':')[1]) * SCALEFACTOR;                      pr.W = Single.Parse(ttd[3].Split(':')[1]) * SCALEFACTOR;                      pr.H = Single.Parse(ttd[4].Split(':')[1]) * SCALEFACTOR;                      items.Add(pr);                  }                  else if (PData.StartsWith("PolyToolTip"))                  {                      PagePolygon pp = new PagePolygon();                      StyleInfo si = new StyleInfo();                      pp.SI = si;                      //si.BackgroundColor = Color.Blue;// Just a test to see where the tooltip is being drawn                      string[] ttd = PData.Split('|');                      PointF[] pts = new PointF[(ttd.Length - 1) / 2];                      pp.Points = pts;                      pp.Tooltip = ttd[0].Split(':')[1];                      for (int i = 0; i < pts.Length; i++)                      {                          pts[i].X = X + Single.Parse(ttd[i*2 +1]) * SCALEFACTOR;                          pts[i].Y = Y + Single.Parse(ttd[i*2 +2]) * SCALEFACTOR;                      }                      items.Add(pp);                  }                  return items;              }                finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                }
Magic Number,fyiReporting.RDL,Comment,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\Comment.cs,Process,The following statement contains a magic number: try              {                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                    Byte[] PrivateData = _br.ReadBytes(RecordData.Length);                  //Ok we should have our private data which I am storing my tooltip value in...                  //now lets interpret it...                              string PData = new System.Text.ASCIIEncoding().GetString(PrivateData);                  //If string starts with "ToolTip" then lets do something with it.. otherwise I don't care about it.                  if (PData.StartsWith("ToolTip"))                  {                      PageRectangle pr = new PageRectangle();                      StyleInfo si = new StyleInfo();                      pr.SI = si;                      //si.BackgroundColor = Color.Blue;// Just a test to see where the tooltip is being drawn                      string[] ttd = PData.Split('|');                      pr.Tooltip = ttd[0].Split(':')[1];                      pr.X = X + Single.Parse(ttd[1].Split(':')[1]) * SCALEFACTOR;                      pr.Y = Y + Single.Parse(ttd[2].Split(':')[1]) * SCALEFACTOR;                      pr.W = Single.Parse(ttd[3].Split(':')[1]) * SCALEFACTOR;                      pr.H = Single.Parse(ttd[4].Split(':')[1]) * SCALEFACTOR;                      items.Add(pr);                  }                  else if (PData.StartsWith("PolyToolTip"))                  {                      PagePolygon pp = new PagePolygon();                      StyleInfo si = new StyleInfo();                      pp.SI = si;                      //si.BackgroundColor = Color.Blue;// Just a test to see where the tooltip is being drawn                      string[] ttd = PData.Split('|');                      PointF[] pts = new PointF[(ttd.Length - 1) / 2];                      pp.Points = pts;                      pp.Tooltip = ttd[0].Split(':')[1];                      for (int i = 0; i < pts.Length; i++)                      {                          pts[i].X = X + Single.Parse(ttd[i*2 +1]) * SCALEFACTOR;                          pts[i].Y = Y + Single.Parse(ttd[i*2 +2]) * SCALEFACTOR;                      }                      items.Add(pp);                  }                  return items;              }                finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                }
Magic Number,fyiReporting.RDL,Comment,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\Comment.cs,Process,The following statement contains a magic number: try              {                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                    Byte[] PrivateData = _br.ReadBytes(RecordData.Length);                  //Ok we should have our private data which I am storing my tooltip value in...                  //now lets interpret it...                              string PData = new System.Text.ASCIIEncoding().GetString(PrivateData);                  //If string starts with "ToolTip" then lets do something with it.. otherwise I don't care about it.                  if (PData.StartsWith("ToolTip"))                  {                      PageRectangle pr = new PageRectangle();                      StyleInfo si = new StyleInfo();                      pr.SI = si;                      //si.BackgroundColor = Color.Blue;// Just a test to see where the tooltip is being drawn                      string[] ttd = PData.Split('|');                      pr.Tooltip = ttd[0].Split(':')[1];                      pr.X = X + Single.Parse(ttd[1].Split(':')[1]) * SCALEFACTOR;                      pr.Y = Y + Single.Parse(ttd[2].Split(':')[1]) * SCALEFACTOR;                      pr.W = Single.Parse(ttd[3].Split(':')[1]) * SCALEFACTOR;                      pr.H = Single.Parse(ttd[4].Split(':')[1]) * SCALEFACTOR;                      items.Add(pr);                  }                  else if (PData.StartsWith("PolyToolTip"))                  {                      PagePolygon pp = new PagePolygon();                      StyleInfo si = new StyleInfo();                      pp.SI = si;                      //si.BackgroundColor = Color.Blue;// Just a test to see where the tooltip is being drawn                      string[] ttd = PData.Split('|');                      PointF[] pts = new PointF[(ttd.Length - 1) / 2];                      pp.Points = pts;                      pp.Tooltip = ttd[0].Split(':')[1];                      for (int i = 0; i < pts.Length; i++)                      {                          pts[i].X = X + Single.Parse(ttd[i*2 +1]) * SCALEFACTOR;                          pts[i].Y = Y + Single.Parse(ttd[i*2 +2]) * SCALEFACTOR;                      }                      items.Add(pp);                  }                  return items;              }                finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                }
Magic Number,fyiReporting.RDL,Comment,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\Comment.cs,Process,The following statement contains a magic number: try              {                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                    Byte[] PrivateData = _br.ReadBytes(RecordData.Length);                  //Ok we should have our private data which I am storing my tooltip value in...                  //now lets interpret it...                              string PData = new System.Text.ASCIIEncoding().GetString(PrivateData);                  //If string starts with "ToolTip" then lets do something with it.. otherwise I don't care about it.                  if (PData.StartsWith("ToolTip"))                  {                      PageRectangle pr = new PageRectangle();                      StyleInfo si = new StyleInfo();                      pr.SI = si;                      //si.BackgroundColor = Color.Blue;// Just a test to see where the tooltip is being drawn                      string[] ttd = PData.Split('|');                      pr.Tooltip = ttd[0].Split(':')[1];                      pr.X = X + Single.Parse(ttd[1].Split(':')[1]) * SCALEFACTOR;                      pr.Y = Y + Single.Parse(ttd[2].Split(':')[1]) * SCALEFACTOR;                      pr.W = Single.Parse(ttd[3].Split(':')[1]) * SCALEFACTOR;                      pr.H = Single.Parse(ttd[4].Split(':')[1]) * SCALEFACTOR;                      items.Add(pr);                  }                  else if (PData.StartsWith("PolyToolTip"))                  {                      PagePolygon pp = new PagePolygon();                      StyleInfo si = new StyleInfo();                      pp.SI = si;                      //si.BackgroundColor = Color.Blue;// Just a test to see where the tooltip is being drawn                      string[] ttd = PData.Split('|');                      PointF[] pts = new PointF[(ttd.Length - 1) / 2];                      pp.Points = pts;                      pp.Tooltip = ttd[0].Split(':')[1];                      for (int i = 0; i < pts.Length; i++)                      {                          pts[i].X = X + Single.Parse(ttd[i*2 +1]) * SCALEFACTOR;                          pts[i].Y = Y + Single.Parse(ttd[i*2 +2]) * SCALEFACTOR;                      }                      items.Add(pp);                  }                  return items;              }                finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                }
Magic Number,fyiReporting.RDL,Comment,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\Comment.cs,Process,The following statement contains a magic number: try              {                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                    Byte[] PrivateData = _br.ReadBytes(RecordData.Length);                  //Ok we should have our private data which I am storing my tooltip value in...                  //now lets interpret it...                              string PData = new System.Text.ASCIIEncoding().GetString(PrivateData);                  //If string starts with "ToolTip" then lets do something with it.. otherwise I don't care about it.                  if (PData.StartsWith("ToolTip"))                  {                      PageRectangle pr = new PageRectangle();                      StyleInfo si = new StyleInfo();                      pr.SI = si;                      //si.BackgroundColor = Color.Blue;// Just a test to see where the tooltip is being drawn                      string[] ttd = PData.Split('|');                      pr.Tooltip = ttd[0].Split(':')[1];                      pr.X = X + Single.Parse(ttd[1].Split(':')[1]) * SCALEFACTOR;                      pr.Y = Y + Single.Parse(ttd[2].Split(':')[1]) * SCALEFACTOR;                      pr.W = Single.Parse(ttd[3].Split(':')[1]) * SCALEFACTOR;                      pr.H = Single.Parse(ttd[4].Split(':')[1]) * SCALEFACTOR;                      items.Add(pr);                  }                  else if (PData.StartsWith("PolyToolTip"))                  {                      PagePolygon pp = new PagePolygon();                      StyleInfo si = new StyleInfo();                      pp.SI = si;                      //si.BackgroundColor = Color.Blue;// Just a test to see where the tooltip is being drawn                      string[] ttd = PData.Split('|');                      PointF[] pts = new PointF[(ttd.Length - 1) / 2];                      pp.Points = pts;                      pp.Tooltip = ttd[0].Split(':')[1];                      for (int i = 0; i < pts.Length; i++)                      {                          pts[i].X = X + Single.Parse(ttd[i*2 +1]) * SCALEFACTOR;                          pts[i].Y = Y + Single.Parse(ttd[i*2 +2]) * SCALEFACTOR;                      }                      items.Add(pp);                  }                  return items;              }                finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                }
Magic Number,fyiReporting.RDL,Comment,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\Comment.cs,Process,The following statement contains a magic number: try              {                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                    Byte[] PrivateData = _br.ReadBytes(RecordData.Length);                  //Ok we should have our private data which I am storing my tooltip value in...                  //now lets interpret it...                              string PData = new System.Text.ASCIIEncoding().GetString(PrivateData);                  //If string starts with "ToolTip" then lets do something with it.. otherwise I don't care about it.                  if (PData.StartsWith("ToolTip"))                  {                      PageRectangle pr = new PageRectangle();                      StyleInfo si = new StyleInfo();                      pr.SI = si;                      //si.BackgroundColor = Color.Blue;// Just a test to see where the tooltip is being drawn                      string[] ttd = PData.Split('|');                      pr.Tooltip = ttd[0].Split(':')[1];                      pr.X = X + Single.Parse(ttd[1].Split(':')[1]) * SCALEFACTOR;                      pr.Y = Y + Single.Parse(ttd[2].Split(':')[1]) * SCALEFACTOR;                      pr.W = Single.Parse(ttd[3].Split(':')[1]) * SCALEFACTOR;                      pr.H = Single.Parse(ttd[4].Split(':')[1]) * SCALEFACTOR;                      items.Add(pr);                  }                  else if (PData.StartsWith("PolyToolTip"))                  {                      PagePolygon pp = new PagePolygon();                      StyleInfo si = new StyleInfo();                      pp.SI = si;                      //si.BackgroundColor = Color.Blue;// Just a test to see where the tooltip is being drawn                      string[] ttd = PData.Split('|');                      PointF[] pts = new PointF[(ttd.Length - 1) / 2];                      pp.Points = pts;                      pp.Tooltip = ttd[0].Split(':')[1];                      for (int i = 0; i < pts.Length; i++)                      {                          pts[i].X = X + Single.Parse(ttd[i*2 +1]) * SCALEFACTOR;                          pts[i].Y = Y + Single.Parse(ttd[i*2 +2]) * SCALEFACTOR;                      }                      items.Add(pp);                  }                  return items;              }                finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                }
Magic Number,fyiReporting.RDL,DrawCurve,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawCurve.cs,Process,The following statement contains a magic number: try              {                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  //Byte 1 will be ObjectID                  byte ObjectID = _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X C X                              // if C = 1 Points are int16' 0 = Points are Float                                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                                                 _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                    float  Tension = _br.ReadSingle();// _br.ReadUInt32(); //20081110 PJR & GJL EMF+ Definition is WRONG!!!                  UInt32 Offset = _br.ReadUInt32();                  UInt32 NumberOfPoints = _br.ReadUInt32();                  UInt32 NumberOfSegments = _br.ReadUInt32();                  EMFPen Emfp = (EMFPen)ObjectTable[ObjectID];                  Pen p = Emfp.myPen;                  //EMFBrush b = p.myBrush;                                  if (Compressed)                  {                      DoCompressed(NumberOfPoints' _br' p'Offset'NumberOfSegments' Tension);                  }                                 else                  {                      DoFloat(NumberOfPoints' _br' p' Offset' NumberOfSegments' Tension);                  }                  return items;              }                finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,DrawCurve,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawCurve.cs,Process,The following statement contains a magic number: try              {                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  //Byte 1 will be ObjectID                  byte ObjectID = _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X C X                              // if C = 1 Points are int16' 0 = Points are Float                                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                                                 _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                    float  Tension = _br.ReadSingle();// _br.ReadUInt32(); //20081110 PJR & GJL EMF+ Definition is WRONG!!!                  UInt32 Offset = _br.ReadUInt32();                  UInt32 NumberOfPoints = _br.ReadUInt32();                  UInt32 NumberOfSegments = _br.ReadUInt32();                  EMFPen Emfp = (EMFPen)ObjectTable[ObjectID];                  Pen p = Emfp.myPen;                  //EMFBrush b = p.myBrush;                                  if (Compressed)                  {                      DoCompressed(NumberOfPoints' _br' p'Offset'NumberOfSegments' Tension);                  }                                 else                  {                      DoFloat(NumberOfPoints' _br' p' Offset' NumberOfSegments' Tension);                  }                  return items;              }                finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,DrawCurve,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawCurve.cs,Process,The following statement contains a magic number: try              {                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  //Byte 1 will be ObjectID                  byte ObjectID = _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X C X                              // if C = 1 Points are int16' 0 = Points are Float                                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                                                 _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                    float  Tension = _br.ReadSingle();// _br.ReadUInt32(); //20081110 PJR & GJL EMF+ Definition is WRONG!!!                  UInt32 Offset = _br.ReadUInt32();                  UInt32 NumberOfPoints = _br.ReadUInt32();                  UInt32 NumberOfSegments = _br.ReadUInt32();                  EMFPen Emfp = (EMFPen)ObjectTable[ObjectID];                  Pen p = Emfp.myPen;                  //EMFBrush b = p.myBrush;                                  if (Compressed)                  {                      DoCompressed(NumberOfPoints' _br' p'Offset'NumberOfSegments' Tension);                  }                                 else                  {                      DoFloat(NumberOfPoints' _br' p' Offset' NumberOfSegments' Tension);                  }                  return items;              }                finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,DrawCurve,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawCurve.cs,Process,The following statement contains a magic number: try              {                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  //Byte 1 will be ObjectID                  byte ObjectID = _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X C X                              // if C = 1 Points are int16' 0 = Points are Float                                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                                                 _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                    float  Tension = _br.ReadSingle();// _br.ReadUInt32(); //20081110 PJR & GJL EMF+ Definition is WRONG!!!                  UInt32 Offset = _br.ReadUInt32();                  UInt32 NumberOfPoints = _br.ReadUInt32();                  UInt32 NumberOfSegments = _br.ReadUInt32();                  EMFPen Emfp = (EMFPen)ObjectTable[ObjectID];                  Pen p = Emfp.myPen;                  //EMFBrush b = p.myBrush;                                  if (Compressed)                  {                      DoCompressed(NumberOfPoints' _br' p'Offset'NumberOfSegments' Tension);                  }                                 else                  {                      DoFloat(NumberOfPoints' _br' p' Offset' NumberOfSegments' Tension);                  }                  return items;              }                finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,DrawEllipse,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawEllipse.cs,Process,The following statement contains a magic number: try              {                                _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  byte ObjectID = _fr.ReadByte();                  //Byte 1 will be ignored                  byte RealFlags = _fr.ReadByte();                  //Byte 2 will be brushtype                  // 0 1 2 3 4 5 6 7                  // X X X X X X C X                  // if C = 1 int16' 0 = Points are Float (ignore P)                                bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                    _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                    EMFPen EMFp = (EMFPen)ObjectTable[ObjectID];                  Pen p = EMFp.myPen;                    if (Compressed)                  {                      Int16 Xp = _br.ReadInt16();                      Int16 Yp = _br.ReadInt16();                      Int16 Wid = _br.ReadInt16();                      Int16 Hgt = _br.ReadInt16();                      DoEllipse(p' Xp' Yp' Wid' Hgt);                  }                  else                  {                      Single Xp = _br.ReadSingle();                      Single Yp = _br.ReadSingle();                      Single Wid = _br.ReadSingle();                      Single Hgt = _br.ReadSingle();                      DoEllipse(p' Xp' Yp' Wid' Hgt);                  }                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,DrawEllipse,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawEllipse.cs,Process,The following statement contains a magic number: try              {                                _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  byte ObjectID = _fr.ReadByte();                  //Byte 1 will be ignored                  byte RealFlags = _fr.ReadByte();                  //Byte 2 will be brushtype                  // 0 1 2 3 4 5 6 7                  // X X X X X X C X                  // if C = 1 int16' 0 = Points are Float (ignore P)                                bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                    _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                    EMFPen EMFp = (EMFPen)ObjectTable[ObjectID];                  Pen p = EMFp.myPen;                    if (Compressed)                  {                      Int16 Xp = _br.ReadInt16();                      Int16 Yp = _br.ReadInt16();                      Int16 Wid = _br.ReadInt16();                      Int16 Hgt = _br.ReadInt16();                      DoEllipse(p' Xp' Yp' Wid' Hgt);                  }                  else                  {                      Single Xp = _br.ReadSingle();                      Single Yp = _br.ReadSingle();                      Single Wid = _br.ReadSingle();                      Single Hgt = _br.ReadSingle();                      DoEllipse(p' Xp' Yp' Wid' Hgt);                  }                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,DrawEllipse,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawEllipse.cs,Process,The following statement contains a magic number: try              {                                _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  byte ObjectID = _fr.ReadByte();                  //Byte 1 will be ignored                  byte RealFlags = _fr.ReadByte();                  //Byte 2 will be brushtype                  // 0 1 2 3 4 5 6 7                  // X X X X X X C X                  // if C = 1 int16' 0 = Points are Float (ignore P)                                bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                    _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                    EMFPen EMFp = (EMFPen)ObjectTable[ObjectID];                  Pen p = EMFp.myPen;                    if (Compressed)                  {                      Int16 Xp = _br.ReadInt16();                      Int16 Yp = _br.ReadInt16();                      Int16 Wid = _br.ReadInt16();                      Int16 Hgt = _br.ReadInt16();                      DoEllipse(p' Xp' Yp' Wid' Hgt);                  }                  else                  {                      Single Xp = _br.ReadSingle();                      Single Yp = _br.ReadSingle();                      Single Wid = _br.ReadSingle();                      Single Hgt = _br.ReadSingle();                      DoEllipse(p' Xp' Yp' Wid' Hgt);                  }                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,DrawEllipse,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawEllipse.cs,Process,The following statement contains a magic number: try              {                                _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  byte ObjectID = _fr.ReadByte();                  //Byte 1 will be ignored                  byte RealFlags = _fr.ReadByte();                  //Byte 2 will be brushtype                  // 0 1 2 3 4 5 6 7                  // X X X X X X C X                  // if C = 1 int16' 0 = Points are Float (ignore P)                                bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                    _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                    EMFPen EMFp = (EMFPen)ObjectTable[ObjectID];                  Pen p = EMFp.myPen;                    if (Compressed)                  {                      Int16 Xp = _br.ReadInt16();                      Int16 Yp = _br.ReadInt16();                      Int16 Wid = _br.ReadInt16();                      Int16 Hgt = _br.ReadInt16();                      DoEllipse(p' Xp' Yp' Wid' Hgt);                  }                  else                  {                      Single Xp = _br.ReadSingle();                      Single Yp = _br.ReadSingle();                      Single Wid = _br.ReadSingle();                      Single Hgt = _br.ReadSingle();                      DoEllipse(p' Xp' Yp' Wid' Hgt);                  }                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,DrawLines,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawLines.cs,Process,The following statement contains a magic number: try              {                                _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  //Byte 1 will be ObjectID                  byte ObjectID = _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X P X L C X                  // if P = 1 Points are Relative to previous point (Ignore C)                  // if C = 1 Points are int16' 0 = Points are Float (ignore P)                  // if L = 1 Draw a line between last and first points                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool Relative = false;                  if (!Compressed)                                      Relative = ((RealFlags & (int)Math.Pow(2' 3)) == (int)Math.Pow(2' 3));                  bool CloseShape = ((RealFlags & (int)Math.Pow(2' 5)) == (int)Math.Pow(2' 5));                   _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  UInt32 NumberOfPoints = _br.ReadUInt32();                   EMFPen Emfp = (EMFPen)ObjectTable[ObjectID];                  Pen p = Emfp.myPen;                                 //EMFBrush b = p.myBrush;                                  if (Compressed)                  {                      DoCompressed(NumberOfPoints' _br'p);                  }                  else if (Relative)                  {                      DoRelative(NumberOfPoints' _br' p);                  }                  else                  {                      DoFloat(NumberOfPoints' _br' p);                  }                  return items;              }                               finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,DrawLines,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawLines.cs,Process,The following statement contains a magic number: try              {                                _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  //Byte 1 will be ObjectID                  byte ObjectID = _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X P X L C X                  // if P = 1 Points are Relative to previous point (Ignore C)                  // if C = 1 Points are int16' 0 = Points are Float (ignore P)                  // if L = 1 Draw a line between last and first points                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool Relative = false;                  if (!Compressed)                                      Relative = ((RealFlags & (int)Math.Pow(2' 3)) == (int)Math.Pow(2' 3));                  bool CloseShape = ((RealFlags & (int)Math.Pow(2' 5)) == (int)Math.Pow(2' 5));                   _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  UInt32 NumberOfPoints = _br.ReadUInt32();                   EMFPen Emfp = (EMFPen)ObjectTable[ObjectID];                  Pen p = Emfp.myPen;                                 //EMFBrush b = p.myBrush;                                  if (Compressed)                  {                      DoCompressed(NumberOfPoints' _br'p);                  }                  else if (Relative)                  {                      DoRelative(NumberOfPoints' _br' p);                  }                  else                  {                      DoFloat(NumberOfPoints' _br' p);                  }                  return items;              }                               finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,DrawLines,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawLines.cs,Process,The following statement contains a magic number: try              {                                _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  //Byte 1 will be ObjectID                  byte ObjectID = _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X P X L C X                  // if P = 1 Points are Relative to previous point (Ignore C)                  // if C = 1 Points are int16' 0 = Points are Float (ignore P)                  // if L = 1 Draw a line between last and first points                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool Relative = false;                  if (!Compressed)                                      Relative = ((RealFlags & (int)Math.Pow(2' 3)) == (int)Math.Pow(2' 3));                  bool CloseShape = ((RealFlags & (int)Math.Pow(2' 5)) == (int)Math.Pow(2' 5));                   _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  UInt32 NumberOfPoints = _br.ReadUInt32();                   EMFPen Emfp = (EMFPen)ObjectTable[ObjectID];                  Pen p = Emfp.myPen;                                 //EMFBrush b = p.myBrush;                                  if (Compressed)                  {                      DoCompressed(NumberOfPoints' _br'p);                  }                  else if (Relative)                  {                      DoRelative(NumberOfPoints' _br' p);                  }                  else                  {                      DoFloat(NumberOfPoints' _br' p);                  }                  return items;              }                               finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,DrawLines,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawLines.cs,Process,The following statement contains a magic number: try              {                                _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  //Byte 1 will be ObjectID                  byte ObjectID = _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X P X L C X                  // if P = 1 Points are Relative to previous point (Ignore C)                  // if C = 1 Points are int16' 0 = Points are Float (ignore P)                  // if L = 1 Draw a line between last and first points                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool Relative = false;                  if (!Compressed)                                      Relative = ((RealFlags & (int)Math.Pow(2' 3)) == (int)Math.Pow(2' 3));                  bool CloseShape = ((RealFlags & (int)Math.Pow(2' 5)) == (int)Math.Pow(2' 5));                   _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  UInt32 NumberOfPoints = _br.ReadUInt32();                   EMFPen Emfp = (EMFPen)ObjectTable[ObjectID];                  Pen p = Emfp.myPen;                                 //EMFBrush b = p.myBrush;                                  if (Compressed)                  {                      DoCompressed(NumberOfPoints' _br'p);                  }                  else if (Relative)                  {                      DoRelative(NumberOfPoints' _br' p);                  }                  else                  {                      DoFloat(NumberOfPoints' _br' p);                  }                  return items;              }                               finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,DrawLines,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawLines.cs,Process,The following statement contains a magic number: try              {                                _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  //Byte 1 will be ObjectID                  byte ObjectID = _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X P X L C X                  // if P = 1 Points are Relative to previous point (Ignore C)                  // if C = 1 Points are int16' 0 = Points are Float (ignore P)                  // if L = 1 Draw a line between last and first points                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool Relative = false;                  if (!Compressed)                                      Relative = ((RealFlags & (int)Math.Pow(2' 3)) == (int)Math.Pow(2' 3));                  bool CloseShape = ((RealFlags & (int)Math.Pow(2' 5)) == (int)Math.Pow(2' 5));                   _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  UInt32 NumberOfPoints = _br.ReadUInt32();                   EMFPen Emfp = (EMFPen)ObjectTable[ObjectID];                  Pen p = Emfp.myPen;                                 //EMFBrush b = p.myBrush;                                  if (Compressed)                  {                      DoCompressed(NumberOfPoints' _br'p);                  }                  else if (Relative)                  {                      DoRelative(NumberOfPoints' _br' p);                  }                  else                  {                      DoFloat(NumberOfPoints' _br' p);                  }                  return items;              }                               finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,DrawLines,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawLines.cs,Process,The following statement contains a magic number: try              {                                _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  //Byte 1 will be ObjectID                  byte ObjectID = _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X P X L C X                  // if P = 1 Points are Relative to previous point (Ignore C)                  // if C = 1 Points are int16' 0 = Points are Float (ignore P)                  // if L = 1 Draw a line between last and first points                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool Relative = false;                  if (!Compressed)                                      Relative = ((RealFlags & (int)Math.Pow(2' 3)) == (int)Math.Pow(2' 3));                  bool CloseShape = ((RealFlags & (int)Math.Pow(2' 5)) == (int)Math.Pow(2' 5));                   _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  UInt32 NumberOfPoints = _br.ReadUInt32();                   EMFPen Emfp = (EMFPen)ObjectTable[ObjectID];                  Pen p = Emfp.myPen;                                 //EMFBrush b = p.myBrush;                                  if (Compressed)                  {                      DoCompressed(NumberOfPoints' _br'p);                  }                  else if (Relative)                  {                      DoRelative(NumberOfPoints' _br' p);                  }                  else                  {                      DoFloat(NumberOfPoints' _br' p);                  }                  return items;              }                               finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,DrawLines,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawLines.cs,Process,The following statement contains a magic number: try              {                                _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  //Byte 1 will be ObjectID                  byte ObjectID = _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X P X L C X                  // if P = 1 Points are Relative to previous point (Ignore C)                  // if C = 1 Points are int16' 0 = Points are Float (ignore P)                  // if L = 1 Draw a line between last and first points                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool Relative = false;                  if (!Compressed)                                      Relative = ((RealFlags & (int)Math.Pow(2' 3)) == (int)Math.Pow(2' 3));                  bool CloseShape = ((RealFlags & (int)Math.Pow(2' 5)) == (int)Math.Pow(2' 5));                   _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  UInt32 NumberOfPoints = _br.ReadUInt32();                   EMFPen Emfp = (EMFPen)ObjectTable[ObjectID];                  Pen p = Emfp.myPen;                                 //EMFBrush b = p.myBrush;                                  if (Compressed)                  {                      DoCompressed(NumberOfPoints' _br'p);                  }                  else if (Relative)                  {                      DoRelative(NumberOfPoints' _br' p);                  }                  else                  {                      DoFloat(NumberOfPoints' _br' p);                  }                  return items;              }                               finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,DrawLines,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawLines.cs,Process,The following statement contains a magic number: try              {                                _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  //Byte 1 will be ObjectID                  byte ObjectID = _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X P X L C X                  // if P = 1 Points are Relative to previous point (Ignore C)                  // if C = 1 Points are int16' 0 = Points are Float (ignore P)                  // if L = 1 Draw a line between last and first points                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool Relative = false;                  if (!Compressed)                                      Relative = ((RealFlags & (int)Math.Pow(2' 3)) == (int)Math.Pow(2' 3));                  bool CloseShape = ((RealFlags & (int)Math.Pow(2' 5)) == (int)Math.Pow(2' 5));                   _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  UInt32 NumberOfPoints = _br.ReadUInt32();                   EMFPen Emfp = (EMFPen)ObjectTable[ObjectID];                  Pen p = Emfp.myPen;                                 //EMFBrush b = p.myBrush;                                  if (Compressed)                  {                      DoCompressed(NumberOfPoints' _br'p);                  }                  else if (Relative)                  {                      DoRelative(NumberOfPoints' _br' p);                  }                  else                  {                      DoFloat(NumberOfPoints' _br' p);                  }                  return items;              }                               finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,DrawLines,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawLines.cs,Process,The following statement contains a magic number: try              {                                _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  //Byte 1 will be ObjectID                  byte ObjectID = _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X P X L C X                  // if P = 1 Points are Relative to previous point (Ignore C)                  // if C = 1 Points are int16' 0 = Points are Float (ignore P)                  // if L = 1 Draw a line between last and first points                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool Relative = false;                  if (!Compressed)                                      Relative = ((RealFlags & (int)Math.Pow(2' 3)) == (int)Math.Pow(2' 3));                  bool CloseShape = ((RealFlags & (int)Math.Pow(2' 5)) == (int)Math.Pow(2' 5));                   _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  UInt32 NumberOfPoints = _br.ReadUInt32();                   EMFPen Emfp = (EMFPen)ObjectTable[ObjectID];                  Pen p = Emfp.myPen;                                 //EMFBrush b = p.myBrush;                                  if (Compressed)                  {                      DoCompressed(NumberOfPoints' _br'p);                  }                  else if (Relative)                  {                      DoRelative(NumberOfPoints' _br' p);                  }                  else                  {                      DoFloat(NumberOfPoints' _br' p);                  }                  return items;              }                               finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,DrawLines,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawLines.cs,Process,The following statement contains a magic number: try              {                                _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  //Byte 1 will be ObjectID                  byte ObjectID = _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X P X L C X                  // if P = 1 Points are Relative to previous point (Ignore C)                  // if C = 1 Points are int16' 0 = Points are Float (ignore P)                  // if L = 1 Draw a line between last and first points                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool Relative = false;                  if (!Compressed)                                      Relative = ((RealFlags & (int)Math.Pow(2' 3)) == (int)Math.Pow(2' 3));                  bool CloseShape = ((RealFlags & (int)Math.Pow(2' 5)) == (int)Math.Pow(2' 5));                   _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  UInt32 NumberOfPoints = _br.ReadUInt32();                   EMFPen Emfp = (EMFPen)ObjectTable[ObjectID];                  Pen p = Emfp.myPen;                                 //EMFBrush b = p.myBrush;                                  if (Compressed)                  {                      DoCompressed(NumberOfPoints' _br'p);                  }                  else if (Relative)                  {                      DoRelative(NumberOfPoints' _br' p);                  }                  else                  {                      DoFloat(NumberOfPoints' _br' p);                  }                  return items;              }                               finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,DrawLines,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawLines.cs,Process,The following statement contains a magic number: try              {                                _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  //Byte 1 will be ObjectID                  byte ObjectID = _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X P X L C X                  // if P = 1 Points are Relative to previous point (Ignore C)                  // if C = 1 Points are int16' 0 = Points are Float (ignore P)                  // if L = 1 Draw a line between last and first points                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool Relative = false;                  if (!Compressed)                                      Relative = ((RealFlags & (int)Math.Pow(2' 3)) == (int)Math.Pow(2' 3));                  bool CloseShape = ((RealFlags & (int)Math.Pow(2' 5)) == (int)Math.Pow(2' 5));                   _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  UInt32 NumberOfPoints = _br.ReadUInt32();                   EMFPen Emfp = (EMFPen)ObjectTable[ObjectID];                  Pen p = Emfp.myPen;                                 //EMFBrush b = p.myBrush;                                  if (Compressed)                  {                      DoCompressed(NumberOfPoints' _br'p);                  }                  else if (Relative)                  {                      DoRelative(NumberOfPoints' _br' p);                  }                  else                  {                      DoFloat(NumberOfPoints' _br' p);                  }                  return items;              }                               finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,DrawLines,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawLines.cs,Process,The following statement contains a magic number: try              {                                _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  //Byte 1 will be ObjectID                  byte ObjectID = _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X P X L C X                  // if P = 1 Points are Relative to previous point (Ignore C)                  // if C = 1 Points are int16' 0 = Points are Float (ignore P)                  // if L = 1 Draw a line between last and first points                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool Relative = false;                  if (!Compressed)                                      Relative = ((RealFlags & (int)Math.Pow(2' 3)) == (int)Math.Pow(2' 3));                  bool CloseShape = ((RealFlags & (int)Math.Pow(2' 5)) == (int)Math.Pow(2' 5));                   _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  UInt32 NumberOfPoints = _br.ReadUInt32();                   EMFPen Emfp = (EMFPen)ObjectTable[ObjectID];                  Pen p = Emfp.myPen;                                 //EMFBrush b = p.myBrush;                                  if (Compressed)                  {                      DoCompressed(NumberOfPoints' _br'p);                  }                  else if (Relative)                  {                      DoRelative(NumberOfPoints' _br' p);                  }                  else                  {                      DoFloat(NumberOfPoints' _br' p);                  }                  return items;              }                               finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,DrawPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawPie.cs,Process,The following statement contains a magic number: try              {                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  //Byte 1 will be ObjectID                  byte ObjectID = _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X C X                                  // if C = 1 Data int16 else float!                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                    Single StartAngle = _br.ReadSingle();                  Single SweepAngle = _br.ReadSingle();                  EMFPen EMFp = (EMFPen)ObjectTable[ObjectID];                  Pen p = EMFp.myPen;                  if (Compressed)                  {                      DoCompressed(StartAngle'SweepAngle' _br' p);                  }                  else                  {                      DoFloat(StartAngle' SweepAngle' _br' p);                  }                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,DrawPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawPie.cs,Process,The following statement contains a magic number: try              {                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  //Byte 1 will be ObjectID                  byte ObjectID = _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X C X                                  // if C = 1 Data int16 else float!                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                    Single StartAngle = _br.ReadSingle();                  Single SweepAngle = _br.ReadSingle();                  EMFPen EMFp = (EMFPen)ObjectTable[ObjectID];                  Pen p = EMFp.myPen;                  if (Compressed)                  {                      DoCompressed(StartAngle'SweepAngle' _br' p);                  }                  else                  {                      DoFloat(StartAngle' SweepAngle' _br' p);                  }                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,DrawPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawPie.cs,Process,The following statement contains a magic number: try              {                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  //Byte 1 will be ObjectID                  byte ObjectID = _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X C X                                  // if C = 1 Data int16 else float!                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                    Single StartAngle = _br.ReadSingle();                  Single SweepAngle = _br.ReadSingle();                  EMFPen EMFp = (EMFPen)ObjectTable[ObjectID];                  Pen p = EMFp.myPen;                  if (Compressed)                  {                      DoCompressed(StartAngle'SweepAngle' _br' p);                  }                  else                  {                      DoFloat(StartAngle' SweepAngle' _br' p);                  }                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,DrawPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawPie.cs,Process,The following statement contains a magic number: try              {                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  //Byte 1 will be ObjectID                  byte ObjectID = _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X C X                                  // if C = 1 Data int16 else float!                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                    Single StartAngle = _br.ReadSingle();                  Single SweepAngle = _br.ReadSingle();                  EMFPen EMFp = (EMFPen)ObjectTable[ObjectID];                  Pen p = EMFp.myPen;                  if (Compressed)                  {                      DoCompressed(StartAngle'SweepAngle' _br' p);                  }                  else                  {                      DoFloat(StartAngle' SweepAngle' _br' p);                  }                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,DrawRects,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawRects.cs,Process,The following statement contains a magic number: try              {                                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  //Byte 1 will be ObjectID                  byte ObjectID = _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X C X                                  // if C = 1 Data int16 else float!                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  UInt32 NumberOfRects = _br.ReadUInt32();                  EMFPen EMFp = (EMFPen)ObjectTable[ObjectID];                  Pen p = EMFp.myPen;                  if (Compressed)                  {                      DoCompressed(NumberOfRects' _br' p);                  }                  else                  {                      DoFloat(NumberOfRects' _br' p);                  }                  return items;              }                                finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,DrawRects,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawRects.cs,Process,The following statement contains a magic number: try              {                                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  //Byte 1 will be ObjectID                  byte ObjectID = _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X C X                                  // if C = 1 Data int16 else float!                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  UInt32 NumberOfRects = _br.ReadUInt32();                  EMFPen EMFp = (EMFPen)ObjectTable[ObjectID];                  Pen p = EMFp.myPen;                  if (Compressed)                  {                      DoCompressed(NumberOfRects' _br' p);                  }                  else                  {                      DoFloat(NumberOfRects' _br' p);                  }                  return items;              }                                finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,DrawRects,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawRects.cs,Process,The following statement contains a magic number: try              {                                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  //Byte 1 will be ObjectID                  byte ObjectID = _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X C X                                  // if C = 1 Data int16 else float!                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  UInt32 NumberOfRects = _br.ReadUInt32();                  EMFPen EMFp = (EMFPen)ObjectTable[ObjectID];                  Pen p = EMFp.myPen;                  if (Compressed)                  {                      DoCompressed(NumberOfRects' _br' p);                  }                  else                  {                      DoFloat(NumberOfRects' _br' p);                  }                  return items;              }                                finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,DrawRects,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawRects.cs,Process,The following statement contains a magic number: try              {                                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  //Byte 1 will be ObjectID                  byte ObjectID = _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X C X                                  // if C = 1 Data int16 else float!                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  UInt32 NumberOfRects = _br.ReadUInt32();                  EMFPen EMFp = (EMFPen)ObjectTable[ObjectID];                  Pen p = EMFp.myPen;                  if (Compressed)                  {                      DoCompressed(NumberOfRects' _br' p);                  }                  else                  {                      DoFloat(NumberOfRects' _br' p);                  }                  return items;              }                                finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,DrawString,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawString.cs,Process,The following statement contains a magic number: try              {                                 _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  //Byte 1 will be ObjectID - a font in the object table                  byte ObjectID = _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X X S                  // if S = type of brush - if S then ARGB' else a brush object in object table                    _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  bool BrushIsARGB = ((RealFlags & (int)Math.Pow(2' 7)) == (int)Math.Pow(2' 7));                  Brush b;                  if (BrushIsARGB)                  {                      byte A' R' G' B;                      B = _br.ReadByte();                      G = _br.ReadByte();                      R = _br.ReadByte();                      A = _br.ReadByte();                      b = new SolidBrush(Color.FromArgb(A' R' G' B));                  }                  else                  {                      UInt32 BrushID = _br.ReadUInt32();                      EMFBrush EMFb = (EMFBrush)ObjectTable[(byte)BrushID];                      b = EMFb.myBrush;                  }                    UInt32 FormatID = _br.ReadUInt32(); // Index of Optional stringFormatobject in Object Table...                  UInt32 StringLength = _br.ReadUInt32();                  //bounding of string...                  Single recX = _br.ReadSingle();                  Single recY = _br.ReadSingle();                  Single recWidth = _br.ReadSingle();                  Single recHeight = _br.ReadSingle();                  //Array of Chars...                                   char[] StringData = new char[StringLength];                  System.Text.UnicodeEncoding d = new System.Text.UnicodeEncoding();                  d.GetChars(_br.ReadBytes((int)StringLength * 2)' 0' (int)StringLength * 2' StringData' 0);                  EMFFont EF = (EMFFont)ObjectTable[(byte)ObjectID];                  Font f = EF.myFont;                  StringFormat sf;                  if (ObjectTable.Contains((byte)FormatID))                  {                      EMFStringFormat ESF = (EMFStringFormat)ObjectTable[(byte)FormatID];                      sf = ESF.myStringFormat;                  }                  else                  {                      sf = new StringFormat();                  }                    DoInstructions(f' sf' b' recX' recY' recWidth' recHeight' new String(StringData));                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,DrawString,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawString.cs,Process,The following statement contains a magic number: try              {                                 _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  //Byte 1 will be ObjectID - a font in the object table                  byte ObjectID = _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X X S                  // if S = type of brush - if S then ARGB' else a brush object in object table                    _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  bool BrushIsARGB = ((RealFlags & (int)Math.Pow(2' 7)) == (int)Math.Pow(2' 7));                  Brush b;                  if (BrushIsARGB)                  {                      byte A' R' G' B;                      B = _br.ReadByte();                      G = _br.ReadByte();                      R = _br.ReadByte();                      A = _br.ReadByte();                      b = new SolidBrush(Color.FromArgb(A' R' G' B));                  }                  else                  {                      UInt32 BrushID = _br.ReadUInt32();                      EMFBrush EMFb = (EMFBrush)ObjectTable[(byte)BrushID];                      b = EMFb.myBrush;                  }                    UInt32 FormatID = _br.ReadUInt32(); // Index of Optional stringFormatobject in Object Table...                  UInt32 StringLength = _br.ReadUInt32();                  //bounding of string...                  Single recX = _br.ReadSingle();                  Single recY = _br.ReadSingle();                  Single recWidth = _br.ReadSingle();                  Single recHeight = _br.ReadSingle();                  //Array of Chars...                                   char[] StringData = new char[StringLength];                  System.Text.UnicodeEncoding d = new System.Text.UnicodeEncoding();                  d.GetChars(_br.ReadBytes((int)StringLength * 2)' 0' (int)StringLength * 2' StringData' 0);                  EMFFont EF = (EMFFont)ObjectTable[(byte)ObjectID];                  Font f = EF.myFont;                  StringFormat sf;                  if (ObjectTable.Contains((byte)FormatID))                  {                      EMFStringFormat ESF = (EMFStringFormat)ObjectTable[(byte)FormatID];                      sf = ESF.myStringFormat;                  }                  else                  {                      sf = new StringFormat();                  }                    DoInstructions(f' sf' b' recX' recY' recWidth' recHeight' new String(StringData));                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,DrawString,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawString.cs,Process,The following statement contains a magic number: try              {                                 _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  //Byte 1 will be ObjectID - a font in the object table                  byte ObjectID = _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X X S                  // if S = type of brush - if S then ARGB' else a brush object in object table                    _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  bool BrushIsARGB = ((RealFlags & (int)Math.Pow(2' 7)) == (int)Math.Pow(2' 7));                  Brush b;                  if (BrushIsARGB)                  {                      byte A' R' G' B;                      B = _br.ReadByte();                      G = _br.ReadByte();                      R = _br.ReadByte();                      A = _br.ReadByte();                      b = new SolidBrush(Color.FromArgb(A' R' G' B));                  }                  else                  {                      UInt32 BrushID = _br.ReadUInt32();                      EMFBrush EMFb = (EMFBrush)ObjectTable[(byte)BrushID];                      b = EMFb.myBrush;                  }                    UInt32 FormatID = _br.ReadUInt32(); // Index of Optional stringFormatobject in Object Table...                  UInt32 StringLength = _br.ReadUInt32();                  //bounding of string...                  Single recX = _br.ReadSingle();                  Single recY = _br.ReadSingle();                  Single recWidth = _br.ReadSingle();                  Single recHeight = _br.ReadSingle();                  //Array of Chars...                                   char[] StringData = new char[StringLength];                  System.Text.UnicodeEncoding d = new System.Text.UnicodeEncoding();                  d.GetChars(_br.ReadBytes((int)StringLength * 2)' 0' (int)StringLength * 2' StringData' 0);                  EMFFont EF = (EMFFont)ObjectTable[(byte)ObjectID];                  Font f = EF.myFont;                  StringFormat sf;                  if (ObjectTable.Contains((byte)FormatID))                  {                      EMFStringFormat ESF = (EMFStringFormat)ObjectTable[(byte)FormatID];                      sf = ESF.myStringFormat;                  }                  else                  {                      sf = new StringFormat();                  }                    DoInstructions(f' sf' b' recX' recY' recWidth' recHeight' new String(StringData));                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,DrawString,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawString.cs,Process,The following statement contains a magic number: try              {                                 _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  //Byte 1 will be ObjectID - a font in the object table                  byte ObjectID = _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X X S                  // if S = type of brush - if S then ARGB' else a brush object in object table                    _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  bool BrushIsARGB = ((RealFlags & (int)Math.Pow(2' 7)) == (int)Math.Pow(2' 7));                  Brush b;                  if (BrushIsARGB)                  {                      byte A' R' G' B;                      B = _br.ReadByte();                      G = _br.ReadByte();                      R = _br.ReadByte();                      A = _br.ReadByte();                      b = new SolidBrush(Color.FromArgb(A' R' G' B));                  }                  else                  {                      UInt32 BrushID = _br.ReadUInt32();                      EMFBrush EMFb = (EMFBrush)ObjectTable[(byte)BrushID];                      b = EMFb.myBrush;                  }                    UInt32 FormatID = _br.ReadUInt32(); // Index of Optional stringFormatobject in Object Table...                  UInt32 StringLength = _br.ReadUInt32();                  //bounding of string...                  Single recX = _br.ReadSingle();                  Single recY = _br.ReadSingle();                  Single recWidth = _br.ReadSingle();                  Single recHeight = _br.ReadSingle();                  //Array of Chars...                                   char[] StringData = new char[StringLength];                  System.Text.UnicodeEncoding d = new System.Text.UnicodeEncoding();                  d.GetChars(_br.ReadBytes((int)StringLength * 2)' 0' (int)StringLength * 2' StringData' 0);                  EMFFont EF = (EMFFont)ObjectTable[(byte)ObjectID];                  Font f = EF.myFont;                  StringFormat sf;                  if (ObjectTable.Contains((byte)FormatID))                  {                      EMFStringFormat ESF = (EMFStringFormat)ObjectTable[(byte)FormatID];                      sf = ESF.myStringFormat;                  }                  else                  {                      sf = new StringFormat();                  }                    DoInstructions(f' sf' b' recX' recY' recWidth' recHeight' new String(StringData));                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,DrawString,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawString.cs,Process,The following statement contains a magic number: try              {                                 _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  //Byte 1 will be ObjectID - a font in the object table                  byte ObjectID = _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X X S                  // if S = type of brush - if S then ARGB' else a brush object in object table                    _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  bool BrushIsARGB = ((RealFlags & (int)Math.Pow(2' 7)) == (int)Math.Pow(2' 7));                  Brush b;                  if (BrushIsARGB)                  {                      byte A' R' G' B;                      B = _br.ReadByte();                      G = _br.ReadByte();                      R = _br.ReadByte();                      A = _br.ReadByte();                      b = new SolidBrush(Color.FromArgb(A' R' G' B));                  }                  else                  {                      UInt32 BrushID = _br.ReadUInt32();                      EMFBrush EMFb = (EMFBrush)ObjectTable[(byte)BrushID];                      b = EMFb.myBrush;                  }                    UInt32 FormatID = _br.ReadUInt32(); // Index of Optional stringFormatobject in Object Table...                  UInt32 StringLength = _br.ReadUInt32();                  //bounding of string...                  Single recX = _br.ReadSingle();                  Single recY = _br.ReadSingle();                  Single recWidth = _br.ReadSingle();                  Single recHeight = _br.ReadSingle();                  //Array of Chars...                                   char[] StringData = new char[StringLength];                  System.Text.UnicodeEncoding d = new System.Text.UnicodeEncoding();                  d.GetChars(_br.ReadBytes((int)StringLength * 2)' 0' (int)StringLength * 2' StringData' 0);                  EMFFont EF = (EMFFont)ObjectTable[(byte)ObjectID];                  Font f = EF.myFont;                  StringFormat sf;                  if (ObjectTable.Contains((byte)FormatID))                  {                      EMFStringFormat ESF = (EMFStringFormat)ObjectTable[(byte)FormatID];                      sf = ESF.myStringFormat;                  }                  else                  {                      sf = new StringFormat();                  }                    DoInstructions(f' sf' b' recX' recY' recWidth' recHeight' new String(StringData));                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,DrawString,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\DrawString.cs,Process,The following statement contains a magic number: try              {                                 _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  //Byte 1 will be ObjectID - a font in the object table                  byte ObjectID = _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X X S                  // if S = type of brush - if S then ARGB' else a brush object in object table                    _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  bool BrushIsARGB = ((RealFlags & (int)Math.Pow(2' 7)) == (int)Math.Pow(2' 7));                  Brush b;                  if (BrushIsARGB)                  {                      byte A' R' G' B;                      B = _br.ReadByte();                      G = _br.ReadByte();                      R = _br.ReadByte();                      A = _br.ReadByte();                      b = new SolidBrush(Color.FromArgb(A' R' G' B));                  }                  else                  {                      UInt32 BrushID = _br.ReadUInt32();                      EMFBrush EMFb = (EMFBrush)ObjectTable[(byte)BrushID];                      b = EMFb.myBrush;                  }                    UInt32 FormatID = _br.ReadUInt32(); // Index of Optional stringFormatobject in Object Table...                  UInt32 StringLength = _br.ReadUInt32();                  //bounding of string...                  Single recX = _br.ReadSingle();                  Single recY = _br.ReadSingle();                  Single recWidth = _br.ReadSingle();                  Single recHeight = _br.ReadSingle();                  //Array of Chars...                                   char[] StringData = new char[StringLength];                  System.Text.UnicodeEncoding d = new System.Text.UnicodeEncoding();                  d.GetChars(_br.ReadBytes((int)StringLength * 2)' 0' (int)StringLength * 2' StringData' 0);                  EMFFont EF = (EMFFont)ObjectTable[(byte)ObjectID];                  Font f = EF.myFont;                  StringFormat sf;                  if (ObjectTable.Contains((byte)FormatID))                  {                      EMFStringFormat ESF = (EMFStringFormat)ObjectTable[(byte)FormatID];                      sf = ESF.myStringFormat;                  }                  else                  {                      sf = new StringFormat();                  }                    DoInstructions(f' sf' b' recX' recY' recWidth' recHeight' new String(StringData));                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,FillEllipse,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillEllipse.cs,Process,The following statement contains a magic number: try              {                                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  _fr.ReadByte();                  //Byte 1 will be ignored                  byte RealFlags = _fr.ReadByte();                  //Byte 2 will be brushtype                  // 0 1 2 3 4 5 6 7                  // X X X X X X C S                  // if S = 1 brushID is an ARGBobject' else its an Index to object table                  // if C = 1 int16' 0 = Points are Float (ignore P)                                bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool BrushIsARGB = ((RealFlags & (int)Math.Pow(2' 7)) == (int)Math.Pow(2' 7));                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  Brush b;                  if (BrushIsARGB)                  {                      byte A' R' G' B;                      B = _br.ReadByte();                      G = _br.ReadByte();                      R = _br.ReadByte();                      A = _br.ReadByte();                      b = new SolidBrush(Color.FromArgb(A' R' G' B));                  }                  else                  {                      UInt32 BrushID = _br.ReadUInt32();                      EMFBrush EMFb = (EMFBrush)ObjectTable[(byte)BrushID];                      b = EMFb.myBrush;                  }                  if (Compressed)                  {                      Int16 Xp = _br.ReadInt16();                      Int16 Yp = _br.ReadInt16();                      Int16 Wid = _br.ReadInt16();                      Int16 Hgt = _br.ReadInt16();                      DoInstructions(Xp' Yp' Wid' Hgt' b);                  }                  else                  {                      Single Xp = _br.ReadSingle();                      Single Yp = _br.ReadSingle();                      Single Wid = _br.ReadSingle();                      Single Hgt = _br.ReadSingle();                      DoInstructions(Xp' Yp' Wid' Hgt' b);                  }                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,FillEllipse,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillEllipse.cs,Process,The following statement contains a magic number: try              {                                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  _fr.ReadByte();                  //Byte 1 will be ignored                  byte RealFlags = _fr.ReadByte();                  //Byte 2 will be brushtype                  // 0 1 2 3 4 5 6 7                  // X X X X X X C S                  // if S = 1 brushID is an ARGBobject' else its an Index to object table                  // if C = 1 int16' 0 = Points are Float (ignore P)                                bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool BrushIsARGB = ((RealFlags & (int)Math.Pow(2' 7)) == (int)Math.Pow(2' 7));                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  Brush b;                  if (BrushIsARGB)                  {                      byte A' R' G' B;                      B = _br.ReadByte();                      G = _br.ReadByte();                      R = _br.ReadByte();                      A = _br.ReadByte();                      b = new SolidBrush(Color.FromArgb(A' R' G' B));                  }                  else                  {                      UInt32 BrushID = _br.ReadUInt32();                      EMFBrush EMFb = (EMFBrush)ObjectTable[(byte)BrushID];                      b = EMFb.myBrush;                  }                  if (Compressed)                  {                      Int16 Xp = _br.ReadInt16();                      Int16 Yp = _br.ReadInt16();                      Int16 Wid = _br.ReadInt16();                      Int16 Hgt = _br.ReadInt16();                      DoInstructions(Xp' Yp' Wid' Hgt' b);                  }                  else                  {                      Single Xp = _br.ReadSingle();                      Single Yp = _br.ReadSingle();                      Single Wid = _br.ReadSingle();                      Single Hgt = _br.ReadSingle();                      DoInstructions(Xp' Yp' Wid' Hgt' b);                  }                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,FillEllipse,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillEllipse.cs,Process,The following statement contains a magic number: try              {                                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  _fr.ReadByte();                  //Byte 1 will be ignored                  byte RealFlags = _fr.ReadByte();                  //Byte 2 will be brushtype                  // 0 1 2 3 4 5 6 7                  // X X X X X X C S                  // if S = 1 brushID is an ARGBobject' else its an Index to object table                  // if C = 1 int16' 0 = Points are Float (ignore P)                                bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool BrushIsARGB = ((RealFlags & (int)Math.Pow(2' 7)) == (int)Math.Pow(2' 7));                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  Brush b;                  if (BrushIsARGB)                  {                      byte A' R' G' B;                      B = _br.ReadByte();                      G = _br.ReadByte();                      R = _br.ReadByte();                      A = _br.ReadByte();                      b = new SolidBrush(Color.FromArgb(A' R' G' B));                  }                  else                  {                      UInt32 BrushID = _br.ReadUInt32();                      EMFBrush EMFb = (EMFBrush)ObjectTable[(byte)BrushID];                      b = EMFb.myBrush;                  }                  if (Compressed)                  {                      Int16 Xp = _br.ReadInt16();                      Int16 Yp = _br.ReadInt16();                      Int16 Wid = _br.ReadInt16();                      Int16 Hgt = _br.ReadInt16();                      DoInstructions(Xp' Yp' Wid' Hgt' b);                  }                  else                  {                      Single Xp = _br.ReadSingle();                      Single Yp = _br.ReadSingle();                      Single Wid = _br.ReadSingle();                      Single Hgt = _br.ReadSingle();                      DoInstructions(Xp' Yp' Wid' Hgt' b);                  }                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,FillEllipse,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillEllipse.cs,Process,The following statement contains a magic number: try              {                                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  _fr.ReadByte();                  //Byte 1 will be ignored                  byte RealFlags = _fr.ReadByte();                  //Byte 2 will be brushtype                  // 0 1 2 3 4 5 6 7                  // X X X X X X C S                  // if S = 1 brushID is an ARGBobject' else its an Index to object table                  // if C = 1 int16' 0 = Points are Float (ignore P)                                bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool BrushIsARGB = ((RealFlags & (int)Math.Pow(2' 7)) == (int)Math.Pow(2' 7));                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  Brush b;                  if (BrushIsARGB)                  {                      byte A' R' G' B;                      B = _br.ReadByte();                      G = _br.ReadByte();                      R = _br.ReadByte();                      A = _br.ReadByte();                      b = new SolidBrush(Color.FromArgb(A' R' G' B));                  }                  else                  {                      UInt32 BrushID = _br.ReadUInt32();                      EMFBrush EMFb = (EMFBrush)ObjectTable[(byte)BrushID];                      b = EMFb.myBrush;                  }                  if (Compressed)                  {                      Int16 Xp = _br.ReadInt16();                      Int16 Yp = _br.ReadInt16();                      Int16 Wid = _br.ReadInt16();                      Int16 Hgt = _br.ReadInt16();                      DoInstructions(Xp' Yp' Wid' Hgt' b);                  }                  else                  {                      Single Xp = _br.ReadSingle();                      Single Yp = _br.ReadSingle();                      Single Wid = _br.ReadSingle();                      Single Hgt = _br.ReadSingle();                      DoInstructions(Xp' Yp' Wid' Hgt' b);                  }                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,FillEllipse,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillEllipse.cs,Process,The following statement contains a magic number: try              {                                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  _fr.ReadByte();                  //Byte 1 will be ignored                  byte RealFlags = _fr.ReadByte();                  //Byte 2 will be brushtype                  // 0 1 2 3 4 5 6 7                  // X X X X X X C S                  // if S = 1 brushID is an ARGBobject' else its an Index to object table                  // if C = 1 int16' 0 = Points are Float (ignore P)                                bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool BrushIsARGB = ((RealFlags & (int)Math.Pow(2' 7)) == (int)Math.Pow(2' 7));                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  Brush b;                  if (BrushIsARGB)                  {                      byte A' R' G' B;                      B = _br.ReadByte();                      G = _br.ReadByte();                      R = _br.ReadByte();                      A = _br.ReadByte();                      b = new SolidBrush(Color.FromArgb(A' R' G' B));                  }                  else                  {                      UInt32 BrushID = _br.ReadUInt32();                      EMFBrush EMFb = (EMFBrush)ObjectTable[(byte)BrushID];                      b = EMFb.myBrush;                  }                  if (Compressed)                  {                      Int16 Xp = _br.ReadInt16();                      Int16 Yp = _br.ReadInt16();                      Int16 Wid = _br.ReadInt16();                      Int16 Hgt = _br.ReadInt16();                      DoInstructions(Xp' Yp' Wid' Hgt' b);                  }                  else                  {                      Single Xp = _br.ReadSingle();                      Single Yp = _br.ReadSingle();                      Single Wid = _br.ReadSingle();                      Single Hgt = _br.ReadSingle();                      DoInstructions(Xp' Yp' Wid' Hgt' b);                  }                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,FillEllipse,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillEllipse.cs,Process,The following statement contains a magic number: try              {                                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  _fr.ReadByte();                  //Byte 1 will be ignored                  byte RealFlags = _fr.ReadByte();                  //Byte 2 will be brushtype                  // 0 1 2 3 4 5 6 7                  // X X X X X X C S                  // if S = 1 brushID is an ARGBobject' else its an Index to object table                  // if C = 1 int16' 0 = Points are Float (ignore P)                                bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool BrushIsARGB = ((RealFlags & (int)Math.Pow(2' 7)) == (int)Math.Pow(2' 7));                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  Brush b;                  if (BrushIsARGB)                  {                      byte A' R' G' B;                      B = _br.ReadByte();                      G = _br.ReadByte();                      R = _br.ReadByte();                      A = _br.ReadByte();                      b = new SolidBrush(Color.FromArgb(A' R' G' B));                  }                  else                  {                      UInt32 BrushID = _br.ReadUInt32();                      EMFBrush EMFb = (EMFBrush)ObjectTable[(byte)BrushID];                      b = EMFb.myBrush;                  }                  if (Compressed)                  {                      Int16 Xp = _br.ReadInt16();                      Int16 Yp = _br.ReadInt16();                      Int16 Wid = _br.ReadInt16();                      Int16 Hgt = _br.ReadInt16();                      DoInstructions(Xp' Yp' Wid' Hgt' b);                  }                  else                  {                      Single Xp = _br.ReadSingle();                      Single Yp = _br.ReadSingle();                      Single Wid = _br.ReadSingle();                      Single Hgt = _br.ReadSingle();                      DoInstructions(Xp' Yp' Wid' Hgt' b);                  }                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,FillEllipse,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillEllipse.cs,Process,The following statement contains a magic number: try              {                                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  _fr.ReadByte();                  //Byte 1 will be ignored                  byte RealFlags = _fr.ReadByte();                  //Byte 2 will be brushtype                  // 0 1 2 3 4 5 6 7                  // X X X X X X C S                  // if S = 1 brushID is an ARGBobject' else its an Index to object table                  // if C = 1 int16' 0 = Points are Float (ignore P)                                bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool BrushIsARGB = ((RealFlags & (int)Math.Pow(2' 7)) == (int)Math.Pow(2' 7));                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  Brush b;                  if (BrushIsARGB)                  {                      byte A' R' G' B;                      B = _br.ReadByte();                      G = _br.ReadByte();                      R = _br.ReadByte();                      A = _br.ReadByte();                      b = new SolidBrush(Color.FromArgb(A' R' G' B));                  }                  else                  {                      UInt32 BrushID = _br.ReadUInt32();                      EMFBrush EMFb = (EMFBrush)ObjectTable[(byte)BrushID];                      b = EMFb.myBrush;                  }                  if (Compressed)                  {                      Int16 Xp = _br.ReadInt16();                      Int16 Yp = _br.ReadInt16();                      Int16 Wid = _br.ReadInt16();                      Int16 Hgt = _br.ReadInt16();                      DoInstructions(Xp' Yp' Wid' Hgt' b);                  }                  else                  {                      Single Xp = _br.ReadSingle();                      Single Yp = _br.ReadSingle();                      Single Wid = _br.ReadSingle();                      Single Hgt = _br.ReadSingle();                      DoInstructions(Xp' Yp' Wid' Hgt' b);                  }                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,FillEllipse,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillEllipse.cs,Process,The following statement contains a magic number: try              {                                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  _fr.ReadByte();                  //Byte 1 will be ignored                  byte RealFlags = _fr.ReadByte();                  //Byte 2 will be brushtype                  // 0 1 2 3 4 5 6 7                  // X X X X X X C S                  // if S = 1 brushID is an ARGBobject' else its an Index to object table                  // if C = 1 int16' 0 = Points are Float (ignore P)                                bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool BrushIsARGB = ((RealFlags & (int)Math.Pow(2' 7)) == (int)Math.Pow(2' 7));                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  Brush b;                  if (BrushIsARGB)                  {                      byte A' R' G' B;                      B = _br.ReadByte();                      G = _br.ReadByte();                      R = _br.ReadByte();                      A = _br.ReadByte();                      b = new SolidBrush(Color.FromArgb(A' R' G' B));                  }                  else                  {                      UInt32 BrushID = _br.ReadUInt32();                      EMFBrush EMFb = (EMFBrush)ObjectTable[(byte)BrushID];                      b = EMFb.myBrush;                  }                  if (Compressed)                  {                      Int16 Xp = _br.ReadInt16();                      Int16 Yp = _br.ReadInt16();                      Int16 Wid = _br.ReadInt16();                      Int16 Hgt = _br.ReadInt16();                      DoInstructions(Xp' Yp' Wid' Hgt' b);                  }                  else                  {                      Single Xp = _br.ReadSingle();                      Single Yp = _br.ReadSingle();                      Single Wid = _br.ReadSingle();                      Single Hgt = _br.ReadSingle();                      DoInstructions(Xp' Yp' Wid' Hgt' b);                  }                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,FillPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillPie.cs,Process,The following statement contains a magic number: try              {                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X C S                                  // if C = 1 Data int16 else float!                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool BrushIsARGB = ((RealFlags & (int)Math.Pow(2' 7)) == (int)Math.Pow(2' 7));                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  Brush b;                  if (BrushIsARGB)                  {                      byte A' R' G' B;                      B = _br.ReadByte();                      G = _br.ReadByte();                      R = _br.ReadByte();                      A = _br.ReadByte();                      b = new SolidBrush(Color.FromArgb(A' R' G' B));                  }                  else                  {                      UInt32 BrushID = _br.ReadUInt32();                      EMFBrush EMFb = (EMFBrush)ObjectTable[(byte)BrushID];                      b = EMFb.myBrush;                  }                  Single StartAngle = _br.ReadSingle();                  Single SweepAngle = _br.ReadSingle();                  if (Compressed)                  {                      DoCompressed(StartAngle'SweepAngle' _br' b);                  }                  else                  {                      DoFloat(StartAngle'SweepAngle' _br' b);                  }                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,FillPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillPie.cs,Process,The following statement contains a magic number: try              {                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X C S                                  // if C = 1 Data int16 else float!                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool BrushIsARGB = ((RealFlags & (int)Math.Pow(2' 7)) == (int)Math.Pow(2' 7));                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  Brush b;                  if (BrushIsARGB)                  {                      byte A' R' G' B;                      B = _br.ReadByte();                      G = _br.ReadByte();                      R = _br.ReadByte();                      A = _br.ReadByte();                      b = new SolidBrush(Color.FromArgb(A' R' G' B));                  }                  else                  {                      UInt32 BrushID = _br.ReadUInt32();                      EMFBrush EMFb = (EMFBrush)ObjectTable[(byte)BrushID];                      b = EMFb.myBrush;                  }                  Single StartAngle = _br.ReadSingle();                  Single SweepAngle = _br.ReadSingle();                  if (Compressed)                  {                      DoCompressed(StartAngle'SweepAngle' _br' b);                  }                  else                  {                      DoFloat(StartAngle'SweepAngle' _br' b);                  }                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,FillPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillPie.cs,Process,The following statement contains a magic number: try              {                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X C S                                  // if C = 1 Data int16 else float!                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool BrushIsARGB = ((RealFlags & (int)Math.Pow(2' 7)) == (int)Math.Pow(2' 7));                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  Brush b;                  if (BrushIsARGB)                  {                      byte A' R' G' B;                      B = _br.ReadByte();                      G = _br.ReadByte();                      R = _br.ReadByte();                      A = _br.ReadByte();                      b = new SolidBrush(Color.FromArgb(A' R' G' B));                  }                  else                  {                      UInt32 BrushID = _br.ReadUInt32();                      EMFBrush EMFb = (EMFBrush)ObjectTable[(byte)BrushID];                      b = EMFb.myBrush;                  }                  Single StartAngle = _br.ReadSingle();                  Single SweepAngle = _br.ReadSingle();                  if (Compressed)                  {                      DoCompressed(StartAngle'SweepAngle' _br' b);                  }                  else                  {                      DoFloat(StartAngle'SweepAngle' _br' b);                  }                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,FillPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillPie.cs,Process,The following statement contains a magic number: try              {                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X C S                                  // if C = 1 Data int16 else float!                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool BrushIsARGB = ((RealFlags & (int)Math.Pow(2' 7)) == (int)Math.Pow(2' 7));                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  Brush b;                  if (BrushIsARGB)                  {                      byte A' R' G' B;                      B = _br.ReadByte();                      G = _br.ReadByte();                      R = _br.ReadByte();                      A = _br.ReadByte();                      b = new SolidBrush(Color.FromArgb(A' R' G' B));                  }                  else                  {                      UInt32 BrushID = _br.ReadUInt32();                      EMFBrush EMFb = (EMFBrush)ObjectTable[(byte)BrushID];                      b = EMFb.myBrush;                  }                  Single StartAngle = _br.ReadSingle();                  Single SweepAngle = _br.ReadSingle();                  if (Compressed)                  {                      DoCompressed(StartAngle'SweepAngle' _br' b);                  }                  else                  {                      DoFloat(StartAngle'SweepAngle' _br' b);                  }                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,FillPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillPie.cs,Process,The following statement contains a magic number: try              {                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X C S                                  // if C = 1 Data int16 else float!                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool BrushIsARGB = ((RealFlags & (int)Math.Pow(2' 7)) == (int)Math.Pow(2' 7));                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  Brush b;                  if (BrushIsARGB)                  {                      byte A' R' G' B;                      B = _br.ReadByte();                      G = _br.ReadByte();                      R = _br.ReadByte();                      A = _br.ReadByte();                      b = new SolidBrush(Color.FromArgb(A' R' G' B));                  }                  else                  {                      UInt32 BrushID = _br.ReadUInt32();                      EMFBrush EMFb = (EMFBrush)ObjectTable[(byte)BrushID];                      b = EMFb.myBrush;                  }                  Single StartAngle = _br.ReadSingle();                  Single SweepAngle = _br.ReadSingle();                  if (Compressed)                  {                      DoCompressed(StartAngle'SweepAngle' _br' b);                  }                  else                  {                      DoFloat(StartAngle'SweepAngle' _br' b);                  }                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,FillPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillPie.cs,Process,The following statement contains a magic number: try              {                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X C S                                  // if C = 1 Data int16 else float!                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool BrushIsARGB = ((RealFlags & (int)Math.Pow(2' 7)) == (int)Math.Pow(2' 7));                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  Brush b;                  if (BrushIsARGB)                  {                      byte A' R' G' B;                      B = _br.ReadByte();                      G = _br.ReadByte();                      R = _br.ReadByte();                      A = _br.ReadByte();                      b = new SolidBrush(Color.FromArgb(A' R' G' B));                  }                  else                  {                      UInt32 BrushID = _br.ReadUInt32();                      EMFBrush EMFb = (EMFBrush)ObjectTable[(byte)BrushID];                      b = EMFb.myBrush;                  }                  Single StartAngle = _br.ReadSingle();                  Single SweepAngle = _br.ReadSingle();                  if (Compressed)                  {                      DoCompressed(StartAngle'SweepAngle' _br' b);                  }                  else                  {                      DoFloat(StartAngle'SweepAngle' _br' b);                  }                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,FillPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillPie.cs,Process,The following statement contains a magic number: try              {                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X C S                                  // if C = 1 Data int16 else float!                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool BrushIsARGB = ((RealFlags & (int)Math.Pow(2' 7)) == (int)Math.Pow(2' 7));                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  Brush b;                  if (BrushIsARGB)                  {                      byte A' R' G' B;                      B = _br.ReadByte();                      G = _br.ReadByte();                      R = _br.ReadByte();                      A = _br.ReadByte();                      b = new SolidBrush(Color.FromArgb(A' R' G' B));                  }                  else                  {                      UInt32 BrushID = _br.ReadUInt32();                      EMFBrush EMFb = (EMFBrush)ObjectTable[(byte)BrushID];                      b = EMFb.myBrush;                  }                  Single StartAngle = _br.ReadSingle();                  Single SweepAngle = _br.ReadSingle();                  if (Compressed)                  {                      DoCompressed(StartAngle'SweepAngle' _br' b);                  }                  else                  {                      DoFloat(StartAngle'SweepAngle' _br' b);                  }                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,FillPie,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillPie.cs,Process,The following statement contains a magic number: try              {                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X C S                                  // if C = 1 Data int16 else float!                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool BrushIsARGB = ((RealFlags & (int)Math.Pow(2' 7)) == (int)Math.Pow(2' 7));                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  Brush b;                  if (BrushIsARGB)                  {                      byte A' R' G' B;                      B = _br.ReadByte();                      G = _br.ReadByte();                      R = _br.ReadByte();                      A = _br.ReadByte();                      b = new SolidBrush(Color.FromArgb(A' R' G' B));                  }                  else                  {                      UInt32 BrushID = _br.ReadUInt32();                      EMFBrush EMFb = (EMFBrush)ObjectTable[(byte)BrushID];                      b = EMFb.myBrush;                  }                  Single StartAngle = _br.ReadSingle();                  Single SweepAngle = _br.ReadSingle();                  if (Compressed)                  {                      DoCompressed(StartAngle'SweepAngle' _br' b);                  }                  else                  {                      DoFloat(StartAngle'SweepAngle' _br' b);                  }                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,FillPolygon,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillPolygon.cs,Process,The following statement contains a magic number: try              {                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X C S                                  // if C = 1 Data int16 else float!                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool BrushIsARGB = ((RealFlags & (int)Math.Pow(2' 7)) == (int)Math.Pow(2' 7));                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  Brush b;                  if (BrushIsARGB)                  {                      byte A' R' G' B;                      B = _br.ReadByte();                      G = _br.ReadByte();                      R = _br.ReadByte();                      A = _br.ReadByte();                      b = new SolidBrush(Color.FromArgb(A' R' G' B));                  }                  else                  {                      UInt32 BrushID = _br.ReadUInt32();                      EMFBrush EMFb = (EMFBrush)ObjectTable[(byte)BrushID];                      b = EMFb.myBrush;                  }                  UInt32 NumberOfPoints = _br.ReadUInt32();                  if (Compressed)                  {                      DoCompressed(NumberOfPoints' _br' b);                  }                  else                  {                      DoFloat(NumberOfPoints' _br' b);                  }                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,FillPolygon,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillPolygon.cs,Process,The following statement contains a magic number: try              {                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X C S                                  // if C = 1 Data int16 else float!                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool BrushIsARGB = ((RealFlags & (int)Math.Pow(2' 7)) == (int)Math.Pow(2' 7));                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  Brush b;                  if (BrushIsARGB)                  {                      byte A' R' G' B;                      B = _br.ReadByte();                      G = _br.ReadByte();                      R = _br.ReadByte();                      A = _br.ReadByte();                      b = new SolidBrush(Color.FromArgb(A' R' G' B));                  }                  else                  {                      UInt32 BrushID = _br.ReadUInt32();                      EMFBrush EMFb = (EMFBrush)ObjectTable[(byte)BrushID];                      b = EMFb.myBrush;                  }                  UInt32 NumberOfPoints = _br.ReadUInt32();                  if (Compressed)                  {                      DoCompressed(NumberOfPoints' _br' b);                  }                  else                  {                      DoFloat(NumberOfPoints' _br' b);                  }                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,FillPolygon,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillPolygon.cs,Process,The following statement contains a magic number: try              {                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X C S                                  // if C = 1 Data int16 else float!                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool BrushIsARGB = ((RealFlags & (int)Math.Pow(2' 7)) == (int)Math.Pow(2' 7));                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  Brush b;                  if (BrushIsARGB)                  {                      byte A' R' G' B;                      B = _br.ReadByte();                      G = _br.ReadByte();                      R = _br.ReadByte();                      A = _br.ReadByte();                      b = new SolidBrush(Color.FromArgb(A' R' G' B));                  }                  else                  {                      UInt32 BrushID = _br.ReadUInt32();                      EMFBrush EMFb = (EMFBrush)ObjectTable[(byte)BrushID];                      b = EMFb.myBrush;                  }                  UInt32 NumberOfPoints = _br.ReadUInt32();                  if (Compressed)                  {                      DoCompressed(NumberOfPoints' _br' b);                  }                  else                  {                      DoFloat(NumberOfPoints' _br' b);                  }                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,FillPolygon,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillPolygon.cs,Process,The following statement contains a magic number: try              {                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X C S                                  // if C = 1 Data int16 else float!                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool BrushIsARGB = ((RealFlags & (int)Math.Pow(2' 7)) == (int)Math.Pow(2' 7));                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  Brush b;                  if (BrushIsARGB)                  {                      byte A' R' G' B;                      B = _br.ReadByte();                      G = _br.ReadByte();                      R = _br.ReadByte();                      A = _br.ReadByte();                      b = new SolidBrush(Color.FromArgb(A' R' G' B));                  }                  else                  {                      UInt32 BrushID = _br.ReadUInt32();                      EMFBrush EMFb = (EMFBrush)ObjectTable[(byte)BrushID];                      b = EMFb.myBrush;                  }                  UInt32 NumberOfPoints = _br.ReadUInt32();                  if (Compressed)                  {                      DoCompressed(NumberOfPoints' _br' b);                  }                  else                  {                      DoFloat(NumberOfPoints' _br' b);                  }                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,FillPolygon,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillPolygon.cs,Process,The following statement contains a magic number: try              {                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X C S                                  // if C = 1 Data int16 else float!                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool BrushIsARGB = ((RealFlags & (int)Math.Pow(2' 7)) == (int)Math.Pow(2' 7));                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  Brush b;                  if (BrushIsARGB)                  {                      byte A' R' G' B;                      B = _br.ReadByte();                      G = _br.ReadByte();                      R = _br.ReadByte();                      A = _br.ReadByte();                      b = new SolidBrush(Color.FromArgb(A' R' G' B));                  }                  else                  {                      UInt32 BrushID = _br.ReadUInt32();                      EMFBrush EMFb = (EMFBrush)ObjectTable[(byte)BrushID];                      b = EMFb.myBrush;                  }                  UInt32 NumberOfPoints = _br.ReadUInt32();                  if (Compressed)                  {                      DoCompressed(NumberOfPoints' _br' b);                  }                  else                  {                      DoFloat(NumberOfPoints' _br' b);                  }                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,FillPolygon,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillPolygon.cs,Process,The following statement contains a magic number: try              {                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X C S                                  // if C = 1 Data int16 else float!                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool BrushIsARGB = ((RealFlags & (int)Math.Pow(2' 7)) == (int)Math.Pow(2' 7));                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  Brush b;                  if (BrushIsARGB)                  {                      byte A' R' G' B;                      B = _br.ReadByte();                      G = _br.ReadByte();                      R = _br.ReadByte();                      A = _br.ReadByte();                      b = new SolidBrush(Color.FromArgb(A' R' G' B));                  }                  else                  {                      UInt32 BrushID = _br.ReadUInt32();                      EMFBrush EMFb = (EMFBrush)ObjectTable[(byte)BrushID];                      b = EMFb.myBrush;                  }                  UInt32 NumberOfPoints = _br.ReadUInt32();                  if (Compressed)                  {                      DoCompressed(NumberOfPoints' _br' b);                  }                  else                  {                      DoFloat(NumberOfPoints' _br' b);                  }                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,FillPolygon,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillPolygon.cs,Process,The following statement contains a magic number: try              {                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X C S                                  // if C = 1 Data int16 else float!                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool BrushIsARGB = ((RealFlags & (int)Math.Pow(2' 7)) == (int)Math.Pow(2' 7));                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  Brush b;                  if (BrushIsARGB)                  {                      byte A' R' G' B;                      B = _br.ReadByte();                      G = _br.ReadByte();                      R = _br.ReadByte();                      A = _br.ReadByte();                      b = new SolidBrush(Color.FromArgb(A' R' G' B));                  }                  else                  {                      UInt32 BrushID = _br.ReadUInt32();                      EMFBrush EMFb = (EMFBrush)ObjectTable[(byte)BrushID];                      b = EMFb.myBrush;                  }                  UInt32 NumberOfPoints = _br.ReadUInt32();                  if (Compressed)                  {                      DoCompressed(NumberOfPoints' _br' b);                  }                  else                  {                      DoFloat(NumberOfPoints' _br' b);                  }                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,FillPolygon,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillPolygon.cs,Process,The following statement contains a magic number: try              {                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X C S                                  // if C = 1 Data int16 else float!                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool BrushIsARGB = ((RealFlags & (int)Math.Pow(2' 7)) == (int)Math.Pow(2' 7));                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  Brush b;                  if (BrushIsARGB)                  {                      byte A' R' G' B;                      B = _br.ReadByte();                      G = _br.ReadByte();                      R = _br.ReadByte();                      A = _br.ReadByte();                      b = new SolidBrush(Color.FromArgb(A' R' G' B));                  }                  else                  {                      UInt32 BrushID = _br.ReadUInt32();                      EMFBrush EMFb = (EMFBrush)ObjectTable[(byte)BrushID];                      b = EMFb.myBrush;                  }                  UInt32 NumberOfPoints = _br.ReadUInt32();                  if (Compressed)                  {                      DoCompressed(NumberOfPoints' _br' b);                  }                  else                  {                      DoFloat(NumberOfPoints' _br' b);                  }                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,FillRects,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillRects.cs,Process,The following statement contains a magic number: try              {                                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X C S                                  // if C = 1 Data int16 else float!                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool BrushIsARGB = ((RealFlags & (int)Math.Pow(2' 7)) == (int)Math.Pow(2' 7));                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  Brush b;                  if (BrushIsARGB)                  {                      byte A' R' G' B;                      B = _br.ReadByte();                      G = _br.ReadByte();                      R = _br.ReadByte();                      A = _br.ReadByte();                      b = new SolidBrush(Color.FromArgb(A' R' G' B));                  }                  else                  {                      UInt32 BrushID = _br.ReadUInt32();                      EMFBrush EMFb = (EMFBrush)ObjectTable[(byte)BrushID];                      b = EMFb.myBrush;                  }                  UInt32 NumberOfRects = _br.ReadUInt32();                  if (Compressed)                  {                      DoCompressed(NumberOfRects' _br' b);                  }                  else                  {                      DoFloat(NumberOfRects' _br' b);                  }                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,FillRects,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillRects.cs,Process,The following statement contains a magic number: try              {                                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X C S                                  // if C = 1 Data int16 else float!                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool BrushIsARGB = ((RealFlags & (int)Math.Pow(2' 7)) == (int)Math.Pow(2' 7));                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  Brush b;                  if (BrushIsARGB)                  {                      byte A' R' G' B;                      B = _br.ReadByte();                      G = _br.ReadByte();                      R = _br.ReadByte();                      A = _br.ReadByte();                      b = new SolidBrush(Color.FromArgb(A' R' G' B));                  }                  else                  {                      UInt32 BrushID = _br.ReadUInt32();                      EMFBrush EMFb = (EMFBrush)ObjectTable[(byte)BrushID];                      b = EMFb.myBrush;                  }                  UInt32 NumberOfRects = _br.ReadUInt32();                  if (Compressed)                  {                      DoCompressed(NumberOfRects' _br' b);                  }                  else                  {                      DoFloat(NumberOfRects' _br' b);                  }                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,FillRects,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillRects.cs,Process,The following statement contains a magic number: try              {                                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X C S                                  // if C = 1 Data int16 else float!                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool BrushIsARGB = ((RealFlags & (int)Math.Pow(2' 7)) == (int)Math.Pow(2' 7));                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  Brush b;                  if (BrushIsARGB)                  {                      byte A' R' G' B;                      B = _br.ReadByte();                      G = _br.ReadByte();                      R = _br.ReadByte();                      A = _br.ReadByte();                      b = new SolidBrush(Color.FromArgb(A' R' G' B));                  }                  else                  {                      UInt32 BrushID = _br.ReadUInt32();                      EMFBrush EMFb = (EMFBrush)ObjectTable[(byte)BrushID];                      b = EMFb.myBrush;                  }                  UInt32 NumberOfRects = _br.ReadUInt32();                  if (Compressed)                  {                      DoCompressed(NumberOfRects' _br' b);                  }                  else                  {                      DoFloat(NumberOfRects' _br' b);                  }                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,FillRects,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillRects.cs,Process,The following statement contains a magic number: try              {                                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X C S                                  // if C = 1 Data int16 else float!                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool BrushIsARGB = ((RealFlags & (int)Math.Pow(2' 7)) == (int)Math.Pow(2' 7));                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  Brush b;                  if (BrushIsARGB)                  {                      byte A' R' G' B;                      B = _br.ReadByte();                      G = _br.ReadByte();                      R = _br.ReadByte();                      A = _br.ReadByte();                      b = new SolidBrush(Color.FromArgb(A' R' G' B));                  }                  else                  {                      UInt32 BrushID = _br.ReadUInt32();                      EMFBrush EMFb = (EMFBrush)ObjectTable[(byte)BrushID];                      b = EMFb.myBrush;                  }                  UInt32 NumberOfRects = _br.ReadUInt32();                  if (Compressed)                  {                      DoCompressed(NumberOfRects' _br' b);                  }                  else                  {                      DoFloat(NumberOfRects' _br' b);                  }                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,FillRects,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillRects.cs,Process,The following statement contains a magic number: try              {                                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X C S                                  // if C = 1 Data int16 else float!                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool BrushIsARGB = ((RealFlags & (int)Math.Pow(2' 7)) == (int)Math.Pow(2' 7));                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  Brush b;                  if (BrushIsARGB)                  {                      byte A' R' G' B;                      B = _br.ReadByte();                      G = _br.ReadByte();                      R = _br.ReadByte();                      A = _br.ReadByte();                      b = new SolidBrush(Color.FromArgb(A' R' G' B));                  }                  else                  {                      UInt32 BrushID = _br.ReadUInt32();                      EMFBrush EMFb = (EMFBrush)ObjectTable[(byte)BrushID];                      b = EMFb.myBrush;                  }                  UInt32 NumberOfRects = _br.ReadUInt32();                  if (Compressed)                  {                      DoCompressed(NumberOfRects' _br' b);                  }                  else                  {                      DoFloat(NumberOfRects' _br' b);                  }                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,FillRects,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillRects.cs,Process,The following statement contains a magic number: try              {                                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X C S                                  // if C = 1 Data int16 else float!                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool BrushIsARGB = ((RealFlags & (int)Math.Pow(2' 7)) == (int)Math.Pow(2' 7));                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  Brush b;                  if (BrushIsARGB)                  {                      byte A' R' G' B;                      B = _br.ReadByte();                      G = _br.ReadByte();                      R = _br.ReadByte();                      A = _br.ReadByte();                      b = new SolidBrush(Color.FromArgb(A' R' G' B));                  }                  else                  {                      UInt32 BrushID = _br.ReadUInt32();                      EMFBrush EMFb = (EMFBrush)ObjectTable[(byte)BrushID];                      b = EMFb.myBrush;                  }                  UInt32 NumberOfRects = _br.ReadUInt32();                  if (Compressed)                  {                      DoCompressed(NumberOfRects' _br' b);                  }                  else                  {                      DoFloat(NumberOfRects' _br' b);                  }                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,FillRects,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillRects.cs,Process,The following statement contains a magic number: try              {                                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X C S                                  // if C = 1 Data int16 else float!                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool BrushIsARGB = ((RealFlags & (int)Math.Pow(2' 7)) == (int)Math.Pow(2' 7));                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  Brush b;                  if (BrushIsARGB)                  {                      byte A' R' G' B;                      B = _br.ReadByte();                      G = _br.ReadByte();                      R = _br.ReadByte();                      A = _br.ReadByte();                      b = new SolidBrush(Color.FromArgb(A' R' G' B));                  }                  else                  {                      UInt32 BrushID = _br.ReadUInt32();                      EMFBrush EMFb = (EMFBrush)ObjectTable[(byte)BrushID];                      b = EMFb.myBrush;                  }                  UInt32 NumberOfRects = _br.ReadUInt32();                  if (Compressed)                  {                      DoCompressed(NumberOfRects' _br' b);                  }                  else                  {                      DoFloat(NumberOfRects' _br' b);                  }                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,FillRects,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillRects.cs,Process,The following statement contains a magic number: try              {                                  _fs = new MemoryStream(BitConverter.GetBytes(Flags));                  _fr = new BinaryReader(_fs);                  _fr.ReadByte();                  //Byte 2 is the real flags                  byte RealFlags = _fr.ReadByte();                  // 0 1 2 3 4 5 6 7                  // X X X X X X C S                                  // if C = 1 Data int16 else float!                  bool Compressed = ((RealFlags & (int)Math.Pow(2' 6)) == (int)Math.Pow(2' 6));                  bool BrushIsARGB = ((RealFlags & (int)Math.Pow(2' 7)) == (int)Math.Pow(2' 7));                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  Brush b;                  if (BrushIsARGB)                  {                      byte A' R' G' B;                      B = _br.ReadByte();                      G = _br.ReadByte();                      R = _br.ReadByte();                      A = _br.ReadByte();                      b = new SolidBrush(Color.FromArgb(A' R' G' B));                  }                  else                  {                      UInt32 BrushID = _br.ReadUInt32();                      EMFBrush EMFb = (EMFBrush)ObjectTable[(byte)BrushID];                      b = EMFb.myBrush;                  }                  UInt32 NumberOfRects = _br.ReadUInt32();                  if (Compressed)                  {                      DoCompressed(NumberOfRects' _br' b);                  }                  else                  {                      DoFloat(NumberOfRects' _br' b);                  }                  return items;              }              finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                  if (_fr != null)                      _fr.Close();                  if (_fs != null)                      _fs.Dispose();              }
Magic Number,fyiReporting.RDL,EmfLinearGradientBrush,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFObjects\EMFBrush.cs,EmfLinearGradientBrush,The following statement contains a magic number: _br.ReadBytes(8);
Magic Number,fyiReporting.RDL,EmfLinearGradientBrush,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFObjects\EMFBrush.cs,EmfLinearGradientBrush,The following statement contains a magic number: if (BrushDataTransform)              {                  _br.ReadBytes(24); //Transform matrix (ignored for now)                }
Magic Number,fyiReporting.RDL,EMFFont,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFObjects\EMFFont.cs,Process,The following statement contains a magic number: try              {                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  UInt32 Version = _br.ReadUInt32();                  Single EmSize = _br.ReadSingle();                  UInt32 SizeUnit = _br.ReadUInt32();                  Int32 FontStyleFlags = _br.ReadInt32();                  _br.ReadUInt32();                  UInt32 NameLength = _br.ReadUInt32();                  char[] FontFamily = new char[NameLength];                   System.Text.UnicodeEncoding d = new System.Text.UnicodeEncoding();                  d.GetChars(_br.ReadBytes((int)NameLength * 2)'0'(int)NameLength * 2'FontFamily'0);                                  Font aFont = new Font(new String(FontFamily)' EmSize' (FontStyle)FontStyleFlags' (GraphicsUnit)SizeUnit);                  EMFFont ThisFont = new EMFFont();                  ThisFont.myFont = aFont;                  return ThisFont;              }              finally              {                  if (_br != null)                      _br.Close();                                 if (_ms != null)                      _ms.Dispose();                          }
Magic Number,fyiReporting.RDL,EMFFont,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFObjects\EMFFont.cs,Process,The following statement contains a magic number: try              {                  _ms = new MemoryStream(RecordData);                  _br = new BinaryReader(_ms);                  UInt32 Version = _br.ReadUInt32();                  Single EmSize = _br.ReadSingle();                  UInt32 SizeUnit = _br.ReadUInt32();                  Int32 FontStyleFlags = _br.ReadInt32();                  _br.ReadUInt32();                  UInt32 NameLength = _br.ReadUInt32();                  char[] FontFamily = new char[NameLength];                   System.Text.UnicodeEncoding d = new System.Text.UnicodeEncoding();                  d.GetChars(_br.ReadBytes((int)NameLength * 2)'0'(int)NameLength * 2'FontFamily'0);                                  Font aFont = new Font(new String(FontFamily)' EmSize' (FontStyle)FontStyleFlags' (GraphicsUnit)SizeUnit);                  EMFFont ThisFont = new EMFFont();                  ThisFont.myFont = aFont;                  return ThisFont;              }              finally              {                  if (_br != null)                      _br.Close();                                 if (_ms != null)                      _ms.Dispose();                          }
Magic Number,fyiReporting.RDL,EMFPen,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFObjects\EMFPen.cs,EMFPen,The following statement contains a magic number: if ((Flags & (UInt32)PenDataFlags.PenDataTransform) == (UInt32)PenDataFlags.PenDataTransform)              {                  //Read the next 24 bytes... A PenDataTransformObject                  Transform = _br.ReadBytes(24);              }
Magic Number,fyiReporting.RDL,EMFStringFormat,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFObjects\EMFStringFormat.cs,EMFStringFormat,The following statement contains a magic number: _br.ReadBytes(4);
Magic Number,fyiReporting.RDL,EMFRecordObject,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFRecordObject.cs,getObject,The following statement contains a magic number: try              {                  //Put the Flags into a stream and then use a binary Reader to read the Flags                  _ms = new MemoryStream(BitConverter.GetBytes(flags));                  _br = new BinaryReader(_ms);                  //ObjectID is least significant byte (which will be the first byte in the byte array due to Little Endian)                         byte Objectid = _br.ReadByte();                  //Object Type next...                  byte ObjectTyp = _br.ReadByte();                  //Don't know what to do if this object continues on the next one!                  bool ContinuesOnNextObject = ((ObjectTyp & 128) == 128);                  if (ContinuesOnNextObject)                      ObjectTyp ^= 128;                    switch ((UInt16)ObjectTyp)                  {                      case (UInt16)EmfObjectType.invalid:                           break;                      case (UInt16)EmfObjectType.brush:                          EMFBrush Obrush = EMFBrush.getEMFBrush(RecordData);                          Obrush.ObjectID = Objectid;                          return Obrush;                      case (UInt16)EmfObjectType.pen:                          EMFPen OPen = EMFPen.getEMFPen(RecordData);                          OPen.ObjectID = Objectid;                          return OPen;                      case (UInt16)EmfObjectType.path:                          break;                      case (UInt16)EmfObjectType.region:                          break;                      case (UInt16)EmfObjectType.image:                          break;                      case (UInt16)EmfObjectType.font:                          EMFFont OFont = EMFFont.getEMFFont(RecordData);                          OFont.ObjectID = Objectid;                          return OFont;                                           case (UInt16)EmfObjectType.stringformat:                          EMFStringFormat Ostringformat = EMFStringFormat.getEMFStringFormat(RecordData);                          Ostringformat.ObjectID = Objectid;                          return Ostringformat;                                             case (UInt16)EmfObjectType.ImageAttributes:                          break;                      case (UInt16)EmfObjectType.CustomLineType:                          break;                  }                  return null;              }               catch (Exception e)                          {                                 throw e;              }                                    finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                                   }
Magic Number,fyiReporting.RDL,EMFRecordObject,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFRecordObject.cs,getObject,The following statement contains a magic number: try              {                  //Put the Flags into a stream and then use a binary Reader to read the Flags                  _ms = new MemoryStream(BitConverter.GetBytes(flags));                  _br = new BinaryReader(_ms);                  //ObjectID is least significant byte (which will be the first byte in the byte array due to Little Endian)                         byte Objectid = _br.ReadByte();                  //Object Type next...                  byte ObjectTyp = _br.ReadByte();                  //Don't know what to do if this object continues on the next one!                  bool ContinuesOnNextObject = ((ObjectTyp & 128) == 128);                  if (ContinuesOnNextObject)                      ObjectTyp ^= 128;                    switch ((UInt16)ObjectTyp)                  {                      case (UInt16)EmfObjectType.invalid:                           break;                      case (UInt16)EmfObjectType.brush:                          EMFBrush Obrush = EMFBrush.getEMFBrush(RecordData);                          Obrush.ObjectID = Objectid;                          return Obrush;                      case (UInt16)EmfObjectType.pen:                          EMFPen OPen = EMFPen.getEMFPen(RecordData);                          OPen.ObjectID = Objectid;                          return OPen;                      case (UInt16)EmfObjectType.path:                          break;                      case (UInt16)EmfObjectType.region:                          break;                      case (UInt16)EmfObjectType.image:                          break;                      case (UInt16)EmfObjectType.font:                          EMFFont OFont = EMFFont.getEMFFont(RecordData);                          OFont.ObjectID = Objectid;                          return OFont;                                           case (UInt16)EmfObjectType.stringformat:                          EMFStringFormat Ostringformat = EMFStringFormat.getEMFStringFormat(RecordData);                          Ostringformat.ObjectID = Objectid;                          return Ostringformat;                                             case (UInt16)EmfObjectType.ImageAttributes:                          break;                      case (UInt16)EmfObjectType.CustomLineType:                          break;                  }                  return null;              }               catch (Exception e)                          {                                 throw e;              }                                    finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                                   }
Magic Number,fyiReporting.RDL,EMFRecordObject,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFRecordObject.cs,getObject,The following statement contains a magic number: try              {                  //Put the Flags into a stream and then use a binary Reader to read the Flags                  _ms = new MemoryStream(BitConverter.GetBytes(flags));                  _br = new BinaryReader(_ms);                  //ObjectID is least significant byte (which will be the first byte in the byte array due to Little Endian)                         byte Objectid = _br.ReadByte();                  //Object Type next...                  byte ObjectTyp = _br.ReadByte();                  //Don't know what to do if this object continues on the next one!                  bool ContinuesOnNextObject = ((ObjectTyp & 128) == 128);                  if (ContinuesOnNextObject)                      ObjectTyp ^= 128;                    switch ((UInt16)ObjectTyp)                  {                      case (UInt16)EmfObjectType.invalid:                           break;                      case (UInt16)EmfObjectType.brush:                          EMFBrush Obrush = EMFBrush.getEMFBrush(RecordData);                          Obrush.ObjectID = Objectid;                          return Obrush;                      case (UInt16)EmfObjectType.pen:                          EMFPen OPen = EMFPen.getEMFPen(RecordData);                          OPen.ObjectID = Objectid;                          return OPen;                      case (UInt16)EmfObjectType.path:                          break;                      case (UInt16)EmfObjectType.region:                          break;                      case (UInt16)EmfObjectType.image:                          break;                      case (UInt16)EmfObjectType.font:                          EMFFont OFont = EMFFont.getEMFFont(RecordData);                          OFont.ObjectID = Objectid;                          return OFont;                                           case (UInt16)EmfObjectType.stringformat:                          EMFStringFormat Ostringformat = EMFStringFormat.getEMFStringFormat(RecordData);                          Ostringformat.ObjectID = Objectid;                          return Ostringformat;                                             case (UInt16)EmfObjectType.ImageAttributes:                          break;                      case (UInt16)EmfObjectType.CustomLineType:                          break;                  }                  return null;              }               catch (Exception e)                          {                                 throw e;              }                                    finally              {                  if (_br != null)                      _br.Close();                  if (_ms != null)                      _ms.Dispose();                                   }
Magic Number,fyiReporting.RDL,EMFSetPageTransform,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFTransform\EMFSetPageTransform.cs,EMFSetPageTransform,The following statement contains a magic number: try              {                  _fs = new MemoryStream(BitConverter.GetBytes(flags));                  _fr = new BinaryReader(_fs);                    //PageUnit...                  UInt16 PageU = _fr.ReadByte();                  PageUnit = (System.Drawing.GraphicsUnit)PageU;                    UInt16 RealFlags = _fr.ReadByte();                  //XXXXXAXX - if A = 1 the transform matrix is post-multiplied else pre-multiplied...                  //01234567                  postMultiplyTransform = ((RealFlags & (UInt16)Math.Pow(2' 5)) == Math.Pow(2' 5));                  PageScale = BitConverter.ToSingle(RecordData' 0);                                }              finally             {                 if (_fr != null)                     _fr.Close();                 if (_fs != null)                     _fs.Dispose();                              }
Magic Number,fyiReporting.RDL,EMFSetPageTransform,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFTransform\EMFSetPageTransform.cs,EMFSetPageTransform,The following statement contains a magic number: try              {                  _fs = new MemoryStream(BitConverter.GetBytes(flags));                  _fr = new BinaryReader(_fs);                    //PageUnit...                  UInt16 PageU = _fr.ReadByte();                  PageUnit = (System.Drawing.GraphicsUnit)PageU;                    UInt16 RealFlags = _fr.ReadByte();                  //XXXXXAXX - if A = 1 the transform matrix is post-multiplied else pre-multiplied...                  //01234567                  postMultiplyTransform = ((RealFlags & (UInt16)Math.Pow(2' 5)) == Math.Pow(2' 5));                  PageScale = BitConverter.ToSingle(RecordData' 0);                                }              finally             {                 if (_fr != null)                     _fr.Close();                 if (_fs != null)                     _fs.Dispose();                              }
Magic Number,fyiReporting.RDL,EMFSetPageTransform,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFTransform\EMFSetPageTransform.cs,EMFSetPageTransform,The following statement contains a magic number: try              {                  _fs = new MemoryStream(BitConverter.GetBytes(flags));                  _fr = new BinaryReader(_fs);                    //PageUnit...                  UInt16 PageU = _fr.ReadByte();                  PageUnit = (System.Drawing.GraphicsUnit)PageU;                    UInt16 RealFlags = _fr.ReadByte();                  //XXXXXAXX - if A = 1 the transform matrix is post-multiplied else pre-multiplied...                  //01234567                  postMultiplyTransform = ((RealFlags & (UInt16)Math.Pow(2' 5)) == Math.Pow(2' 5));                  PageScale = BitConverter.ToSingle(RecordData' 0);                                }              finally             {                 if (_fr != null)                     _fr.Close();                 if (_fs != null)                     _fs.Dispose();                              }
Magic Number,fyiReporting.RDL,EMFSetPageTransform,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFTransform\EMFSetPageTransform.cs,EMFSetPageTransform,The following statement contains a magic number: try              {                  _fs = new MemoryStream(BitConverter.GetBytes(flags));                  _fr = new BinaryReader(_fs);                    //PageUnit...                  UInt16 PageU = _fr.ReadByte();                  PageUnit = (System.Drawing.GraphicsUnit)PageU;                    UInt16 RealFlags = _fr.ReadByte();                  //XXXXXAXX - if A = 1 the transform matrix is post-multiplied else pre-multiplied...                  //01234567                  postMultiplyTransform = ((RealFlags & (UInt16)Math.Pow(2' 5)) == Math.Pow(2' 5));                  PageScale = BitConverter.ToSingle(RecordData' 0);                                }              finally             {                 if (_fr != null)                     _fr.Close();                 if (_fs != null)                     _fs.Dispose();                              }
Magic Number,fyiReporting.RDL,Expression,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Expression.cs,FinalPass,The following statement contains a magic number: try   			{  				_Expr = p.Parse(lu' _Source);  			}  			catch (Exception e)  			{  				_Expr = new ConstantError(e.Message);  				// Invalid expression  				OwnerReport.rl.LogError(8' ErrorText(e.Message));  			}
Magic Number,fyiReporting.RDL,Expression,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Expression.cs,FinalPass,The following statement contains a magic number: try  			{  				_Expr = _Expr.ConstantOptimization();  			}  			catch(Exception ex)  			{  				OwnerReport.rl.LogError(4' "Expression:" + _Source + "\r\nConstant Optimization exception:\r\n" + ex.Message + "\r\nStack trace:\r\n" + ex.StackTrace );  			}
Magic Number,fyiReporting.RDL,Expression,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Expression.cs,Evaluate,The following statement contains a magic number: try   			{  				// Check to see if we're evaluating an expression in a page header or footer;  				//   If that is the case the rows are cached by page.  				if (row == null && this.UniqueName != null)  				{  					Rows rows = rpt.GetPageExpressionRows(UniqueName);  					if (rows != null && rows.Data != null && rows.Data.Count > 0)  						row = rows.Data[0];  				}    				return _Expr.Evaluate(rpt' row);  			}  			catch (Exception e)  			{  				string err;  				if (e.InnerException != null)  					err = String.Format("Exception evaluating {0}.  {1}.  {2}"' _Source' e.Message' e.InnerException.Message);  				else  					err = String.Format("Exception evaluating {0}.  {1}"' _Source' e.Message);    				ReportError(rpt' 4' err);  				return null;  			}
Magic Number,fyiReporting.RDL,Expression,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Expression.cs,EvaluateString,The following statement contains a magic number: try   			{  				return _Expr.EvaluateString(rpt' row);  			}  			catch (Exception e)  			{	  				string err = String.Format("Exception evaluating {0}.  {1}"' _Source' e.Message);  				ReportError(rpt' 4' err);  				return null;  			}
Magic Number,fyiReporting.RDL,Expression,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Expression.cs,EvaluateDouble,The following statement contains a magic number: try   			{  				return _Expr.EvaluateDouble(rpt' row);  			}  			catch (Exception e)  			{	  				string err = String.Format("Exception evaluating {0}.  {1}"' _Source' e.Message);  				ReportError(rpt' 4' err);  				return double.NaN;  			}
Magic Number,fyiReporting.RDL,Expression,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Expression.cs,EvaluateDecimal,The following statement contains a magic number: try   			{  				return _Expr.EvaluateDecimal(rpt' row);  			}  			catch (Exception e)  			{	  				string err = String.Format("Exception evaluating {0}.  {1}"' _Source' e.Message);  				ReportError(rpt' 4' err);  				return decimal.MinValue;  			}
Magic Number,fyiReporting.RDL,Expression,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Expression.cs,EvaluateInt32,The following statement contains a magic number: try              {                  return _Expr.EvaluateInt32(rpt' row);              }              catch (Exception e)              {                  string err = String.Format("Exception evaluating {0}.  {1}"' _Source' e.Message);                  ReportError(rpt' 4' err);                  return int.MinValue;              }
Magic Number,fyiReporting.RDL,Expression,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Expression.cs,EvaluateDateTime,The following statement contains a magic number: try   			{  				return _Expr.EvaluateDateTime(rpt' row);  			}  			catch (Exception e)  			{	  				string err = String.Format("Exception evaluating {0}.  {1}"' _Source' e.Message);  				ReportError(rpt' 4' err);  				return DateTime.MinValue;  			}
Magic Number,fyiReporting.RDL,Expression,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Expression.cs,EvaluateBoolean,The following statement contains a magic number: try   			{  				return _Expr.EvaluateBoolean(rpt' row);  			}  			catch (Exception e)  			{	  				string err = String.Format("Exception evaluating {0}.  {1}"' _Source' e.Message);  				ReportError(rpt' 4' err);  				return false;  			}
Magic Number,fyiReporting.RDL,Field,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Field.cs,Field,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "DataField":  						_DataField = xNodeLoop.InnerText;  						break;  					case "TypeName":		// Extension !!!!!!!!!!!!!!!!!  					case "rd:TypeName":		// Microsoft Designer uses this extension  						_Type = DataType.GetStyle(xNodeLoop.InnerText' this.OwnerReport);  						break;  					case "Value":  						_Value = new Expression(r' this' xNodeLoop' ExpressionType.Variant);  						break;  					default:  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown Field element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,Field,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Field.cs,Field,The following statement contains a magic number: if (_DataField != null && _Value != null)  				OwnerReport.rl.LogError(8' "Only DataField or Value may be specified in a Field element' not both.");  			else if (_DataField == null && _Value == null)  				OwnerReport.rl.LogError(8' "Either DataField or Value must be specified in a Field element.");
Magic Number,fyiReporting.RDL,Field,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Field.cs,Field,The following statement contains a magic number: if (_DataField != null && _Value != null)  				OwnerReport.rl.LogError(8' "Only DataField or Value may be specified in a Field element' not both.");  			else if (_DataField == null && _Value == null)  				OwnerReport.rl.LogError(8' "Either DataField or Value must be specified in a Field element.");
Magic Number,fyiReporting.RDL,Field,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Field.cs,FinalPass,The following statement contains a magic number: if (_DataField != null)  			{  				Fields f = (Fields) this.Parent;  				DataSetDefn ds = (DataSetDefn) f.Parent;  				Query q = ds.Query;  				if (q != null && q.Columns != null)  				{  					qc = (QueryColumn) q.Columns[_DataField];  					if (qc == null)  					{	// couldn't find the data field  						OwnerReport.rl.LogError(8' "DataField '" + _DataField + "' not part of query.");  					}  				}  			}
Magic Number,fyiReporting.RDL,Fields,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Fields.cs,Fields,The following statement contains a magic number: if (xNode.ChildNodes.Count < 10)  				_Items = new ListDictionary();	// Hashtable is overkill for small lists  			else  				_Items = new Hashtable(xNode.ChildNodes.Count);
Magic Number,fyiReporting.RDL,Fields,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Fields.cs,Fields,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Field":  						f = new Field(r' this' xNodeLoop);  						f.ColumnNumber = iCol++;			// Assign the column number  						break;  					default:	  						f=null;	  						r.rl.LogError(4' "Unknown element '" + xNodeLoop.Name + "' in fields list.");   						break;  				}  				if (f != null)  				{  					if (_Items.Contains(f.Name.Nm))  					{  						r.rl.LogError(4' "Field " + f.Name + " has duplicates.");   					}  					else	  						_Items.Add(f.Name.Nm' f);  				}  			}
Magic Number,fyiReporting.RDL,Fields,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Fields.cs,Fields,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Field":  						f = new Field(r' this' xNodeLoop);  						f.ColumnNumber = iCol++;			// Assign the column number  						break;  					default:	  						f=null;	  						r.rl.LogError(4' "Unknown element '" + xNodeLoop.Name + "' in fields list.");   						break;  				}  				if (f != null)  				{  					if (_Items.Contains(f.Name.Nm))  					{  						r.rl.LogError(4' "Field " + f.Name + " has duplicates.");   					}  					else	  						_Items.Add(f.Name.Nm' f);  				}  			}
Magic Number,fyiReporting.RDL,Filter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Filter.cs,Filter,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "FilterExpression":  						_FilterExpression = new Expression(r' this' xNodeLoop' ExpressionType.Variant);  						break;  					case "Operator":  						_FilterOperator = RDL.FilterOperator.GetStyle(xNodeLoop.InnerText);  						if (_FilterOperator == FilterOperatorEnum.Unknown)  							OwnerReport.rl.LogError(8' "Unknown Filter operator '" + xNodeLoop.InnerText + "'.");  						break;  					case "FilterValues":  						_FilterValues = new FilterValues(r' this' xNodeLoop);  						break;  					default:  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown Filter element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,Filter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Filter.cs,Filter,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "FilterExpression":  						_FilterExpression = new Expression(r' this' xNodeLoop' ExpressionType.Variant);  						break;  					case "Operator":  						_FilterOperator = RDL.FilterOperator.GetStyle(xNodeLoop.InnerText);  						if (_FilterOperator == FilterOperatorEnum.Unknown)  							OwnerReport.rl.LogError(8' "Unknown Filter operator '" + xNodeLoop.InnerText + "'.");  						break;  					case "FilterValues":  						_FilterValues = new FilterValues(r' this' xNodeLoop);  						break;  					default:  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown Filter element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,Filter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Filter.cs,Filter,The following statement contains a magic number: if (_FilterExpression == null)  				OwnerReport.rl.LogError(8' "Filter requires the FilterExpression element.");
Magic Number,fyiReporting.RDL,Filter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Filter.cs,Filter,The following statement contains a magic number: if (_FilterValues == null)  			{  				OwnerReport.rl.LogError(8' "Filter requires the FilterValues element.");  				return;		// some of the filter operator checks require values  			}
Magic Number,fyiReporting.RDL,Filter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Filter.cs,Filter,The following statement contains a magic number: switch (_FilterOperator)  			{  				case FilterOperatorEnum.Like:  				case FilterOperatorEnum.Equal:  				case FilterOperatorEnum.NotEqual:  				case FilterOperatorEnum.GreaterThan:  				case FilterOperatorEnum.GreaterThanOrEqual:  				case FilterOperatorEnum.LessThan:  				case FilterOperatorEnum.LessThanOrEqual:  					if (_FilterValues.Items.Count != 1)  						OwnerReport.rl.LogError(8' "Filter Operator requires exactly 1 FilterValue.");  					break;  				case FilterOperatorEnum.TopN:  				case FilterOperatorEnum.BottomN:  				case FilterOperatorEnum.TopPercent:  				case FilterOperatorEnum.BottomPercent:  					_FilterOperatorSingleRow = false;  					if (_FilterValues.Items.Count != 1)  						OwnerReport.rl.LogError(8' "Filter Operator requires exactly 1 FilterValue.");  					break;  				case FilterOperatorEnum.In:  					break;  				case FilterOperatorEnum.Between:  					if (_FilterValues.Items.Count != 2)  						OwnerReport.rl.LogError(8' "Filter Operator Between requires exactly 2 FilterValues.");  					break;  				default:		  					OwnerReport.rl.LogError(8' "Valid Filter operator must be specified.");  					break;  			}
Magic Number,fyiReporting.RDL,Filter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Filter.cs,Filter,The following statement contains a magic number: switch (_FilterOperator)  			{  				case FilterOperatorEnum.Like:  				case FilterOperatorEnum.Equal:  				case FilterOperatorEnum.NotEqual:  				case FilterOperatorEnum.GreaterThan:  				case FilterOperatorEnum.GreaterThanOrEqual:  				case FilterOperatorEnum.LessThan:  				case FilterOperatorEnum.LessThanOrEqual:  					if (_FilterValues.Items.Count != 1)  						OwnerReport.rl.LogError(8' "Filter Operator requires exactly 1 FilterValue.");  					break;  				case FilterOperatorEnum.TopN:  				case FilterOperatorEnum.BottomN:  				case FilterOperatorEnum.TopPercent:  				case FilterOperatorEnum.BottomPercent:  					_FilterOperatorSingleRow = false;  					if (_FilterValues.Items.Count != 1)  						OwnerReport.rl.LogError(8' "Filter Operator requires exactly 1 FilterValue.");  					break;  				case FilterOperatorEnum.In:  					break;  				case FilterOperatorEnum.Between:  					if (_FilterValues.Items.Count != 2)  						OwnerReport.rl.LogError(8' "Filter Operator Between requires exactly 2 FilterValues.");  					break;  				default:		  					OwnerReport.rl.LogError(8' "Valid Filter operator must be specified.");  					break;  			}
Magic Number,fyiReporting.RDL,Filter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Filter.cs,Filter,The following statement contains a magic number: switch (_FilterOperator)  			{  				case FilterOperatorEnum.Like:  				case FilterOperatorEnum.Equal:  				case FilterOperatorEnum.NotEqual:  				case FilterOperatorEnum.GreaterThan:  				case FilterOperatorEnum.GreaterThanOrEqual:  				case FilterOperatorEnum.LessThan:  				case FilterOperatorEnum.LessThanOrEqual:  					if (_FilterValues.Items.Count != 1)  						OwnerReport.rl.LogError(8' "Filter Operator requires exactly 1 FilterValue.");  					break;  				case FilterOperatorEnum.TopN:  				case FilterOperatorEnum.BottomN:  				case FilterOperatorEnum.TopPercent:  				case FilterOperatorEnum.BottomPercent:  					_FilterOperatorSingleRow = false;  					if (_FilterValues.Items.Count != 1)  						OwnerReport.rl.LogError(8' "Filter Operator requires exactly 1 FilterValue.");  					break;  				case FilterOperatorEnum.In:  					break;  				case FilterOperatorEnum.Between:  					if (_FilterValues.Items.Count != 2)  						OwnerReport.rl.LogError(8' "Filter Operator Between requires exactly 2 FilterValues.");  					break;  				default:		  					OwnerReport.rl.LogError(8' "Valid Filter operator must be specified.");  					break;  			}
Magic Number,fyiReporting.RDL,Filter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Filter.cs,Filter,The following statement contains a magic number: switch (_FilterOperator)  			{  				case FilterOperatorEnum.Like:  				case FilterOperatorEnum.Equal:  				case FilterOperatorEnum.NotEqual:  				case FilterOperatorEnum.GreaterThan:  				case FilterOperatorEnum.GreaterThanOrEqual:  				case FilterOperatorEnum.LessThan:  				case FilterOperatorEnum.LessThanOrEqual:  					if (_FilterValues.Items.Count != 1)  						OwnerReport.rl.LogError(8' "Filter Operator requires exactly 1 FilterValue.");  					break;  				case FilterOperatorEnum.TopN:  				case FilterOperatorEnum.BottomN:  				case FilterOperatorEnum.TopPercent:  				case FilterOperatorEnum.BottomPercent:  					_FilterOperatorSingleRow = false;  					if (_FilterValues.Items.Count != 1)  						OwnerReport.rl.LogError(8' "Filter Operator requires exactly 1 FilterValue.");  					break;  				case FilterOperatorEnum.In:  					break;  				case FilterOperatorEnum.Between:  					if (_FilterValues.Items.Count != 2)  						OwnerReport.rl.LogError(8' "Filter Operator Between requires exactly 2 FilterValues.");  					break;  				default:		  					OwnerReport.rl.LogError(8' "Valid Filter operator must be specified.");  					break;  			}
Magic Number,fyiReporting.RDL,Filter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Filter.cs,Filter,The following statement contains a magic number: switch (_FilterOperator)  			{  				case FilterOperatorEnum.Like:  				case FilterOperatorEnum.Equal:  				case FilterOperatorEnum.NotEqual:  				case FilterOperatorEnum.GreaterThan:  				case FilterOperatorEnum.GreaterThanOrEqual:  				case FilterOperatorEnum.LessThan:  				case FilterOperatorEnum.LessThanOrEqual:  					if (_FilterValues.Items.Count != 1)  						OwnerReport.rl.LogError(8' "Filter Operator requires exactly 1 FilterValue.");  					break;  				case FilterOperatorEnum.TopN:  				case FilterOperatorEnum.BottomN:  				case FilterOperatorEnum.TopPercent:  				case FilterOperatorEnum.BottomPercent:  					_FilterOperatorSingleRow = false;  					if (_FilterValues.Items.Count != 1)  						OwnerReport.rl.LogError(8' "Filter Operator requires exactly 1 FilterValue.");  					break;  				case FilterOperatorEnum.In:  					break;  				case FilterOperatorEnum.Between:  					if (_FilterValues.Items.Count != 2)  						OwnerReport.rl.LogError(8' "Filter Operator Between requires exactly 2 FilterValues.");  					break;  				default:		  					OwnerReport.rl.LogError(8' "Valid Filter operator must be specified.");  					break;  			}
Magic Number,fyiReporting.RDL,Filter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Filter.cs,ApplyTopBottomFilter,The following statement contains a magic number: if (_FilterOperator == FilterOperatorEnum.TopN ||  				_FilterOperator == FilterOperatorEnum.BottomN)  			{  				ival = (int) val;  				if (ival != val)  					throw new Exception(string.Format(Strings.Filter_Error_TopNAndBottomNRequireInt' val));  				if (ival >= data.Data.Count)		// includes all the data?  					return;  				ival--;					// make zero based  			}  			else  			{  				if (val >= 100)			// greater than 100% means all the data  					return;  				ival = (int) (data.Data.Count * (val/100));  				if (ival <= 0)			// if less than equal 0; then request results in no data  				{  					data.Data.Clear();  					return;  				}  				if (ival >= data.Data.Count)	// make sure rounding hasn't forced us past 100%  					return;  				ival--;					// make zero based  			}
Magic Number,fyiReporting.RDL,Filter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Filter.cs,ApplyTopBottomFilter,The following statement contains a magic number: if (_FilterOperator == FilterOperatorEnum.TopN ||  				_FilterOperator == FilterOperatorEnum.BottomN)  			{  				ival = (int) val;  				if (ival != val)  					throw new Exception(string.Format(Strings.Filter_Error_TopNAndBottomNRequireInt' val));  				if (ival >= data.Data.Count)		// includes all the data?  					return;  				ival--;					// make zero based  			}  			else  			{  				if (val >= 100)			// greater than 100% means all the data  					return;  				ival = (int) (data.Data.Count * (val/100));  				if (ival <= 0)			// if less than equal 0; then request results in no data  				{  					data.Data.Clear();  					return;  				}  				if (ival >= data.Data.Count)	// make sure rounding hasn't forced us past 100%  					return;  				ival--;					// make zero based  			}
Magic Number,fyiReporting.RDL,Filters,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Filters.cs,Filters,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Filter":  						f = new Filter(r' this' xNodeLoop);  						break;  					default:	  						f=null;		// don't know what this is  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown Filters element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  				if (f != null)  					_Items.Add(f);  			}
Magic Number,fyiReporting.RDL,Filters,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Filters.cs,Filters,The following statement contains a magic number: if (_Items.Count == 0)  				OwnerReport.rl.LogError(8' "Filters require at least one Filter be defined.");  			else  				_Items.TrimExcess();
Magic Number,fyiReporting.RDL,FilterValues,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\FilterValues.cs,FilterValues,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "FilterValue":  						f = new FilterValue(r' this' xNodeLoop);  						break;  					default:	  						f=null;		// don't know what this is  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown FilterValues element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  				if (f != null)  					_Items.Add(f);  			}
Magic Number,fyiReporting.RDL,FilterValues,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\FilterValues.cs,FilterValues,The following statement contains a magic number: if (_Items.Count == 0)  				OwnerReport.rl.LogError(8' "For FilterValues at least one FilterValue is required.");  			else                  _Items.TrimExcess();
Magic Number,fyiReporting.RDL,Footer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Footer.cs,Footer,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "TableRows":  						_TableRows = new TableRows(r' this' xNodeLoop);  						break;  					case "RepeatOnNewPage":  						_RepeatOnNewPage = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					default:  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown Footer element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,Footer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Footer.cs,Footer,The following statement contains a magic number: if (_TableRows == null)  				OwnerReport.rl.LogError(8' "TableRows element is required with a Footer but not specified.");
Magic Number,fyiReporting.RDL,GroupExpressions,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\GroupExpressions.cs,GroupExpressions,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "GroupExpression":  						g = new GroupExpression(r' this' xNodeLoop);  						break;  					default:	  						g=null;		// don't know what this is  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown GroupExpressions element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  				if (g != null)  					_Items.Add(g);  			}
Magic Number,fyiReporting.RDL,GroupExpressions,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\GroupExpressions.cs,GroupExpressions,The following statement contains a magic number: if (_Items.Count == 0)  				OwnerReport.rl.LogError(8' "GroupExpressions require at least one GroupExpression be defined.");  			else                  _Items.TrimExcess();
Magic Number,fyiReporting.RDL,Grouping,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Grouping.cs,Grouping,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Label":  						_Label = new Expression(r' this' xNodeLoop' ExpressionType.String);  						break;  					case "GroupExpressions":  						_GroupExpressions = new GroupExpressions(r' this' xNodeLoop);  						break;  					case "PageBreakAtStart":  						_PageBreakAtStart = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "PageBreakAtEnd":  						_PageBreakAtEnd = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "Custom":  						_Custom = new Custom(r' this' xNodeLoop);  						break;  					case "Filters":  						_Filters = new Filters(r' this' xNodeLoop);  						break;  					case "Parent":  						_ParentGroup = new Expression(r' this' xNodeLoop' ExpressionType.Variant);  						break;  					case "DataElementName":  						_DataElementName = xNodeLoop.InnerText;  						break;  					case "DataCollectionName":  						_DataCollectionName = xNodeLoop.InnerText;  						break;  					case "DataElementOutput":  						_DataElementOutput = fyiReporting.RDL.DataElementOutput.GetStyle(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					default:	  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown Grouping element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,Grouping,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Grouping.cs,Grouping,The following statement contains a magic number: if (this.Name != null)  			{  				try  				{  					OwnerReport.LUAggrScope.Add(this.Name.Nm' this);		// add to referenceable Grouping's  				}  				catch	// wish duplicate had its own exception  				{  					OwnerReport.rl.LogError(8' "Duplicate Grouping name '" + this.Name.Nm + "'.");  				}  			}
Magic Number,fyiReporting.RDL,Grouping,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Grouping.cs,Grouping,The following statement contains a magic number: if (_GroupExpressions == null)  				OwnerReport.rl.LogError(8' "Group Expressions are required within group '" + (this.Name==null? "unnamed": this.Name.Nm) + "'.");
Magic Number,fyiReporting.RDL,Header,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Header.cs,Header,The following statement contains a magic number: if (_TableRows == null)  				OwnerReport.rl.LogError(8' "Header requires the TableRows element.");
Magic Number,fyiReporting.RDL,Image,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Image.cs,CopyStream,The following statement contains a magic number: byte[] buffer = new byte[16 * 1024];
Magic Number,fyiReporting.RDL,Image,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Image.cs,CopyStream,The following statement contains a magic number: byte[] buffer = new byte[16 * 1024];
Magic Number,fyiReporting.RDL,Image,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Image.cs,Image,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Source":  						_ImageSource = fyiReporting.RDL.ImageSource.GetStyle(xNodeLoop.InnerText);  						break;  					case "Value":  						_Value = new Expression(r' this' xNodeLoop' ExpressionType.Variant);  						break;  					case "MIMEType":  						_MIMEType = new Expression(r' this' xNodeLoop' ExpressionType.String);  						break;  					case "Sizing":  						_Sizing = ImageSizing.GetStyle(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					default:  						if (ReportItemElement(xNodeLoop))	// try at ReportItem level  							break;  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown Image element " + xNodeLoop.Name + " ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,Image,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Image.cs,Image,The following statement contains a magic number: if (_ImageSource==ImageSourceEnum.Unknown)  				OwnerReport.rl.LogError(8' "Image requires a Source element.");
Magic Number,fyiReporting.RDL,Image,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Image.cs,Image,The following statement contains a magic number: if (_Value == null)  				OwnerReport.rl.LogError(8' "Image requires the Value element.");
Magic Number,fyiReporting.RDL,Image,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Image.cs,RunPage,The following statement contains a magic number: try   			{  				strm = GetImageStream(r' row' out mtype);                  if (strm == null)                  {                      r.rl.LogError(4' string.Format("Unable to load image {0}."' this.Name.Nm));                      return;                  }  				im = System.Drawing.Image.FromStream(strm);  				int height = im.Height;  				int width = im.Width;  				MemoryStream ostrm = new MemoryStream();  				strm.Position = 0;  				ImageFormat imf;  				switch(mtype.ToLower())  				{	  					case "image/jpeg" :  						imf = ImageFormat.Jpeg;  						CopyStream(strm' ostrm);  						break;  					case "image/png":  						imf = ImageFormat.Png;  						CopyStream(strm' ostrm);  						break;  					default: // from old code where all images convert to jpeg' i don't know why. May be need delete it and add all support formats.  						imf = ImageFormat.Jpeg;  						System.Drawing.Imaging.ImageCodecInfo[] info;  						info = ImageCodecInfo.GetImageEncoders();  						EncoderParameters encoderParameters;  						encoderParameters = new EncoderParameters(1);  						encoderParameters.Param[0] = new EncoderParameter(Encoder.Quality' ImageQualityManager.EmbeddedImageQuality);  						System.Drawing.Imaging.ImageCodecInfo codec = null;  						for (int i = 0; i < info.Length; i++)  						{  							if (info[i].FormatDescription == "JPEG")  							{  								codec = info[i];  								break;  							}  						}  						im.Save(ostrm' codec' encoderParameters);  						break;  				}    				byte[] ba = ostrm.ToArray();  				ostrm.Close();  				PageImage pi = new PageImage(imf' ba' width' height);  				pi.Sizing = this._Sizing;  				this.SetPagePositionAndStyle(r' pi' row);    				pgs.CurrentPage.AddObject(pi);  				if (_ConstantImage)  				{  					wc.PgImage = pi;  					// create unique name; PDF generation uses this to optimize the saving of the image only once  					pi.Name = "pi" + Interlocked.Increment(ref Parser.Counter).ToString();	// create unique name  				}                    SetPagePositionEnd(pgs' pi.Y + pi.H);              }  			catch (Exception e)  			{	  				// image failed to load' continue processing  				r.rl.LogError(4' "Image load failed.  " + e.Message);  			}  			finally  			{  				if (strm != null)  					strm.Close();  				if (im != null)  					im.Dispose();  			}
Magic Number,fyiReporting.RDL,Image,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Image.cs,RunPage,The following statement contains a magic number: try   			{  				strm = GetImageStream(r' row' out mtype);                  if (strm == null)                  {                      r.rl.LogError(4' string.Format("Unable to load image {0}."' this.Name.Nm));                      return;                  }  				im = System.Drawing.Image.FromStream(strm);  				int height = im.Height;  				int width = im.Width;  				MemoryStream ostrm = new MemoryStream();  				strm.Position = 0;  				ImageFormat imf;  				switch(mtype.ToLower())  				{	  					case "image/jpeg" :  						imf = ImageFormat.Jpeg;  						CopyStream(strm' ostrm);  						break;  					case "image/png":  						imf = ImageFormat.Png;  						CopyStream(strm' ostrm);  						break;  					default: // from old code where all images convert to jpeg' i don't know why. May be need delete it and add all support formats.  						imf = ImageFormat.Jpeg;  						System.Drawing.Imaging.ImageCodecInfo[] info;  						info = ImageCodecInfo.GetImageEncoders();  						EncoderParameters encoderParameters;  						encoderParameters = new EncoderParameters(1);  						encoderParameters.Param[0] = new EncoderParameter(Encoder.Quality' ImageQualityManager.EmbeddedImageQuality);  						System.Drawing.Imaging.ImageCodecInfo codec = null;  						for (int i = 0; i < info.Length; i++)  						{  							if (info[i].FormatDescription == "JPEG")  							{  								codec = info[i];  								break;  							}  						}  						im.Save(ostrm' codec' encoderParameters);  						break;  				}    				byte[] ba = ostrm.ToArray();  				ostrm.Close();  				PageImage pi = new PageImage(imf' ba' width' height);  				pi.Sizing = this._Sizing;  				this.SetPagePositionAndStyle(r' pi' row);    				pgs.CurrentPage.AddObject(pi);  				if (_ConstantImage)  				{  					wc.PgImage = pi;  					// create unique name; PDF generation uses this to optimize the saving of the image only once  					pi.Name = "pi" + Interlocked.Increment(ref Parser.Counter).ToString();	// create unique name  				}                    SetPagePositionEnd(pgs' pi.Y + pi.H);              }  			catch (Exception e)  			{	  				// image failed to load' continue processing  				r.rl.LogError(4' "Image load failed.  " + e.Message);  			}  			finally  			{  				if (strm != null)  					strm.Close();  				if (im != null)  					im.Dispose();  			}
Magic Number,fyiReporting.RDL,Image,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Image.cs,GetImageStream,The following statement contains a magic number: try   			{  				switch (this.ImageSource)  				{  					case ImageSourceEnum.Database:  						if (_MIMEType == null)  							return null;  						mtype = _MIMEType.EvaluateString(rpt' row);  						object o = _Value.Evaluate(rpt' row);  						strm = new MemoryStream((byte[]) o);  						break;  					case ImageSourceEnum.Embedded:  						string name = _Value.EvaluateString(rpt' row);  						EmbeddedImage ei = (EmbeddedImage) OwnerReport.LUEmbeddedImages[name];  						mtype = ei.MIMEType;  						byte[] ba = Convert.FromBase64String(ei.ImageData);                          _EmbeddedImageData = ei.ImageData; // we need this for html embedded image                          strm = new MemoryStream(ba);  						break;  					case ImageSourceEnum.External:  						//Added Image URL from forum' User: solidstate http://www.fyireporting.com/forum/viewtopic.php?t=905                          string fname = this.ImageUrl = _Value.EvaluateString(rpt' row);  						mtype = GetMimeType(fname);  						if (fname.StartsWith("http:") ||  							fname.StartsWith("file:") ||  							fname.StartsWith("https:"))  						{  							WebRequest wreq = WebRequest.Create(fname);  							WebResponse wres = wreq.GetResponse();  							strm = wres.GetResponseStream();  						}  						else  							strm = new FileStream(fname' System.IO.FileMode.Open' FileAccess.Read);		  						break;  					default:  						return null;  				}  			}  			catch (Exception e)  			{  				if (strm != null)  				{  					strm.Close();  					strm = null;  				}  				rpt.rl.LogError(4' string.Format("Unable to load image. {0}"' e.Message));  			}
Magic Number,fyiReporting.RDL,ImageSizing,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ImageSizing.cs,GetStyle,The following statement contains a magic number: try              {                  rs = (ImageSizingEnum)Enum.Parse(typeof(ImageSizingEnum)' s);              }              catch               {                  if (rl != null)                  {                      rl.LogError(4' "Unknown ImageSizing '" + s + "'. AutoSize assumed.");                  }                  rs = ImageSizingEnum.AutoSize;               }
Magic Number,fyiReporting.RDL,LegendLayout,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\LegendLayout.cs,GetStyle,The following statement contains a magic number: switch (s)  			{		  				case "Column":  					rs = LegendLayoutEnum.Column;  					break;  				case "Row":  					rs = LegendLayoutEnum.Row;  					break;  				case "Table":  					rs = LegendLayoutEnum.Table;  					break;  				default:		                      if (rl != null)  					    rl.LogError(4' "Unknown LegendLayout '" + s + "'.  Column assumed.");  					rs = LegendLayoutEnum.Column;  					break;  			}
Magic Number,fyiReporting.RDL,LegendPosition,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\LegendPosition.cs,GetStyle,The following statement contains a magic number: switch (s)  			{		  				case "TopLeft":  					rs = LegendPositionEnum.TopLeft;  					break;  				case "TopCenter":  					rs = LegendPositionEnum.TopCenter;  					break;  				case "TopRight":  					rs = LegendPositionEnum.TopRight;  					break;  				case "LeftTop":  					rs = LegendPositionEnum.LeftTop;  					break;  				case "LeftCenter":  					rs = LegendPositionEnum.LeftCenter;  					break;  				case "LeftBottom":  					rs = LegendPositionEnum.LeftBottom;  					break;  				case "RightTop":  					rs = LegendPositionEnum.RightTop;  					break;  				case "RightCenter":  					rs = LegendPositionEnum.RightCenter;  					break;  				case "RightBottom":  					rs = LegendPositionEnum.RightBottom;  					break;  				case "BottomRight":  					rs = LegendPositionEnum.BottomRight;  					break;  				case "BottomCenter":  					rs = LegendPositionEnum.BottomCenter;  					break;  				case "BottomLeft":  					rs = LegendPositionEnum.BottomLeft;  					break;  				default:		                      if (rl != null)  					    rl.LogError(4' "Unknown LegendPosition '" + s + "'.  RightTop assumed.");  					rs = LegendPositionEnum.RightTop;  					break;  			}
Magic Number,fyiReporting.RDL,Line,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Line.cs,Line,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				// nothing beyond reportitem for now  				if (!ReportItemElement(xNodeLoop))	// try at ReportItem level  				{					  					// don't know this element - log it  					OwnerReport.rl.LogError(4' "Unknown Line element " + xNodeLoop.Name + " ignored.");  				}  			}
Magic Number,fyiReporting.RDL,List,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\List.cs,List,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Grouping":  						_Grouping = new Grouping(r' this' xNodeLoop);  						break;  					case "Sorting":  						_Sorting = new Sorting(r' this' xNodeLoop);  						break;  					case "ReportItems":  						_ReportItems = new ReportItems(r' this' xNodeLoop);  						break;  					case "DataInstanceName":  						_DataInstanceName = xNodeLoop.InnerText;  						break;  					case "DataInstanceElementOutput":  						_DataInstanceElementOutput = fyiReporting.RDL.DataInstanceElementOutput.GetStyle(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					default:	  						if (DataRegionElement(xNodeLoop))	// try at DataRegion level  							break;  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown List element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,MarkerType,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\MarkerType.cs,GetStyle,The following statement contains a magic number: switch (s)  			{		  				case "None":  					rs = MarkerTypeEnum.None;  					break;  				case "Square":  					rs = MarkerTypeEnum.Square;  					break;  				case "Circle":  					rs = MarkerTypeEnum.Circle;  					break;  				case "Diamond":  					rs = MarkerTypeEnum.Diamond;  					break;  				case "Triangle":  					rs = MarkerTypeEnum.Triangle;  					break;  				case "Cross":  					rs = MarkerTypeEnum.Cross;  					break;  				case "Auto":  					rs = MarkerTypeEnum.Auto;  					break;  				default:		  					rl.LogError(4' "Unknown MarkerType '" + s + "'.  None assumed.");  					rs = MarkerTypeEnum.None;  					break;  			}
Magic Number,fyiReporting.RDL,Matrix,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Matrix.cs,Matrix,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Corner":  						_Corner = new Corner(r' this' xNodeLoop);  						break;  					case "ColumnGroupings":  						_ColumnGroupings = new ColumnGroupings(r' this' xNodeLoop);  						break;  					case "RowGroupings":  						_RowGroupings = new RowGroupings(r' this' xNodeLoop);  						break;  					case "MatrixRows":  						_MatrixRows = new MatrixRows(r' this' xNodeLoop);  						break;  					case "MatrixColumns":  						_MatrixColumns = new MatrixColumns(r' this' xNodeLoop);  						break;  					case "LayoutDirection":  						_LayoutDirection = MatrixLayoutDirection.GetStyle(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "GroupsBeforeRowHeaders":  						_GroupsBeforeRowHeaders = XmlUtil.Integer(xNodeLoop.InnerText);  						break;  					case "CellDataElementName":  						_CellDataElementName = xNodeLoop.InnerText;  						break;  					case "CellDataElementOutput":  						_CellDataElementOutput = MatrixCellDataElementOutput.GetStyle(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					default:  						if (DataRegionElement(xNodeLoop))	// try at DataRegion level  							break;  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown Matrix element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,Matrix,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Matrix.cs,Matrix,The following statement contains a magic number: if (_ColumnGroupings == null)  				OwnerReport.rl.LogError(8' "Matrix element ColumnGroupings not specified for " + (this.Name == null? "'name not specified'": this.Name.Nm));
Magic Number,fyiReporting.RDL,Matrix,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Matrix.cs,Matrix,The following statement contains a magic number: if (_RowGroupings == null)  				OwnerReport.rl.LogError(8' "Matrix element RowGroupings not specified for " + (this.Name == null? "'name not specified'": this.Name.Nm));
Magic Number,fyiReporting.RDL,Matrix,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Matrix.cs,Matrix,The following statement contains a magic number: if (_MatrixRows == null)  				OwnerReport.rl.LogError(8' "Matrix element MatrixRows not specified for " + (this.Name == null? "'name not specified'": this.Name.Nm));
Magic Number,fyiReporting.RDL,Matrix,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Matrix.cs,Matrix,The following statement contains a magic number: if (_MatrixColumns == null)   				OwnerReport.rl.LogError(8' "Matrix element MatrixColumns not specified for " + (this.Name == null? "'name not specified'": this.Name.Nm));
Magic Number,fyiReporting.RDL,Matrix,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Matrix.cs,Matrix,The following statement contains a magic number: if (OwnerReport.rl.MaxSeverity > 4)  				return;
Magic Number,fyiReporting.RDL,Matrix,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Matrix.cs,Matrix,The following statement contains a magic number: if (mc != sc)  			{  				OwnerReport.rl.LogError(8' "The count of MatrixCells must be 1 or equal to the number of StaticColumns if there are any.  Matrix " + (this.Name == null? "unknown.": this.Name.Nm));  			}
Magic Number,fyiReporting.RDL,Matrix,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Matrix.cs,Matrix,The following statement contains a magic number: if (mc != sc)  			{  				OwnerReport.rl.LogError(8' "The count of MatrixColumns must be 1 or equal to the number of StaticColumns if there are any.  Matrix " + (this.Name == null? "unknown.": this.Name.Nm));  			}
Magic Number,fyiReporting.RDL,Matrix,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Matrix.cs,Matrix,The following statement contains a magic number: if (mr != sr)  			{  				OwnerReport.rl.LogError(8' "The count of MatrixRows must be 1 or equal to the number of StaticRows if there are any.  Matrix " + (this.Name == null? "unknown.": this.Name.Nm));  			}
Magic Number,fyiReporting.RDL,MatrixCell,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\MatrixCell.cs,MatrixCell,The following statement contains a magic number: if (_ReportItems == null)  				OwnerReport.rl.LogError(8' "MatrixCell requires the ReportItems element.");
Magic Number,fyiReporting.RDL,MatrixCellDataElementOutput,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\MatrixCellDataElementOutput.cs,GetStyle,The following statement contains a magic number: switch (s)  			{		  				case "Output":  					rs = MatrixCellDataElementOutputEnum.Output;  					break;  				case "NoOutput":  					rs = MatrixCellDataElementOutputEnum.NoOutput;  					break;  				default:		  					rl.LogError(4' "Unknown MatrixCellDataElementOutput '" + s + "'.  Output assumed.");  					rs = MatrixCellDataElementOutputEnum.Output;  					break;  			}
Magic Number,fyiReporting.RDL,MatrixCells,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\MatrixCells.cs,MatrixCells,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "MatrixCell":  						m = new MatrixCell(r' this' xNodeLoop);  						break;  					default:	  						m=null;		// don't know what this is  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown MatrixCells element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  				if (m != null)  					_Items.Add(m);  			}
Magic Number,fyiReporting.RDL,MatrixCells,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\MatrixCells.cs,MatrixCells,The following statement contains a magic number: if (_Items.Count == 0)  				OwnerReport.rl.LogError(8' "For MatrixCells at least one MatrixCell is required.");  			else                  _Items.TrimExcess();
Magic Number,fyiReporting.RDL,MatrixColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\MatrixColumn.cs,MatrixColumn,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Width":  						_Width = new RSize(r' xNodeLoop);  						break;  					default:  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown MatrixColumn element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,MatrixColumns,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\MatrixColumns.cs,MatrixColumns,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "MatrixColumn":  						m = new MatrixColumn(r' this' xNodeLoop);  						break;  					default:	  						m=null;		// don't know what this is  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown MatrixColumns element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  				if (m != null)  					_Items.Add(m);  			}
Magic Number,fyiReporting.RDL,MatrixColumns,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\MatrixColumns.cs,MatrixColumns,The following statement contains a magic number: if (_Items.Count == 0)  				OwnerReport.rl.LogError(8' "For MatrixColumns at least one MatrixColumn is required.");  			else                  _Items.TrimExcess();
Magic Number,fyiReporting.RDL,MatrixEntryComparer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\MatrixEntry.cs,Compare,The following statement contains a magic number: try              {                  foreach (SortBy sb in _Sorting.Items)                  {                      IExpr e = sb.SortExpression.Expr;                      o1 = e.Evaluate(_rpt' m1.R);                      o2 = e.Evaluate(_rpt' m2.R);                      tc = e.GetTypeCode();                      rc = Filter.ApplyCompare(tc' o1' o2);                      if (rc != 0)                          return sb.Direction == SortDirectionEnum.Ascending? rc : -rc;                  }              }              catch (Exception e)		// this really shouldn't happen              {                  _rpt.rl.LogError(8'                      string.Format("Matrix Sort rows exception\r\nArguments: {0} {1}\r\nTypecode: {2}\r\n{3}\r\n{4}"'                      o1' o2' tc.ToString()' e.Message' e.StackTrace));                  return m1.HashItem.CompareTo(m2.HashItem);              }
Magic Number,fyiReporting.RDL,MatrixLayoutDirection,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\MatrixLayoutDirection.cs,GetStyle,The following statement contains a magic number: switch (s)  			{		  				case "LTR":  				case "LeftToRight":  					rs = MatrixLayoutDirectionEnum.LTR;  					break;  				case "RTL":  				case "RightToLeft":  					rs = MatrixLayoutDirectionEnum.RTL;  					break;  				default:		  					rl.LogError(4' "Unknown MatrixLayoutDirection '" + s + "'.  LTR assumed.");  					rs = MatrixLayoutDirectionEnum.LTR;  					break;  			}
Magic Number,fyiReporting.RDL,MatrixRow,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\MatrixRow.cs,MatrixRow,The following statement contains a magic number: if (_MatrixCells == null)  				OwnerReport.rl.LogError(8' "MatrixRow requires the MatrixCells element.");
Magic Number,fyiReporting.RDL,MatrixRows,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\MatrixRows.cs,MatrixRows,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "MatrixRow":  						m = new MatrixRow(r' this' xNodeLoop);  						break;  					default:	  						m=null;		// don't know what this is  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown MatrixRows element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  				if (m != null)  					_Items.Add(m);  			}
Magic Number,fyiReporting.RDL,MatrixRows,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\MatrixRows.cs,MatrixRows,The following statement contains a magic number: if (_Items.Count == 0)  				OwnerReport.rl.LogError(8' "For MatrixRows at least one MatrixRow is required.");  			else                  _Items.TrimExcess();
Magic Number,fyiReporting.RDL,PageFooter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\PageFooter.cs,PageFooter,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Height":  						_Height = new RSize(r' xNodeLoop);  						break;  					case "PrintOnFirstPage":  						_PrintOnFirstPage = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "PrintOnLastPage":  						_PrintOnLastPage = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "ReportItems":  						_ReportItems = new ReportItems(r' this' xNodeLoop);  						break;  					case "Style":  						_Style = new Style(r' this' xNodeLoop);  						break;  					default:  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown PageFooter element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,PageFooter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\PageFooter.cs,PageFooter,The following statement contains a magic number: if (_Height == null)  				OwnerReport.rl.LogError(8' "PageFooter Height is required.");
Magic Number,fyiReporting.RDL,PageHeader,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\PageHeader.cs,PageHeader,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Height":  						_Height = new RSize(r' xNodeLoop);  						break;  					case "PrintOnFirstPage":  						_PrintOnFirstPage = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "PrintOnLastPage":  						_PrintOnLastPage = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "ReportItems":  						_ReportItems = new ReportItems(r' this' xNodeLoop);  						break;  					case "Style":  						_Style = new Style(r' this' xNodeLoop);  						break;  					default:  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown PageHeader element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,PageHeader,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\PageHeader.cs,PageHeader,The following statement contains a magic number: if (_Height == null)  				OwnerReport.rl.LogError(8' "PageHeader Height is required.");
Magic Number,fyiReporting.RDL,ParameterValues,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ParameterValues.cs,ParameterValues,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "ParameterValue":  						pv = new ParameterValue(r' this' xNodeLoop);  						break;  					default:  						pv=null;		// don't know what this is  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown ParameterValues element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  				if (pv != null)  					_Items.Add(pv);  			}
Magic Number,fyiReporting.RDL,ParameterValues,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ParameterValues.cs,ParameterValues,The following statement contains a magic number: if (_Items.Count == 0)  				OwnerReport.rl.LogError(8' "For ParameterValues at least one ParameterValue is required.");  			else                  _Items.TrimExcess();
Magic Number,fyiReporting.RDL,PlotArea,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\PlotArea.cs,PlotArea,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Style":  						_Style = new Style(r' this' xNodeLoop);  						break;  					default:  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown PlotArea element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,PlotType,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\PlotType.cs,GetStyle,The following statement contains a magic number: switch (s)  			{		  				case "Auto":  					pt = PlotTypeEnum.Auto;  					break;  				case "Line":  					pt = PlotTypeEnum.Line;  					break;  				default:		  					rl.LogError(4' "Unknown PlotType '" + s + "'.  Auto assumed.");  					pt = PlotTypeEnum.Auto;  					break;  			}
Magic Number,fyiReporting.RDL,Query,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Query.cs,Query,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "DataSourceName":  						_DataSourceName = xNodeLoop.InnerText;  						break;  					case "CommandType":  						_QueryCommandType = fyiReporting.RDL.QueryCommandType.GetStyle(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "CommandText":  						_CommandText = new Expression(r' this' xNodeLoop' ExpressionType.String);  						break;  					case "QueryParameters":  						_QueryParameters = new QueryParameters(r' this' xNodeLoop);  						break;  					case "Timeout":  						_Timeout = XmlUtil.Integer(xNodeLoop.InnerText);  						break;  					case "RowLimit":				// Extension of RDL specification  						_RowLimit = XmlUtil.Integer(xNodeLoop.InnerText);  						break;  					default:	  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown Query element '" + xNodeLoop.Name + "' ignored.");  						break;  				}	// end of switch  			}
Magic Number,fyiReporting.RDL,Query,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Query.cs,Query,The following statement contains a magic number: if (_DataSourceName == null)  			{  				r.rl.LogError(8' "DataSourceName element not specified for Query.");  				return;  			}
Magic Number,fyiReporting.RDL,Query,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Query.cs,FinalPass,The following statement contains a magic number: if (ds == null)  			{  				OwnerReport.rl.LogError(8' "Query references unknown data source '" + _DataSourceName + "'");  				return;  			}
Magic Number,fyiReporting.RDL,Query,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Query.cs,FinalPass,The following statement contains a magic number: try   			{  				cmSQL = cnSQL.CreateCommand();		  				cmSQL.CommandText = AddParametersAsLiterals(null' cnSQL' sql' false);                  if (this._QueryCommandType == QueryCommandTypeEnum.StoredProcedure)                      cmSQL.CommandType = CommandType.StoredProcedure;    				AddParameters(null' cnSQL' cmSQL' false);  				dr = cmSQL.ExecuteReader(CommandBehavior.SchemaOnly);  				if (dr.FieldCount < 10)  					_Columns = new ListDictionary();	// Hashtable is overkill for small lists  				else  					_Columns = new Hashtable(dr.FieldCount);    				for (int i=0; i < dr.FieldCount; i++)  				{   					QueryColumn qc = new QueryColumn(i' dr.GetName(i)' Type.GetTypeCode(dr.GetFieldType(i)) );    					try { _Columns.Add(qc.colName' qc); }  					catch	// name has already been added to list:   					{	// According to the RDL spec SQL names are matched by Name not by relative  						//   position: this seems wrong to me and causes this problem; but   						//   user can fix by using "as" keyword to name columns in Select   						//    e.g.  Select col as "col1"' col as "col2" from tableA  						OwnerReport.rl.LogError(8' String.Format("Column '{0}' is not uniquely defined within the SQL Select columns."' qc.colName));  					}  				}  			}  			catch (Exception e)  			{                  // Issue #35 - Kept the logging                  OwnerReport.rl.LogError(4' "SQL Exception during report compilation: " + e.Message + "\r\nSQL: " + sql);                  throw;              }  			finally  			{  				if (cmSQL != null)  				{  					cmSQL.Dispose();  					if (dr != null)  						dr.Close();  				}  			}
Magic Number,fyiReporting.RDL,Query,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Query.cs,FinalPass,The following statement contains a magic number: try   			{  				cmSQL = cnSQL.CreateCommand();		  				cmSQL.CommandText = AddParametersAsLiterals(null' cnSQL' sql' false);                  if (this._QueryCommandType == QueryCommandTypeEnum.StoredProcedure)                      cmSQL.CommandType = CommandType.StoredProcedure;    				AddParameters(null' cnSQL' cmSQL' false);  				dr = cmSQL.ExecuteReader(CommandBehavior.SchemaOnly);  				if (dr.FieldCount < 10)  					_Columns = new ListDictionary();	// Hashtable is overkill for small lists  				else  					_Columns = new Hashtable(dr.FieldCount);    				for (int i=0; i < dr.FieldCount; i++)  				{   					QueryColumn qc = new QueryColumn(i' dr.GetName(i)' Type.GetTypeCode(dr.GetFieldType(i)) );    					try { _Columns.Add(qc.colName' qc); }  					catch	// name has already been added to list:   					{	// According to the RDL spec SQL names are matched by Name not by relative  						//   position: this seems wrong to me and causes this problem; but   						//   user can fix by using "as" keyword to name columns in Select   						//    e.g.  Select col as "col1"' col as "col2" from tableA  						OwnerReport.rl.LogError(8' String.Format("Column '{0}' is not uniquely defined within the SQL Select columns."' qc.colName));  					}  				}  			}  			catch (Exception e)  			{                  // Issue #35 - Kept the logging                  OwnerReport.rl.LogError(4' "SQL Exception during report compilation: " + e.Message + "\r\nSQL: " + sql);                  throw;              }  			finally  			{  				if (cmSQL != null)  				{  					cmSQL.Dispose();  					if (dr != null)  						dr.Close();  				}  			}
Magic Number,fyiReporting.RDL,Query,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Query.cs,FinalPass,The following statement contains a magic number: try   			{  				cmSQL = cnSQL.CreateCommand();		  				cmSQL.CommandText = AddParametersAsLiterals(null' cnSQL' sql' false);                  if (this._QueryCommandType == QueryCommandTypeEnum.StoredProcedure)                      cmSQL.CommandType = CommandType.StoredProcedure;    				AddParameters(null' cnSQL' cmSQL' false);  				dr = cmSQL.ExecuteReader(CommandBehavior.SchemaOnly);  				if (dr.FieldCount < 10)  					_Columns = new ListDictionary();	// Hashtable is overkill for small lists  				else  					_Columns = new Hashtable(dr.FieldCount);    				for (int i=0; i < dr.FieldCount; i++)  				{   					QueryColumn qc = new QueryColumn(i' dr.GetName(i)' Type.GetTypeCode(dr.GetFieldType(i)) );    					try { _Columns.Add(qc.colName' qc); }  					catch	// name has already been added to list:   					{	// According to the RDL spec SQL names are matched by Name not by relative  						//   position: this seems wrong to me and causes this problem; but   						//   user can fix by using "as" keyword to name columns in Select   						//    e.g.  Select col as "col1"' col as "col2" from tableA  						OwnerReport.rl.LogError(8' String.Format("Column '{0}' is not uniquely defined within the SQL Select columns."' qc.colName));  					}  				}  			}  			catch (Exception e)  			{                  // Issue #35 - Kept the logging                  OwnerReport.rl.LogError(4' "SQL Exception during report compilation: " + e.Message + "\r\nSQL: " + sql);                  throw;              }  			finally  			{  				if (cmSQL != null)  				{  					cmSQL.Dispose();  					if (dr != null)  						dr.Close();  				}  			}
Magic Number,fyiReporting.RDL,Query,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Query.cs,GetData,The following statement contains a magic number: try   			{  				cmSQL = cnSQL.CreateCommand();		  				cmSQL.CommandText = AddParametersAsLiterals(rpt' cnSQL' sql' true);                  if (this._QueryCommandType == QueryCommandTypeEnum.StoredProcedure)                      cmSQL.CommandType = CommandType.StoredProcedure;                  if (this._Timeout > 0)  					cmSQL.CommandTimeout = this._Timeout;  				  				AddParameters(rpt' cnSQL' cmSQL' true);  				dr = cmSQL.ExecuteReader(CommandBehavior.SingleResult);                    List<Row> ar = new List<Row>();  				_Data.Data = ar;  				int rowCount=0;  				int maxRows = _RowLimit > 0? _RowLimit: int.MaxValue;  				int fieldCount = flds.Items.Count;    				// Determine the query column number for each field  				int[] qcn = new int[flds.Items.Count];  				foreach (Field fld in flds)  				{  					qcn[fld.ColumnNumber] = -1;  					if (fld.Value != null)  						continue;  					try  					{  						qcn[fld.ColumnNumber] = dr.GetOrdinal(fld.DataField);  					}  					catch   					{  						qcn[fld.ColumnNumber] = -1;  					}  				}    				while (dr.Read())  				{  					Row or = new Row(_Data' fieldCount);    					foreach (Field fld in flds)  					{  						if (qcn[fld.ColumnNumber] != -1)  						{  							or.Data[fld.ColumnNumber] = dr.GetValue(qcn[fld.ColumnNumber]);  						}  					}    					// Apply the filters  					if (f == null || f.Apply(rpt' or))  					{  						or.RowNumber = rowCount;	//   						rowCount++;  						ar.Add(or);  					}  					if (--maxRows <= 0)				// don't retrieve more than max  						break;  				}                  ar.TrimExcess();		// free up any extraneous space; can be sizeable for large # rows  				if (f != null)  					f.ApplyFinalFilters(rpt' _Data' false);	  //#if DEBUG  //				rpt.rl.LogError(4' "Rows Read:" + ar.Count.ToString() + " SQL:" + sql );  //#endif  			}  			catch (Exception e)  			{                  // Issue #35 - Kept the logging  				rpt.rl.LogError(8' "SQL Exception" + e.Message + "\r\n" + e.StackTrace);                  throw;  			}  			finally  			{  				if (cmSQL != null)  				{  					cmSQL.Dispose();  					if (dr != null)  						dr.Close();  				}  			}
Magic Number,fyiReporting.RDL,QueryCommandType,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\QueryCommandType.cs,GetStyle,The following statement contains a magic number: switch (s)  			{		  				case "Text":  					rs = QueryCommandTypeEnum.Text;  					break;  				case "StoredProcedure":  					rs = QueryCommandTypeEnum.StoredProcedure;  					break;  				case "TableDirect":  					rs = QueryCommandTypeEnum.TableDirect;  					break;  				default:		// user error just force to normal TODO  					rl.LogError(4' "Unknown Query CommandType '" + s + "'.  Text assumed.");  					rs = QueryCommandTypeEnum.Text;  					break;  			}
Magic Number,fyiReporting.RDL,QueryParameter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\QueryParameter.cs,QueryParameter,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Value":  						_Value = new Expression(r' this' xNodeLoop' ExpressionType.Variant);  						break;  					default:	  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown QueryParameter element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,QueryParameter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\QueryParameter.cs,QueryParameter,The following statement contains a magic number: if (_Name == null)  				OwnerReport.rl.LogError(8' "QueryParameter name is required but not specified.");
Magic Number,fyiReporting.RDL,QueryParameter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\QueryParameter.cs,QueryParameter,The following statement contains a magic number: if (_Value == null)  				OwnerReport.rl.LogError(8' "QueryParameter Value is required but not specified or invalid for " + _Name==null? "<unknown name>": _Name.Nm);
Magic Number,fyiReporting.RDL,QueryParameters,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\QueryParameters.cs,QueryParameters,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "QueryParameter":  						q = new QueryParameter(r' this' xNodeLoop);  						break;  					default:	  						q=null;		// don't know what this is  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown QueryParameters element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  				if (q != null)  					_Items.Add(q);  			}
Magic Number,fyiReporting.RDL,QueryParameters,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\QueryParameters.cs,QueryParameters,The following statement contains a magic number: if (_Items.Count == 0)  				OwnerReport.rl.LogError(8' "For QueryParameters at least one QueryParameter is required.");  			else                  _Items.TrimExcess();
Magic Number,fyiReporting.RDL,Rectangle,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Rectangle.cs,Rectangle,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "ReportItems":  						_ReportItems = new ReportItems(r' this' xNodeLoop);  						break;  					case "PageBreakAtStart":  						_PageBreakAtStart = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "PageBreakAtEnd":  						_PageBreakAtEnd = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					default:	  						if (ReportItemElement(xNodeLoop))	// try at ReportItem level  							break;  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown Rectangle element " + xNodeLoop.Name + " ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,ReportClass,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportClass.cs,ReportClass,The following statement contains a magic number: if (_ClassName == null)  				OwnerReport.rl.LogError(8' "Class ClassName is required but not specified.");
Magic Number,fyiReporting.RDL,ReportClass,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportClass.cs,ReportClass,The following statement contains a magic number: if (_InstanceName == null)  				OwnerReport.rl.LogError(8' "Class InstanceName is required but not specified or invalid for " + _ClassName==null? "<unknown name>": _ClassName);
Magic Number,fyiReporting.RDL,ReportClass,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportClass.cs,Load,The following statement contains a magic number: if (wc.Instance == null)  			{  				string e = String.Format("Unable to create instance of class {0}.  {1}"'  					_ClassName' err);  				if (rpt == null)  					OwnerReport.rl.LogError(4' e);  				else  					rpt.rl.LogError(4' e);  				wc.bCreateFailed = true;  			}
Magic Number,fyiReporting.RDL,ReportClass,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportClass.cs,Load,The following statement contains a magic number: if (wc.Instance == null)  			{  				string e = String.Format("Unable to create instance of class {0}.  {1}"'  					_ClassName' err);  				if (rpt == null)  					OwnerReport.rl.LogError(4' e);  				else  					rpt.rl.LogError(4' e);  				wc.bCreateFailed = true;  			}
Magic Number,fyiReporting.RDL,ReportDefn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportDefn.cs,ReportDefn,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Description":  						_Description = xNodeLoop.InnerText;  						break;  					case "Author":  						_Author = xNodeLoop.InnerText;  						break;  					case "AutoRefresh":  						_AutoRefresh = XmlUtil.Integer(xNodeLoop.InnerText);  						break;  					case "DataSources":  						_DataSourcesDefn = new DataSourcesDefn(this' null' xNodeLoop);  						break;  					case "DataSets":  						_DataSetsDefn = new DataSetsDefn(this' null' xNodeLoop);  						break;  					case "Body":  						_Body = new Body(this' null' xNodeLoop);  						break;  					case "ReportParameters":  						_ReportParameters = new ReportParameters(this' null' xNodeLoop);  						break;  					case "Width":  						_Width = new RSize(this' xNodeLoop);  						break;  					case "PageHeader":  						_PageHeader = new PageHeader(this' null' xNodeLoop);  						break;  					case "PageFooter":  						_PageFooter = new PageFooter(this' null' xNodeLoop);  						break;  					case "PageHeight":  						_PageHeight = new RSize(this' xNodeLoop);  						break;  					case "PageWidth":  						_PageWidth = new RSize(this' xNodeLoop);  						break;  					case "LeftMargin":  						_LeftMargin = new RSize(this' xNodeLoop);  						break;  					case "RightMargin":  						_RightMargin = new RSize(this' xNodeLoop);  						break;  					case "TopMargin":  						_TopMargin = new RSize(this' xNodeLoop);  						break;  					case "BottomMargin":  						_BottomMargin = new RSize(this' xNodeLoop);  						break;  					case "EmbeddedImages":  						_EmbeddedImages = new EmbeddedImages(this' null' xNodeLoop);  						break;  					case "Language":  						_Language =  new Expression(this' null' xNodeLoop' ExpressionType.String);  						break;  					case "Code":  						_Code = new Code(this' null' xNodeLoop);  						break;  					case "CodeModules":  						_CodeModules = new CodeModules(this' null' xNodeLoop);  						break;  					case "Classes":  						_Classes = new Classes(this' null' xNodeLoop);  						break;  					case "DataTransform":  						_DataTransform = xNodeLoop.InnerText;  						break;  					case "DataSchema":  						_DataSchema = xNodeLoop.InnerText;  						break;  					case "DataElementName":  						_DataElementName = xNodeLoop.InnerText;  						break;  					case "DataElementStyle":  						_DataElementStyle = fyiReporting.RDL.DataElementStyle.GetStyle(xNodeLoop.InnerText' this.rl);  						break;  					default:  						// don't know this element - log it  						this.rl.LogError(4' "Unknown Report element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,ReportDefn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportDefn.cs,ReportDefn,The following statement contains a magic number: if (_Body == null)  				rl.LogError(8' "Body not specified for report.");
Magic Number,fyiReporting.RDL,ReportDefn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportDefn.cs,ReportDefn,The following statement contains a magic number: if (_Width == null)  				rl.LogError(4' "Width not specified for report.  Assuming page width.");
Magic Number,fyiReporting.RDL,ReportDefn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportDefn.cs,ReportDefn,The following statement contains a magic number: if (rl.MaxSeverity <= 4)	// don't do final pass if already have serious errors  			{  				FinalPass(folder);	// call final parser pass for expression resolution  			}
Magic Number,fyiReporting.RDL,ReportItem,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportItem.cs,PositioningFinalPass,The following statement contains a magic number: int maxParents = 100;
Magic Number,fyiReporting.RDL,ReportItem,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportItem.cs,PositioningFinalPass,The following statement contains a magic number: for (int ti = i-1; ti >= 0 && maxParents > 0; ti--)  			{                  ReportItem ri = items[ti];    				int xw = ri.Left == null? 0: ri.Left.Size;  				int w2 = PositioningWidth(ri);                  if (ri is Line)                  {   // normalize the width                      if (w2 < 0)                      {                          xw -= w2;                          w2 = -w2;                      }                  }                  if (ri.Height == null || ri.Top == null) // if position/height not specified don't use to reposition                      continue;                  if (y < ri.Top.Size + ri.Height.Size)                      continue;                  _YParents.Add(ri);		// X coordinate overlap                  maxParents--;                  if (xw <= x && xw + w2 >= x + w &&       // if item above completely covers the report item then it will be pushed down first                      maxParents > 30)                      //   and we haven't already set the maxParents.                         maxParents=30;                        //   just add a few more if necessary               }
Magic Number,fyiReporting.RDL,ReportItem,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportItem.cs,PositioningFinalPass,The following statement contains a magic number: for (int ti = i-1; ti >= 0 && maxParents > 0; ti--)  			{                  ReportItem ri = items[ti];    				int xw = ri.Left == null? 0: ri.Left.Size;  				int w2 = PositioningWidth(ri);                  if (ri is Line)                  {   // normalize the width                      if (w2 < 0)                      {                          xw -= w2;                          w2 = -w2;                      }                  }                  if (ri.Height == null || ri.Top == null) // if position/height not specified don't use to reposition                      continue;                  if (y < ri.Top.Size + ri.Height.Size)                      continue;                  _YParents.Add(ri);		// X coordinate overlap                  maxParents--;                  if (xw <= x && xw + w2 >= x + w &&       // if item above completely covers the report item then it will be pushed down first                      maxParents > 30)                      //   and we haven't already set the maxParents.                         maxParents=30;                        //   just add a few more if necessary               }
Magic Number,fyiReporting.RDL,ReportItem,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportItem.cs,PositioningWidth,The following statement contains a magic number: if (ri.Width == null)  			{  				if (ri is Table)  				{  					Table t = ri as Table;  					w = t.WidthInUnits;  				}  				else  					w = int.MaxValue/2;	// MaxValue/2 is just meant to be a large number (but won't overflow when adding in the x)  			}  			else  				w = ri.Width.Size;
Magic Number,fyiReporting.RDL,ReportItems,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportItems.cs,ReportItems,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Rectangle":  						ri = new Rectangle(r' this' xNodeLoop);  						break;  					case "Line":  						ri = new Line(r' this' xNodeLoop);  						break;  					case "Textbox":  						ri = new Textbox(r' this' xNodeLoop);  						break;  					case "Image":  						ri = new Image(r' this' xNodeLoop);  						break;  					case "Subreport":  						ri = new Subreport(r' this' xNodeLoop);  						break;  					// DataRegions: list' table' matrix' chart  					case "List":   						ri = new List(r' this' xNodeLoop);  						break;  					case "Table":                      case "Grid":                      case "fyi:Grid":                          ri = new Table(r' this' xNodeLoop);  						break;  					case "Matrix":   						ri = new Matrix(r' this' xNodeLoop);  						break;  					case "Chart":   						ri = new Chart(r' this' xNodeLoop);  						break;  					case "ChartExpression":		// For internal use only   						ri = new ChartExpression(r' this' xNodeLoop);  						break;                      case "CustomReportItem":                          ri = new CustomReportItem(r' this' xNodeLoop);                          break;  					default:  						ri=null;		// don't know what this is  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown ReportItems element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  				if (ri != null)  				{  					_Items.Add(ri);  				}  			}
Magic Number,fyiReporting.RDL,ReportItems,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportItems.cs,ReportItems,The following statement contains a magic number: if (_Items.Count == 0)  				OwnerReport.rl.LogError(8' "At least one item must be in the ReportItems.");  			else                  _Items.TrimExcess();
Magic Number,fyiReporting.RDL,ReportLog,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportLog.cs,LogError,The following statement contains a magic number: if (severity >= 12)		  				throw new Exception(msg);
Magic Number,fyiReporting.RDL,ReportLog,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportLog.cs,Reset,The following statement contains a magic number: if (_MaxSeverity < 8)				// we keep the severity to indicate we can't run report  				_MaxSeverity=0;
Magic Number,fyiReporting.RDL,ReportParameter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportParameter.cs,ReportParameter,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "DataType":  						_dt = DataType.GetStyle(xNodeLoop.InnerText' this.OwnerReport);  						_NumericType = DataType.IsNumeric(_dt);  						break;  					case "Nullable":  						_Nullable = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "DefaultValue":  						_DefaultValue = new DefaultValue(r' this' xNodeLoop);  						break;  					case "AllowBlank":  						_AllowBlank = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "Prompt":  						_Prompt = xNodeLoop.InnerText;  						break;  					case "Hidden":  						_Hidden = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						OwnerReport.rl.LogError(4' "ReportParameter element Hidden is currently ignored.");	// TODO  						break;  					case "MultiValue":  						_MultiValue = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "ValidValues":  						_ValidValues = new ValidValues(r' this' xNodeLoop);  						break;  					case "UsedInQuery":  						_UsedInQuery = TrueFalseAuto.GetStyle(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					default:	  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown ReportParameter element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,ReportParameter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportParameter.cs,ReportParameter,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "DataType":  						_dt = DataType.GetStyle(xNodeLoop.InnerText' this.OwnerReport);  						_NumericType = DataType.IsNumeric(_dt);  						break;  					case "Nullable":  						_Nullable = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "DefaultValue":  						_DefaultValue = new DefaultValue(r' this' xNodeLoop);  						break;  					case "AllowBlank":  						_AllowBlank = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "Prompt":  						_Prompt = xNodeLoop.InnerText;  						break;  					case "Hidden":  						_Hidden = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						OwnerReport.rl.LogError(4' "ReportParameter element Hidden is currently ignored.");	// TODO  						break;  					case "MultiValue":  						_MultiValue = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "ValidValues":  						_ValidValues = new ValidValues(r' this' xNodeLoop);  						break;  					case "UsedInQuery":  						_UsedInQuery = TrueFalseAuto.GetStyle(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					default:	  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown ReportParameter element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,ReportParameter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportParameter.cs,ReportParameter,The following statement contains a magic number: if (_Name == null)  				OwnerReport.rl.LogError(8' "ReportParameter name is required but not specified.");
Magic Number,fyiReporting.RDL,ReportParameter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportParameter.cs,ReportParameter,The following statement contains a magic number: if (_dt == TypeCode.Object)  				OwnerReport.rl.LogError(8' string.Format("ReportParameter DataType is required but not specified or invalid for {0}."' _Name==null? "<unknown name>": _Name.Nm));
Magic Number,fyiReporting.RDL,ReportParameter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportParameter.cs,SetRuntimeValue,The following statement contains a magic number: try   			{  				if (v is String && _NumericType)  					v = ConvertStringToNumber((string) v);  				rtv = Convert.ChangeType(v' _dt);   			}  			catch (Exception e)  			{  				// illegal parameter passed                  string err = "Illegal parameter value for '" + Name.Nm + "' provided.  Value =" + v.ToString();                  if (rpt == null)                      OwnerReport.rl.LogError(4' err);                  else                      rpt.rl.LogError(4' err);  				throw new ArgumentException(string.Format("Unable to convert '{0}' to {1} for {2}"' v' _dt' Name.Nm)'e);  			}
Magic Number,fyiReporting.RDL,ReportParameter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportParameter.cs,SetRuntimeValue,The following statement contains a magic number: try   			{  				if (v is String && _NumericType)  					v = ConvertStringToNumber((string) v);  				rtv = Convert.ChangeType(v' _dt);   			}  			catch (Exception e)  			{  				// illegal parameter passed                  string err = "Illegal parameter value for '" + Name.Nm + "' provided.  Value =" + v.ToString();                  if (rpt == null)                      OwnerReport.rl.LogError(4' err);                  else                      rpt.rl.LogError(4' err);  				throw new ArgumentException(string.Format("Unable to convert '{0}' to {1} for {2}"' v' _dt' Name.Nm)'e);  			}
Magic Number,fyiReporting.RDL,ReportParameter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportParameter.cs,SetRuntimeValues,The following statement contains a magic number: foreach (object v in vs)              {                  object rtv;                  if (!AllowBlank && _dt == TypeCode.String && v.ToString() == "")                  {                      string err = string.Format("Empty string isn't allowed for {0}."' Name.Nm);                      if (rpt == null)                          OwnerReport.rl.LogError(4' err);                      else                          rpt.rl.LogError(4' err);                      throw new ArgumentException(err);                  }                  try                  {                      object nv = v;                      if (nv is String && _NumericType)                          nv = ConvertStringToNumber((string)nv);                      rtv = Convert.ChangeType(nv' _dt);                      ar.Add(rtv);                  }                  catch (Exception e)                  {                      // illegal parameter passed                      string err = "Illegal parameter value for '" + Name.Nm + "' provided.  Value =" + v.ToString();                      if (rpt == null)                          OwnerReport.rl.LogError(4' err);                      else                          rpt.rl.LogError(4' err);                      throw new ArgumentException(string.Format("Unable to convert '{0}' to {1} for {2}"' v' _dt' Name.Nm)' e);                  }              }
Magic Number,fyiReporting.RDL,ReportParameter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportParameter.cs,SetRuntimeValues,The following statement contains a magic number: foreach (object v in vs)              {                  object rtv;                  if (!AllowBlank && _dt == TypeCode.String && v.ToString() == "")                  {                      string err = string.Format("Empty string isn't allowed for {0}."' Name.Nm);                      if (rpt == null)                          OwnerReport.rl.LogError(4' err);                      else                          rpt.rl.LogError(4' err);                      throw new ArgumentException(err);                  }                  try                  {                      object nv = v;                      if (nv is String && _NumericType)                          nv = ConvertStringToNumber((string)nv);                      rtv = Convert.ChangeType(nv' _dt);                      ar.Add(rtv);                  }                  catch (Exception e)                  {                      // illegal parameter passed                      string err = "Illegal parameter value for '" + Name.Nm + "' provided.  Value =" + v.ToString();                      if (rpt == null)                          OwnerReport.rl.LogError(4' err);                      else                          rpt.rl.LogError(4' err);                      throw new ArgumentException(string.Format("Unable to convert '{0}' to {1} for {2}"' v' _dt' Name.Nm)' e);                  }              }
Magic Number,fyiReporting.RDL,ReportParameter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportParameter.cs,SetRuntimeValues,The following statement contains a magic number: foreach (object v in vs)              {                  object rtv;                  if (!AllowBlank && _dt == TypeCode.String && v.ToString() == "")                  {                      string err = string.Format("Empty string isn't allowed for {0}."' Name.Nm);                      if (rpt == null)                          OwnerReport.rl.LogError(4' err);                      else                          rpt.rl.LogError(4' err);                      throw new ArgumentException(err);                  }                  try                  {                      object nv = v;                      if (nv is String && _NumericType)                          nv = ConvertStringToNumber((string)nv);                      rtv = Convert.ChangeType(nv' _dt);                      ar.Add(rtv);                  }                  catch (Exception e)                  {                      // illegal parameter passed                      string err = "Illegal parameter value for '" + Name.Nm + "' provided.  Value =" + v.ToString();                      if (rpt == null)                          OwnerReport.rl.LogError(4' err);                      else                          rpt.rl.LogError(4' err);                      throw new ArgumentException(string.Format("Unable to convert '{0}' to {1} for {2}"' v' _dt' Name.Nm)' e);                  }              }
Magic Number,fyiReporting.RDL,ReportParameter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportParameter.cs,SetRuntimeValues,The following statement contains a magic number: foreach (object v in vs)              {                  object rtv;                  if (!AllowBlank && _dt == TypeCode.String && v.ToString() == "")                  {                      string err = string.Format("Empty string isn't allowed for {0}."' Name.Nm);                      if (rpt == null)                          OwnerReport.rl.LogError(4' err);                      else                          rpt.rl.LogError(4' err);                      throw new ArgumentException(err);                  }                  try                  {                      object nv = v;                      if (nv is String && _NumericType)                          nv = ConvertStringToNumber((string)nv);                      rtv = Convert.ChangeType(nv' _dt);                      ar.Add(rtv);                  }                  catch (Exception e)                  {                      // illegal parameter passed                      string err = "Illegal parameter value for '" + Name.Nm + "' provided.  Value =" + v.ToString();                      if (rpt == null)                          OwnerReport.rl.LogError(4' err);                      else                          rpt.rl.LogError(4' err);                      throw new ArgumentException(string.Format("Unable to convert '{0}' to {1} for {2}"' v' _dt' Name.Nm)' e);                  }              }
Magic Number,fyiReporting.RDL,ReportParameters,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportParameters.cs,ReportParameters,The following statement contains a magic number: if (xNode.ChildNodes.Count < 10)  				_Items = new ListDictionary();	// Hashtable is overkill for small lists  			else  				_Items = new Hashtable(xNode.ChildNodes.Count);
Magic Number,fyiReporting.RDL,ReportParameters,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportParameters.cs,ReportParameters,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				if (xNodeLoop.Name == "ReportParameter")  				{  					ReportParameter rp = new ReportParameter(r' this' xNodeLoop);                      if (rp.Name != null)  					    _Items.Add(rp.Name.Nm' rp);  				}  				else  					OwnerReport.rl.LogError(4' "Unknown ReportParameters element '" + xNodeLoop.Name + "' ignored.");  			}
Magic Number,fyiReporting.RDL,ReportParameters,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportParameters.cs,SetRuntimeValues,The following statement contains a magic number: foreach (string pname in parms.Keys)	// Loop thru the passed parameters  			{  				ReportParameter rp = (ReportParameter) _Items[pname];  				if (rp == null)  				{	// When not found treat it as a warning message  					if (!pname.StartsWith("rs:"))	// don't care about report server parameters  						rpt.rl.LogError(4' "Unknown ReportParameter passed '" + pname + "' ignored.");  					continue;  				}                    // Search for the valid values                  object parmValue = parms[pname];                  if (parmValue is string && rp.ValidValues != null)                  {                      string[] dvs = rp.ValidValues.DisplayValues(rpt);                      if (dvs != null && dvs.Length > 0)                      {                          for (int i = 0; i < dvs.Length; i++)                          {                              if (dvs[i] == (string) parmValue)                              {                                  object[] dv = rp.ValidValues.DataValues(rpt);                                  parmValue = dv[i];                                  break;                              }                          }                      }                  }  				rp.SetRuntimeValue(rpt' parmValue);  			}
Magic Number,fyiReporting.RDL,RowGrouping,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\RowGrouping.cs,RowGrouping,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Width":  						_Width = new RSize(r' xNodeLoop);  						break;  					case "DynamicRows":  						_DynamicRows = new DynamicRows(r' this' xNodeLoop);  						break;  					case "StaticRows":  						_StaticRows = new StaticRows(r' this' xNodeLoop);  						break;  					default:	  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown RowGrouping element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,RowGrouping,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\RowGrouping.cs,RowGrouping,The following statement contains a magic number: if (_Width == null)  				OwnerReport.rl.LogError(8' "RowGrouping requires the Width element.");
Magic Number,fyiReporting.RDL,RowGroupings,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\RowGroupings.cs,RowGroupings,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "RowGrouping":  						g = new RowGrouping(r' this' xNodeLoop);  						break;  					default:	  						g=null;		// don't know what this is  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown RowGroupings element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  				if (g != null)  					_Items.Add(g);  			}
Magic Number,fyiReporting.RDL,RowGroupings,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\RowGroupings.cs,RowGroupings,The following statement contains a magic number: if (_Items.Count == 0)  				OwnerReport.rl.LogError(8' "For RowGroupings at least one RowGrouping is required.");  			else  			{                  _Items.TrimExcess();  				_StaticCount = GetStaticCount();  			}
Magic Number,fyiReporting.RDL,Rows,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Rows.cs,Compare,The following statement contains a magic number: try   			{  				foreach (RowsSortExpression se in _SortBy)  				{  					o1 = se.expr.Evaluate(this._Rpt' r1);  					o2 = se.expr.Evaluate(this._Rpt' r2);  					tc = se.expr.GetTypeCode();  					rc = Filter.ApplyCompare(tc' o1' o2);  					if (rc != 0)  						return se.bAscending? rc: -rc;  				}  			}  			catch (Exception e)		// this really shouldn't happen  			{  				_Rpt.rl.LogError(8'                       string.Format("Sort rows exception\r\nArguments: {0} {1}\r\nTypecode: {2}\r\n{3}\r\n{4}"'                       o1' o2' tc.ToString()' e.Message' e.StackTrace));  			}
Magic Number,fyiReporting.RDL,RSize,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\RSize.cs,RSize,The following statement contains a magic number: try		// Convert.ToDecimal can be very picky  			{  				if (space != -1)	// any spaces  				{  					n = t.Substring(0'space).Trim();	// number string  					u = t.Substring(space).Trim();	// unit string  				}  				else if (t.Length >= 3)  				{  					n = t.Substring(0' t.Length-2).Trim();  					u = t.Substring(t.Length-2).Trim();  				}  				else  				{  					// Illegal unit                      if (r != null)  					    r.rl.LogError(4' string.Format("Illegal size '{0}' specified' assuming 0 length."' t));  					_Size = 0;  					return;  				}  				if (!Regex.IsMatch(n' @"\A[ ]*[-]?[0-9]*[.]?[0-9]*[ ]*\Z"))  				{  					r.rl.LogError(4' string.Format("Unknown characters in '{0}' specified.  Number must be of form '###.##'.  Local conversion will be attempted."' t));  					d = Convert.ToDecimal(n' NumberFormatInfo.CurrentInfo);		// initial number  				}  				else  					d = Convert.ToDecimal(n' NumberFormatInfo.InvariantInfo);		// initial number  			}  			catch (Exception ex)   			{  				// Illegal unit                  if (r != null)  				    r.rl.LogError(4' "Illegal size '" + t + "' specified' assuming 0 length.\r\n"+ex.Message);  				_Size = 0;  				return;  			}
Magic Number,fyiReporting.RDL,RSize,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\RSize.cs,RSize,The following statement contains a magic number: try		// Convert.ToDecimal can be very picky  			{  				if (space != -1)	// any spaces  				{  					n = t.Substring(0'space).Trim();	// number string  					u = t.Substring(space).Trim();	// unit string  				}  				else if (t.Length >= 3)  				{  					n = t.Substring(0' t.Length-2).Trim();  					u = t.Substring(t.Length-2).Trim();  				}  				else  				{  					// Illegal unit                      if (r != null)  					    r.rl.LogError(4' string.Format("Illegal size '{0}' specified' assuming 0 length."' t));  					_Size = 0;  					return;  				}  				if (!Regex.IsMatch(n' @"\A[ ]*[-]?[0-9]*[.]?[0-9]*[ ]*\Z"))  				{  					r.rl.LogError(4' string.Format("Unknown characters in '{0}' specified.  Number must be of form '###.##'.  Local conversion will be attempted."' t));  					d = Convert.ToDecimal(n' NumberFormatInfo.CurrentInfo);		// initial number  				}  				else  					d = Convert.ToDecimal(n' NumberFormatInfo.InvariantInfo);		// initial number  			}  			catch (Exception ex)   			{  				// Illegal unit                  if (r != null)  				    r.rl.LogError(4' "Illegal size '" + t + "' specified' assuming 0 length.\r\n"+ex.Message);  				_Size = 0;  				return;  			}
Magic Number,fyiReporting.RDL,RSize,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\RSize.cs,RSize,The following statement contains a magic number: try		// Convert.ToDecimal can be very picky  			{  				if (space != -1)	// any spaces  				{  					n = t.Substring(0'space).Trim();	// number string  					u = t.Substring(space).Trim();	// unit string  				}  				else if (t.Length >= 3)  				{  					n = t.Substring(0' t.Length-2).Trim();  					u = t.Substring(t.Length-2).Trim();  				}  				else  				{  					// Illegal unit                      if (r != null)  					    r.rl.LogError(4' string.Format("Illegal size '{0}' specified' assuming 0 length."' t));  					_Size = 0;  					return;  				}  				if (!Regex.IsMatch(n' @"\A[ ]*[-]?[0-9]*[.]?[0-9]*[ ]*\Z"))  				{  					r.rl.LogError(4' string.Format("Unknown characters in '{0}' specified.  Number must be of form '###.##'.  Local conversion will be attempted."' t));  					d = Convert.ToDecimal(n' NumberFormatInfo.CurrentInfo);		// initial number  				}  				else  					d = Convert.ToDecimal(n' NumberFormatInfo.InvariantInfo);		// initial number  			}  			catch (Exception ex)   			{  				// Illegal unit                  if (r != null)  				    r.rl.LogError(4' "Illegal size '" + t + "' specified' assuming 0 length.\r\n"+ex.Message);  				_Size = 0;  				return;  			}
Magic Number,fyiReporting.RDL,RSize,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\RSize.cs,RSize,The following statement contains a magic number: try		// Convert.ToDecimal can be very picky  			{  				if (space != -1)	// any spaces  				{  					n = t.Substring(0'space).Trim();	// number string  					u = t.Substring(space).Trim();	// unit string  				}  				else if (t.Length >= 3)  				{  					n = t.Substring(0' t.Length-2).Trim();  					u = t.Substring(t.Length-2).Trim();  				}  				else  				{  					// Illegal unit                      if (r != null)  					    r.rl.LogError(4' string.Format("Illegal size '{0}' specified' assuming 0 length."' t));  					_Size = 0;  					return;  				}  				if (!Regex.IsMatch(n' @"\A[ ]*[-]?[0-9]*[.]?[0-9]*[ ]*\Z"))  				{  					r.rl.LogError(4' string.Format("Unknown characters in '{0}' specified.  Number must be of form '###.##'.  Local conversion will be attempted."' t));  					d = Convert.ToDecimal(n' NumberFormatInfo.CurrentInfo);		// initial number  				}  				else  					d = Convert.ToDecimal(n' NumberFormatInfo.InvariantInfo);		// initial number  			}  			catch (Exception ex)   			{  				// Illegal unit                  if (r != null)  				    r.rl.LogError(4' "Illegal size '" + t + "' specified' assuming 0 length.\r\n"+ex.Message);  				_Size = 0;  				return;  			}
Magic Number,fyiReporting.RDL,RSize,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\RSize.cs,RSize,The following statement contains a magic number: try		// Convert.ToDecimal can be very picky  			{  				if (space != -1)	// any spaces  				{  					n = t.Substring(0'space).Trim();	// number string  					u = t.Substring(space).Trim();	// unit string  				}  				else if (t.Length >= 3)  				{  					n = t.Substring(0' t.Length-2).Trim();  					u = t.Substring(t.Length-2).Trim();  				}  				else  				{  					// Illegal unit                      if (r != null)  					    r.rl.LogError(4' string.Format("Illegal size '{0}' specified' assuming 0 length."' t));  					_Size = 0;  					return;  				}  				if (!Regex.IsMatch(n' @"\A[ ]*[-]?[0-9]*[.]?[0-9]*[ ]*\Z"))  				{  					r.rl.LogError(4' string.Format("Unknown characters in '{0}' specified.  Number must be of form '###.##'.  Local conversion will be attempted."' t));  					d = Convert.ToDecimal(n' NumberFormatInfo.CurrentInfo);		// initial number  				}  				else  					d = Convert.ToDecimal(n' NumberFormatInfo.InvariantInfo);		// initial number  			}  			catch (Exception ex)   			{  				// Illegal unit                  if (r != null)  				    r.rl.LogError(4' "Illegal size '" + t + "' specified' assuming 0 length.\r\n"+ex.Message);  				_Size = 0;  				return;  			}
Magic Number,fyiReporting.RDL,RSize,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\RSize.cs,RSize,The following statement contains a magic number: try		// Convert.ToDecimal can be very picky  			{  				if (space != -1)	// any spaces  				{  					n = t.Substring(0'space).Trim();	// number string  					u = t.Substring(space).Trim();	// unit string  				}  				else if (t.Length >= 3)  				{  					n = t.Substring(0' t.Length-2).Trim();  					u = t.Substring(t.Length-2).Trim();  				}  				else  				{  					// Illegal unit                      if (r != null)  					    r.rl.LogError(4' string.Format("Illegal size '{0}' specified' assuming 0 length."' t));  					_Size = 0;  					return;  				}  				if (!Regex.IsMatch(n' @"\A[ ]*[-]?[0-9]*[.]?[0-9]*[ ]*\Z"))  				{  					r.rl.LogError(4' string.Format("Unknown characters in '{0}' specified.  Number must be of form '###.##'.  Local conversion will be attempted."' t));  					d = Convert.ToDecimal(n' NumberFormatInfo.CurrentInfo);		// initial number  				}  				else  					d = Convert.ToDecimal(n' NumberFormatInfo.InvariantInfo);		// initial number  			}  			catch (Exception ex)   			{  				// Illegal unit                  if (r != null)  				    r.rl.LogError(4' "Illegal size '" + t + "' specified' assuming 0 length.\r\n"+ex.Message);  				_Size = 0;  				return;  			}
Magic Number,fyiReporting.RDL,RSize,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\RSize.cs,RSize,The following statement contains a magic number: switch(u)			// convert to millimeters  			{                  case "in": //Inches                      _Size = (int)(d * PARTS_PER_INCH);                      break;                  case "cm": //Centimeters                      _Size = (int)(d * PARTS_PER_CM);                      break;                  case "mm": //Millimeters                      _Size = (int)(d * PARTS_PER_MM);                      break;                  case "pt": //Points                      _Size = (int)(d * PARTS_PER_POINT);                      break;                  case "pc": //Picas                      _Size = (int)(d * PARTS_PER_PICA);                      break;                  default:                      // Illegal unit                      if (r != null)                          r.rl.LogError(4' "Unknown sizing unit '" + u + "' specified' assuming inches.");                      _Size = (int)(d * PARTS_PER_INCH);                      break;  			}
Magic Number,fyiReporting.RDL,RSize,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\RSize.cs,RSize,The following statement contains a magic number: if (_Size > 160 * 2540)	// Size can't be greater than 160 inches according to spec  			{   // but RdlEngine supports higher values so just do a warning                  if (r != null)  				    r.rl.LogError(4' "Size '" + this._Original + "' is larger than the RDL specification maximum of 160 inches.");  //				_Size = 160 * 2540;     // this would force maximum to spec max of 160  			}
Magic Number,fyiReporting.RDL,RSize,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\RSize.cs,RSize,The following statement contains a magic number: if (_Size > 160 * 2540)	// Size can't be greater than 160 inches according to spec  			{   // but RdlEngine supports higher values so just do a warning                  if (r != null)  				    r.rl.LogError(4' "Size '" + this._Original + "' is larger than the RDL specification maximum of 160 inches.");  //				_Size = 160 * 2540;     // this would force maximum to spec max of 160  			}
Magic Number,fyiReporting.RDL,RSize,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\RSize.cs,RSize,The following statement contains a magic number: if (_Size > 160 * 2540)	// Size can't be greater than 160 inches according to spec  			{   // but RdlEngine supports higher values so just do a warning                  if (r != null)  				    r.rl.LogError(4' "Size '" + this._Original + "' is larger than the RDL specification maximum of 160 inches.");  //				_Size = 160 * 2540;     // this would force maximum to spec max of 160  			}
Magic Number,fyiReporting.RDL,RSize,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\RSize.cs,PixelsFromPoints,The following statement contains a magic number: int result = (int) (x * 96 / POINTSIZED);
Magic Number,fyiReporting.RDL,RSize,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\RSize.cs,TwipsFromPoints,The following statement contains a magic number: return (int)Math.Round(pt * 20' 0);
Magic Number,fyiReporting.RDL,SeriesGrouping,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\SeriesGrouping.cs,SeriesGrouping,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "DynamicSeries":  						_DynamicSeries = new DynamicSeries(r' this' xNodeLoop);  						break;  					case "StaticSeries":  						_StaticSeries = new StaticSeries(r' this' xNodeLoop);  						break;  					case "Style":  						_Style = new Style(OwnerReport' this' xNodeLoop);  						OwnerReport.rl.LogError(4' "Style element in SeriesGrouping is currently ignored."); // TODO  						break;  					default:	  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown SeriesGrouping element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,SeriesGrouping,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\SeriesGrouping.cs,SeriesGrouping,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "DynamicSeries":  						_DynamicSeries = new DynamicSeries(r' this' xNodeLoop);  						break;  					case "StaticSeries":  						_StaticSeries = new StaticSeries(r' this' xNodeLoop);  						break;  					case "Style":  						_Style = new Style(OwnerReport' this' xNodeLoop);  						OwnerReport.rl.LogError(4' "Style element in SeriesGrouping is currently ignored."); // TODO  						break;  					default:	  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown SeriesGrouping element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,SeriesGroupings,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\SeriesGroupings.cs,SeriesGroupings,The following statement contains a magic number: if (_Items.Count == 0)  				OwnerReport.rl.LogError(8' "For SeriesGroupings at least one SeriesGrouping is required.");  			else                  _Items.TrimExcess();
Magic Number,fyiReporting.RDL,SortBy,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\SortBy.cs,SortBy,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "SortExpression":  						_SortExpression = new Expression(r' this' xNodeLoop' ExpressionType.Variant);  						break;  					case "Direction":  						_Direction = SortDirection.GetStyle(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					default:  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown SortBy element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,SortBy,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\SortBy.cs,SortBy,The following statement contains a magic number: if (_SortExpression == null)  				OwnerReport.rl.LogError(8' "SortBy requires the SortExpression element.");
Magic Number,fyiReporting.RDL,SortDirection,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\SortDirection.cs,GetStyle,The following statement contains a magic number: switch (s)  			{		  				case "Ascending":  					rs = SortDirectionEnum.Ascending;  					break;  				case "Descending":  					rs = SortDirectionEnum.Descending;  					break;  				default:		  					rl.LogError(4' "Unknown SortDirection '" + s + "'.  Ascending assumed.");  					rs = SortDirectionEnum.Ascending;  					break;  			}
Magic Number,fyiReporting.RDL,Sorting,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Sorting.cs,Sorting,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "SortBy":  						s = new SortBy(r' this' xNodeLoop);  						break;  					default:	  						s=null;		// don't know what this is  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown Sorting element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  				if (s != null)  					_Items.Add(s);  			}
Magic Number,fyiReporting.RDL,Sorting,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Sorting.cs,Sorting,The following statement contains a magic number: if (_Items.Count == 0)  				OwnerReport.rl.LogError(8' "Sorting requires at least one SortBy be defined.");  			else                  _Items.TrimExcess();
Magic Number,fyiReporting.RDL,StaticCategories,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\StaticCategories.cs,StaticCategories,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "StaticMember":  						sm = new StaticMember(r' this' xNodeLoop);  						break;  					default:		  						sm=null;		// don't know what this is  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown StaticCategories element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  				if (sm != null)  					_Items.Add(sm);  			}
Magic Number,fyiReporting.RDL,StaticCategories,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\StaticCategories.cs,StaticCategories,The following statement contains a magic number: if (_Items.Count == 0)  				OwnerReport.rl.LogError(8' "For StaticCategories at least one StaticMember is required.");  			else                  _Items.TrimExcess();
Magic Number,fyiReporting.RDL,StaticColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\StaticColumn.cs,StaticColumn,The following statement contains a magic number: if (_ReportItems == null)  				OwnerReport.rl.LogError(8' "StaticColumn requires the ReportItems element.");
Magic Number,fyiReporting.RDL,StaticColumns,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\StaticColumns.cs,StaticColumns,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "StaticColumn":  						sc = new StaticColumn(r' this' xNodeLoop);  						break;  					default:	  						sc=null;		// don't know what this is  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown StaticColumns element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  				if (sc != null)  					_Items.Add(sc);  			}
Magic Number,fyiReporting.RDL,StaticColumns,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\StaticColumns.cs,StaticColumns,The following statement contains a magic number: if (_Items.Count == 0)  				OwnerReport.rl.LogError(8' "For StaticColumns at least one StaticColumn is required.");  			else                  _Items.TrimExcess();
Magic Number,fyiReporting.RDL,StaticMember,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\StaticMember.cs,StaticMember,The following statement contains a magic number: if (_Label == null)  				OwnerReport.rl.LogError(8' "StaticMember requires the Label element.");
Magic Number,fyiReporting.RDL,StaticRow,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\StaticRow.cs,StaticRow,The following statement contains a magic number: if (_ReportItems == null)  				OwnerReport.rl.LogError(8' "StaticRow requires the ReportItems element.");
Magic Number,fyiReporting.RDL,StaticRows,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\StaticRows.cs,StaticRows,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "StaticRow":  						sr = new StaticRow(r' this' xNodeLoop);  						break;  					default:	  						sr=null;		// don't know what this is  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown StaticRows element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  				if (sr != null)  					_Items.Add(sr);  			}
Magic Number,fyiReporting.RDL,StaticRows,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\StaticRows.cs,StaticRows,The following statement contains a magic number: if (_Items.Count == 0)  				OwnerReport.rl.LogError(8' "For StaticRows at least one StaticRow is required.");  			else                  _Items.TrimExcess();
Magic Number,fyiReporting.RDL,StaticSeries,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\StaticSeries.cs,StaticSeries,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "StaticMember":  						sm = new StaticMember(r' this' xNodeLoop);  						break;  					default:	  						sm=null;		// don't know what this is  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown StaticSeries element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  				if (sm != null)  					_Items.Add(sm);  			}
Magic Number,fyiReporting.RDL,StaticSeries,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\StaticSeries.cs,StaticSeries,The following statement contains a magic number: if (_Items.Count == 0)  				OwnerReport.rl.LogError(8' "For StaticSeries at least one StaticMember is required.");  			else                  _Items.TrimExcess();
Magic Number,fyiReporting.RDL,Style,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Style.cs,Style,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "BorderColor":  						_BorderColor = new StyleBorderColor(r' this' xNodeLoop);  						break;  					case "BorderStyle":  						_BorderStyle = new StyleBorderStyle(r' this' xNodeLoop);  						break;  					case "BorderWidth":  						_BorderWidth = new StyleBorderWidth(r' this' xNodeLoop);  						break;  					case "BackgroundColor":  						_BackgroundColor = new Expression(r' this' xNodeLoop' ExpressionType.Color);  						break;  					case "BackgroundGradientType":   						_BackgroundGradientType = new Expression(r' this' xNodeLoop' ExpressionType.Enum);  						break;  					case "BackgroundGradientEndColor":  						_BackgroundGradientEndColor = new Expression(r' this' xNodeLoop' ExpressionType.Color);  						break;  					case "BackgroundImage":  						_BackgroundImage = new StyleBackgroundImage(r' this' xNodeLoop);  						break;  					case "FontStyle":  						_FontStyle = new Expression(r' this' xNodeLoop' ExpressionType.Enum);  						break;  					case "FontFamily":  						_FontFamily = new Expression(r' this' xNodeLoop' ExpressionType.String);  						break;  					case "FontSize":  						_FontSize = new Expression(r' this' xNodeLoop' ExpressionType.ReportUnit);  						break;  					case "FontWeight":  						_FontWeight = new Expression(r' this' xNodeLoop' ExpressionType.Enum);  						break;  					case "Format":  						_Format =  new Expression(r' this' xNodeLoop' ExpressionType.String);  						break;  					case "TextDecoration":  						_TextDecoration = new Expression(r' this' xNodeLoop' ExpressionType.Enum);  						break;  					case "TextAlign":  						_TextAlign = new Expression(r' this' xNodeLoop' ExpressionType.Enum);  						break;  					case "VerticalAlign":  						_VerticalAlign = new Expression(r' this' xNodeLoop' ExpressionType.Enum);  						break;  					case "Color":  						_Color =  new Expression(r' this' xNodeLoop' ExpressionType.Color);  						break;  					case "PaddingLeft":  						_PaddingLeft = new Expression(r' this' xNodeLoop' ExpressionType.ReportUnit);  						break;  					case "PaddingRight":  						_PaddingRight = new Expression(r' this' xNodeLoop' ExpressionType.ReportUnit);  						break;  					case "PaddingTop":  						_PaddingTop =  new Expression(r' this' xNodeLoop' ExpressionType.ReportUnit);  						break;  					case "PaddingBottom":  						_PaddingBottom = new Expression(r' this' xNodeLoop' ExpressionType.ReportUnit);  						break;  					case "LineHeight":  						_LineHeight = new Expression(r' this' xNodeLoop' ExpressionType.ReportUnit);  						break;  					case "Direction":  						_Direction = new Expression(r' this' xNodeLoop' ExpressionType.Enum);  						break;  					case "WritingMode":  						_WritingMode = new Expression(r' this' xNodeLoop' ExpressionType.Enum);  						break;  					case "Language":  						_Language = new Expression(r' this' xNodeLoop' ExpressionType.Language);  						break;  					case "UnicodeBiDirectional":  						_UnicodeBiDirectional = new Expression(r' this' xNodeLoop' ExpressionType.Enum);  						break;  					case "Calendar":  						_Calendar = new Expression(r' this' xNodeLoop' ExpressionType.Enum);  						break;  					case "NumeralLanguage":  						_NumeralLanguage = new Expression(r' this' xNodeLoop' ExpressionType.Language);  						break;  					case "NumeralVariant":  						_NumeralVariant = new Expression(r' this' xNodeLoop' ExpressionType.Integer);  						break;  					default:	  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown Style element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,Style,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Style.cs,DrawStringDefaults,The following statement contains a magic number: try  			{  				// Just use defaults to Create font and brush.  				drawFont = new Font("Arial"' 10);  				drawBrush = new SolidBrush(System.Drawing.Color.Black);  				// Set format of string.  				drawFormat = new StringFormat();  				drawFormat.Alignment = StringAlignment.Center;                                      // 06122007AJM Fixed so that long names are written vertically                  // need to add w to make slightly bigger                  SizeF len = g.MeasureString(o.ToString()+ "w"' drawFont);                  if (len.Width > rect.Width)                  {                      drawFormat.FormatFlags = StringFormatFlags.DirectionVertical;                      rect = (new System.Drawing.Rectangle(rect.X' rect.Y' rect.Width' (int)len.Width));                      drawFormat.Alignment = StringAlignment.Near;                  }                     // Draw string to image  				g.DrawString(o.ToString()' drawFont' drawBrush' rect' drawFormat);  			}  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawBrush != null)  					drawBrush.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,Style,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Style.cs,MeasureStringDefaults,The following statement contains a magic number: try			// Want to make sure we dispose of the font and brush (no matter what)  			{  				s = Style.GetFormatedString(rpt' null' r' o' tc);    				drawFont = new Font("Arial"' 10);  				drawFormat = new StringFormat();  				drawFormat.Alignment = StringAlignment.Near;    				// Measure string  				if (maxWidth == int.MaxValue)  					drawFormat.FormatFlags |= StringFormatFlags.NoWrap;                  // 06122007AJM need to add w to make slightly bigger                  SizeF ms = g.MeasureString(s + "w"' drawFont' maxWidth' drawFormat);  				size = new Size((int) Math.Ceiling(ms.Width)'   					(int) Math.Ceiling(ms.Height));  			}  			finally  			{  				if (drawFont != null)  					drawFont.Dispose();  				if (drawFormat != null)  					drawFormat.Dispose();  			}
Magic Number,fyiReporting.RDL,Style,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Style.cs,GetFont,The following statement contains a magic number: if (this.FontSize != null)  			{  				string lsize = this.FontSize.EvaluateString(rpt' r);  				RSize rs = new RSize(this.OwnerReport' lsize);  				size = rs.Points;  			}  			else  				size = 10;
Magic Number,fyiReporting.RDL,Style,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Style.cs,EvalFontSize,The following statement contains a magic number: if (_FontSize == null)  				return 10;
Magic Number,fyiReporting.RDL,Style,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Style.cs,EvalNumeralVariant,The following statement contains a magic number: if (v < 1 || v > 7)		// correct for bad data  				v = 1;
Magic Number,fyiReporting.RDL,StyleBackgroundImage,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\StyleBackgroundImage.cs,StyleBackgroundImage,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Source":  						_Source = StyleBackgroundImageSource.GetStyle(xNodeLoop.InnerText);  						break;  					case "Value":  						_Value = new Expression(r' this' xNodeLoop' ExpressionType.String);  						break;  					case "MIMEType":  						_MIMEType = new Expression(r' this' xNodeLoop' ExpressionType.String);  						break;  					case "BackgroundRepeat":  						_BackgroundRepeat = new Expression(r' this' xNodeLoop' ExpressionType.Enum);  						break;  					default:	  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown BackgroundImage element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,StyleBackgroundImage,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\StyleBackgroundImage.cs,StyleBackgroundImage,The following statement contains a magic number: if (_Source == StyleBackgroundImageSourceEnum.Unknown)  				OwnerReport.rl.LogError(8' "BackgroundImage requires the Source element.");
Magic Number,fyiReporting.RDL,StyleBackgroundImage,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\StyleBackgroundImage.cs,StyleBackgroundImage,The following statement contains a magic number: if (_Value == null)  				OwnerReport.rl.LogError(8' "BackgroundImage requires the Value element.");
Magic Number,fyiReporting.RDL,StyleBackgroundImage,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\StyleBackgroundImage.cs,GetPageImage,The following statement contains a magic number: try   			{  				strm = GetImageStream(rpt' row' out mtype);                  if (strm == null)                  {                      rpt.rl.LogError(4' string.Format("Unable to load image {0}."'                           this._Value==null?"": this._Value.EvaluateString(rpt' row)));                      return null;                  }                  im = System.Drawing.Image.FromStream(strm);  				int height = im.Height;  				int width = im.Width;  				MemoryStream ostrm = new MemoryStream();  				ImageFormat imf;  				//				if (mtype.ToLower() == "image/jpeg")    //TODO: how do we get png to work  				//					imf = ImageFormat.Jpeg;  				//				else                    imf = ImageFormat.Jpeg;                  System.Drawing.Imaging.ImageCodecInfo[] info;                  info = ImageCodecInfo.GetImageEncoders();                  EncoderParameters encoderParameters;                  encoderParameters = new EncoderParameters(1);                  encoderParameters.Param[0] = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality' ImageQualityManager.EmbeddedImageQuality);                  System.Drawing.Imaging.ImageCodecInfo codec = null;                  for (int i = 0; i < info.Length; i++)                  {                      if (info[i].FormatDescription == "JPEG")                      {                          codec = info[i];                          break;                      }                  }                  im.Save(ostrm' codec' encoderParameters);    				byte[] ba = ostrm.ToArray();  				ostrm.Close();  				pi = new PageImage(imf' ba' width' height);  				pi.SI = new StyleInfo();	// this will just default everything  				if (_BackgroundRepeat != null)  				{  					string r = _BackgroundRepeat.EvaluateString(rpt' row).ToLower();  					switch (r)  					{  						case "repeat":  							pi.Repeat = ImageRepeat.Repeat;  							break;  						case "repeatx":  							pi.Repeat = ImageRepeat.RepeatX;  							break;  						case "repeaty":  							pi.Repeat = ImageRepeat.RepeatY;  							break;  						case "norepeat":  						default:  							pi.Repeat = ImageRepeat.NoRepeat;  							break;  					}  				}  				else  					pi.Repeat = ImageRepeat.Repeat;    				if (_ConstantImage)  				{  					wc.PgImage = pi;  					// create unique name; PDF generation uses this to optimize the saving of the image only once  					pi.Name = "pi" + Interlocked.Increment(ref Parser.Counter).ToString();	// create unique name  				}  			}  			finally  			{  				if (strm != null)  					strm.Close();  				if (im != null)  					im.Dispose();  			}
Magic Number,fyiReporting.RDL,StyleBorderColor,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\StyleBorderColor.cs,StyleBorderColor,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Default":  						_Default = new Expression(r' this' xNodeLoop' ExpressionType.Color);  						break;  					case "Left":  						_Left = new Expression(r' this' xNodeLoop' ExpressionType.Color);  						break;  					case "Right":  						_Right = new Expression(r' this' xNodeLoop' ExpressionType.Color);  						break;  					case "Top":  						_Top = new Expression(r' this' xNodeLoop' ExpressionType.Color);  						break;  					case "Bottom":  						_Bottom = new Expression(r' this' xNodeLoop' ExpressionType.Color);  						break;  					default:  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown BorderColor element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,StyleBorderStyle,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\StyleBorderStyle.cs,StyleBorderStyle,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Default":  						_Default = new Expression(r' this' xNodeLoop' ExpressionType.Enum);  						break;  					case "Left":  						_Left = new Expression(r' this' xNodeLoop' ExpressionType.Enum);  						break;  					case "Right":  						_Right = new Expression(r' this' xNodeLoop' ExpressionType.Enum);  						break;  					case "Top":  						_Top = new Expression(r' this' xNodeLoop' ExpressionType.Enum);  						break;  					case "Bottom":  						_Bottom = new Expression(r' this' xNodeLoop' ExpressionType.Enum);  						break;  					default:	  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown BorderStyle element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,StyleBorderWidth,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\StyleBorderWidth.cs,StyleBorderWidth,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Default":  						_Default = new Expression(r' this' xNodeLoop' ExpressionType.ReportUnit);  						break;  					case "Left":  						_Left = new Expression(r' this' xNodeLoop' ExpressionType.ReportUnit);  						break;  					case "Right":  						_Right = new Expression(r' this' xNodeLoop' ExpressionType.ReportUnit);  						break;  					case "Top":  						_Top = new Expression(r' this' xNodeLoop' ExpressionType.ReportUnit);  						break;  					case "Bottom":  						_Bottom = new Expression(r' this' xNodeLoop' ExpressionType.ReportUnit);  						break;  					default:	  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown BorderWidth element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,Subreport,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Subreport.cs,Subreport,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "ReportName":  						_ReportName = xNodeLoop.InnerText;  						break;  					case "Parameters":  						_Parameters = new SubReportParameters(r' this' xNodeLoop);  						break;  					case "NoRows":  						_NoRows = new Expression(r' this' xNodeLoop' ExpressionType.String);  						break;  					case "MergeTransactions":  						_MergeTransactions = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					default:	  						if (ReportItemElement(xNodeLoop))	// try at ReportItem level  							break;  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown Image element " + xNodeLoop.Name + " ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,Subreport,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Subreport.cs,Subreport,The following statement contains a magic number: if (_ReportName == null)  				OwnerReport.rl.LogError(8' "Subreport requires the ReportName element.");
Magic Number,fyiReporting.RDL,Subreport,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Subreport.cs,FinalPass,The following statement contains a magic number: if (this.InPageHeaderOrFooter())  				OwnerReport.rl.LogError(8' String.Format("The Subreport '{0}' is not allowed in a PageHeader or PageFooter"' this.Name == null? "unknown": Name.Nm) );
Magic Number,fyiReporting.RDL,Subreport,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Subreport.cs,GetReport,The following statement contains a magic number: try  			{  				prog = GetRdlSource(name);  				rdlp =  new RDLParser(prog);  				rdlp.Folder = folder;  				if(OwnerReport.OverwriteInSubreport)  				{  					rdlp.OverwriteConnectionString = OwnerReport.OverwriteConnectionString;  					rdlp.OverwriteInSubreport = OwnerReport.OverwriteInSubreport;  				}    				r = rdlp.Parse(OwnerReport.GetObjectNumber());  				OwnerReport.SetObjectNumber(r.ReportDefinition.GetObjectNumber());  				if (r.ErrorMaxSeverity > 0)   				{  					string err;  					if (r.ErrorMaxSeverity > 4)  						err = string.Format("Subreport {0} failed to compile with the following errors."' this._ReportName);  					else  						err = string.Format("Subreport {0} compiled with the following warnings."' this._ReportName);  					OwnerReport.rl.LogError(r.ErrorMaxSeverity' err);  					OwnerReport.rl.LogError(r.rl);	// log all these errors  					OwnerReport.rl.LogError(0' "End of Subreport errors");  				}  				// If we've loaded the report; we should tell it where it got loaded from  				if (r.ErrorMaxSeverity <= 4)   				{	  					rdefn = r.ReportDefinition;  				}  			}  			catch (Exception ex)  			{  				OwnerReport.rl.LogError(8' string.Format("Subreport {0} failed with exception. {1}"' this._ReportName' ex.Message));  			}
Magic Number,fyiReporting.RDL,Subreport,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Subreport.cs,GetReport,The following statement contains a magic number: try  			{  				prog = GetRdlSource(name);  				rdlp =  new RDLParser(prog);  				rdlp.Folder = folder;  				if(OwnerReport.OverwriteInSubreport)  				{  					rdlp.OverwriteConnectionString = OwnerReport.OverwriteConnectionString;  					rdlp.OverwriteInSubreport = OwnerReport.OverwriteInSubreport;  				}    				r = rdlp.Parse(OwnerReport.GetObjectNumber());  				OwnerReport.SetObjectNumber(r.ReportDefinition.GetObjectNumber());  				if (r.ErrorMaxSeverity > 0)   				{  					string err;  					if (r.ErrorMaxSeverity > 4)  						err = string.Format("Subreport {0} failed to compile with the following errors."' this._ReportName);  					else  						err = string.Format("Subreport {0} compiled with the following warnings."' this._ReportName);  					OwnerReport.rl.LogError(r.ErrorMaxSeverity' err);  					OwnerReport.rl.LogError(r.rl);	// log all these errors  					OwnerReport.rl.LogError(0' "End of Subreport errors");  				}  				// If we've loaded the report; we should tell it where it got loaded from  				if (r.ErrorMaxSeverity <= 4)   				{	  					rdefn = r.ReportDefinition;  				}  			}  			catch (Exception ex)  			{  				OwnerReport.rl.LogError(8' string.Format("Subreport {0} failed with exception. {1}"' this._ReportName' ex.Message));  			}
Magic Number,fyiReporting.RDL,Subreport,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Subreport.cs,GetReport,The following statement contains a magic number: try  			{  				prog = GetRdlSource(name);  				rdlp =  new RDLParser(prog);  				rdlp.Folder = folder;  				if(OwnerReport.OverwriteInSubreport)  				{  					rdlp.OverwriteConnectionString = OwnerReport.OverwriteConnectionString;  					rdlp.OverwriteInSubreport = OwnerReport.OverwriteInSubreport;  				}    				r = rdlp.Parse(OwnerReport.GetObjectNumber());  				OwnerReport.SetObjectNumber(r.ReportDefinition.GetObjectNumber());  				if (r.ErrorMaxSeverity > 0)   				{  					string err;  					if (r.ErrorMaxSeverity > 4)  						err = string.Format("Subreport {0} failed to compile with the following errors."' this._ReportName);  					else  						err = string.Format("Subreport {0} compiled with the following warnings."' this._ReportName);  					OwnerReport.rl.LogError(r.ErrorMaxSeverity' err);  					OwnerReport.rl.LogError(r.rl);	// log all these errors  					OwnerReport.rl.LogError(0' "End of Subreport errors");  				}  				// If we've loaded the report; we should tell it where it got loaded from  				if (r.ErrorMaxSeverity <= 4)   				{	  					rdefn = r.ReportDefinition;  				}  			}  			catch (Exception ex)  			{  				OwnerReport.rl.LogError(8' string.Format("Subreport {0} failed with exception. {1}"' this._ReportName' ex.Message));  			}
Magic Number,fyiReporting.RDL,SubreportParameter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\SubreportParameter.cs,SubreportParameter,The following statement contains a magic number: if (_Name == null)  			{	// Name is required for parameters  				OwnerReport.rl.LogError(8' "Parameter Name attribute required.");  			}
Magic Number,fyiReporting.RDL,SubreportParameter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\SubreportParameter.cs,SubreportParameter,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Value":  						_Value = new Expression(r' this' xNodeLoop' ExpressionType.Variant);  						break;  					default:  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown Subreport parameter element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,SubreportParameter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\SubreportParameter.cs,SubreportParameter,The following statement contains a magic number: if (_Value == null)  			{	// Value is required for parameters  				OwnerReport.rl.LogError(8' "The Parameter Value element is required but was not specified.");  			}
Magic Number,fyiReporting.RDL,SubReportParameters,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\SubreportParameters.cs,SubReportParameters,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Parameter":  						rp = new SubreportParameter(r' this' xNodeLoop);  						break;  					default:	  						rp=null;		// don't know what this is  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown SubreportParameters element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  				if (rp != null)  					_Items.Add(rp);  			}
Magic Number,fyiReporting.RDL,Subtotal,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Subtotal.cs,Subtotal,The following statement contains a magic number: if (_ReportItems == null)  				OwnerReport.rl.LogError(8' "Subtotal requires the ReportItems element.");
Magic Number,fyiReporting.RDL,SubtotalPosition,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\SubtotalPosition.cs,GetStyle,The following statement contains a magic number: switch (s)  			{		  				case "Before":  					rs = SubtotalPositionEnum.Before;  					break;  				case "After":  					rs = SubtotalPositionEnum.After;  					break;  				default:		  					rl.LogError(4' "Unknown SubtotalPosition '" + s + "'.  Before assumed.");  					rs = SubtotalPositionEnum.Before;  					break;  			}
Magic Number,fyiReporting.RDL,Table,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Table.cs,Table,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "TableColumns":  						_TableColumns = new TableColumns(r' this' xNodeLoop);  						break;  					case "Header":  						_Header = new Header(r' this' xNodeLoop);  						break;  					case "TableGroups":  						_TableGroups = new TableGroups(r' this' xNodeLoop);  						break;  					case "Details":  						_Details = new Details(r' this' xNodeLoop);  						break;  					case "Footer":  						_Footer = new Footer(r' this' xNodeLoop);  						break;  					case "FillPage":  						_FillPage = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "DetailDataElementName":  						_DetailDataElementName = xNodeLoop.InnerText;  						break;  					case "DetailDataCollectionName":  						_DetailDataCollectionName = xNodeLoop.InnerText;  						break;  					case "DetailDataElementOutput":  						_DetailDataElementOutput = fyiReporting.RDL.DataElementOutput.GetStyle(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					default:	  						if (DataRegionElement(xNodeLoop))	// try at DataRegion level  							break;  						// don't know this element - log it                          OwnerReport.rl.LogError(4' "Unknown " + xNode.Name + " element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,Table,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Table.cs,Table,The following statement contains a magic number: if (_TableColumns == null)  			{  				OwnerReport.rl.LogError(8' "TableColumns element must be specified for a "+xNode.Name+".");  				return;  			}
Magic Number,fyiReporting.RDL,Table,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Table.cs,Table,The following statement contains a magic number: if (_IsGrid)              {                  if (_TableGroups != null)                      OwnerReport.rl.LogError(8' "TableGroups not allowed in Grid element '" + xNode.Name + "'.");              }
Magic Number,fyiReporting.RDL,Table,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Table.cs,Table,The following statement contains a magic number: if (OwnerReport.rl.MaxSeverity < 8)  				VerifyCC();
Magic Number,fyiReporting.RDL,Table,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Table.cs,VerifyCCTableRows,The following statement contains a magic number: foreach (TableRow tr in trs.Items)  			{  				int cols=0;  				foreach (TableCell tc in tr.TableCells.Items)  				{  					cols += tc.ColSpan;  				}  				if (cols != colCount)  					OwnerReport.rl.LogError(8' String.Format("{0} must have the same number of columns as TableColumns."' label));  			}
Magic Number,fyiReporting.RDL,TableCell,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\TableCell.cs,TableCell,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "ReportItems":  						_ReportItems = new ReportItems(r' this' xNodeLoop);  						break;  					case "ColSpan":  						_ColSpan = XmlUtil.Integer(xNodeLoop.InnerText);  						break;  					default:  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown TableCell element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,TableCell,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\TableCell.cs,TableCell,The following statement contains a magic number: if (_ReportItems == null)  				OwnerReport.rl.LogError(8' "ReportItems element is required with a TableCell but not specified.");  			else if (_ReportItems.Items.Count != 1)  				OwnerReport.rl.LogError(8' "Only one element in ReportItems element is allowed within a TableCell.");
Magic Number,fyiReporting.RDL,TableCell,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\TableCell.cs,TableCell,The following statement contains a magic number: if (_ReportItems == null)  				OwnerReport.rl.LogError(8' "ReportItems element is required with a TableCell but not specified.");  			else if (_ReportItems.Items.Count != 1)  				OwnerReport.rl.LogError(8' "Only one element in ReportItems element is allowed within a TableCell.");
Magic Number,fyiReporting.RDL,TableCells,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\TableCells.cs,TableCells,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "TableCell":  						tc = new TableCell(r' this' xNodeLoop' colIndex);  						colIndex += tc.ColSpan;  						break;  					default:	  						tc=null;		// don't know what this is  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown TableCells element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  				if (tc != null)  					_Items.Add(tc);  			}
Magic Number,fyiReporting.RDL,TableColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\TableColumn.cs,TableColumn,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Width":  						_Width = new RSize(r' xNodeLoop);  						break;  					case "Visibility":  						_Visibility = new Visibility(r' this' xNodeLoop);  						break;  					case "FixedHeader":  						_FixedHeader = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					default:  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown TableColumn element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,TableColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\TableColumn.cs,TableColumn,The following statement contains a magic number: if (_Width == null)  				OwnerReport.rl.LogError(8' "TableColumn requires the Width element.");
Magic Number,fyiReporting.RDL,TableColumns,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\TableColumns.cs,TableColumns,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "TableColumn":  						tc = new TableColumn(r' this' xNodeLoop);  						break;  					default:	  						tc=null;		// don't know what this is  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown TableColumns element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  				if (tc != null)  					_Items.Add(tc);  			}
Magic Number,fyiReporting.RDL,TableColumns,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\TableColumns.cs,TableColumns,The following statement contains a magic number: if (_Items.Count == 0)  				OwnerReport.rl.LogError(8' "For TableColumns at least one TableColumn is required.");  			else                  _Items.TrimExcess();
Magic Number,fyiReporting.RDL,TableGroup,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\TableGroup.cs,TableGroup,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Grouping":  						_Grouping = new Grouping(r' this' xNodeLoop);  						break;  					case "Sorting":  						_Sorting = new Sorting(r' this' xNodeLoop);  						break;  					case "Header":  						_Header = new Header(r' this' xNodeLoop);  						break;  					case "Footer":  						_Footer = new Footer(r' this' xNodeLoop);  						break;  					case "Visibility":  						_Visibility = new Visibility(r' this' xNodeLoop);  						break;  					default:	  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown TableGroup element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,TableGroup,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\TableGroup.cs,TableGroup,The following statement contains a magic number: if (_Grouping == null)  				OwnerReport.rl.LogError(8' "TableGroup requires the Grouping element.");
Magic Number,fyiReporting.RDL,TableGroups,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\TableGroups.cs,TableGroups,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "TableGroup":  						tg = new TableGroup(r' this' xNodeLoop);  						break;  					default:	  						tg=null;		// don't know what this is  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown TableGroups element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  				if (tg != null)  					_Items.Add(tg);  			}
Magic Number,fyiReporting.RDL,TableGroups,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\TableGroups.cs,TableGroups,The following statement contains a magic number: if (_Items.Count == 0)  				OwnerReport.rl.LogError(8' "For TableGroups at least one TableGroup is required.");  			else                  _Items.TrimExcess();
Magic Number,fyiReporting.RDL,TableRow,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\TableRow.cs,TableRow,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "TableCells":  						_TableCells = new TableCells(r' this' xNodeLoop);  						break;  					case "Height":  						_Height = new RSize(r' xNodeLoop);  						break;  					case "Visibility":  						_Visibility = new Visibility(r' this' xNodeLoop);  						break;  					default:  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown TableRow element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,TableRow,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\TableRow.cs,TableRow,The following statement contains a magic number: if (_TableCells == null)  				OwnerReport.rl.LogError(8' "TableRow requires the TableCells element.");
Magic Number,fyiReporting.RDL,TableRow,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\TableRow.cs,TableRow,The following statement contains a magic number: if (_Height == null)  				OwnerReport.rl.LogError(8' "TableRow requires the Height element.");
Magic Number,fyiReporting.RDL,TableRows,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\TableRows.cs,TableRows,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "TableRow":  						t = new TableRow(r' this' xNodeLoop);  						break;  					default:	  						t=null;		// don't know what this is  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown TableRows element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  				if (t != null)  					_Items.Add(t);  			}
Magic Number,fyiReporting.RDL,TableRows,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\TableRows.cs,TableRows,The following statement contains a magic number: if (_Items.Count == 0)  				OwnerReport.rl.LogError(8' "For TableRows at least one TableRow is required.");  			else                  _Items.TrimExcess();
Magic Number,fyiReporting.RDL,Textbox,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Textbox.cs,Textbox,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Value":  						_Value = new Expression(r' this' xNodeLoop' ExpressionType.Variant);  						break;  					case "CanGrow":  						_CanGrow = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "CanShrink":  						_CanShrink = XmlUtil.Boolean(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					case "HideDuplicates":  						_HideDuplicates = xNodeLoop.InnerText;  						break;  					case "ToggleImage":  						_ToggleImage = new ToggleImage(r' this' xNodeLoop);  						break;  					case "DataElementStyle":  						_DataElementStyle = fyiReporting.RDL.DataElementStyle.GetStyle(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					default:  						if (ReportItemElement(xNodeLoop))	// try at ReportItem level  							break;  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown Textbox element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,Textbox,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Textbox.cs,Textbox,The following statement contains a magic number: if (_Value == null)  				OwnerReport.rl.LogError(8' "Textbox value not specified for " + (this.Name == null? "'name not specified'": this.Name.Nm));
Magic Number,fyiReporting.RDL,Textbox,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Textbox.cs,Textbox,The following statement contains a magic number: if (this.Name != null)  			{  				try  				{  					OwnerReport.LUReportItems.Add(this.Name.Nm' this);		// add to referenceable TextBoxes  				}  				catch		// Duplicate name  				{  					OwnerReport.rl.LogError(4' "Duplicate Textbox name '" + this.Name.Nm + "' ignored.");  				}  			}
Magic Number,fyiReporting.RDL,Textbox,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Textbox.cs,FinalPass,The following statement contains a magic number: if (_HideDuplicates != null)  			{  				object o = OwnerReport.LUAggrScope[_HideDuplicates];  				if (o == null)  				{  					OwnerReport.rl.LogError(4' "HideDuplicate '" +_HideDuplicates + "' is not a Group or DataSet name.   It will be ignored.");  					_HideDuplicates=null;  				}  				else if (o is Grouping)  				{	  					Grouping g = o as Grouping;  					g.AddHideDuplicates(this);  				}  				else if (o is DataSetDefn)  				{  					DataSetDefn ds = o as DataSetDefn;  					ds.AddHideDuplicates(this);  				}  			}
Magic Number,fyiReporting.RDL,Textbox,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Textbox.cs,RunText,The following statement contains a magic number: if (IsHtml(rpt' row) && t != null && t.Contains("<expr>"))              {                  string[] parts = HTMLEXPR.Split(t);                  StringBuilder sb = new StringBuilder(t.Length);                  foreach (string s in parts)                  {                      if (s.StartsWith("<expr>") && s.EndsWith("</expr>"))                      {                          string expr = s.Substring(6' s.Length - 13);                          DynamicExpression de = new DynamicExpression(rpt' this' expr' row);                          sb.Append(de.Evaluate(rpt' row));                      }                      else                          sb.Append(s);                  }                  t = sb.ToString();              }
Magic Number,fyiReporting.RDL,Textbox,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Textbox.cs,RunText,The following statement contains a magic number: if (IsHtml(rpt' row) && t != null && t.Contains("<expr>"))              {                  string[] parts = HTMLEXPR.Split(t);                  StringBuilder sb = new StringBuilder(t.Length);                  foreach (string s in parts)                  {                      if (s.StartsWith("<expr>") && s.EndsWith("</expr>"))                      {                          string expr = s.Substring(6' s.Length - 13);                          DynamicExpression de = new DynamicExpression(rpt' this' expr' row);                          sb.Append(de.Evaluate(rpt' row));                      }                      else                          sb.Append(s);                  }                  t = sb.ToString();              }
Magic Number,fyiReporting.RDL,ThreeDPropertiesDrawingStyle,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ThreeDPropertiesDrawingStyle.cs,GetStyle,The following statement contains a magic number: switch (s)  			{		  				case "Cylinder":  					ds = ThreeDPropertiesDrawingStyleEnum.Cylinder;  					break;  				case "Cube":  					ds = ThreeDPropertiesDrawingStyleEnum.Cube;  					break;  				default:	  					rl.LogError(4' "Unknown DrawingStyle '" + s + "'.  Cube assumed.");  					ds = ThreeDPropertiesDrawingStyleEnum.Cube;  					break;  			}
Magic Number,fyiReporting.RDL,ThreeDPropertiesShading,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ThreeDPropertiesShading.cs,GetStyle,The following statement contains a magic number: switch (s)  			{		  				case "None":  					sh = ThreeDPropertiesShadingEnum.None;  					break;  				case "Simple":  					sh = ThreeDPropertiesShadingEnum.Simple;  					break;  				case "Real":  					sh = ThreeDPropertiesShadingEnum.Real;  					break;  				default:	  					rl.LogError(4' "Unknown Shading '" + s + "'.  None assumed.");  					sh = ThreeDPropertiesShadingEnum.None;  					break;  			}
Magic Number,fyiReporting.RDL,Title,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Title.cs,Title,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Caption":  						_Caption = new Expression(r' this' xNodeLoop' ExpressionType.String);  						break;  					case "Style":  						_Style = new Style(r' this' xNodeLoop);  						break;  					case "Position":  						_Position = TitlePosition.GetStyle(xNodeLoop.InnerText' OwnerReport.rl);  						break;  					default:  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown Title element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,TitlePosition,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\TitlePosition.cs,GetStyle,The following statement contains a magic number: switch (s)  			{		  				case "Center":  					rs = TitlePositionEnum.Center;  					break;  				case "Near":  					rs = TitlePositionEnum.Near;  					break;  				case "Far":  					rs = TitlePositionEnum.Far;  					break;  				default:	  					rl.LogError(4' "Unknown TitlePosition '" + s + "'.  Center assumed.");  					rs = TitlePositionEnum.Center;  					break;  			}
Magic Number,fyiReporting.RDL,ToggleImage,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ToggleImage.cs,ToggleImage,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "InitialState":  						_InitialState = new Expression(r' this' xNodeLoop' ExpressionType.Boolean);  						break;  					default:  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown ToggleImage element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,ToggleImage,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ToggleImage.cs,ToggleImage,The following statement contains a magic number: if (_InitialState == null)  				OwnerReport.rl.LogError(8' "ToggleImage requires the InitialState element.");
Magic Number,fyiReporting.RDL,TrueFalseAuto,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\TrueFalseAuto.cs,GetStyle,The following statement contains a magic number: switch (s)  			{		  				case "True":  					rs = TrueFalseAutoEnum.True;  					break;  				case "False":  					rs = TrueFalseAutoEnum.False;  					break;  				case "Auto":  					rs = TrueFalseAutoEnum.Auto;  					break;  				default:		  					rl.LogError(4' "Unknown True False Auto value of '" + s + "'.  Auto assumed.");  					rs = TrueFalseAutoEnum.Auto;  					break;  			}
Magic Number,fyiReporting.RDL,ValidValues,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ValidValues.cs,ValidValues,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "DataSetReference":  						_DataSetReference = new DataSetReference(r' this' xNodeLoop);  						break;  					case "ParameterValues":  						_ParameterValues = new ParameterValues(r' this' xNodeLoop);  						break;  					default:  						OwnerReport.rl.LogError(4' "Unknown ValidValues element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,ValidValues,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ValidValues.cs,ValidValues,The following statement contains a magic number: if (_DataSetReference == null)  			{  				if (_ParameterValues == null)				  				{  					OwnerReport.rl.LogError(8' "For ValidValues element either DataSetReference or ParameterValue must be specified' but not both.");  				}  			}  			else if (_ParameterValues != null)  			{  				OwnerReport.rl.LogError(8' "For ValidValues element either DataSetReference or ParameterValue must be specified' but not both.");  			}
Magic Number,fyiReporting.RDL,ValidValues,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ValidValues.cs,ValidValues,The following statement contains a magic number: if (_DataSetReference == null)  			{  				if (_ParameterValues == null)				  				{  					OwnerReport.rl.LogError(8' "For ValidValues element either DataSetReference or ParameterValue must be specified' but not both.");  				}  			}  			else if (_ParameterValues != null)  			{  				OwnerReport.rl.LogError(8' "For ValidValues element either DataSetReference or ParameterValue must be specified' but not both.");  			}
Magic Number,fyiReporting.RDL,ValidValues,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ValidValues.cs,DisplayValues,The following statement contains a magic number: lock (this)  			{  				string[] dsplValues = rpt.Cache.Get(this' "displayvalues") as string[];  				object[] dataValues;    				if (dsplValues != null)  					return dsplValues;    				if (_DataSetReference != null)  					_DataSetReference.SupplyValues(rpt' out dsplValues' out dataValues);  				else  					_ParameterValues.SupplyValues(rpt' out dsplValues' out dataValues);                    if (dataValues == null)                      dataValues = new object[0];                  if (dsplValues == null)                      dsplValues = new string[0];    				// there shouldn't be a problem; but if there is it doesn't matter as values can be recreated  				try {rpt.Cache.Add(this' "datavalues"' dataValues);}   				catch (Exception e1)  				{  					rpt.rl.LogError(4' "Error caching data values.  " + e1.Message);  				}  				try {rpt.Cache.Add(this' "displayvalues"' dsplValues);}   				catch (Exception e2)  				{  					rpt.rl.LogError(4' "Error caching display values.  " + e2.Message);  				}    				return dsplValues;  			}
Magic Number,fyiReporting.RDL,ValidValues,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ValidValues.cs,DisplayValues,The following statement contains a magic number: lock (this)  			{  				string[] dsplValues = rpt.Cache.Get(this' "displayvalues") as string[];  				object[] dataValues;    				if (dsplValues != null)  					return dsplValues;    				if (_DataSetReference != null)  					_DataSetReference.SupplyValues(rpt' out dsplValues' out dataValues);  				else  					_ParameterValues.SupplyValues(rpt' out dsplValues' out dataValues);                    if (dataValues == null)                      dataValues = new object[0];                  if (dsplValues == null)                      dsplValues = new string[0];    				// there shouldn't be a problem; but if there is it doesn't matter as values can be recreated  				try {rpt.Cache.Add(this' "datavalues"' dataValues);}   				catch (Exception e1)  				{  					rpt.rl.LogError(4' "Error caching data values.  " + e1.Message);  				}  				try {rpt.Cache.Add(this' "displayvalues"' dsplValues);}   				catch (Exception e2)  				{  					rpt.rl.LogError(4' "Error caching display values.  " + e2.Message);  				}    				return dsplValues;  			}
Magic Number,fyiReporting.RDL,ValidValues,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ValidValues.cs,DataValues,The following statement contains a magic number: lock (this)  			{  				string[] dsplValues;  				object[] dataValues = rpt.Cache.Get(this' "datavalues") as object[];    				if (dataValues != null)  					return dataValues;    				if (_DataSetReference != null)  					_DataSetReference.SupplyValues(rpt' out dsplValues' out dataValues);  				else  					_ParameterValues.SupplyValues(rpt' out dsplValues' out dataValues);                    if (dataValues == null)                      dataValues = new object[0];                  if (dsplValues == null)                      dsplValues = new string[0];    				// there shouldn't be a problem; but if there is it doesn't matter as values can be recreated  				try {rpt.Cache.Add(this' "datavalues"' dataValues);}   				catch (Exception e1)  				{  					rpt.rl.LogError(4' "Error caching data values.  " + e1.Message);  				}  				try {rpt.Cache.Add(this' "displayvalues"' dsplValues);}   				catch (Exception e2)  				{  					rpt.rl.LogError(4' "Error caching display values.  " + e2.Message);  				}  				return dataValues;  			}
Magic Number,fyiReporting.RDL,ValidValues,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ValidValues.cs,DataValues,The following statement contains a magic number: lock (this)  			{  				string[] dsplValues;  				object[] dataValues = rpt.Cache.Get(this' "datavalues") as object[];    				if (dataValues != null)  					return dataValues;    				if (_DataSetReference != null)  					_DataSetReference.SupplyValues(rpt' out dsplValues' out dataValues);  				else  					_ParameterValues.SupplyValues(rpt' out dsplValues' out dataValues);                    if (dataValues == null)                      dataValues = new object[0];                  if (dsplValues == null)                      dsplValues = new string[0];    				// there shouldn't be a problem; but if there is it doesn't matter as values can be recreated  				try {rpt.Cache.Add(this' "datavalues"' dataValues);}   				catch (Exception e1)  				{  					rpt.rl.LogError(4' "Error caching data values.  " + e1.Message);  				}  				try {rpt.Cache.Add(this' "displayvalues"' dsplValues);}   				catch (Exception e2)  				{  					rpt.rl.LogError(4' "Error caching display values.  " + e2.Message);  				}  				return dataValues;  			}
Magic Number,fyiReporting.RDL,ValueAxis,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ValueAxis.cs,ValueAxis,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Axis":  						_Axis = new Axis(r' this' xNodeLoop);  						break;  					default:	  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown ValueAxis element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,Values,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Values.cs,Values,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Value":  						v = new Expression(r' this' xNodeLoop' ExpressionType.Variant);  						break;  					default:	  						v=null;	  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown Value element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  				if (v != null)  					_Items.Add(v);  			}
Magic Number,fyiReporting.RDL,Visibility,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Visibility.cs,Visibility,The following statement contains a magic number: foreach(XmlNode xNodeLoop in xNode.ChildNodes)  			{  				if (xNodeLoop.NodeType != XmlNodeType.Element)  					continue;  				switch (xNodeLoop.Name)  				{  					case "Hidden":  						_Hidden = new Expression(r' this' xNodeLoop' ExpressionType.Boolean);  						break;  					case "ToggleItem":  						_ToggleItem = xNodeLoop.InnerText;  						break;  					default:	  						// don't know this element - log it  						OwnerReport.rl.LogError(4' "Unknown Visibility element '" + xNodeLoop.Name + "' ignored.");  						break;  				}  			}
Magic Number,fyiReporting.RDL,RenderExcel2003,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderExcel2003.cs,CopyRow,The following statement contains a magic number: for (int j = srcRow.FirstCellNum; j <= srcRow.LastCellNum; j++)              {                  XSSFCell oldCell = (XSSFCell)srcRow.GetCell(j); // ancienne cell                  HSSFCell newCell = (HSSFCell)destRow.GetCell(j); // new cell                  if (oldCell != null)                  {                      if (newCell == null)                      {                          newCell = (HSSFCell)destRow.CreateCell(j);                      }                      // copy chaque cell                      CopyCell(oldCell' newCell' styleMap' retVal);                      // copy les informations de fusion entre les cellules                      CellRangeAddress mergedRegion = GetMergedRegion(srcSheet' srcRow.RowNum'                              (short)oldCell.ColumnIndex);                        if (mergedRegion != null)                      {                          CellRangeAddress newMergedRegion = new CellRangeAddress(mergedRegion.FirstRow'                                  mergedRegion.LastRow' mergedRegion.FirstColumn' mergedRegion.LastColumn);                          if (IsNewMergedRegion(newMergedRegion' mergedRegions))                          {                              mergedRegions.Add(newMergedRegion);                              destSheet.AddMergedRegion(newMergedRegion);                          }                            if (newMergedRegion.FirstColumn == 0 && newMergedRegion.LastColumn == 6 && newMergedRegion.FirstRow == newMergedRegion.LastRow)                          {                              HSSFCellStyle style2 = (HSSFCellStyle)retVal.CreateCellStyle();                              style2.VerticalAlignment = VerticalAlignment.Center;                              style2.Alignment = HorizontalAlignment.Left;                              style2.FillForegroundColor = HSSFColor.Teal.Index;                              style2.FillPattern = FillPattern.SolidForeground;                                for (int i = destRow.FirstCellNum; i <= destRow.LastCellNum; i++)                              {                                  if (destRow.GetCell(i) != null)                                      destRow.GetCell(i).CellStyle = style2;                              }                          }                      }                  }              }
Magic Number,fyiReporting.RDL,RenderPdf_iTextSharp,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf_iTextSharp.cs,AddLine,The following statement contains a magic number: switch (ls)              {                  case BorderStyleEnum.Dashed:                      _contentByte.SetLineDash(new float[] { width * 3' width }' 0);                      break;                  case BorderStyleEnum.Dotted:                      _contentByte.SetLineDash(new float[] { width }' 0);                      break;                  case BorderStyleEnum.Solid:                  default:                      _contentByte.SetLineDash(new float[] { }' 0);                      break;              }
Magic Number,fyiReporting.RDL,RenderPdf_iTextSharp,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf_iTextSharp.cs,AddCurve,The following statement contains a magic number: if (pts.Length > 2)              {   // do a spline curve                  PointF[] tangents = iGetCurveTangents(pts);                  iDoCurve(pts' tangents' si);              }              else              {   // we only have two points; just do a line segment                  AddLine(pts[0].X' pts[0].Y' pts[1].X' pts[1].Y' si);              }
Magic Number,fyiReporting.RDL,RenderPdf_iTextSharp,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf_iTextSharp.cs,AddText,The following statement contains a magic number: for (int i = 0; i < sa.Length; i++)              {                  string text = sa[i];                  float textwidth = tw[i];                  // Calculate the x positino                  float startX = x + si.PaddingLeft;						// TODO: handle tb_rl                  float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl                  int align = 0;                  if (si.WritingMode == WritingModeEnum.lr_tb)                  {	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now                      switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (width > 0)                              {                                  startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                                  align = Element.ALIGN_CENTER;                              }                              break;                          case TextAlignEnum.Right:                              if (width > 0)                              {                                  startX = x + width - textwidth - si.PaddingRight;                                  align = Element.ALIGN_RIGHT;                              }                              break;                          case TextAlignEnum.Left:                          default:                              align = Element.ALIGN_LEFT;                              break;                      }                        // Calculate the y position                      switch (si.VerticalAlign)                      {                          case VerticalAlignEnum.Middle:                              if (height <= 0)                                  break;                                // calculate the middle of the region                              startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom) / 2 - si.FontSize / 2;                              // now go up or down depending on which line                              if (sa.Length == 1)                                  break;                              if (sa.Length % 2 == 0)	// even number                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize) + si.FontSize / 2;                              }                              else                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize);                              }                              break;                          case VerticalAlignEnum.Bottom:                              if (height <= 0)                                  break;                                startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length - i));                              break;                          case VerticalAlignEnum.Top:                          default:                              break;                      }                  }                  else                  {                      //25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                        switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                    }                    // Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)                  if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)                  {	// background color' height and width are specified                      iAddFillRect(x' y' width' height' si.BackgroundColor);                  }                    // Set the clipping path' (Itext have no clip)                  if (height > 0 && width > 0)                  {                      _contentByte.SetRGBColorFill(si.Color.R' si.Color.G' si.Color.B);                        if (si.WritingMode == WritingModeEnum.lr_tb)                      {                          //If textline after measure with word break can fit just simple show Text                          if (width >= textwidth)                          {                              _contentByte.BeginText();                              _contentByte.SetFontAndSize(bf' si.FontSize);                              _contentByte.SetTextMatrix(startX' (PageSize.yHeight - startY - si.FontSize));                              _contentByte.ShowText(text);                              _contentByte.EndText();                          }                          else                          {                              //else use Column text to wrap or clip (wrap: for example a text like an URL so word break is not working here' itextsharp ColumnText do the work for us)                              ColumnText ct = new ColumnText(_contentByte);                              Phrase myPhrase = new Phrase(text' new iTextSharp.text.Font(bf' si.FontSize));                              ct.SetSimpleColumn(myPhrase' x + si.PaddingLeft' PageSize.yHeight - startY' x + width - si.PaddingRight' PageSize.yHeight - y - si.PaddingBottom - height' 10f' align);                              ct.Go();                          }                      }                      else                      {                          //Not checked                          double rads = -283.0 / 180.0;                          double radsCos = Math.Cos(rads);                          double radsSin = Math.Sin(rads);                          _contentByte.BeginText();                          _contentByte.SetFontAndSize(bf' si.FontSize);                          _contentByte.SetTextMatrix((float)radsCos' (float)radsSin' (float)-radsSin' (float)radsCos' startX' PageSize.yHeight - startY);                          _contentByte.ShowText(text);                          _contentByte.EndText();                      }                        //add URL                      if (url != null)                          _pdfDocument.Add(new Annotation(x' PageSize.yHeight - (y + height)' width + x' PageSize.yHeight - y' url));                      //add tooltip                      if (tooltip != null)                          _pdfDocument.Add(new Annotation(x' PageSize.yHeight - (y + height)' width + x' PageSize.yHeight - y' tooltip));                    }                    // Handle underlining etc.                  float maxX;                  switch (si.TextDecoration)                  {                      case TextDecorationEnum.Underline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + si.FontSize + 1' maxX' startY + si.FontSize + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.LineThrough:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + (si.FontSize / 2) + 1' maxX' startY + (si.FontSize / 2) + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.Overline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + 1' maxX' startY + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.None:                      default:                          break;                  }              }
Magic Number,fyiReporting.RDL,RenderPdf_iTextSharp,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf_iTextSharp.cs,AddText,The following statement contains a magic number: for (int i = 0; i < sa.Length; i++)              {                  string text = sa[i];                  float textwidth = tw[i];                  // Calculate the x positino                  float startX = x + si.PaddingLeft;						// TODO: handle tb_rl                  float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl                  int align = 0;                  if (si.WritingMode == WritingModeEnum.lr_tb)                  {	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now                      switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (width > 0)                              {                                  startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                                  align = Element.ALIGN_CENTER;                              }                              break;                          case TextAlignEnum.Right:                              if (width > 0)                              {                                  startX = x + width - textwidth - si.PaddingRight;                                  align = Element.ALIGN_RIGHT;                              }                              break;                          case TextAlignEnum.Left:                          default:                              align = Element.ALIGN_LEFT;                              break;                      }                        // Calculate the y position                      switch (si.VerticalAlign)                      {                          case VerticalAlignEnum.Middle:                              if (height <= 0)                                  break;                                // calculate the middle of the region                              startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom) / 2 - si.FontSize / 2;                              // now go up or down depending on which line                              if (sa.Length == 1)                                  break;                              if (sa.Length % 2 == 0)	// even number                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize) + si.FontSize / 2;                              }                              else                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize);                              }                              break;                          case VerticalAlignEnum.Bottom:                              if (height <= 0)                                  break;                                startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length - i));                              break;                          case VerticalAlignEnum.Top:                          default:                              break;                      }                  }                  else                  {                      //25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                        switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                    }                    // Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)                  if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)                  {	// background color' height and width are specified                      iAddFillRect(x' y' width' height' si.BackgroundColor);                  }                    // Set the clipping path' (Itext have no clip)                  if (height > 0 && width > 0)                  {                      _contentByte.SetRGBColorFill(si.Color.R' si.Color.G' si.Color.B);                        if (si.WritingMode == WritingModeEnum.lr_tb)                      {                          //If textline after measure with word break can fit just simple show Text                          if (width >= textwidth)                          {                              _contentByte.BeginText();                              _contentByte.SetFontAndSize(bf' si.FontSize);                              _contentByte.SetTextMatrix(startX' (PageSize.yHeight - startY - si.FontSize));                              _contentByte.ShowText(text);                              _contentByte.EndText();                          }                          else                          {                              //else use Column text to wrap or clip (wrap: for example a text like an URL so word break is not working here' itextsharp ColumnText do the work for us)                              ColumnText ct = new ColumnText(_contentByte);                              Phrase myPhrase = new Phrase(text' new iTextSharp.text.Font(bf' si.FontSize));                              ct.SetSimpleColumn(myPhrase' x + si.PaddingLeft' PageSize.yHeight - startY' x + width - si.PaddingRight' PageSize.yHeight - y - si.PaddingBottom - height' 10f' align);                              ct.Go();                          }                      }                      else                      {                          //Not checked                          double rads = -283.0 / 180.0;                          double radsCos = Math.Cos(rads);                          double radsSin = Math.Sin(rads);                          _contentByte.BeginText();                          _contentByte.SetFontAndSize(bf' si.FontSize);                          _contentByte.SetTextMatrix((float)radsCos' (float)radsSin' (float)-radsSin' (float)radsCos' startX' PageSize.yHeight - startY);                          _contentByte.ShowText(text);                          _contentByte.EndText();                      }                        //add URL                      if (url != null)                          _pdfDocument.Add(new Annotation(x' PageSize.yHeight - (y + height)' width + x' PageSize.yHeight - y' url));                      //add tooltip                      if (tooltip != null)                          _pdfDocument.Add(new Annotation(x' PageSize.yHeight - (y + height)' width + x' PageSize.yHeight - y' tooltip));                    }                    // Handle underlining etc.                  float maxX;                  switch (si.TextDecoration)                  {                      case TextDecorationEnum.Underline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + si.FontSize + 1' maxX' startY + si.FontSize + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.LineThrough:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + (si.FontSize / 2) + 1' maxX' startY + (si.FontSize / 2) + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.Overline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + 1' maxX' startY + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.None:                      default:                          break;                  }              }
Magic Number,fyiReporting.RDL,RenderPdf_iTextSharp,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf_iTextSharp.cs,AddText,The following statement contains a magic number: for (int i = 0; i < sa.Length; i++)              {                  string text = sa[i];                  float textwidth = tw[i];                  // Calculate the x positino                  float startX = x + si.PaddingLeft;						// TODO: handle tb_rl                  float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl                  int align = 0;                  if (si.WritingMode == WritingModeEnum.lr_tb)                  {	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now                      switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (width > 0)                              {                                  startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                                  align = Element.ALIGN_CENTER;                              }                              break;                          case TextAlignEnum.Right:                              if (width > 0)                              {                                  startX = x + width - textwidth - si.PaddingRight;                                  align = Element.ALIGN_RIGHT;                              }                              break;                          case TextAlignEnum.Left:                          default:                              align = Element.ALIGN_LEFT;                              break;                      }                        // Calculate the y position                      switch (si.VerticalAlign)                      {                          case VerticalAlignEnum.Middle:                              if (height <= 0)                                  break;                                // calculate the middle of the region                              startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom) / 2 - si.FontSize / 2;                              // now go up or down depending on which line                              if (sa.Length == 1)                                  break;                              if (sa.Length % 2 == 0)	// even number                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize) + si.FontSize / 2;                              }                              else                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize);                              }                              break;                          case VerticalAlignEnum.Bottom:                              if (height <= 0)                                  break;                                startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length - i));                              break;                          case VerticalAlignEnum.Top:                          default:                              break;                      }                  }                  else                  {                      //25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                        switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                    }                    // Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)                  if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)                  {	// background color' height and width are specified                      iAddFillRect(x' y' width' height' si.BackgroundColor);                  }                    // Set the clipping path' (Itext have no clip)                  if (height > 0 && width > 0)                  {                      _contentByte.SetRGBColorFill(si.Color.R' si.Color.G' si.Color.B);                        if (si.WritingMode == WritingModeEnum.lr_tb)                      {                          //If textline after measure with word break can fit just simple show Text                          if (width >= textwidth)                          {                              _contentByte.BeginText();                              _contentByte.SetFontAndSize(bf' si.FontSize);                              _contentByte.SetTextMatrix(startX' (PageSize.yHeight - startY - si.FontSize));                              _contentByte.ShowText(text);                              _contentByte.EndText();                          }                          else                          {                              //else use Column text to wrap or clip (wrap: for example a text like an URL so word break is not working here' itextsharp ColumnText do the work for us)                              ColumnText ct = new ColumnText(_contentByte);                              Phrase myPhrase = new Phrase(text' new iTextSharp.text.Font(bf' si.FontSize));                              ct.SetSimpleColumn(myPhrase' x + si.PaddingLeft' PageSize.yHeight - startY' x + width - si.PaddingRight' PageSize.yHeight - y - si.PaddingBottom - height' 10f' align);                              ct.Go();                          }                      }                      else                      {                          //Not checked                          double rads = -283.0 / 180.0;                          double radsCos = Math.Cos(rads);                          double radsSin = Math.Sin(rads);                          _contentByte.BeginText();                          _contentByte.SetFontAndSize(bf' si.FontSize);                          _contentByte.SetTextMatrix((float)radsCos' (float)radsSin' (float)-radsSin' (float)radsCos' startX' PageSize.yHeight - startY);                          _contentByte.ShowText(text);                          _contentByte.EndText();                      }                        //add URL                      if (url != null)                          _pdfDocument.Add(new Annotation(x' PageSize.yHeight - (y + height)' width + x' PageSize.yHeight - y' url));                      //add tooltip                      if (tooltip != null)                          _pdfDocument.Add(new Annotation(x' PageSize.yHeight - (y + height)' width + x' PageSize.yHeight - y' tooltip));                    }                    // Handle underlining etc.                  float maxX;                  switch (si.TextDecoration)                  {                      case TextDecorationEnum.Underline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + si.FontSize + 1' maxX' startY + si.FontSize + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.LineThrough:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + (si.FontSize / 2) + 1' maxX' startY + (si.FontSize / 2) + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.Overline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + 1' maxX' startY + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.None:                      default:                          break;                  }              }
Magic Number,fyiReporting.RDL,RenderPdf_iTextSharp,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf_iTextSharp.cs,AddText,The following statement contains a magic number: for (int i = 0; i < sa.Length; i++)              {                  string text = sa[i];                  float textwidth = tw[i];                  // Calculate the x positino                  float startX = x + si.PaddingLeft;						// TODO: handle tb_rl                  float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl                  int align = 0;                  if (si.WritingMode == WritingModeEnum.lr_tb)                  {	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now                      switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (width > 0)                              {                                  startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                                  align = Element.ALIGN_CENTER;                              }                              break;                          case TextAlignEnum.Right:                              if (width > 0)                              {                                  startX = x + width - textwidth - si.PaddingRight;                                  align = Element.ALIGN_RIGHT;                              }                              break;                          case TextAlignEnum.Left:                          default:                              align = Element.ALIGN_LEFT;                              break;                      }                        // Calculate the y position                      switch (si.VerticalAlign)                      {                          case VerticalAlignEnum.Middle:                              if (height <= 0)                                  break;                                // calculate the middle of the region                              startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom) / 2 - si.FontSize / 2;                              // now go up or down depending on which line                              if (sa.Length == 1)                                  break;                              if (sa.Length % 2 == 0)	// even number                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize) + si.FontSize / 2;                              }                              else                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize);                              }                              break;                          case VerticalAlignEnum.Bottom:                              if (height <= 0)                                  break;                                startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length - i));                              break;                          case VerticalAlignEnum.Top:                          default:                              break;                      }                  }                  else                  {                      //25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                        switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                    }                    // Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)                  if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)                  {	// background color' height and width are specified                      iAddFillRect(x' y' width' height' si.BackgroundColor);                  }                    // Set the clipping path' (Itext have no clip)                  if (height > 0 && width > 0)                  {                      _contentByte.SetRGBColorFill(si.Color.R' si.Color.G' si.Color.B);                        if (si.WritingMode == WritingModeEnum.lr_tb)                      {                          //If textline after measure with word break can fit just simple show Text                          if (width >= textwidth)                          {                              _contentByte.BeginText();                              _contentByte.SetFontAndSize(bf' si.FontSize);                              _contentByte.SetTextMatrix(startX' (PageSize.yHeight - startY - si.FontSize));                              _contentByte.ShowText(text);                              _contentByte.EndText();                          }                          else                          {                              //else use Column text to wrap or clip (wrap: for example a text like an URL so word break is not working here' itextsharp ColumnText do the work for us)                              ColumnText ct = new ColumnText(_contentByte);                              Phrase myPhrase = new Phrase(text' new iTextSharp.text.Font(bf' si.FontSize));                              ct.SetSimpleColumn(myPhrase' x + si.PaddingLeft' PageSize.yHeight - startY' x + width - si.PaddingRight' PageSize.yHeight - y - si.PaddingBottom - height' 10f' align);                              ct.Go();                          }                      }                      else                      {                          //Not checked                          double rads = -283.0 / 180.0;                          double radsCos = Math.Cos(rads);                          double radsSin = Math.Sin(rads);                          _contentByte.BeginText();                          _contentByte.SetFontAndSize(bf' si.FontSize);                          _contentByte.SetTextMatrix((float)radsCos' (float)radsSin' (float)-radsSin' (float)radsCos' startX' PageSize.yHeight - startY);                          _contentByte.ShowText(text);                          _contentByte.EndText();                      }                        //add URL                      if (url != null)                          _pdfDocument.Add(new Annotation(x' PageSize.yHeight - (y + height)' width + x' PageSize.yHeight - y' url));                      //add tooltip                      if (tooltip != null)                          _pdfDocument.Add(new Annotation(x' PageSize.yHeight - (y + height)' width + x' PageSize.yHeight - y' tooltip));                    }                    // Handle underlining etc.                  float maxX;                  switch (si.TextDecoration)                  {                      case TextDecorationEnum.Underline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + si.FontSize + 1' maxX' startY + si.FontSize + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.LineThrough:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + (si.FontSize / 2) + 1' maxX' startY + (si.FontSize / 2) + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.Overline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + 1' maxX' startY + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.None:                      default:                          break;                  }              }
Magic Number,fyiReporting.RDL,RenderPdf_iTextSharp,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf_iTextSharp.cs,AddText,The following statement contains a magic number: for (int i = 0; i < sa.Length; i++)              {                  string text = sa[i];                  float textwidth = tw[i];                  // Calculate the x positino                  float startX = x + si.PaddingLeft;						// TODO: handle tb_rl                  float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl                  int align = 0;                  if (si.WritingMode == WritingModeEnum.lr_tb)                  {	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now                      switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (width > 0)                              {                                  startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                                  align = Element.ALIGN_CENTER;                              }                              break;                          case TextAlignEnum.Right:                              if (width > 0)                              {                                  startX = x + width - textwidth - si.PaddingRight;                                  align = Element.ALIGN_RIGHT;                              }                              break;                          case TextAlignEnum.Left:                          default:                              align = Element.ALIGN_LEFT;                              break;                      }                        // Calculate the y position                      switch (si.VerticalAlign)                      {                          case VerticalAlignEnum.Middle:                              if (height <= 0)                                  break;                                // calculate the middle of the region                              startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom) / 2 - si.FontSize / 2;                              // now go up or down depending on which line                              if (sa.Length == 1)                                  break;                              if (sa.Length % 2 == 0)	// even number                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize) + si.FontSize / 2;                              }                              else                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize);                              }                              break;                          case VerticalAlignEnum.Bottom:                              if (height <= 0)                                  break;                                startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length - i));                              break;                          case VerticalAlignEnum.Top:                          default:                              break;                      }                  }                  else                  {                      //25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                        switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                    }                    // Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)                  if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)                  {	// background color' height and width are specified                      iAddFillRect(x' y' width' height' si.BackgroundColor);                  }                    // Set the clipping path' (Itext have no clip)                  if (height > 0 && width > 0)                  {                      _contentByte.SetRGBColorFill(si.Color.R' si.Color.G' si.Color.B);                        if (si.WritingMode == WritingModeEnum.lr_tb)                      {                          //If textline after measure with word break can fit just simple show Text                          if (width >= textwidth)                          {                              _contentByte.BeginText();                              _contentByte.SetFontAndSize(bf' si.FontSize);                              _contentByte.SetTextMatrix(startX' (PageSize.yHeight - startY - si.FontSize));                              _contentByte.ShowText(text);                              _contentByte.EndText();                          }                          else                          {                              //else use Column text to wrap or clip (wrap: for example a text like an URL so word break is not working here' itextsharp ColumnText do the work for us)                              ColumnText ct = new ColumnText(_contentByte);                              Phrase myPhrase = new Phrase(text' new iTextSharp.text.Font(bf' si.FontSize));                              ct.SetSimpleColumn(myPhrase' x + si.PaddingLeft' PageSize.yHeight - startY' x + width - si.PaddingRight' PageSize.yHeight - y - si.PaddingBottom - height' 10f' align);                              ct.Go();                          }                      }                      else                      {                          //Not checked                          double rads = -283.0 / 180.0;                          double radsCos = Math.Cos(rads);                          double radsSin = Math.Sin(rads);                          _contentByte.BeginText();                          _contentByte.SetFontAndSize(bf' si.FontSize);                          _contentByte.SetTextMatrix((float)radsCos' (float)radsSin' (float)-radsSin' (float)radsCos' startX' PageSize.yHeight - startY);                          _contentByte.ShowText(text);                          _contentByte.EndText();                      }                        //add URL                      if (url != null)                          _pdfDocument.Add(new Annotation(x' PageSize.yHeight - (y + height)' width + x' PageSize.yHeight - y' url));                      //add tooltip                      if (tooltip != null)                          _pdfDocument.Add(new Annotation(x' PageSize.yHeight - (y + height)' width + x' PageSize.yHeight - y' tooltip));                    }                    // Handle underlining etc.                  float maxX;                  switch (si.TextDecoration)                  {                      case TextDecorationEnum.Underline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + si.FontSize + 1' maxX' startY + si.FontSize + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.LineThrough:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + (si.FontSize / 2) + 1' maxX' startY + (si.FontSize / 2) + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.Overline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + 1' maxX' startY + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.None:                      default:                          break;                  }              }
Magic Number,fyiReporting.RDL,RenderPdf_iTextSharp,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf_iTextSharp.cs,AddText,The following statement contains a magic number: for (int i = 0; i < sa.Length; i++)              {                  string text = sa[i];                  float textwidth = tw[i];                  // Calculate the x positino                  float startX = x + si.PaddingLeft;						// TODO: handle tb_rl                  float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl                  int align = 0;                  if (si.WritingMode == WritingModeEnum.lr_tb)                  {	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now                      switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (width > 0)                              {                                  startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                                  align = Element.ALIGN_CENTER;                              }                              break;                          case TextAlignEnum.Right:                              if (width > 0)                              {                                  startX = x + width - textwidth - si.PaddingRight;                                  align = Element.ALIGN_RIGHT;                              }                              break;                          case TextAlignEnum.Left:                          default:                              align = Element.ALIGN_LEFT;                              break;                      }                        // Calculate the y position                      switch (si.VerticalAlign)                      {                          case VerticalAlignEnum.Middle:                              if (height <= 0)                                  break;                                // calculate the middle of the region                              startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom) / 2 - si.FontSize / 2;                              // now go up or down depending on which line                              if (sa.Length == 1)                                  break;                              if (sa.Length % 2 == 0)	// even number                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize) + si.FontSize / 2;                              }                              else                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize);                              }                              break;                          case VerticalAlignEnum.Bottom:                              if (height <= 0)                                  break;                                startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length - i));                              break;                          case VerticalAlignEnum.Top:                          default:                              break;                      }                  }                  else                  {                      //25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                        switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                    }                    // Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)                  if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)                  {	// background color' height and width are specified                      iAddFillRect(x' y' width' height' si.BackgroundColor);                  }                    // Set the clipping path' (Itext have no clip)                  if (height > 0 && width > 0)                  {                      _contentByte.SetRGBColorFill(si.Color.R' si.Color.G' si.Color.B);                        if (si.WritingMode == WritingModeEnum.lr_tb)                      {                          //If textline after measure with word break can fit just simple show Text                          if (width >= textwidth)                          {                              _contentByte.BeginText();                              _contentByte.SetFontAndSize(bf' si.FontSize);                              _contentByte.SetTextMatrix(startX' (PageSize.yHeight - startY - si.FontSize));                              _contentByte.ShowText(text);                              _contentByte.EndText();                          }                          else                          {                              //else use Column text to wrap or clip (wrap: for example a text like an URL so word break is not working here' itextsharp ColumnText do the work for us)                              ColumnText ct = new ColumnText(_contentByte);                              Phrase myPhrase = new Phrase(text' new iTextSharp.text.Font(bf' si.FontSize));                              ct.SetSimpleColumn(myPhrase' x + si.PaddingLeft' PageSize.yHeight - startY' x + width - si.PaddingRight' PageSize.yHeight - y - si.PaddingBottom - height' 10f' align);                              ct.Go();                          }                      }                      else                      {                          //Not checked                          double rads = -283.0 / 180.0;                          double radsCos = Math.Cos(rads);                          double radsSin = Math.Sin(rads);                          _contentByte.BeginText();                          _contentByte.SetFontAndSize(bf' si.FontSize);                          _contentByte.SetTextMatrix((float)radsCos' (float)radsSin' (float)-radsSin' (float)radsCos' startX' PageSize.yHeight - startY);                          _contentByte.ShowText(text);                          _contentByte.EndText();                      }                        //add URL                      if (url != null)                          _pdfDocument.Add(new Annotation(x' PageSize.yHeight - (y + height)' width + x' PageSize.yHeight - y' url));                      //add tooltip                      if (tooltip != null)                          _pdfDocument.Add(new Annotation(x' PageSize.yHeight - (y + height)' width + x' PageSize.yHeight - y' tooltip));                    }                    // Handle underlining etc.                  float maxX;                  switch (si.TextDecoration)                  {                      case TextDecorationEnum.Underline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + si.FontSize + 1' maxX' startY + si.FontSize + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.LineThrough:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + (si.FontSize / 2) + 1' maxX' startY + (si.FontSize / 2) + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.Overline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + 1' maxX' startY + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.None:                      default:                          break;                  }              }
Magic Number,fyiReporting.RDL,RenderPdf_iTextSharp,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf_iTextSharp.cs,AddText,The following statement contains a magic number: for (int i = 0; i < sa.Length; i++)              {                  string text = sa[i];                  float textwidth = tw[i];                  // Calculate the x positino                  float startX = x + si.PaddingLeft;						// TODO: handle tb_rl                  float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl                  int align = 0;                  if (si.WritingMode == WritingModeEnum.lr_tb)                  {	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now                      switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (width > 0)                              {                                  startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                                  align = Element.ALIGN_CENTER;                              }                              break;                          case TextAlignEnum.Right:                              if (width > 0)                              {                                  startX = x + width - textwidth - si.PaddingRight;                                  align = Element.ALIGN_RIGHT;                              }                              break;                          case TextAlignEnum.Left:                          default:                              align = Element.ALIGN_LEFT;                              break;                      }                        // Calculate the y position                      switch (si.VerticalAlign)                      {                          case VerticalAlignEnum.Middle:                              if (height <= 0)                                  break;                                // calculate the middle of the region                              startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom) / 2 - si.FontSize / 2;                              // now go up or down depending on which line                              if (sa.Length == 1)                                  break;                              if (sa.Length % 2 == 0)	// even number                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize) + si.FontSize / 2;                              }                              else                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize);                              }                              break;                          case VerticalAlignEnum.Bottom:                              if (height <= 0)                                  break;                                startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length - i));                              break;                          case VerticalAlignEnum.Top:                          default:                              break;                      }                  }                  else                  {                      //25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                        switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                    }                    // Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)                  if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)                  {	// background color' height and width are specified                      iAddFillRect(x' y' width' height' si.BackgroundColor);                  }                    // Set the clipping path' (Itext have no clip)                  if (height > 0 && width > 0)                  {                      _contentByte.SetRGBColorFill(si.Color.R' si.Color.G' si.Color.B);                        if (si.WritingMode == WritingModeEnum.lr_tb)                      {                          //If textline after measure with word break can fit just simple show Text                          if (width >= textwidth)                          {                              _contentByte.BeginText();                              _contentByte.SetFontAndSize(bf' si.FontSize);                              _contentByte.SetTextMatrix(startX' (PageSize.yHeight - startY - si.FontSize));                              _contentByte.ShowText(text);                              _contentByte.EndText();                          }                          else                          {                              //else use Column text to wrap or clip (wrap: for example a text like an URL so word break is not working here' itextsharp ColumnText do the work for us)                              ColumnText ct = new ColumnText(_contentByte);                              Phrase myPhrase = new Phrase(text' new iTextSharp.text.Font(bf' si.FontSize));                              ct.SetSimpleColumn(myPhrase' x + si.PaddingLeft' PageSize.yHeight - startY' x + width - si.PaddingRight' PageSize.yHeight - y - si.PaddingBottom - height' 10f' align);                              ct.Go();                          }                      }                      else                      {                          //Not checked                          double rads = -283.0 / 180.0;                          double radsCos = Math.Cos(rads);                          double radsSin = Math.Sin(rads);                          _contentByte.BeginText();                          _contentByte.SetFontAndSize(bf' si.FontSize);                          _contentByte.SetTextMatrix((float)radsCos' (float)radsSin' (float)-radsSin' (float)radsCos' startX' PageSize.yHeight - startY);                          _contentByte.ShowText(text);                          _contentByte.EndText();                      }                        //add URL                      if (url != null)                          _pdfDocument.Add(new Annotation(x' PageSize.yHeight - (y + height)' width + x' PageSize.yHeight - y' url));                      //add tooltip                      if (tooltip != null)                          _pdfDocument.Add(new Annotation(x' PageSize.yHeight - (y + height)' width + x' PageSize.yHeight - y' tooltip));                    }                    // Handle underlining etc.                  float maxX;                  switch (si.TextDecoration)                  {                      case TextDecorationEnum.Underline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + si.FontSize + 1' maxX' startY + si.FontSize + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.LineThrough:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + (si.FontSize / 2) + 1' maxX' startY + (si.FontSize / 2) + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.Overline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + 1' maxX' startY + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.None:                      default:                          break;                  }              }
Magic Number,fyiReporting.RDL,RenderPdf_iTextSharp,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf_iTextSharp.cs,AddText,The following statement contains a magic number: for (int i = 0; i < sa.Length; i++)              {                  string text = sa[i];                  float textwidth = tw[i];                  // Calculate the x positino                  float startX = x + si.PaddingLeft;						// TODO: handle tb_rl                  float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl                  int align = 0;                  if (si.WritingMode == WritingModeEnum.lr_tb)                  {	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now                      switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (width > 0)                              {                                  startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                                  align = Element.ALIGN_CENTER;                              }                              break;                          case TextAlignEnum.Right:                              if (width > 0)                              {                                  startX = x + width - textwidth - si.PaddingRight;                                  align = Element.ALIGN_RIGHT;                              }                              break;                          case TextAlignEnum.Left:                          default:                              align = Element.ALIGN_LEFT;                              break;                      }                        // Calculate the y position                      switch (si.VerticalAlign)                      {                          case VerticalAlignEnum.Middle:                              if (height <= 0)                                  break;                                // calculate the middle of the region                              startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom) / 2 - si.FontSize / 2;                              // now go up or down depending on which line                              if (sa.Length == 1)                                  break;                              if (sa.Length % 2 == 0)	// even number                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize) + si.FontSize / 2;                              }                              else                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize);                              }                              break;                          case VerticalAlignEnum.Bottom:                              if (height <= 0)                                  break;                                startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length - i));                              break;                          case VerticalAlignEnum.Top:                          default:                              break;                      }                  }                  else                  {                      //25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                        switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                    }                    // Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)                  if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)                  {	// background color' height and width are specified                      iAddFillRect(x' y' width' height' si.BackgroundColor);                  }                    // Set the clipping path' (Itext have no clip)                  if (height > 0 && width > 0)                  {                      _contentByte.SetRGBColorFill(si.Color.R' si.Color.G' si.Color.B);                        if (si.WritingMode == WritingModeEnum.lr_tb)                      {                          //If textline after measure with word break can fit just simple show Text                          if (width >= textwidth)                          {                              _contentByte.BeginText();                              _contentByte.SetFontAndSize(bf' si.FontSize);                              _contentByte.SetTextMatrix(startX' (PageSize.yHeight - startY - si.FontSize));                              _contentByte.ShowText(text);                              _contentByte.EndText();                          }                          else                          {                              //else use Column text to wrap or clip (wrap: for example a text like an URL so word break is not working here' itextsharp ColumnText do the work for us)                              ColumnText ct = new ColumnText(_contentByte);                              Phrase myPhrase = new Phrase(text' new iTextSharp.text.Font(bf' si.FontSize));                              ct.SetSimpleColumn(myPhrase' x + si.PaddingLeft' PageSize.yHeight - startY' x + width - si.PaddingRight' PageSize.yHeight - y - si.PaddingBottom - height' 10f' align);                              ct.Go();                          }                      }                      else                      {                          //Not checked                          double rads = -283.0 / 180.0;                          double radsCos = Math.Cos(rads);                          double radsSin = Math.Sin(rads);                          _contentByte.BeginText();                          _contentByte.SetFontAndSize(bf' si.FontSize);                          _contentByte.SetTextMatrix((float)radsCos' (float)radsSin' (float)-radsSin' (float)radsCos' startX' PageSize.yHeight - startY);                          _contentByte.ShowText(text);                          _contentByte.EndText();                      }                        //add URL                      if (url != null)                          _pdfDocument.Add(new Annotation(x' PageSize.yHeight - (y + height)' width + x' PageSize.yHeight - y' url));                      //add tooltip                      if (tooltip != null)                          _pdfDocument.Add(new Annotation(x' PageSize.yHeight - (y + height)' width + x' PageSize.yHeight - y' tooltip));                    }                    // Handle underlining etc.                  float maxX;                  switch (si.TextDecoration)                  {                      case TextDecorationEnum.Underline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + si.FontSize + 1' maxX' startY + si.FontSize + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.LineThrough:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + (si.FontSize / 2) + 1' maxX' startY + (si.FontSize / 2) + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.Overline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + 1' maxX' startY + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.None:                      default:                          break;                  }              }
Magic Number,fyiReporting.RDL,RenderPdf_iTextSharp,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf_iTextSharp.cs,AddText,The following statement contains a magic number: for (int i = 0; i < sa.Length; i++)              {                  string text = sa[i];                  float textwidth = tw[i];                  // Calculate the x positino                  float startX = x + si.PaddingLeft;						// TODO: handle tb_rl                  float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl                  int align = 0;                  if (si.WritingMode == WritingModeEnum.lr_tb)                  {	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now                      switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (width > 0)                              {                                  startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                                  align = Element.ALIGN_CENTER;                              }                              break;                          case TextAlignEnum.Right:                              if (width > 0)                              {                                  startX = x + width - textwidth - si.PaddingRight;                                  align = Element.ALIGN_RIGHT;                              }                              break;                          case TextAlignEnum.Left:                          default:                              align = Element.ALIGN_LEFT;                              break;                      }                        // Calculate the y position                      switch (si.VerticalAlign)                      {                          case VerticalAlignEnum.Middle:                              if (height <= 0)                                  break;                                // calculate the middle of the region                              startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom) / 2 - si.FontSize / 2;                              // now go up or down depending on which line                              if (sa.Length == 1)                                  break;                              if (sa.Length % 2 == 0)	// even number                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize) + si.FontSize / 2;                              }                              else                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize);                              }                              break;                          case VerticalAlignEnum.Bottom:                              if (height <= 0)                                  break;                                startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length - i));                              break;                          case VerticalAlignEnum.Top:                          default:                              break;                      }                  }                  else                  {                      //25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                        switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                    }                    // Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)                  if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)                  {	// background color' height and width are specified                      iAddFillRect(x' y' width' height' si.BackgroundColor);                  }                    // Set the clipping path' (Itext have no clip)                  if (height > 0 && width > 0)                  {                      _contentByte.SetRGBColorFill(si.Color.R' si.Color.G' si.Color.B);                        if (si.WritingMode == WritingModeEnum.lr_tb)                      {                          //If textline after measure with word break can fit just simple show Text                          if (width >= textwidth)                          {                              _contentByte.BeginText();                              _contentByte.SetFontAndSize(bf' si.FontSize);                              _contentByte.SetTextMatrix(startX' (PageSize.yHeight - startY - si.FontSize));                              _contentByte.ShowText(text);                              _contentByte.EndText();                          }                          else                          {                              //else use Column text to wrap or clip (wrap: for example a text like an URL so word break is not working here' itextsharp ColumnText do the work for us)                              ColumnText ct = new ColumnText(_contentByte);                              Phrase myPhrase = new Phrase(text' new iTextSharp.text.Font(bf' si.FontSize));                              ct.SetSimpleColumn(myPhrase' x + si.PaddingLeft' PageSize.yHeight - startY' x + width - si.PaddingRight' PageSize.yHeight - y - si.PaddingBottom - height' 10f' align);                              ct.Go();                          }                      }                      else                      {                          //Not checked                          double rads = -283.0 / 180.0;                          double radsCos = Math.Cos(rads);                          double radsSin = Math.Sin(rads);                          _contentByte.BeginText();                          _contentByte.SetFontAndSize(bf' si.FontSize);                          _contentByte.SetTextMatrix((float)radsCos' (float)radsSin' (float)-radsSin' (float)radsCos' startX' PageSize.yHeight - startY);                          _contentByte.ShowText(text);                          _contentByte.EndText();                      }                        //add URL                      if (url != null)                          _pdfDocument.Add(new Annotation(x' PageSize.yHeight - (y + height)' width + x' PageSize.yHeight - y' url));                      //add tooltip                      if (tooltip != null)                          _pdfDocument.Add(new Annotation(x' PageSize.yHeight - (y + height)' width + x' PageSize.yHeight - y' tooltip));                    }                    // Handle underlining etc.                  float maxX;                  switch (si.TextDecoration)                  {                      case TextDecorationEnum.Underline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + si.FontSize + 1' maxX' startY + si.FontSize + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.LineThrough:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + (si.FontSize / 2) + 1' maxX' startY + (si.FontSize / 2) + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.Overline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + 1' maxX' startY + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.None:                      default:                          break;                  }              }
Magic Number,fyiReporting.RDL,RenderPdf_iTextSharp,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf_iTextSharp.cs,AddText,The following statement contains a magic number: for (int i = 0; i < sa.Length; i++)              {                  string text = sa[i];                  float textwidth = tw[i];                  // Calculate the x positino                  float startX = x + si.PaddingLeft;						// TODO: handle tb_rl                  float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl                  int align = 0;                  if (si.WritingMode == WritingModeEnum.lr_tb)                  {	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now                      switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (width > 0)                              {                                  startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                                  align = Element.ALIGN_CENTER;                              }                              break;                          case TextAlignEnum.Right:                              if (width > 0)                              {                                  startX = x + width - textwidth - si.PaddingRight;                                  align = Element.ALIGN_RIGHT;                              }                              break;                          case TextAlignEnum.Left:                          default:                              align = Element.ALIGN_LEFT;                              break;                      }                        // Calculate the y position                      switch (si.VerticalAlign)                      {                          case VerticalAlignEnum.Middle:                              if (height <= 0)                                  break;                                // calculate the middle of the region                              startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom) / 2 - si.FontSize / 2;                              // now go up or down depending on which line                              if (sa.Length == 1)                                  break;                              if (sa.Length % 2 == 0)	// even number                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize) + si.FontSize / 2;                              }                              else                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize);                              }                              break;                          case VerticalAlignEnum.Bottom:                              if (height <= 0)                                  break;                                startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length - i));                              break;                          case VerticalAlignEnum.Top:                          default:                              break;                      }                  }                  else                  {                      //25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                        switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                    }                    // Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)                  if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)                  {	// background color' height and width are specified                      iAddFillRect(x' y' width' height' si.BackgroundColor);                  }                    // Set the clipping path' (Itext have no clip)                  if (height > 0 && width > 0)                  {                      _contentByte.SetRGBColorFill(si.Color.R' si.Color.G' si.Color.B);                        if (si.WritingMode == WritingModeEnum.lr_tb)                      {                          //If textline after measure with word break can fit just simple show Text                          if (width >= textwidth)                          {                              _contentByte.BeginText();                              _contentByte.SetFontAndSize(bf' si.FontSize);                              _contentByte.SetTextMatrix(startX' (PageSize.yHeight - startY - si.FontSize));                              _contentByte.ShowText(text);                              _contentByte.EndText();                          }                          else                          {                              //else use Column text to wrap or clip (wrap: for example a text like an URL so word break is not working here' itextsharp ColumnText do the work for us)                              ColumnText ct = new ColumnText(_contentByte);                              Phrase myPhrase = new Phrase(text' new iTextSharp.text.Font(bf' si.FontSize));                              ct.SetSimpleColumn(myPhrase' x + si.PaddingLeft' PageSize.yHeight - startY' x + width - si.PaddingRight' PageSize.yHeight - y - si.PaddingBottom - height' 10f' align);                              ct.Go();                          }                      }                      else                      {                          //Not checked                          double rads = -283.0 / 180.0;                          double radsCos = Math.Cos(rads);                          double radsSin = Math.Sin(rads);                          _contentByte.BeginText();                          _contentByte.SetFontAndSize(bf' si.FontSize);                          _contentByte.SetTextMatrix((float)radsCos' (float)radsSin' (float)-radsSin' (float)radsCos' startX' PageSize.yHeight - startY);                          _contentByte.ShowText(text);                          _contentByte.EndText();                      }                        //add URL                      if (url != null)                          _pdfDocument.Add(new Annotation(x' PageSize.yHeight - (y + height)' width + x' PageSize.yHeight - y' url));                      //add tooltip                      if (tooltip != null)                          _pdfDocument.Add(new Annotation(x' PageSize.yHeight - (y + height)' width + x' PageSize.yHeight - y' tooltip));                    }                    // Handle underlining etc.                  float maxX;                  switch (si.TextDecoration)                  {                      case TextDecorationEnum.Underline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + si.FontSize + 1' maxX' startY + si.FontSize + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.LineThrough:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + (si.FontSize / 2) + 1' maxX' startY + (si.FontSize / 2) + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.Overline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + 1' maxX' startY + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.None:                      default:                          break;                  }              }
Magic Number,fyiReporting.RDL,RenderPdf_iTextSharp,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf_iTextSharp.cs,AddText,The following statement contains a magic number: for (int i = 0; i < sa.Length; i++)              {                  string text = sa[i];                  float textwidth = tw[i];                  // Calculate the x positino                  float startX = x + si.PaddingLeft;						// TODO: handle tb_rl                  float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl                  int align = 0;                  if (si.WritingMode == WritingModeEnum.lr_tb)                  {	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now                      switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (width > 0)                              {                                  startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                                  align = Element.ALIGN_CENTER;                              }                              break;                          case TextAlignEnum.Right:                              if (width > 0)                              {                                  startX = x + width - textwidth - si.PaddingRight;                                  align = Element.ALIGN_RIGHT;                              }                              break;                          case TextAlignEnum.Left:                          default:                              align = Element.ALIGN_LEFT;                              break;                      }                        // Calculate the y position                      switch (si.VerticalAlign)                      {                          case VerticalAlignEnum.Middle:                              if (height <= 0)                                  break;                                // calculate the middle of the region                              startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom) / 2 - si.FontSize / 2;                              // now go up or down depending on which line                              if (sa.Length == 1)                                  break;                              if (sa.Length % 2 == 0)	// even number                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize) + si.FontSize / 2;                              }                              else                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize);                              }                              break;                          case VerticalAlignEnum.Bottom:                              if (height <= 0)                                  break;                                startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length - i));                              break;                          case VerticalAlignEnum.Top:                          default:                              break;                      }                  }                  else                  {                      //25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                        switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                    }                    // Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)                  if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)                  {	// background color' height and width are specified                      iAddFillRect(x' y' width' height' si.BackgroundColor);                  }                    // Set the clipping path' (Itext have no clip)                  if (height > 0 && width > 0)                  {                      _contentByte.SetRGBColorFill(si.Color.R' si.Color.G' si.Color.B);                        if (si.WritingMode == WritingModeEnum.lr_tb)                      {                          //If textline after measure with word break can fit just simple show Text                          if (width >= textwidth)                          {                              _contentByte.BeginText();                              _contentByte.SetFontAndSize(bf' si.FontSize);                              _contentByte.SetTextMatrix(startX' (PageSize.yHeight - startY - si.FontSize));                              _contentByte.ShowText(text);                              _contentByte.EndText();                          }                          else                          {                              //else use Column text to wrap or clip (wrap: for example a text like an URL so word break is not working here' itextsharp ColumnText do the work for us)                              ColumnText ct = new ColumnText(_contentByte);                              Phrase myPhrase = new Phrase(text' new iTextSharp.text.Font(bf' si.FontSize));                              ct.SetSimpleColumn(myPhrase' x + si.PaddingLeft' PageSize.yHeight - startY' x + width - si.PaddingRight' PageSize.yHeight - y - si.PaddingBottom - height' 10f' align);                              ct.Go();                          }                      }                      else                      {                          //Not checked                          double rads = -283.0 / 180.0;                          double radsCos = Math.Cos(rads);                          double radsSin = Math.Sin(rads);                          _contentByte.BeginText();                          _contentByte.SetFontAndSize(bf' si.FontSize);                          _contentByte.SetTextMatrix((float)radsCos' (float)radsSin' (float)-radsSin' (float)radsCos' startX' PageSize.yHeight - startY);                          _contentByte.ShowText(text);                          _contentByte.EndText();                      }                        //add URL                      if (url != null)                          _pdfDocument.Add(new Annotation(x' PageSize.yHeight - (y + height)' width + x' PageSize.yHeight - y' url));                      //add tooltip                      if (tooltip != null)                          _pdfDocument.Add(new Annotation(x' PageSize.yHeight - (y + height)' width + x' PageSize.yHeight - y' tooltip));                    }                    // Handle underlining etc.                  float maxX;                  switch (si.TextDecoration)                  {                      case TextDecorationEnum.Underline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + si.FontSize + 1' maxX' startY + si.FontSize + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.LineThrough:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + (si.FontSize / 2) + 1' maxX' startY + (si.FontSize / 2) + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.Overline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + 1' maxX' startY + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.None:                      default:                          break;                  }              }
Magic Number,fyiReporting.RDL,RenderPdf_iTextSharp,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf_iTextSharp.cs,AddText,The following statement contains a magic number: for (int i = 0; i < sa.Length; i++)              {                  string text = sa[i];                  float textwidth = tw[i];                  // Calculate the x positino                  float startX = x + si.PaddingLeft;						// TODO: handle tb_rl                  float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl                  int align = 0;                  if (si.WritingMode == WritingModeEnum.lr_tb)                  {	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now                      switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (width > 0)                              {                                  startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                                  align = Element.ALIGN_CENTER;                              }                              break;                          case TextAlignEnum.Right:                              if (width > 0)                              {                                  startX = x + width - textwidth - si.PaddingRight;                                  align = Element.ALIGN_RIGHT;                              }                              break;                          case TextAlignEnum.Left:                          default:                              align = Element.ALIGN_LEFT;                              break;                      }                        // Calculate the y position                      switch (si.VerticalAlign)                      {                          case VerticalAlignEnum.Middle:                              if (height <= 0)                                  break;                                // calculate the middle of the region                              startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom) / 2 - si.FontSize / 2;                              // now go up or down depending on which line                              if (sa.Length == 1)                                  break;                              if (sa.Length % 2 == 0)	// even number                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize) + si.FontSize / 2;                              }                              else                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize);                              }                              break;                          case VerticalAlignEnum.Bottom:                              if (height <= 0)                                  break;                                startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length - i));                              break;                          case VerticalAlignEnum.Top:                          default:                              break;                      }                  }                  else                  {                      //25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                        switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                    }                    // Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)                  if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)                  {	// background color' height and width are specified                      iAddFillRect(x' y' width' height' si.BackgroundColor);                  }                    // Set the clipping path' (Itext have no clip)                  if (height > 0 && width > 0)                  {                      _contentByte.SetRGBColorFill(si.Color.R' si.Color.G' si.Color.B);                        if (si.WritingMode == WritingModeEnum.lr_tb)                      {                          //If textline after measure with word break can fit just simple show Text                          if (width >= textwidth)                          {                              _contentByte.BeginText();                              _contentByte.SetFontAndSize(bf' si.FontSize);                              _contentByte.SetTextMatrix(startX' (PageSize.yHeight - startY - si.FontSize));                              _contentByte.ShowText(text);                              _contentByte.EndText();                          }                          else                          {                              //else use Column text to wrap or clip (wrap: for example a text like an URL so word break is not working here' itextsharp ColumnText do the work for us)                              ColumnText ct = new ColumnText(_contentByte);                              Phrase myPhrase = new Phrase(text' new iTextSharp.text.Font(bf' si.FontSize));                              ct.SetSimpleColumn(myPhrase' x + si.PaddingLeft' PageSize.yHeight - startY' x + width - si.PaddingRight' PageSize.yHeight - y - si.PaddingBottom - height' 10f' align);                              ct.Go();                          }                      }                      else                      {                          //Not checked                          double rads = -283.0 / 180.0;                          double radsCos = Math.Cos(rads);                          double radsSin = Math.Sin(rads);                          _contentByte.BeginText();                          _contentByte.SetFontAndSize(bf' si.FontSize);                          _contentByte.SetTextMatrix((float)radsCos' (float)radsSin' (float)-radsSin' (float)radsCos' startX' PageSize.yHeight - startY);                          _contentByte.ShowText(text);                          _contentByte.EndText();                      }                        //add URL                      if (url != null)                          _pdfDocument.Add(new Annotation(x' PageSize.yHeight - (y + height)' width + x' PageSize.yHeight - y' url));                      //add tooltip                      if (tooltip != null)                          _pdfDocument.Add(new Annotation(x' PageSize.yHeight - (y + height)' width + x' PageSize.yHeight - y' tooltip));                    }                    // Handle underlining etc.                  float maxX;                  switch (si.TextDecoration)                  {                      case TextDecorationEnum.Underline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + si.FontSize + 1' maxX' startY + si.FontSize + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.LineThrough:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + (si.FontSize / 2) + 1' maxX' startY + (si.FontSize / 2) + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.Overline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + 1' maxX' startY + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.None:                      default:                          break;                  }              }
Magic Number,fyiReporting.RDL,RenderPdf_iTextSharp,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf_iTextSharp.cs,AddText,The following statement contains a magic number: for (int i = 0; i < sa.Length; i++)              {                  string text = sa[i];                  float textwidth = tw[i];                  // Calculate the x positino                  float startX = x + si.PaddingLeft;						// TODO: handle tb_rl                  float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl                  int align = 0;                  if (si.WritingMode == WritingModeEnum.lr_tb)                  {	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now                      switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (width > 0)                              {                                  startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                                  align = Element.ALIGN_CENTER;                              }                              break;                          case TextAlignEnum.Right:                              if (width > 0)                              {                                  startX = x + width - textwidth - si.PaddingRight;                                  align = Element.ALIGN_RIGHT;                              }                              break;                          case TextAlignEnum.Left:                          default:                              align = Element.ALIGN_LEFT;                              break;                      }                        // Calculate the y position                      switch (si.VerticalAlign)                      {                          case VerticalAlignEnum.Middle:                              if (height <= 0)                                  break;                                // calculate the middle of the region                              startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom) / 2 - si.FontSize / 2;                              // now go up or down depending on which line                              if (sa.Length == 1)                                  break;                              if (sa.Length % 2 == 0)	// even number                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize) + si.FontSize / 2;                              }                              else                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize);                              }                              break;                          case VerticalAlignEnum.Bottom:                              if (height <= 0)                                  break;                                startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length - i));                              break;                          case VerticalAlignEnum.Top:                          default:                              break;                      }                  }                  else                  {                      //25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                        switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                    }                    // Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)                  if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)                  {	// background color' height and width are specified                      iAddFillRect(x' y' width' height' si.BackgroundColor);                  }                    // Set the clipping path' (Itext have no clip)                  if (height > 0 && width > 0)                  {                      _contentByte.SetRGBColorFill(si.Color.R' si.Color.G' si.Color.B);                        if (si.WritingMode == WritingModeEnum.lr_tb)                      {                          //If textline after measure with word break can fit just simple show Text                          if (width >= textwidth)                          {                              _contentByte.BeginText();                              _contentByte.SetFontAndSize(bf' si.FontSize);                              _contentByte.SetTextMatrix(startX' (PageSize.yHeight - startY - si.FontSize));                              _contentByte.ShowText(text);                              _contentByte.EndText();                          }                          else                          {                              //else use Column text to wrap or clip (wrap: for example a text like an URL so word break is not working here' itextsharp ColumnText do the work for us)                              ColumnText ct = new ColumnText(_contentByte);                              Phrase myPhrase = new Phrase(text' new iTextSharp.text.Font(bf' si.FontSize));                              ct.SetSimpleColumn(myPhrase' x + si.PaddingLeft' PageSize.yHeight - startY' x + width - si.PaddingRight' PageSize.yHeight - y - si.PaddingBottom - height' 10f' align);                              ct.Go();                          }                      }                      else                      {                          //Not checked                          double rads = -283.0 / 180.0;                          double radsCos = Math.Cos(rads);                          double radsSin = Math.Sin(rads);                          _contentByte.BeginText();                          _contentByte.SetFontAndSize(bf' si.FontSize);                          _contentByte.SetTextMatrix((float)radsCos' (float)radsSin' (float)-radsSin' (float)radsCos' startX' PageSize.yHeight - startY);                          _contentByte.ShowText(text);                          _contentByte.EndText();                      }                        //add URL                      if (url != null)                          _pdfDocument.Add(new Annotation(x' PageSize.yHeight - (y + height)' width + x' PageSize.yHeight - y' url));                      //add tooltip                      if (tooltip != null)                          _pdfDocument.Add(new Annotation(x' PageSize.yHeight - (y + height)' width + x' PageSize.yHeight - y' tooltip));                    }                    // Handle underlining etc.                  float maxX;                  switch (si.TextDecoration)                  {                      case TextDecorationEnum.Underline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + si.FontSize + 1' maxX' startY + si.FontSize + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.LineThrough:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + (si.FontSize / 2) + 1' maxX' startY + (si.FontSize / 2) + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.Overline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + 1' maxX' startY + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.None:                      default:                          break;                  }              }
Magic Number,fyiReporting.RDL,RenderPdf_iTextSharp,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf_iTextSharp.cs,AddText,The following statement contains a magic number: for (int i = 0; i < sa.Length; i++)              {                  string text = sa[i];                  float textwidth = tw[i];                  // Calculate the x positino                  float startX = x + si.PaddingLeft;						// TODO: handle tb_rl                  float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl                  int align = 0;                  if (si.WritingMode == WritingModeEnum.lr_tb)                  {	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now                      switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (width > 0)                              {                                  startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                                  align = Element.ALIGN_CENTER;                              }                              break;                          case TextAlignEnum.Right:                              if (width > 0)                              {                                  startX = x + width - textwidth - si.PaddingRight;                                  align = Element.ALIGN_RIGHT;                              }                              break;                          case TextAlignEnum.Left:                          default:                              align = Element.ALIGN_LEFT;                              break;                      }                        // Calculate the y position                      switch (si.VerticalAlign)                      {                          case VerticalAlignEnum.Middle:                              if (height <= 0)                                  break;                                // calculate the middle of the region                              startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom) / 2 - si.FontSize / 2;                              // now go up or down depending on which line                              if (sa.Length == 1)                                  break;                              if (sa.Length % 2 == 0)	// even number                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize) + si.FontSize / 2;                              }                              else                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize);                              }                              break;                          case VerticalAlignEnum.Bottom:                              if (height <= 0)                                  break;                                startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length - i));                              break;                          case VerticalAlignEnum.Top:                          default:                              break;                      }                  }                  else                  {                      //25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                        switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                    }                    // Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)                  if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)                  {	// background color' height and width are specified                      iAddFillRect(x' y' width' height' si.BackgroundColor);                  }                    // Set the clipping path' (Itext have no clip)                  if (height > 0 && width > 0)                  {                      _contentByte.SetRGBColorFill(si.Color.R' si.Color.G' si.Color.B);                        if (si.WritingMode == WritingModeEnum.lr_tb)                      {                          //If textline after measure with word break can fit just simple show Text                          if (width >= textwidth)                          {                              _contentByte.BeginText();                              _contentByte.SetFontAndSize(bf' si.FontSize);                              _contentByte.SetTextMatrix(startX' (PageSize.yHeight - startY - si.FontSize));                              _contentByte.ShowText(text);                              _contentByte.EndText();                          }                          else                          {                              //else use Column text to wrap or clip (wrap: for example a text like an URL so word break is not working here' itextsharp ColumnText do the work for us)                              ColumnText ct = new ColumnText(_contentByte);                              Phrase myPhrase = new Phrase(text' new iTextSharp.text.Font(bf' si.FontSize));                              ct.SetSimpleColumn(myPhrase' x + si.PaddingLeft' PageSize.yHeight - startY' x + width - si.PaddingRight' PageSize.yHeight - y - si.PaddingBottom - height' 10f' align);                              ct.Go();                          }                      }                      else                      {                          //Not checked                          double rads = -283.0 / 180.0;                          double radsCos = Math.Cos(rads);                          double radsSin = Math.Sin(rads);                          _contentByte.BeginText();                          _contentByte.SetFontAndSize(bf' si.FontSize);                          _contentByte.SetTextMatrix((float)radsCos' (float)radsSin' (float)-radsSin' (float)radsCos' startX' PageSize.yHeight - startY);                          _contentByte.ShowText(text);                          _contentByte.EndText();                      }                        //add URL                      if (url != null)                          _pdfDocument.Add(new Annotation(x' PageSize.yHeight - (y + height)' width + x' PageSize.yHeight - y' url));                      //add tooltip                      if (tooltip != null)                          _pdfDocument.Add(new Annotation(x' PageSize.yHeight - (y + height)' width + x' PageSize.yHeight - y' tooltip));                    }                    // Handle underlining etc.                  float maxX;                  switch (si.TextDecoration)                  {                      case TextDecorationEnum.Underline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + si.FontSize + 1' maxX' startY + si.FontSize + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.LineThrough:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + (si.FontSize / 2) + 1' maxX' startY + (si.FontSize / 2) + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.Overline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + 1' maxX' startY + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.None:                      default:                          break;                  }              }
Magic Number,fyiReporting.RDL,RenderPdf_iTextSharp,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf_iTextSharp.cs,AddText,The following statement contains a magic number: for (int i = 0; i < sa.Length; i++)              {                  string text = sa[i];                  float textwidth = tw[i];                  // Calculate the x positino                  float startX = x + si.PaddingLeft;						// TODO: handle tb_rl                  float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl                  int align = 0;                  if (si.WritingMode == WritingModeEnum.lr_tb)                  {	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now                      switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (width > 0)                              {                                  startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                                  align = Element.ALIGN_CENTER;                              }                              break;                          case TextAlignEnum.Right:                              if (width > 0)                              {                                  startX = x + width - textwidth - si.PaddingRight;                                  align = Element.ALIGN_RIGHT;                              }                              break;                          case TextAlignEnum.Left:                          default:                              align = Element.ALIGN_LEFT;                              break;                      }                        // Calculate the y position                      switch (si.VerticalAlign)                      {                          case VerticalAlignEnum.Middle:                              if (height <= 0)                                  break;                                // calculate the middle of the region                              startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom) / 2 - si.FontSize / 2;                              // now go up or down depending on which line                              if (sa.Length == 1)                                  break;                              if (sa.Length % 2 == 0)	// even number                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize) + si.FontSize / 2;                              }                              else                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize);                              }                              break;                          case VerticalAlignEnum.Bottom:                              if (height <= 0)                                  break;                                startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length - i));                              break;                          case VerticalAlignEnum.Top:                          default:                              break;                      }                  }                  else                  {                      //25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                        switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                    }                    // Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)                  if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)                  {	// background color' height and width are specified                      iAddFillRect(x' y' width' height' si.BackgroundColor);                  }                    // Set the clipping path' (Itext have no clip)                  if (height > 0 && width > 0)                  {                      _contentByte.SetRGBColorFill(si.Color.R' si.Color.G' si.Color.B);                        if (si.WritingMode == WritingModeEnum.lr_tb)                      {                          //If textline after measure with word break can fit just simple show Text                          if (width >= textwidth)                          {                              _contentByte.BeginText();                              _contentByte.SetFontAndSize(bf' si.FontSize);                              _contentByte.SetTextMatrix(startX' (PageSize.yHeight - startY - si.FontSize));                              _contentByte.ShowText(text);                              _contentByte.EndText();                          }                          else                          {                              //else use Column text to wrap or clip (wrap: for example a text like an URL so word break is not working here' itextsharp ColumnText do the work for us)                              ColumnText ct = new ColumnText(_contentByte);                              Phrase myPhrase = new Phrase(text' new iTextSharp.text.Font(bf' si.FontSize));                              ct.SetSimpleColumn(myPhrase' x + si.PaddingLeft' PageSize.yHeight - startY' x + width - si.PaddingRight' PageSize.yHeight - y - si.PaddingBottom - height' 10f' align);                              ct.Go();                          }                      }                      else                      {                          //Not checked                          double rads = -283.0 / 180.0;                          double radsCos = Math.Cos(rads);                          double radsSin = Math.Sin(rads);                          _contentByte.BeginText();                          _contentByte.SetFontAndSize(bf' si.FontSize);                          _contentByte.SetTextMatrix((float)radsCos' (float)radsSin' (float)-radsSin' (float)radsCos' startX' PageSize.yHeight - startY);                          _contentByte.ShowText(text);                          _contentByte.EndText();                      }                        //add URL                      if (url != null)                          _pdfDocument.Add(new Annotation(x' PageSize.yHeight - (y + height)' width + x' PageSize.yHeight - y' url));                      //add tooltip                      if (tooltip != null)                          _pdfDocument.Add(new Annotation(x' PageSize.yHeight - (y + height)' width + x' PageSize.yHeight - y' tooltip));                    }                    // Handle underlining etc.                  float maxX;                  switch (si.TextDecoration)                  {                      case TextDecorationEnum.Underline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + si.FontSize + 1' maxX' startY + si.FontSize + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.LineThrough:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + (si.FontSize / 2) + 1' maxX' startY + (si.FontSize / 2) + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.Overline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          AddLine(startX' startY + 1' maxX' startY + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.None:                      default:                          break;                  }              }
Magic Number,fyiReporting.RDL,RenderPdf_iTextSharp,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf_iTextSharp.cs,iGetCurveTangents,The following statement contains a magic number: if (tangents.Length <= 2)                  return tangents;
Magic Number,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,SetColumnWidth,The following statement contains a magic number: float eu = (float)(w / 72f) * 11;
Magic Number,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,GetCellFormatIndex,The following statement contains a magic number: if ((StyleInfo.GetFormatCode(si._Format) != 999)     //True must be Excel07 format code value                 || ((StyleInfo.GetFormatCode(si._Format) == 0)                      && change))  //general code (default format) already added - checking to see if format has changed - need another entry if that is the case              {                  sb.AppendFormat("<xf numFmtId= \"{0}\" fontId= \"{1}\" fillId= \"{2}\" borderId= \"{3}\" xfId= \"0\" applyNumberFormat= \"1\" "' (StyleInfo.GetFormatCode(si._Format))' fi' filli' bi);                  if (fi > 0)                      sb.AppendFormat("applyFont = \"1\" ");                  if (filli > 0)                      sb.AppendFormat("applyFill = \"1\" ");                  if (bi > 0)                      sb.AppendFormat("applyBorder = \"1\" ");                  sb.AppendFormat("applyAlignment = \"1\" >");                  sb.AppendFormat("<alignment horizontal= \"{0}\" wrapText= \"1\" /></xf>"' GetAlignment(si.TextAlign));                }              else  //must be user defined format code value              {                  foreach (string f in _FormatCache) //format code value must be somewhere in the format cache                  {                      if (f.Contains(si._Format))                      {                          sb.AppendFormat("<xf numFmtId= \"{0}\" fontId= \"{1}\" fillId= \"{2}\" borderId= \"{3}\" xfId= \"0\" applyNumberFormat= \"1\" "' (_FormatCache.GetIndex(f) + 164)' fi' filli' bi);                          if (fi > 0)                              sb.AppendFormat("applyFont = \"1\" ");                          if (filli > 0)                              sb.AppendFormat("applyFill = \"1\" ");                          if (bi > 0)                              sb.AppendFormat("applyBorder = \"1\" ");                          sb.AppendFormat("applyAlignment = \"1\" >");                          sb.AppendFormat("<alignment horizontal= \"{0}\" wrapText= \"1\" /></xf>"' GetAlignment(si.TextAlign));                      }                  }              }
Magic Number,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,GetCellFormatIndex,The following statement contains a magic number: if ((StyleInfo.GetFormatCode(si._Format) != 999)     //True must be Excel07 format code value                 || ((StyleInfo.GetFormatCode(si._Format) == 0)                      && change))  //general code (default format) already added - checking to see if format has changed - need another entry if that is the case              {                  sb.AppendFormat("<xf numFmtId= \"{0}\" fontId= \"{1}\" fillId= \"{2}\" borderId= \"{3}\" xfId= \"0\" applyNumberFormat= \"1\" "' (StyleInfo.GetFormatCode(si._Format))' fi' filli' bi);                  if (fi > 0)                      sb.AppendFormat("applyFont = \"1\" ");                  if (filli > 0)                      sb.AppendFormat("applyFill = \"1\" ");                  if (bi > 0)                      sb.AppendFormat("applyBorder = \"1\" ");                  sb.AppendFormat("applyAlignment = \"1\" >");                  sb.AppendFormat("<alignment horizontal= \"{0}\" wrapText= \"1\" /></xf>"' GetAlignment(si.TextAlign));                }              else  //must be user defined format code value              {                  foreach (string f in _FormatCache) //format code value must be somewhere in the format cache                  {                      if (f.Contains(si._Format))                      {                          sb.AppendFormat("<xf numFmtId= \"{0}\" fontId= \"{1}\" fillId= \"{2}\" borderId= \"{3}\" xfId= \"0\" applyNumberFormat= \"1\" "' (_FormatCache.GetIndex(f) + 164)' fi' filli' bi);                          if (fi > 0)                              sb.AppendFormat("applyFont = \"1\" ");                          if (filli > 0)                              sb.AppendFormat("applyFill = \"1\" ");                          if (bi > 0)                              sb.AppendFormat("applyBorder = \"1\" ");                          sb.AppendFormat("applyAlignment = \"1\" >");                          sb.AppendFormat("<alignment horizontal= \"{0}\" wrapText= \"1\" /></xf>"' GetAlignment(si.TextAlign));                      }                  }              }
Magic Number,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,GetFontIndex,The following statement contains a magic number: StringBuilder sb = new StringBuilder(150);
Magic Number,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,GetFormatIndex,The following statement contains a magic number: StringBuilder sb = new StringBuilder(150);
Magic Number,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,GetFormatIndex,The following statement contains a magic number: if ((StyleInfo.GetFormatCode(si._Format) == 999)                  && (si._Format != string.Empty)                  && (si._Format != null)                  && !(UserDefinedFormatExists(_FormatCache'si._Format)))              {                  sb.AppendFormat("<numFmt numFmtId = \"{0}\" formatCode =\"{1}\"/> "' (_FormatCache.Count + 164)' si._Format);  //WRP 31102008 "164" seems to be default base value for user defined formats                  int i = _FormatCache.GetIndex(sb.ToString());                  return i;              }
Magic Number,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,GetFormatIndex,The following statement contains a magic number: if ((StyleInfo.GetFormatCode(si._Format) == 999)                  && (si._Format != string.Empty)                  && (si._Format != null)                  && !(UserDefinedFormatExists(_FormatCache'si._Format)))              {                  sb.AppendFormat("<numFmt numFmtId = \"{0}\" formatCode =\"{1}\"/> "' (_FormatCache.Count + 164)' si._Format);  //WRP 31102008 "164" seems to be default base value for user defined formats                  int i = _FormatCache.GetIndex(sb.ToString());                  return i;              }
Magic Number,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,GetColor,The following statement contains a magic number: string sb = Convert.ToString(b' 16).ToUpperInvariant();
Magic Number,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,GetBorderIndex,The following statement contains a magic number: StringBuilder sb = new StringBuilder(150);
Magic Number,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,WriteStyles,The following statement contains a magic number: StringBuilder sb = new StringBuilder(500);
Magic Number,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,WriteWorkbook,The following statement contains a magic number: StringBuilder sb = new StringBuilder(400);
Magic Number,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,WriteWorkbookRels,The following statement contains a magic number: StringBuilder sb = new StringBuilder(400);
Magic Number,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,WriteApp,The following statement contains a magic number: StringBuilder sb = new StringBuilder(400);
Magic Number,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,WriteApp,The following statement contains a magic number: if (_Sheets.Count == 0)              { // we'll output an empty sheet in this case; just so we have a valid file                  sb.Append("<vt:lpstr>Sheet1</vt:lpstr>");              }              else              {                  foreach (SheetInfo sinfo in _Sheets)                  {                      int length = sinfo.Name.Length;                      if (length > 31)                      {                          length = 31; //XX 31 char max length?                      }                      sb.AppendFormat("<vt:lpstr>{0}</vt:lpstr>"' sinfo.Name.Substring(0' length));                  }              }
Magic Number,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,WriteApp,The following statement contains a magic number: if (_Sheets.Count == 0)              { // we'll output an empty sheet in this case; just so we have a valid file                  sb.Append("<vt:lpstr>Sheet1</vt:lpstr>");              }              else              {                  foreach (SheetInfo sinfo in _Sheets)                  {                      int length = sinfo.Name.Length;                      if (length > 31)                      {                          length = 31; //XX 31 char max length?                      }                      sb.AppendFormat("<vt:lpstr>{0}</vt:lpstr>"' sinfo.Name.Substring(0' length));                  }              }
Magic Number,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,ColumnIndexToName,The following statement contains a magic number: char second = (char)(((int)'A') + columnIndex % 26);
Magic Number,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,ColumnIndexToName,The following statement contains a magic number: columnIndex /= 26;
Magic Number,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,WriteData,The following statement contains a magic number: using (XmlTextWriter xtw = new XmlTextWriter(ms' Encoding.UTF8))              {                  xtw.WriteStartDocument(true);                  xtw.WriteStartElement("worksheet");                  xtw.WriteAttributeString("xmlns"' "http://schemas.openxmlformats.org/spreadsheetml/2006/main");                  xtw.WriteAttributeString("xmlns:r"' "http://schemas.openxmlformats.org/officeDocument/2006/relationships");                  xtw.WriteStartElement("dimension");                  string lastCell = RowColumnToPosition(grid.Count - 2' grid.GetColumnCount(grid.Count - 2) - 1);                  xtw.WriteAttributeString("ref"' "A1:" + lastCell);                  xtw.WriteEndElement();                  xtw.WriteStartElement("sheetViews");                  xtw.WriteStartElement("sheetView"); xtw.WriteAttributeString("tabSelected"' "1");                  xtw.WriteAttributeString("workbookViewId"' "0");                  xtw.WriteEndElement();                  xtw.WriteEndElement();                  xtw.WriteStartElement("sheetFormatPr");                  xtw.WriteAttributeString("defaultRowHeight"' "15");                  xtw.WriteEndElement();                  // column width information e.g.   //<cols><col min="1" max="1" width="18.5703125" customWidth="1"/></cols>                  xtw.WriteStartElement("cols");                  int cols = grid.GetColumnCount(0);                  for (int ci = 1; ci < cols; ci++)                  {                      CellData cd = grid[0' ci] as CellData;                      if (cd == null)                // skip empty grid items                          continue;                      xtw.WriteStartElement("col");                      string sc = ci.ToString();                      xtw.WriteAttributeString("min"' sc);                      xtw.WriteAttributeString("max"' sc);                      xtw.WriteAttributeString("width"' cd.Val.ToString().Replace('''''.'));                      xtw.WriteAttributeString("customWidth"' "1");                      xtw.WriteEndElement();                  }                  xtw.WriteEndElement();                  // sheet data                  xtw.WriteStartElement("sheetData");                  WriteGridData(xtw' grid' mergecells);  // write table data                  xtw.WriteEndElement();                  // Merge Cells AJM 130608                    if (mergecells.Count > 0)  // 311008 WRP merge cells should only be shown in XML if count greater then 0                  {                      xtw.WriteStartElement("mergeCells");                      xtw.WriteAttributeString("count"' mergecells.Count.ToString());                      WriteMergeCells(xtw' mergecells);                      xtw.WriteEndElement();                  }                  xtw.WriteStartElement("pageMargins");                  xtw.WriteAttributeString("left"' "0.7");                  xtw.WriteAttributeString("right"' "0.7");                  xtw.WriteAttributeString("top"' "0.75");                  xtw.WriteAttributeString("bottom"' "0.75");                  xtw.WriteAttributeString("header"' "0.3");                  xtw.WriteAttributeString("footer"' "0.3");                  xtw.WriteEndElement();                  xtw.WriteEndElement();                  xtw.Flush();                  byte[] ba = ms.ToArray();                  zip.Write(ba' 0' ba.Length);              }
Magic Number,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,WriteData,The following statement contains a magic number: using (XmlTextWriter xtw = new XmlTextWriter(ms' Encoding.UTF8))              {                  xtw.WriteStartDocument(true);                  xtw.WriteStartElement("worksheet");                  xtw.WriteAttributeString("xmlns"' "http://schemas.openxmlformats.org/spreadsheetml/2006/main");                  xtw.WriteAttributeString("xmlns:r"' "http://schemas.openxmlformats.org/officeDocument/2006/relationships");                  xtw.WriteStartElement("dimension");                  string lastCell = RowColumnToPosition(grid.Count - 2' grid.GetColumnCount(grid.Count - 2) - 1);                  xtw.WriteAttributeString("ref"' "A1:" + lastCell);                  xtw.WriteEndElement();                  xtw.WriteStartElement("sheetViews");                  xtw.WriteStartElement("sheetView"); xtw.WriteAttributeString("tabSelected"' "1");                  xtw.WriteAttributeString("workbookViewId"' "0");                  xtw.WriteEndElement();                  xtw.WriteEndElement();                  xtw.WriteStartElement("sheetFormatPr");                  xtw.WriteAttributeString("defaultRowHeight"' "15");                  xtw.WriteEndElement();                  // column width information e.g.   //<cols><col min="1" max="1" width="18.5703125" customWidth="1"/></cols>                  xtw.WriteStartElement("cols");                  int cols = grid.GetColumnCount(0);                  for (int ci = 1; ci < cols; ci++)                  {                      CellData cd = grid[0' ci] as CellData;                      if (cd == null)                // skip empty grid items                          continue;                      xtw.WriteStartElement("col");                      string sc = ci.ToString();                      xtw.WriteAttributeString("min"' sc);                      xtw.WriteAttributeString("max"' sc);                      xtw.WriteAttributeString("width"' cd.Val.ToString().Replace('''''.'));                      xtw.WriteAttributeString("customWidth"' "1");                      xtw.WriteEndElement();                  }                  xtw.WriteEndElement();                  // sheet data                  xtw.WriteStartElement("sheetData");                  WriteGridData(xtw' grid' mergecells);  // write table data                  xtw.WriteEndElement();                  // Merge Cells AJM 130608                    if (mergecells.Count > 0)  // 311008 WRP merge cells should only be shown in XML if count greater then 0                  {                      xtw.WriteStartElement("mergeCells");                      xtw.WriteAttributeString("count"' mergecells.Count.ToString());                      WriteMergeCells(xtw' mergecells);                      xtw.WriteEndElement();                  }                  xtw.WriteStartElement("pageMargins");                  xtw.WriteAttributeString("left"' "0.7");                  xtw.WriteAttributeString("right"' "0.7");                  xtw.WriteAttributeString("top"' "0.75");                  xtw.WriteAttributeString("bottom"' "0.75");                  xtw.WriteAttributeString("header"' "0.3");                  xtw.WriteAttributeString("footer"' "0.3");                  xtw.WriteEndElement();                  xtw.WriteEndElement();                  xtw.Flush();                  byte[] ba = ms.ToArray();                  zip.Write(ba' 0' ba.Length);              }
Magic Number,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,WriteGridData,The following statement contains a magic number: DateTime BaseDate = new DateTime(1899' 12' 31);
Magic Number,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,WriteGridData,The following statement contains a magic number: DateTime BaseDate = new DateTime(1899' 12' 31);
Magic Number,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,WriteGridData,The following statement contains a magic number: DateTime BaseDate = new DateTime(1899' 12' 31);
Magic Number,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,WriteGridData,The following statement contains a magic number: for (int ri = 1; ri < rows; ri++)              {                  xtw.WriteStartElement("row");                  relPos = RowIndexToName(ri - 1);                  xtw.WriteAttributeString("r"' relPos);                  int cols = grid.GetColumnCount(ri);                  xtw.WriteAttributeString("spans"' "1:" + (cols - 1).ToString());                  CellData cd = grid[ri' 0] as CellData;                  if (cd != null)                // skip empty grid items                  {                      xtw.WriteAttributeString("ht"' Convert.ToString(cd.Val' NumberFormatInfo.InvariantInfo));                      xtw.WriteAttributeString("customHeight"' "1");                  }                  for (int ci = 1; ci < cols; ci++)   //this writes the sparse matrix to the Excel07 XMl sheettable document                  {                      cd = grid[ri' ci] as CellData;                      if (cd == null)                // skip empty grid items                          continue;                      xtw.WriteStartElement("c");                      relPos = RowColumnToPosition(ri - 1' ci - 1);                      xtw.WriteAttributeString("r"' relPos);                      //WRP 31102008 - Am I dealing with string/general values?                      k = 0;                      foreach (string f in _FormatXfsCache)                      {                          if (k.ToString() == cd.FormatIndex.ToString())                          {                              value = f;                              FormatGeneral = (f.Contains("<xf numFmtId= \"0\""));                                                    }                          k++;                      }                      k = 0;                      foreach (string f in _StringCache)                      {                          if (k.ToString() == cd.Val.ToString())                              value = f;                          k++;                      }                            if ((FormatGeneral))                      {                      // WRP 31102008 string values stored in sharedString XML document.  Need to reference them from there                          xtw.WriteAttributeString("t"' "s");                          xtw.WriteAttributeString("s"' cd.FormatIndex.ToString());                          xtw.WriteElementString("v"' cd.Val.ToString());                      }                      else                      //WRP 31102008 Need to have "non" string values only in worksheet XML documents in Excel07                      {                          k = 0;                          foreach (string f in _StringCache)                          {                              if (k.ToString() == cd.Val.ToString())                                  value = f;                              k++;                          }                          //WRP 31102008 - Adding support for excel import of date values.                          //using specific date formats (ignore culture) to check for date value - cannot have any string values in data sheet - must reference them from sharedstring XML document.                            if ((DateTime.TryParseExact(value' dateformats' System.Globalization.CultureInfo.InvariantCulture' System.Globalization.DateTimeStyles.None' out ValueDate)))                          {                              interval = ValueDate - BaseDate;  //subtract the basedate from our date to get interval                              Days = interval.Days;                              if (Days >= 60) Days++;          // WRP 31102008 must allow adjust for 29 Feb 1900 which Excel considers a valid date  - it is NOT!!!                              value = Days.ToString();                          }                          else                          {   //WRP 31102008 RDL number values in reports contain fromatting characters - need to remove these to extract pure numbers                              value = value.Replace("("' "-");                              value = value.Replace(")"' "");                              value = value.Replace(CultureInfo.CurrentCulture.NumberFormat.NumberGroupSeparator' "");                              value = value.Replace(CultureInfo.CurrentCulture.NumberFormat.NumberDecimalSeparator' ".");                              value = value.Replace("$"' "");                                if (value.IndexOf('%') != -1)       //WRP 31102008 if a properly RDL formatted percentage need to remove "%" and pass throught value/100 to excel for correct formatting                              {                                  value = value.Replace("%"' String.Empty);                                  decimal decvalue = Convert.ToDecimal(value) / 100;                                  value = decvalue.ToString();                                  }                              value = Regex.Replace(value' @"\s+"' "");      //WRP 31102008 remove any white space                                if (!(IsNumeric(value) || IsNumeric(value'CultureInfo.CurrentCulture)))                              {                                  xtw.WriteAttributeString("t"'"s");                                  value = cd.Val.ToString();                              }                                xtw.WriteAttributeString("s"' cd.FormatIndex.ToString());                                }                          xtw.WriteElementString("v"' value);                        }                      xtw.WriteEndElement();                  }                  xtw.WriteEndElement();              }
Magic Number,fyiReporting.RDL,ExcelValet,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ExcelValet.cs,WriteGridData,The following statement contains a magic number: for (int ri = 1; ri < rows; ri++)              {                  xtw.WriteStartElement("row");                  relPos = RowIndexToName(ri - 1);                  xtw.WriteAttributeString("r"' relPos);                  int cols = grid.GetColumnCount(ri);                  xtw.WriteAttributeString("spans"' "1:" + (cols - 1).ToString());                  CellData cd = grid[ri' 0] as CellData;                  if (cd != null)                // skip empty grid items                  {                      xtw.WriteAttributeString("ht"' Convert.ToString(cd.Val' NumberFormatInfo.InvariantInfo));                      xtw.WriteAttributeString("customHeight"' "1");                  }                  for (int ci = 1; ci < cols; ci++)   //this writes the sparse matrix to the Excel07 XMl sheettable document                  {                      cd = grid[ri' ci] as CellData;                      if (cd == null)                // skip empty grid items                          continue;                      xtw.WriteStartElement("c");                      relPos = RowColumnToPosition(ri - 1' ci - 1);                      xtw.WriteAttributeString("r"' relPos);                      //WRP 31102008 - Am I dealing with string/general values?                      k = 0;                      foreach (string f in _FormatXfsCache)                      {                          if (k.ToString() == cd.FormatIndex.ToString())                          {                              value = f;                              FormatGeneral = (f.Contains("<xf numFmtId= \"0\""));                                                    }                          k++;                      }                      k = 0;                      foreach (string f in _StringCache)                      {                          if (k.ToString() == cd.Val.ToString())                              value = f;                          k++;                      }                            if ((FormatGeneral))                      {                      // WRP 31102008 string values stored in sharedString XML document.  Need to reference them from there                          xtw.WriteAttributeString("t"' "s");                          xtw.WriteAttributeString("s"' cd.FormatIndex.ToString());                          xtw.WriteElementString("v"' cd.Val.ToString());                      }                      else                      //WRP 31102008 Need to have "non" string values only in worksheet XML documents in Excel07                      {                          k = 0;                          foreach (string f in _StringCache)                          {                              if (k.ToString() == cd.Val.ToString())                                  value = f;                              k++;                          }                          //WRP 31102008 - Adding support for excel import of date values.                          //using specific date formats (ignore culture) to check for date value - cannot have any string values in data sheet - must reference them from sharedstring XML document.                            if ((DateTime.TryParseExact(value' dateformats' System.Globalization.CultureInfo.InvariantCulture' System.Globalization.DateTimeStyles.None' out ValueDate)))                          {                              interval = ValueDate - BaseDate;  //subtract the basedate from our date to get interval                              Days = interval.Days;                              if (Days >= 60) Days++;          // WRP 31102008 must allow adjust for 29 Feb 1900 which Excel considers a valid date  - it is NOT!!!                              value = Days.ToString();                          }                          else                          {   //WRP 31102008 RDL number values in reports contain fromatting characters - need to remove these to extract pure numbers                              value = value.Replace("("' "-");                              value = value.Replace(")"' "");                              value = value.Replace(CultureInfo.CurrentCulture.NumberFormat.NumberGroupSeparator' "");                              value = value.Replace(CultureInfo.CurrentCulture.NumberFormat.NumberDecimalSeparator' ".");                              value = value.Replace("$"' "");                                if (value.IndexOf('%') != -1)       //WRP 31102008 if a properly RDL formatted percentage need to remove "%" and pass throught value/100 to excel for correct formatting                              {                                  value = value.Replace("%"' String.Empty);                                  decimal decvalue = Convert.ToDecimal(value) / 100;                                  value = decvalue.ToString();                                  }                              value = Regex.Replace(value' @"\s+"' "");      //WRP 31102008 remove any white space                                if (!(IsNumeric(value) || IsNumeric(value'CultureInfo.CurrentCulture)))                              {                                  xtw.WriteAttributeString("t"'"s");                                  value = cd.Val.ToString();                              }                                xtw.WriteAttributeString("s"' cd.FormatIndex.ToString());                                }                          xtw.WriteElementString("v"' value);                        }                      xtw.WriteEndElement();                  }                  xtw.WriteEndElement();              }
Magic Number,fyiReporting.RDL,PdfPatternEntry,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfPattern.cs,HorizontalBrick,The following statement contains a magic number: for (int i = 0; i <= 25; i++)              {              	stream.AppendFormat("\r\n\t .5 w\t[] 0 d\t {0} 50 m\t{0} 53 l\tS\t\t"'i*4'i*4);              }
Magic Number,fyiReporting.RDL,PdfPatternEntry,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfPattern.cs,HorizontalBrick,The following statement contains a magic number: for (int i = 0; i <= 25; i++)              {              	stream.AppendFormat("\r\n\t .5 w\t[] 0 d\t {0} 50 m\t{0} 53 l\tS\t\t"'i*4'i*4);              }
Magic Number,fyiReporting.RDL,PdfPatternEntry,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfPattern.cs,HorizontalBrick,The following statement contains a magic number: for (int i = 0; i <= 25; i++)              {              	stream.AppendFormat("\r\n\t .5 w\t[] 0 d\t {0} 50 m\t{0} 53 l\tS\t\t"'i*4'i*4);              }
Magic Number,fyiReporting.RDL,PdfPatternEntry,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfPattern.cs,HorizontalBrick,The following statement contains a magic number: for (int i = 0; i <= 25; i++)              {              	stream.AppendFormat("\r\n\t .5 w\t[] 0 d\t {0} 53 m\t{0} 56 l\tS\t\t"'i*4 + 2'i*4 + 2);              }
Magic Number,fyiReporting.RDL,PdfPatternEntry,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfPattern.cs,HorizontalBrick,The following statement contains a magic number: for (int i = 0; i <= 25; i++)              {              	stream.AppendFormat("\r\n\t .5 w\t[] 0 d\t {0} 53 m\t{0} 56 l\tS\t\t"'i*4 + 2'i*4 + 2);              }
Magic Number,fyiReporting.RDL,PdfPatternEntry,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfPattern.cs,HorizontalBrick,The following statement contains a magic number: for (int i = 0; i <= 25; i++)              {              	stream.AppendFormat("\r\n\t .5 w\t[] 0 d\t {0} 53 m\t{0} 56 l\tS\t\t"'i*4 + 2'i*4 + 2);              }
Magic Number,fyiReporting.RDL,PdfPatternEntry,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfPattern.cs,HorizontalBrick,The following statement contains a magic number: for (int i = 0; i <= 25; i++)              {              	stream.AppendFormat("\r\n\t .5 w\t[] 0 d\t {0} 53 m\t{0} 56 l\tS\t\t"'i*4 + 2'i*4 + 2);              }
Magic Number,fyiReporting.RDL,PdfPatternEntry,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfPattern.cs,HorizontalBrick,The following statement contains a magic number: for (int i = 0; i <= 25; i++)              {              	stream.AppendFormat("\r\n\t .5 w\t[] 0 d\t {0} 53 m\t{0} 56 l\tS\t\t"'i*4 + 2'i*4 + 2);              }
Magic Number,fyiReporting.RDL,PdfPatternEntry,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfPattern.cs,DiagonalBrick,The following statement contains a magic number: for (int i = 0; i <= 25; i++)              {              	stream.AppendFormat("\r\n\t .5 w\t[] 0 d\t {0} 50 m\t{0} 53 l\tS\t\t"'i*4'i*4);              }
Magic Number,fyiReporting.RDL,PdfPatternEntry,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfPattern.cs,DiagonalBrick,The following statement contains a magic number: for (int i = 0; i <= 25; i++)              {              	stream.AppendFormat("\r\n\t .5 w\t[] 0 d\t {0} 50 m\t{0} 53 l\tS\t\t"'i*4'i*4);              }
Magic Number,fyiReporting.RDL,PdfPatternEntry,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfPattern.cs,DiagonalBrick,The following statement contains a magic number: for (int i = 0; i <= 25; i++)              {              	stream.AppendFormat("\r\n\t .5 w\t[] 0 d\t {0} 50 m\t{0} 53 l\tS\t\t"'i*4'i*4);              }
Magic Number,fyiReporting.RDL,PdfPatternEntry,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfPattern.cs,DiagonalBrick,The following statement contains a magic number: for (int i = 0; i <= 25; i++)              {              	stream.AppendFormat("\r\n\t .5 w\t[] 0 d\t {0} 53 m\t{0} 56 l\tS\t\t"'i*4 + 2'i*4 + 2);              }
Magic Number,fyiReporting.RDL,PdfPatternEntry,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfPattern.cs,DiagonalBrick,The following statement contains a magic number: for (int i = 0; i <= 25; i++)              {              	stream.AppendFormat("\r\n\t .5 w\t[] 0 d\t {0} 53 m\t{0} 56 l\tS\t\t"'i*4 + 2'i*4 + 2);              }
Magic Number,fyiReporting.RDL,PdfPatternEntry,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfPattern.cs,DiagonalBrick,The following statement contains a magic number: for (int i = 0; i <= 25; i++)              {              	stream.AppendFormat("\r\n\t .5 w\t[] 0 d\t {0} 53 m\t{0} 56 l\tS\t\t"'i*4 + 2'i*4 + 2);              }
Magic Number,fyiReporting.RDL,PdfPatternEntry,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfPattern.cs,DiagonalBrick,The following statement contains a magic number: for (int i = 0; i <= 25; i++)              {              	stream.AppendFormat("\r\n\t .5 w\t[] 0 d\t {0} 53 m\t{0} 56 l\tS\t\t"'i*4 + 2'i*4 + 2);              }
Magic Number,fyiReporting.RDL,PdfPatternEntry,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfPattern.cs,DiagonalBrick,The following statement contains a magic number: for (int i = 0; i <= 25; i++)              {              	stream.AppendFormat("\r\n\t .5 w\t[] 0 d\t {0} 53 m\t{0} 56 l\tS\t\t"'i*4 + 2'i*4 + 2);              }
Magic Number,fyiReporting.RDL,RenderRtf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderRtf.cs,EscapeText,The following statement contains a magic number: foreach (char c in s)  			{                  if (c == '{' || c == '}' || c == '\\')                      rs.AppendFormat(@"\{0}"' c);                  else if (c == '\n')         // newline?                      rs.Append(@"\line");                  else if ((int)c <= 127)	// in ANSI range                      rs.Append(c);                  else                  {                      rs.AppendFormat(@"\u{0}?"' (int)c);                  }              }
Magic Number,fyiReporting.RDL,RenderRtf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderRtf.cs,RtfAnsi,The following statement contains a magic number: foreach (char c in s)              {                  if ((int)c <= 127)   // in ANSI range                       rs.Append(c);                  else                      rs.Append(@"\u" + (int)c + "?");              }
Magic Number,fyiReporting.RDL,RenderRtf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderRtf.cs,DoStyle,The following statement contains a magic number: tw.Write(@"\fs{0}"' (int) Math.Round(si.FontSize * 2'0));
Magic Number,fyiReporting.RDL,RenderRtf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderRtf.cs,PutImage,The following statement contains a magic number: foreach (byte b in ba)              {                  tw.Write(HEXCHARS[(byte)((b >> 4) & 0x0f)]);                  tw.Write(HEXCHARS[(byte)(b & 0x0f)]);              }
Magic Number,fyiReporting.RDL,RenderRtf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderRtf.cs,GetTwipsFromPixels,The following statement contains a magic number: return (int)Math.Round(RSize.PointsFromPixels(GetGraphics' pixels) * 20' 0);
Magic Number,fyiReporting.RDL,RenderTif,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderTif.cs,ConvertToBitonal,The following statement contains a magic number: int pixelValue = 128;
Magic Number,fyiReporting.RDL,RenderTif,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderTif.cs,ConvertToBitonal,The following statement contains a magic number: int threshold = 500;
Magic Number,fyiReporting.RDL,RenderTif,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderTif.cs,ConvertToBitonal,The following statement contains a magic number: for (int y = 0; y < height; y++)              {                  sourceIndex = y * sourceData.Stride;                  destinationIndex = y * destinationData.Stride;                  destinationValue = 0;                  pixelValue = 128;                    // Iterate pixels                   for (int x = 0; x < width; x++)                  {                      // Compute pixel brightness (i.e. total of Red' Green' and Blue values)                       pixelTotal = sourceBuffer[sourceIndex + 1] + sourceBuffer[sourceIndex + 2] + sourceBuffer[sourceIndex + 3];                      if (pixelTotal > threshold)                      {                          destinationValue += (byte)pixelValue;                      }                      if (pixelValue == 1)                      {                          destinationBuffer[destinationIndex] = destinationValue;                          destinationIndex++;                          destinationValue = 0;                          pixelValue = 128;                      }                      else                      {                          pixelValue >>= 1;                      }                      sourceIndex += 4;                  }                  if (pixelValue != 128)                  {                      destinationBuffer[destinationIndex] = destinationValue;                  }              }
Magic Number,fyiReporting.RDL,RenderTif,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderTif.cs,ConvertToBitonal,The following statement contains a magic number: for (int y = 0; y < height; y++)              {                  sourceIndex = y * sourceData.Stride;                  destinationIndex = y * destinationData.Stride;                  destinationValue = 0;                  pixelValue = 128;                    // Iterate pixels                   for (int x = 0; x < width; x++)                  {                      // Compute pixel brightness (i.e. total of Red' Green' and Blue values)                       pixelTotal = sourceBuffer[sourceIndex + 1] + sourceBuffer[sourceIndex + 2] + sourceBuffer[sourceIndex + 3];                      if (pixelTotal > threshold)                      {                          destinationValue += (byte)pixelValue;                      }                      if (pixelValue == 1)                      {                          destinationBuffer[destinationIndex] = destinationValue;                          destinationIndex++;                          destinationValue = 0;                          pixelValue = 128;                      }                      else                      {                          pixelValue >>= 1;                      }                      sourceIndex += 4;                  }                  if (pixelValue != 128)                  {                      destinationBuffer[destinationIndex] = destinationValue;                  }              }
Magic Number,fyiReporting.RDL,RenderTif,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderTif.cs,ConvertToBitonal,The following statement contains a magic number: for (int y = 0; y < height; y++)              {                  sourceIndex = y * sourceData.Stride;                  destinationIndex = y * destinationData.Stride;                  destinationValue = 0;                  pixelValue = 128;                    // Iterate pixels                   for (int x = 0; x < width; x++)                  {                      // Compute pixel brightness (i.e. total of Red' Green' and Blue values)                       pixelTotal = sourceBuffer[sourceIndex + 1] + sourceBuffer[sourceIndex + 2] + sourceBuffer[sourceIndex + 3];                      if (pixelTotal > threshold)                      {                          destinationValue += (byte)pixelValue;                      }                      if (pixelValue == 1)                      {                          destinationBuffer[destinationIndex] = destinationValue;                          destinationIndex++;                          destinationValue = 0;                          pixelValue = 128;                      }                      else                      {                          pixelValue >>= 1;                      }                      sourceIndex += 4;                  }                  if (pixelValue != 128)                  {                      destinationBuffer[destinationIndex] = destinationValue;                  }              }
Magic Number,fyiReporting.RDL,RenderTif,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderTif.cs,ConvertToBitonal,The following statement contains a magic number: for (int y = 0; y < height; y++)              {                  sourceIndex = y * sourceData.Stride;                  destinationIndex = y * destinationData.Stride;                  destinationValue = 0;                  pixelValue = 128;                    // Iterate pixels                   for (int x = 0; x < width; x++)                  {                      // Compute pixel brightness (i.e. total of Red' Green' and Blue values)                       pixelTotal = sourceBuffer[sourceIndex + 1] + sourceBuffer[sourceIndex + 2] + sourceBuffer[sourceIndex + 3];                      if (pixelTotal > threshold)                      {                          destinationValue += (byte)pixelValue;                      }                      if (pixelValue == 1)                      {                          destinationBuffer[destinationIndex] = destinationValue;                          destinationIndex++;                          destinationValue = 0;                          pixelValue = 128;                      }                      else                      {                          pixelValue >>= 1;                      }                      sourceIndex += 4;                  }                  if (pixelValue != 128)                  {                      destinationBuffer[destinationIndex] = destinationValue;                  }              }
Magic Number,fyiReporting.RDL,RenderTif,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderTif.cs,ConvertToBitonal,The following statement contains a magic number: for (int y = 0; y < height; y++)              {                  sourceIndex = y * sourceData.Stride;                  destinationIndex = y * destinationData.Stride;                  destinationValue = 0;                  pixelValue = 128;                    // Iterate pixels                   for (int x = 0; x < width; x++)                  {                      // Compute pixel brightness (i.e. total of Red' Green' and Blue values)                       pixelTotal = sourceBuffer[sourceIndex + 1] + sourceBuffer[sourceIndex + 2] + sourceBuffer[sourceIndex + 3];                      if (pixelTotal > threshold)                      {                          destinationValue += (byte)pixelValue;                      }                      if (pixelValue == 1)                      {                          destinationBuffer[destinationIndex] = destinationValue;                          destinationIndex++;                          destinationValue = 0;                          pixelValue = 128;                      }                      else                      {                          pixelValue >>= 1;                      }                      sourceIndex += 4;                  }                  if (pixelValue != 128)                  {                      destinationBuffer[destinationIndex] = destinationValue;                  }              }
Magic Number,fyiReporting.RDL,RenderTif,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderTif.cs,ConvertToBitonal,The following statement contains a magic number: for (int y = 0; y < height; y++)              {                  sourceIndex = y * sourceData.Stride;                  destinationIndex = y * destinationData.Stride;                  destinationValue = 0;                  pixelValue = 128;                    // Iterate pixels                   for (int x = 0; x < width; x++)                  {                      // Compute pixel brightness (i.e. total of Red' Green' and Blue values)                       pixelTotal = sourceBuffer[sourceIndex + 1] + sourceBuffer[sourceIndex + 2] + sourceBuffer[sourceIndex + 3];                      if (pixelTotal > threshold)                      {                          destinationValue += (byte)pixelValue;                      }                      if (pixelValue == 1)                      {                          destinationBuffer[destinationIndex] = destinationValue;                          destinationIndex++;                          destinationValue = 0;                          pixelValue = 128;                      }                      else                      {                          pixelValue >>= 1;                      }                      sourceIndex += 4;                  }                  if (pixelValue != 128)                  {                      destinationBuffer[destinationIndex] = destinationValue;                  }              }
Magic Number,fyiReporting.RDL,RenderTif,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderTif.cs,SaveBitmap,The following statement contains a magic number: if (pageNo == 1)              {                  // Handling saving first page                     // STEP: Prepare ImageCodecInfo for saving                   ImageCodecInfo info = null;                    foreach (ImageCodecInfo i in ImageCodecInfo.GetImageEncoders())                  {                      if (i.MimeType == "image/tiff")                      {                          info = i;                          break;                      }                  }                    // STEP: Prepare parameters                   EncoderParameters encoderParams = new EncoderParameters(2);                    encoderParams.Param[0] = new EncoderParameter(                      System.Drawing.Imaging.Encoder.SaveFlag' (long)EncoderValue.MultiFrame                  );                    encoderParams.Param[1] = new EncoderParameter(                      System.Drawing.Imaging.Encoder.Compression'                       (long)(_RenderColor? EncoderValue.CompressionLZW: EncoderValue.CompressionCCITT3)                  );                    // STEP: Save bitmap                   tif.Save(st' info' encoderParams);              }              else              {                  // STEP: Prepare parameters                   EncoderParameters encoderParams = new EncoderParameters(1);                    encoderParams.Param[0] = new EncoderParameter(                      System.Drawing.Imaging.Encoder.SaveFlag' (long)EncoderValue.FrameDimensionPage                  );                    // STEP: Save bitmap                   tif.SaveAdd(bm' encoderParams);              }
Magic Number,fyiReporting.RDL,ZipOutputStream,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\ZipWrap.cs,ZipOutputStream,The following statement contains a magic number: Type[] types = new Type[3];
Magic Number,fyiReporting.RDL,ZipOutputStream,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\ZipWrap.cs,ZipOutputStream,The following statement contains a magic number: types[2] = typeof(int);
Magic Number,fyiReporting.RDL,ZipOutputStream,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\ZipWrap.cs,Write,The following statement contains a magic number: Encoding enc = Encoding.GetEncoding(65001);
Magic Number,fyiReporting.RDL,RenderHtmlTable,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\HtmlConverter\RenderHtmlTable.cs,Image,The following statement contains a magic number: try  			{     				if (ioin.CanSeek)		// ioin.Length requires Seek support  				{  					byte[] ba = new byte[ioin.Length];  					ioin.Read(ba' 0' ba.Length);  					io.Write(ba' 0' ba.Length);  				}  				else  				{  					byte[] ba = new byte[1000];		// read a 1000 bytes at a time  					while (true)  					{  						int length = ioin.Read(ba' 0' ba.Length);  						if (length <= 0)  							break;  						io.Write(ba' 0' length);  					}  				}  			}  			finally  			{  				io.Flush();  				io.Close();  			}
Magic Number,fyiReporting.RDL,XmlUtil,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\XmlUtil.cs,Boolean,The following statement contains a magic number: rl.LogError(4' "Unknown True/False value '" + tf + "'.  False assumed.");
Magic Number,fyiReporting.RDL,XmlUtil,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\XmlUtil.cs,ColorFromHtml,The following statement contains a magic number: try   			{  				c = ColorTranslator.FromHtml(sc);  			}  			catch   			{  				c = dc;  				if (rpt != null)  					rpt.rl.LogError(4' string.Format("'{0}' is an invalid HTML color."' sc));  			}
Magic Number,fyiReporting.RDL,XmlUtil,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\XmlUtil.cs,XmlAnsi,The following statement contains a magic number: foreach (char c in s)  			{  				if (c == '<')  					rs.Append("&lt;");  				else if (c == '&')  					rs.Append("&amp;");  				else if ((int) c <= 127)	// in ANSI range  					rs.Append(c);  				else  					rs.Append("&#" + ((int) c).ToString() + ";");  			}
Magic Number,fyiReporting.RDL,XmlUtil,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\XmlUtil.cs,HtmlAnsi,The following statement contains a magic number: foreach (char c in s)              {                  if ((int)c <= 127)	// in ANSI range                      rs.Append(c);                  else                      rs.Append("&#" + ((int)c).ToString() + ";");              }
Magic Number,fyiReporting.RDL,Lexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Lexer.cs,GetNextToken,The following statement contains a magic number: while(!reader.EndOfInput())  			{  				char ch = reader.GetNext();    				// skipping whitespaces  				if(Char.IsWhiteSpace(ch))  				{  					continue;  				}  				switch(ch)  				{  					case '=':  						return new Token(ch.ToString()' reader.Line' reader.Column' reader.Line' reader.Column' TokenTypes.EQUAL);  					case '+':  						return new Token(ch.ToString()' reader.Line' reader.Column' reader.Line' reader.Column' TokenTypes.PLUS);  					case '-':  						return new Token(ch.ToString()' reader.Line' reader.Column' reader.Line' reader.Column' TokenTypes.MINUS);  					case '(':  						return new Token(ch.ToString()' reader.Line' reader.Column' reader.Line' reader.Column' TokenTypes.LPAREN);  					case ')':  						return new Token(ch.ToString()' reader.Line' reader.Column' reader.Line' reader.Column' TokenTypes.RPAREN);  					case ''':  						return new Token(ch.ToString()' reader.Line' reader.Column' reader.Line' reader.Column' TokenTypes.COMMA);  					case '^':  						return new Token(ch.ToString()' reader.Line' reader.Column' reader.Line' reader.Column' TokenTypes.EXP);  					case '%':  						return new Token(ch.ToString()' reader.Line' reader.Column' reader.Line' reader.Column' TokenTypes.MODULUS);  					case '!':  						if (reader.Peek() == '=')  						{  							reader.GetNext();	// go past the equal  							return new Token(ch.ToString()' reader.Line' reader.Column' reader.Line' reader.Column' TokenTypes.NOTEQUAL);  						}  						else  							return new Token(ch.ToString()' reader.Line' reader.Column' reader.Line' reader.Column' TokenTypes.NOT);  					case '&':  						return new Token(ch.ToString()' reader.Line' reader.Column' reader.Line' reader.Column' TokenTypes.PLUSSTRING);  					case '|':  						if (reader.Peek() == '|')  						{  							reader.GetNext();	// go past the '|'  							return new Token(ch.ToString()' reader.Line' reader.Column' reader.Line' reader.Column' TokenTypes.OR);  						}  						break;  					case '>':  						if (reader.Peek() == '=')  						{  							reader.GetNext();	// go past the equal  							return new Token(ch.ToString()' reader.Line' reader.Column' reader.Line' reader.Column' TokenTypes.GREATERTHANOREQUAL);  						}  						else  							return new Token(ch.ToString()' reader.Line' reader.Column' reader.Line' reader.Column' TokenTypes.GREATERTHAN);  					case '/':  						if (reader.Peek() == '*')  						{	// beginning of a comment of form /* a comment */  							reader.GetNext();	// go past the '*'  							ReadComment();  							continue;  						}  						else  							return new Token(ch.ToString()' reader.Line' reader.Column' reader.Line' reader.Column' TokenTypes.FORWARDSLASH);  					case '<':  						if (reader.Peek() == '=')  						{  							reader.GetNext();	// go past the equal  							return new Token(ch.ToString()' reader.Line' reader.Column' reader.Line' reader.Column' TokenTypes.LESSTHANOREQUAL);  						}                          else if (reader.Peek() == '>')                          {                              reader.GetNext();	// go past the >                              return new Token(ch.ToString()' reader.Line' reader.Column' reader.Line' reader.Column' TokenTypes.NOTEQUAL);                          }                          else  							return new Token(ch.ToString()' reader.Line' reader.Column' reader.Line' reader.Column' TokenTypes.LESSTHAN);  					case '*':  						return new Token(ch.ToString()' reader.Line' reader.Column' reader.Line' reader.Column' TokenTypes.STAR);  					case '"':  					case '\'':  						return ReadQuoted(ch);                      case '{':                          return ReadIdentifier(ch' 4);   					default:  						break;  				} // end of swith  				if (Char.IsDigit(ch))  					return ReadNumber(ch);                  else if (ch == '.')                  {                      char tc = reader.Peek();                      if (Char.IsDigit(tc))                          return ReadNumber(ch);                      return new Token(ch.ToString()' reader.Line' reader.Column' reader.Line' reader.Column' TokenTypes.DOT);                  }  				else if (Char.IsLetter(ch) || ch == '_')  					return ReadIdentifier(ch);  				else  					return new Token(ch.ToString()' reader.Line' reader.Column' reader.Line' reader.Column' TokenTypes.OTHER);  			}
Magic Number,fyiReporting.RDL,Lexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Lexer.cs,ReadIdentifier,The following statement contains a magic number: StringBuilder identifier = new StringBuilder(30);
Magic Number,fyiReporting.RDL,Lexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Lexer.cs,ReadIdentifier,The following statement contains a magic number: while (!reader.EndOfInput())  			{  				cPeek = reader.Peek();                  if (state == 1)                  {                      if (Char.IsLetterOrDigit(cPeek) || cPeek == '.' ||                          cPeek == '!' || cPeek == '_')                          identifier.Append(reader.GetNext());                      else if (Char.IsWhiteSpace(cPeek))                      {                          reader.GetNext();   // skip space                          if (identifier[identifier.Length - 1] == '.' ||                              identifier[identifier.Length - 1] == '!')                              state = 3;  // need to have an identfier next                          else                              state = 2;  // need to get '.' or '!' next                      }                      else                          break;                  }                  else if (state == 2)                  {   // state must equal 2                      if (cPeek == '.' || cPeek == '!')                      {                          state = 3;                          identifier.Append(reader.GetNext());                      }                      else if (Char.IsWhiteSpace(cPeek))                          reader.GetNext();                      else                           break;                  }                  else if (state == 3)                  {   // state must equal 3                      if (Char.IsLetter(cPeek) || cPeek == '_')                      {                          state = 1;                          identifier.Append(reader.GetNext());                      }                      else if (Char.IsWhiteSpace(cPeek))                      {                          reader.GetNext();                      }                      else                          break;                  }                  else if (state == 4)                  { // state must equal 4 Josh: 6:21:10 added state 4 for field/param shortcuts  					if (Char.IsLetterOrDigit(cPeek) || cPeek == '@' ||  					cPeek == '?' || cPeek == '_' || cPeek == '}' ||  					cPeek == '!')  					{  						identifier.Append(reader.GetNext());    						if (cPeek == '}')  							break;  					}  					else if (Char.IsWhiteSpace(cPeek))  					{  						reader.GetNext(); // skip space  					}  					else  						break;                  }   			}
Magic Number,fyiReporting.RDL,Lexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Lexer.cs,ReadIdentifier,The following statement contains a magic number: while (!reader.EndOfInput())  			{  				cPeek = reader.Peek();                  if (state == 1)                  {                      if (Char.IsLetterOrDigit(cPeek) || cPeek == '.' ||                          cPeek == '!' || cPeek == '_')                          identifier.Append(reader.GetNext());                      else if (Char.IsWhiteSpace(cPeek))                      {                          reader.GetNext();   // skip space                          if (identifier[identifier.Length - 1] == '.' ||                              identifier[identifier.Length - 1] == '!')                              state = 3;  // need to have an identfier next                          else                              state = 2;  // need to get '.' or '!' next                      }                      else                          break;                  }                  else if (state == 2)                  {   // state must equal 2                      if (cPeek == '.' || cPeek == '!')                      {                          state = 3;                          identifier.Append(reader.GetNext());                      }                      else if (Char.IsWhiteSpace(cPeek))                          reader.GetNext();                      else                           break;                  }                  else if (state == 3)                  {   // state must equal 3                      if (Char.IsLetter(cPeek) || cPeek == '_')                      {                          state = 1;                          identifier.Append(reader.GetNext());                      }                      else if (Char.IsWhiteSpace(cPeek))                      {                          reader.GetNext();                      }                      else                          break;                  }                  else if (state == 4)                  { // state must equal 4 Josh: 6:21:10 added state 4 for field/param shortcuts  					if (Char.IsLetterOrDigit(cPeek) || cPeek == '@' ||  					cPeek == '?' || cPeek == '_' || cPeek == '}' ||  					cPeek == '!')  					{  						identifier.Append(reader.GetNext());    						if (cPeek == '}')  							break;  					}  					else if (Char.IsWhiteSpace(cPeek))  					{  						reader.GetNext(); // skip space  					}  					else  						break;                  }   			}
Magic Number,fyiReporting.RDL,Lexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Lexer.cs,ReadIdentifier,The following statement contains a magic number: while (!reader.EndOfInput())  			{  				cPeek = reader.Peek();                  if (state == 1)                  {                      if (Char.IsLetterOrDigit(cPeek) || cPeek == '.' ||                          cPeek == '!' || cPeek == '_')                          identifier.Append(reader.GetNext());                      else if (Char.IsWhiteSpace(cPeek))                      {                          reader.GetNext();   // skip space                          if (identifier[identifier.Length - 1] == '.' ||                              identifier[identifier.Length - 1] == '!')                              state = 3;  // need to have an identfier next                          else                              state = 2;  // need to get '.' or '!' next                      }                      else                          break;                  }                  else if (state == 2)                  {   // state must equal 2                      if (cPeek == '.' || cPeek == '!')                      {                          state = 3;                          identifier.Append(reader.GetNext());                      }                      else if (Char.IsWhiteSpace(cPeek))                          reader.GetNext();                      else                           break;                  }                  else if (state == 3)                  {   // state must equal 3                      if (Char.IsLetter(cPeek) || cPeek == '_')                      {                          state = 1;                          identifier.Append(reader.GetNext());                      }                      else if (Char.IsWhiteSpace(cPeek))                      {                          reader.GetNext();                      }                      else                          break;                  }                  else if (state == 4)                  { // state must equal 4 Josh: 6:21:10 added state 4 for field/param shortcuts  					if (Char.IsLetterOrDigit(cPeek) || cPeek == '@' ||  					cPeek == '?' || cPeek == '_' || cPeek == '}' ||  					cPeek == '!')  					{  						identifier.Append(reader.GetNext());    						if (cPeek == '}')  							break;  					}  					else if (Char.IsWhiteSpace(cPeek))  					{  						reader.GetNext(); // skip space  					}  					else  						break;                  }   			}
Magic Number,fyiReporting.RDL,Lexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Lexer.cs,ReadIdentifier,The following statement contains a magic number: while (!reader.EndOfInput())  			{  				cPeek = reader.Peek();                  if (state == 1)                  {                      if (Char.IsLetterOrDigit(cPeek) || cPeek == '.' ||                          cPeek == '!' || cPeek == '_')                          identifier.Append(reader.GetNext());                      else if (Char.IsWhiteSpace(cPeek))                      {                          reader.GetNext();   // skip space                          if (identifier[identifier.Length - 1] == '.' ||                              identifier[identifier.Length - 1] == '!')                              state = 3;  // need to have an identfier next                          else                              state = 2;  // need to get '.' or '!' next                      }                      else                          break;                  }                  else if (state == 2)                  {   // state must equal 2                      if (cPeek == '.' || cPeek == '!')                      {                          state = 3;                          identifier.Append(reader.GetNext());                      }                      else if (Char.IsWhiteSpace(cPeek))                          reader.GetNext();                      else                           break;                  }                  else if (state == 3)                  {   // state must equal 3                      if (Char.IsLetter(cPeek) || cPeek == '_')                      {                          state = 1;                          identifier.Append(reader.GetNext());                      }                      else if (Char.IsWhiteSpace(cPeek))                      {                          reader.GetNext();                      }                      else                          break;                  }                  else if (state == 4)                  { // state must equal 4 Josh: 6:21:10 added state 4 for field/param shortcuts  					if (Char.IsLetterOrDigit(cPeek) || cPeek == '@' ||  					cPeek == '?' || cPeek == '_' || cPeek == '}' ||  					cPeek == '!')  					{  						identifier.Append(reader.GetNext());    						if (cPeek == '}')  							break;  					}  					else if (Char.IsWhiteSpace(cPeek))  					{  						reader.GetNext(); // skip space  					}  					else  						break;                  }   			}
Magic Number,fyiReporting.RDL,Lexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Lexer.cs,ReadIdentifier,The following statement contains a magic number: while (!reader.EndOfInput())  			{  				cPeek = reader.Peek();                  if (state == 1)                  {                      if (Char.IsLetterOrDigit(cPeek) || cPeek == '.' ||                          cPeek == '!' || cPeek == '_')                          identifier.Append(reader.GetNext());                      else if (Char.IsWhiteSpace(cPeek))                      {                          reader.GetNext();   // skip space                          if (identifier[identifier.Length - 1] == '.' ||                              identifier[identifier.Length - 1] == '!')                              state = 3;  // need to have an identfier next                          else                              state = 2;  // need to get '.' or '!' next                      }                      else                          break;                  }                  else if (state == 2)                  {   // state must equal 2                      if (cPeek == '.' || cPeek == '!')                      {                          state = 3;                          identifier.Append(reader.GetNext());                      }                      else if (Char.IsWhiteSpace(cPeek))                          reader.GetNext();                      else                           break;                  }                  else if (state == 3)                  {   // state must equal 3                      if (Char.IsLetter(cPeek) || cPeek == '_')                      {                          state = 1;                          identifier.Append(reader.GetNext());                      }                      else if (Char.IsWhiteSpace(cPeek))                      {                          reader.GetNext();                      }                      else                          break;                  }                  else if (state == 4)                  { // state must equal 4 Josh: 6:21:10 added state 4 for field/param shortcuts  					if (Char.IsLetterOrDigit(cPeek) || cPeek == '@' ||  					cPeek == '?' || cPeek == '_' || cPeek == '}' ||  					cPeek == '!')  					{  						identifier.Append(reader.GetNext());    						if (cPeek == '}')  							break;  					}  					else if (Char.IsWhiteSpace(cPeek))  					{  						reader.GetNext(); // skip space  					}  					else  						break;                  }   			}
Magic Number,fyiReporting.RDL,Lexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Lexer.cs,ReadIdentifier,The following statement contains a magic number: while (!reader.EndOfInput())  			{  				cPeek = reader.Peek();                  if (state == 1)                  {                      if (Char.IsLetterOrDigit(cPeek) || cPeek == '.' ||                          cPeek == '!' || cPeek == '_')                          identifier.Append(reader.GetNext());                      else if (Char.IsWhiteSpace(cPeek))                      {                          reader.GetNext();   // skip space                          if (identifier[identifier.Length - 1] == '.' ||                              identifier[identifier.Length - 1] == '!')                              state = 3;  // need to have an identfier next                          else                              state = 2;  // need to get '.' or '!' next                      }                      else                          break;                  }                  else if (state == 2)                  {   // state must equal 2                      if (cPeek == '.' || cPeek == '!')                      {                          state = 3;                          identifier.Append(reader.GetNext());                      }                      else if (Char.IsWhiteSpace(cPeek))                          reader.GetNext();                      else                           break;                  }                  else if (state == 3)                  {   // state must equal 3                      if (Char.IsLetter(cPeek) || cPeek == '_')                      {                          state = 1;                          identifier.Append(reader.GetNext());                      }                      else if (Char.IsWhiteSpace(cPeek))                      {                          reader.GetNext();                      }                      else                          break;                  }                  else if (state == 4)                  { // state must equal 4 Josh: 6:21:10 added state 4 for field/param shortcuts  					if (Char.IsLetterOrDigit(cPeek) || cPeek == '@' ||  					cPeek == '?' || cPeek == '_' || cPeek == '}' ||  					cPeek == '!')  					{  						identifier.Append(reader.GetNext());    						if (cPeek == '}')  							break;  					}  					else if (Char.IsWhiteSpace(cPeek))  					{  						reader.GetNext(); // skip space  					}  					else  						break;                  }   			}
Magic Number,fyiReporting.RDL,Lexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Lexer.cs,ReadIdentifier,The following statement contains a magic number: if (state == 4)              {                  if (identifier[identifier.Length - 1] != '}')                      throw new ParserException(Strings.Parser_ErrorP_CurlyBracketExpected);                    identifier = new StringBuilder(ParseShortcut(identifier.ToString()));              }
Magic Number,fyiReporting.RDL,Parser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Parser.cs,MatchFuncIDent,The following statement contains a magic number: if (!bOnePart)				              {                  result = (firstPart == "Parameters")?                      ResolveParametersMethod(method' thirdPart' args):                      ResolveMethodCall(fullname' args);	// throw exception when fails              }  			else switch(method.ToLower())  			{  				case "iif":  					if (args.Length != 3)  						throw new ParserException(Strings.Parser_ErrorP_iff_function_requires_3_arguments + GetLocationInfo(curToken));  //  We allow any type for the first argument; it will get converted to boolean at runtime  //					if (args[0].GetTypeCode() != TypeCode.Boolean)  //						throw new ParserException("First argument to iif function must be boolean." + GetLocationInfo(curToken));  					result = new FunctionIif(args[0]' args[1]' args[2]);  					break;  				case "choose":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_ChooseRequires2Arguments + GetLocationInfo(curToken));  					switch (args[0].GetTypeCode())  					{  						case TypeCode.Double:  						case TypeCode.Single:  						case TypeCode.Int32:  						case TypeCode.Decimal:  						case TypeCode.Int16:  						case TypeCode.Int64:                          case TypeCode.UInt16:                          case TypeCode.UInt32:                          case TypeCode.UInt64:  							break;  						default:  							throw new ParserException(Strings.Parser_ErrorP_ChooseFirstArgumentMustNumeric + GetLocationInfo(curToken));  					}  					result = new FunctionChoose(args);  					break;  				case "switch":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_SwitchRequires2Arguments + GetLocationInfo(curToken));  				    if (args.Length % 2 != 0)  						throw new ParserException(Strings.Parser_ErrorP_SwitchMustEvenArguments + GetLocationInfo(curToken));  					for (int i=0; i < args.Length; i = i+2)  					{  						if (args[i].GetTypeCode() != TypeCode.Boolean)  							throw new ParserException(Strings.Parser_ErrorP_SwitchMustBoolean + GetLocationInfo(curToken));  					}  					result = new FunctionSwitch(args);  					break;  				case "format":  					if (args.Length > 2 || args.Length < 1)  						throw new ParserException(Strings.Parser_ErrorP_FormatRequires2Arguments + GetLocationInfo(curToken));  					if (args.Length == 1)  					{  						result = new FunctionFormat(args[0]' new ConstantString(""));  					}  					else  					{  						if (args[1].GetTypeCode() != TypeCode.String)  							throw new ParserException(Strings.Parser_ErrorP_SecondMustString + GetLocationInfo(curToken));  						result = new FunctionFormat(args[0]' args[1]);  					}  					break;    				case "fields":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_FieldsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionFieldCollection(idLookup.Fields' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                  TODO: generalize this code                          curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else  							throw new ParserException(string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Fields") + GetLocationInfo(curToken));                      }                      break;  				case "parameters":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ParametersRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionParameterCollection(idLookup.Parameters' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Parameters") + GetLocationInfo(curToken)));                      }                      break;  				case "reportitems":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ReportItemsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionReportItemCollection(idLookup.ReportItems' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "ReportItems") + GetLocationInfo(curToken)));                      }                      break;  				case "globals":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_GlobalsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionGlobalCollection(idLookup.Globals' args[0]);  					break;  				case "user":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_UserRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionUserCollection(idLookup.User' args[0]);  					break;  				case "sum":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrSum aggrFS = new FunctionAggrSum(_DataCache' args[0]' scope);  					aggrFS.LevelCheck = bSimple;  					result = aggrFS;  					break;  				case "avg":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrAvg aggrFA = new FunctionAggrAvg(_DataCache' args[0]' scope);  					aggrFA.LevelCheck = bSimple;  					result = aggrFA;  					break;  				case "min":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMin aggrFMin = new FunctionAggrMin(_DataCache' args[0]' scope);  					aggrFMin.LevelCheck = bSimple;  					result = aggrFMin;  					break;  				case "max":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMax aggrFMax = new FunctionAggrMax(_DataCache' args[0]' scope);  					aggrFMax.LevelCheck = bSimple;  					result = aggrFMax;  					break;  				case "first":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrFirst(_DataCache' args[0]' scope);  					break;  				case "last":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrLast(_DataCache' args[0]' scope);  					break;  				case "next":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrNext(_DataCache' args[0]' scope);  					break;  				case "previous":  				    scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrPrevious(_DataCache' args[0]' scope);  					break;  				case "level":  					scope = ResolveAggrScope(args' 1' out bSimple);  					result = new FunctionAggrLevel(scope);  					break;                  case "aggregate":                      scope = ResolveAggrScope(args' 2' out bSimple);                      FunctionAggrArray aggr = new FunctionAggrArray(_DataCache' args[0]' scope);                      aggr.LevelCheck = bSimple;                      result = aggr;                      break;                  case "count":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCount aggrFC = new FunctionAggrCount(_DataCache' args[0]' scope);  					aggrFC.LevelCheck = bSimple;  					result = aggrFC;  					break;  				case "countrows":  					scope = ResolveAggrScope(args' 1' out bSimple);  					FunctionAggrCountRows aggrFCR = new FunctionAggrCountRows(scope);  					aggrFCR.LevelCheck = bSimple;  					result = aggrFCR;  					break;                  case "countdistinct":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCountDistinct aggrFCD = new FunctionAggrCountDistinct(_DataCache' args[0]' scope);  					aggrFCD.LevelCheck = bSimple;  					result = aggrFCD;  					break;  				case "rownumber":  					scope = ResolveAggrScope(args' 1' out bSimple);  					IExpr texpr = new ConstantDouble("0");  					result = new FunctionAggrRvCount(_DataCache' texpr' scope);  					break;  				case "runningvalue":  					if (args.Length < 2 || args.Length > 3)  						throw new ParserException(Strings.Parser_ErrorP_RunningValue_takes_2_or_3_arguments + GetLocationInfo(curToken));  					string aggrFunc = args[1].EvaluateString(null' null);  					if (aggrFunc == null)  						throw new ParserException(Strings.Parser_ErrorP_RunningValueArgumentInvalid + GetLocationInfo(curToken));  					scope = ResolveAggrScope(args' 3' out bSimple);  					switch(aggrFunc.ToLower())  					{  						case "sum":  							result = new FunctionAggrRvSum(_DataCache' args[0]' scope);  							break;  						case "avg":  							result = new FunctionAggrRvAvg(_DataCache' args[0]' scope);  							break;  						case "count":  							result = new FunctionAggrRvCount(_DataCache' args[0]' scope);  							break;  						case "max":  							result = new FunctionAggrRvMax(_DataCache' args[0]' scope);  							break;  						case "min":  							result = new FunctionAggrRvMin(_DataCache' args[0]' scope);  							break;  						case "stdev":  							result = new FunctionAggrRvStdev(_DataCache' args[0]' scope);  							break;  						case "stdevp":  							result = new FunctionAggrRvStdevp(_DataCache' args[0]' scope);  							break;  						case "var":  							result = new FunctionAggrRvVar(_DataCache' args[0]' scope);  							break;  						case "varp":  							result = new FunctionAggrRvVarp(_DataCache' args[0]' scope);  							break;  						default:  							throw new ParserException(string.Format(Strings.Parser_ErrorP_RunningValueNotSupported' aggrFunc) + GetLocationInfo(curToken));  					}  					break;  				case "stdev":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdev aggrSDev = new FunctionAggrStdev(_DataCache' args[0]' scope);  					aggrSDev.LevelCheck = bSimple;  					result = aggrSDev;  					break;  				case "stdevp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdevp aggrSDevP = new FunctionAggrStdevp(_DataCache' args[0]' scope);  					aggrSDevP.LevelCheck = bSimple;  					result = aggrSDevP;  					break;  				case "var":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVar aggrVar = new FunctionAggrVar(_DataCache' args[0]' scope);  					aggrVar.LevelCheck = bSimple;  					result = aggrVar;  					break;  				case "varp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVarp aggrVarP = new FunctionAggrVarp(_DataCache' args[0]' scope);  					aggrVarP.LevelCheck = bSimple;  					result = aggrVarP;  					break;  				default:  					result = ResolveMethodCall(fullname' args);		// through exception when fails  					break;  			}
Magic Number,fyiReporting.RDL,Parser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Parser.cs,MatchFuncIDent,The following statement contains a magic number: if (!bOnePart)				              {                  result = (firstPart == "Parameters")?                      ResolveParametersMethod(method' thirdPart' args):                      ResolveMethodCall(fullname' args);	// throw exception when fails              }  			else switch(method.ToLower())  			{  				case "iif":  					if (args.Length != 3)  						throw new ParserException(Strings.Parser_ErrorP_iff_function_requires_3_arguments + GetLocationInfo(curToken));  //  We allow any type for the first argument; it will get converted to boolean at runtime  //					if (args[0].GetTypeCode() != TypeCode.Boolean)  //						throw new ParserException("First argument to iif function must be boolean." + GetLocationInfo(curToken));  					result = new FunctionIif(args[0]' args[1]' args[2]);  					break;  				case "choose":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_ChooseRequires2Arguments + GetLocationInfo(curToken));  					switch (args[0].GetTypeCode())  					{  						case TypeCode.Double:  						case TypeCode.Single:  						case TypeCode.Int32:  						case TypeCode.Decimal:  						case TypeCode.Int16:  						case TypeCode.Int64:                          case TypeCode.UInt16:                          case TypeCode.UInt32:                          case TypeCode.UInt64:  							break;  						default:  							throw new ParserException(Strings.Parser_ErrorP_ChooseFirstArgumentMustNumeric + GetLocationInfo(curToken));  					}  					result = new FunctionChoose(args);  					break;  				case "switch":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_SwitchRequires2Arguments + GetLocationInfo(curToken));  				    if (args.Length % 2 != 0)  						throw new ParserException(Strings.Parser_ErrorP_SwitchMustEvenArguments + GetLocationInfo(curToken));  					for (int i=0; i < args.Length; i = i+2)  					{  						if (args[i].GetTypeCode() != TypeCode.Boolean)  							throw new ParserException(Strings.Parser_ErrorP_SwitchMustBoolean + GetLocationInfo(curToken));  					}  					result = new FunctionSwitch(args);  					break;  				case "format":  					if (args.Length > 2 || args.Length < 1)  						throw new ParserException(Strings.Parser_ErrorP_FormatRequires2Arguments + GetLocationInfo(curToken));  					if (args.Length == 1)  					{  						result = new FunctionFormat(args[0]' new ConstantString(""));  					}  					else  					{  						if (args[1].GetTypeCode() != TypeCode.String)  							throw new ParserException(Strings.Parser_ErrorP_SecondMustString + GetLocationInfo(curToken));  						result = new FunctionFormat(args[0]' args[1]);  					}  					break;    				case "fields":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_FieldsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionFieldCollection(idLookup.Fields' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                  TODO: generalize this code                          curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else  							throw new ParserException(string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Fields") + GetLocationInfo(curToken));                      }                      break;  				case "parameters":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ParametersRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionParameterCollection(idLookup.Parameters' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Parameters") + GetLocationInfo(curToken)));                      }                      break;  				case "reportitems":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ReportItemsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionReportItemCollection(idLookup.ReportItems' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "ReportItems") + GetLocationInfo(curToken)));                      }                      break;  				case "globals":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_GlobalsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionGlobalCollection(idLookup.Globals' args[0]);  					break;  				case "user":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_UserRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionUserCollection(idLookup.User' args[0]);  					break;  				case "sum":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrSum aggrFS = new FunctionAggrSum(_DataCache' args[0]' scope);  					aggrFS.LevelCheck = bSimple;  					result = aggrFS;  					break;  				case "avg":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrAvg aggrFA = new FunctionAggrAvg(_DataCache' args[0]' scope);  					aggrFA.LevelCheck = bSimple;  					result = aggrFA;  					break;  				case "min":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMin aggrFMin = new FunctionAggrMin(_DataCache' args[0]' scope);  					aggrFMin.LevelCheck = bSimple;  					result = aggrFMin;  					break;  				case "max":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMax aggrFMax = new FunctionAggrMax(_DataCache' args[0]' scope);  					aggrFMax.LevelCheck = bSimple;  					result = aggrFMax;  					break;  				case "first":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrFirst(_DataCache' args[0]' scope);  					break;  				case "last":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrLast(_DataCache' args[0]' scope);  					break;  				case "next":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrNext(_DataCache' args[0]' scope);  					break;  				case "previous":  				    scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrPrevious(_DataCache' args[0]' scope);  					break;  				case "level":  					scope = ResolveAggrScope(args' 1' out bSimple);  					result = new FunctionAggrLevel(scope);  					break;                  case "aggregate":                      scope = ResolveAggrScope(args' 2' out bSimple);                      FunctionAggrArray aggr = new FunctionAggrArray(_DataCache' args[0]' scope);                      aggr.LevelCheck = bSimple;                      result = aggr;                      break;                  case "count":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCount aggrFC = new FunctionAggrCount(_DataCache' args[0]' scope);  					aggrFC.LevelCheck = bSimple;  					result = aggrFC;  					break;  				case "countrows":  					scope = ResolveAggrScope(args' 1' out bSimple);  					FunctionAggrCountRows aggrFCR = new FunctionAggrCountRows(scope);  					aggrFCR.LevelCheck = bSimple;  					result = aggrFCR;  					break;                  case "countdistinct":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCountDistinct aggrFCD = new FunctionAggrCountDistinct(_DataCache' args[0]' scope);  					aggrFCD.LevelCheck = bSimple;  					result = aggrFCD;  					break;  				case "rownumber":  					scope = ResolveAggrScope(args' 1' out bSimple);  					IExpr texpr = new ConstantDouble("0");  					result = new FunctionAggrRvCount(_DataCache' texpr' scope);  					break;  				case "runningvalue":  					if (args.Length < 2 || args.Length > 3)  						throw new ParserException(Strings.Parser_ErrorP_RunningValue_takes_2_or_3_arguments + GetLocationInfo(curToken));  					string aggrFunc = args[1].EvaluateString(null' null);  					if (aggrFunc == null)  						throw new ParserException(Strings.Parser_ErrorP_RunningValueArgumentInvalid + GetLocationInfo(curToken));  					scope = ResolveAggrScope(args' 3' out bSimple);  					switch(aggrFunc.ToLower())  					{  						case "sum":  							result = new FunctionAggrRvSum(_DataCache' args[0]' scope);  							break;  						case "avg":  							result = new FunctionAggrRvAvg(_DataCache' args[0]' scope);  							break;  						case "count":  							result = new FunctionAggrRvCount(_DataCache' args[0]' scope);  							break;  						case "max":  							result = new FunctionAggrRvMax(_DataCache' args[0]' scope);  							break;  						case "min":  							result = new FunctionAggrRvMin(_DataCache' args[0]' scope);  							break;  						case "stdev":  							result = new FunctionAggrRvStdev(_DataCache' args[0]' scope);  							break;  						case "stdevp":  							result = new FunctionAggrRvStdevp(_DataCache' args[0]' scope);  							break;  						case "var":  							result = new FunctionAggrRvVar(_DataCache' args[0]' scope);  							break;  						case "varp":  							result = new FunctionAggrRvVarp(_DataCache' args[0]' scope);  							break;  						default:  							throw new ParserException(string.Format(Strings.Parser_ErrorP_RunningValueNotSupported' aggrFunc) + GetLocationInfo(curToken));  					}  					break;  				case "stdev":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdev aggrSDev = new FunctionAggrStdev(_DataCache' args[0]' scope);  					aggrSDev.LevelCheck = bSimple;  					result = aggrSDev;  					break;  				case "stdevp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdevp aggrSDevP = new FunctionAggrStdevp(_DataCache' args[0]' scope);  					aggrSDevP.LevelCheck = bSimple;  					result = aggrSDevP;  					break;  				case "var":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVar aggrVar = new FunctionAggrVar(_DataCache' args[0]' scope);  					aggrVar.LevelCheck = bSimple;  					result = aggrVar;  					break;  				case "varp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVarp aggrVarP = new FunctionAggrVarp(_DataCache' args[0]' scope);  					aggrVarP.LevelCheck = bSimple;  					result = aggrVarP;  					break;  				default:  					result = ResolveMethodCall(fullname' args);		// through exception when fails  					break;  			}
Magic Number,fyiReporting.RDL,Parser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Parser.cs,MatchFuncIDent,The following statement contains a magic number: if (!bOnePart)				              {                  result = (firstPart == "Parameters")?                      ResolveParametersMethod(method' thirdPart' args):                      ResolveMethodCall(fullname' args);	// throw exception when fails              }  			else switch(method.ToLower())  			{  				case "iif":  					if (args.Length != 3)  						throw new ParserException(Strings.Parser_ErrorP_iff_function_requires_3_arguments + GetLocationInfo(curToken));  //  We allow any type for the first argument; it will get converted to boolean at runtime  //					if (args[0].GetTypeCode() != TypeCode.Boolean)  //						throw new ParserException("First argument to iif function must be boolean." + GetLocationInfo(curToken));  					result = new FunctionIif(args[0]' args[1]' args[2]);  					break;  				case "choose":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_ChooseRequires2Arguments + GetLocationInfo(curToken));  					switch (args[0].GetTypeCode())  					{  						case TypeCode.Double:  						case TypeCode.Single:  						case TypeCode.Int32:  						case TypeCode.Decimal:  						case TypeCode.Int16:  						case TypeCode.Int64:                          case TypeCode.UInt16:                          case TypeCode.UInt32:                          case TypeCode.UInt64:  							break;  						default:  							throw new ParserException(Strings.Parser_ErrorP_ChooseFirstArgumentMustNumeric + GetLocationInfo(curToken));  					}  					result = new FunctionChoose(args);  					break;  				case "switch":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_SwitchRequires2Arguments + GetLocationInfo(curToken));  				    if (args.Length % 2 != 0)  						throw new ParserException(Strings.Parser_ErrorP_SwitchMustEvenArguments + GetLocationInfo(curToken));  					for (int i=0; i < args.Length; i = i+2)  					{  						if (args[i].GetTypeCode() != TypeCode.Boolean)  							throw new ParserException(Strings.Parser_ErrorP_SwitchMustBoolean + GetLocationInfo(curToken));  					}  					result = new FunctionSwitch(args);  					break;  				case "format":  					if (args.Length > 2 || args.Length < 1)  						throw new ParserException(Strings.Parser_ErrorP_FormatRequires2Arguments + GetLocationInfo(curToken));  					if (args.Length == 1)  					{  						result = new FunctionFormat(args[0]' new ConstantString(""));  					}  					else  					{  						if (args[1].GetTypeCode() != TypeCode.String)  							throw new ParserException(Strings.Parser_ErrorP_SecondMustString + GetLocationInfo(curToken));  						result = new FunctionFormat(args[0]' args[1]);  					}  					break;    				case "fields":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_FieldsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionFieldCollection(idLookup.Fields' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                  TODO: generalize this code                          curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else  							throw new ParserException(string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Fields") + GetLocationInfo(curToken));                      }                      break;  				case "parameters":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ParametersRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionParameterCollection(idLookup.Parameters' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Parameters") + GetLocationInfo(curToken)));                      }                      break;  				case "reportitems":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ReportItemsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionReportItemCollection(idLookup.ReportItems' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "ReportItems") + GetLocationInfo(curToken)));                      }                      break;  				case "globals":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_GlobalsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionGlobalCollection(idLookup.Globals' args[0]);  					break;  				case "user":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_UserRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionUserCollection(idLookup.User' args[0]);  					break;  				case "sum":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrSum aggrFS = new FunctionAggrSum(_DataCache' args[0]' scope);  					aggrFS.LevelCheck = bSimple;  					result = aggrFS;  					break;  				case "avg":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrAvg aggrFA = new FunctionAggrAvg(_DataCache' args[0]' scope);  					aggrFA.LevelCheck = bSimple;  					result = aggrFA;  					break;  				case "min":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMin aggrFMin = new FunctionAggrMin(_DataCache' args[0]' scope);  					aggrFMin.LevelCheck = bSimple;  					result = aggrFMin;  					break;  				case "max":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMax aggrFMax = new FunctionAggrMax(_DataCache' args[0]' scope);  					aggrFMax.LevelCheck = bSimple;  					result = aggrFMax;  					break;  				case "first":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrFirst(_DataCache' args[0]' scope);  					break;  				case "last":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrLast(_DataCache' args[0]' scope);  					break;  				case "next":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrNext(_DataCache' args[0]' scope);  					break;  				case "previous":  				    scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrPrevious(_DataCache' args[0]' scope);  					break;  				case "level":  					scope = ResolveAggrScope(args' 1' out bSimple);  					result = new FunctionAggrLevel(scope);  					break;                  case "aggregate":                      scope = ResolveAggrScope(args' 2' out bSimple);                      FunctionAggrArray aggr = new FunctionAggrArray(_DataCache' args[0]' scope);                      aggr.LevelCheck = bSimple;                      result = aggr;                      break;                  case "count":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCount aggrFC = new FunctionAggrCount(_DataCache' args[0]' scope);  					aggrFC.LevelCheck = bSimple;  					result = aggrFC;  					break;  				case "countrows":  					scope = ResolveAggrScope(args' 1' out bSimple);  					FunctionAggrCountRows aggrFCR = new FunctionAggrCountRows(scope);  					aggrFCR.LevelCheck = bSimple;  					result = aggrFCR;  					break;                  case "countdistinct":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCountDistinct aggrFCD = new FunctionAggrCountDistinct(_DataCache' args[0]' scope);  					aggrFCD.LevelCheck = bSimple;  					result = aggrFCD;  					break;  				case "rownumber":  					scope = ResolveAggrScope(args' 1' out bSimple);  					IExpr texpr = new ConstantDouble("0");  					result = new FunctionAggrRvCount(_DataCache' texpr' scope);  					break;  				case "runningvalue":  					if (args.Length < 2 || args.Length > 3)  						throw new ParserException(Strings.Parser_ErrorP_RunningValue_takes_2_or_3_arguments + GetLocationInfo(curToken));  					string aggrFunc = args[1].EvaluateString(null' null);  					if (aggrFunc == null)  						throw new ParserException(Strings.Parser_ErrorP_RunningValueArgumentInvalid + GetLocationInfo(curToken));  					scope = ResolveAggrScope(args' 3' out bSimple);  					switch(aggrFunc.ToLower())  					{  						case "sum":  							result = new FunctionAggrRvSum(_DataCache' args[0]' scope);  							break;  						case "avg":  							result = new FunctionAggrRvAvg(_DataCache' args[0]' scope);  							break;  						case "count":  							result = new FunctionAggrRvCount(_DataCache' args[0]' scope);  							break;  						case "max":  							result = new FunctionAggrRvMax(_DataCache' args[0]' scope);  							break;  						case "min":  							result = new FunctionAggrRvMin(_DataCache' args[0]' scope);  							break;  						case "stdev":  							result = new FunctionAggrRvStdev(_DataCache' args[0]' scope);  							break;  						case "stdevp":  							result = new FunctionAggrRvStdevp(_DataCache' args[0]' scope);  							break;  						case "var":  							result = new FunctionAggrRvVar(_DataCache' args[0]' scope);  							break;  						case "varp":  							result = new FunctionAggrRvVarp(_DataCache' args[0]' scope);  							break;  						default:  							throw new ParserException(string.Format(Strings.Parser_ErrorP_RunningValueNotSupported' aggrFunc) + GetLocationInfo(curToken));  					}  					break;  				case "stdev":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdev aggrSDev = new FunctionAggrStdev(_DataCache' args[0]' scope);  					aggrSDev.LevelCheck = bSimple;  					result = aggrSDev;  					break;  				case "stdevp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdevp aggrSDevP = new FunctionAggrStdevp(_DataCache' args[0]' scope);  					aggrSDevP.LevelCheck = bSimple;  					result = aggrSDevP;  					break;  				case "var":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVar aggrVar = new FunctionAggrVar(_DataCache' args[0]' scope);  					aggrVar.LevelCheck = bSimple;  					result = aggrVar;  					break;  				case "varp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVarp aggrVarP = new FunctionAggrVarp(_DataCache' args[0]' scope);  					aggrVarP.LevelCheck = bSimple;  					result = aggrVarP;  					break;  				default:  					result = ResolveMethodCall(fullname' args);		// through exception when fails  					break;  			}
Magic Number,fyiReporting.RDL,Parser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Parser.cs,MatchFuncIDent,The following statement contains a magic number: if (!bOnePart)				              {                  result = (firstPart == "Parameters")?                      ResolveParametersMethod(method' thirdPart' args):                      ResolveMethodCall(fullname' args);	// throw exception when fails              }  			else switch(method.ToLower())  			{  				case "iif":  					if (args.Length != 3)  						throw new ParserException(Strings.Parser_ErrorP_iff_function_requires_3_arguments + GetLocationInfo(curToken));  //  We allow any type for the first argument; it will get converted to boolean at runtime  //					if (args[0].GetTypeCode() != TypeCode.Boolean)  //						throw new ParserException("First argument to iif function must be boolean." + GetLocationInfo(curToken));  					result = new FunctionIif(args[0]' args[1]' args[2]);  					break;  				case "choose":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_ChooseRequires2Arguments + GetLocationInfo(curToken));  					switch (args[0].GetTypeCode())  					{  						case TypeCode.Double:  						case TypeCode.Single:  						case TypeCode.Int32:  						case TypeCode.Decimal:  						case TypeCode.Int16:  						case TypeCode.Int64:                          case TypeCode.UInt16:                          case TypeCode.UInt32:                          case TypeCode.UInt64:  							break;  						default:  							throw new ParserException(Strings.Parser_ErrorP_ChooseFirstArgumentMustNumeric + GetLocationInfo(curToken));  					}  					result = new FunctionChoose(args);  					break;  				case "switch":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_SwitchRequires2Arguments + GetLocationInfo(curToken));  				    if (args.Length % 2 != 0)  						throw new ParserException(Strings.Parser_ErrorP_SwitchMustEvenArguments + GetLocationInfo(curToken));  					for (int i=0; i < args.Length; i = i+2)  					{  						if (args[i].GetTypeCode() != TypeCode.Boolean)  							throw new ParserException(Strings.Parser_ErrorP_SwitchMustBoolean + GetLocationInfo(curToken));  					}  					result = new FunctionSwitch(args);  					break;  				case "format":  					if (args.Length > 2 || args.Length < 1)  						throw new ParserException(Strings.Parser_ErrorP_FormatRequires2Arguments + GetLocationInfo(curToken));  					if (args.Length == 1)  					{  						result = new FunctionFormat(args[0]' new ConstantString(""));  					}  					else  					{  						if (args[1].GetTypeCode() != TypeCode.String)  							throw new ParserException(Strings.Parser_ErrorP_SecondMustString + GetLocationInfo(curToken));  						result = new FunctionFormat(args[0]' args[1]);  					}  					break;    				case "fields":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_FieldsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionFieldCollection(idLookup.Fields' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                  TODO: generalize this code                          curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else  							throw new ParserException(string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Fields") + GetLocationInfo(curToken));                      }                      break;  				case "parameters":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ParametersRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionParameterCollection(idLookup.Parameters' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Parameters") + GetLocationInfo(curToken)));                      }                      break;  				case "reportitems":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ReportItemsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionReportItemCollection(idLookup.ReportItems' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "ReportItems") + GetLocationInfo(curToken)));                      }                      break;  				case "globals":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_GlobalsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionGlobalCollection(idLookup.Globals' args[0]);  					break;  				case "user":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_UserRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionUserCollection(idLookup.User' args[0]);  					break;  				case "sum":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrSum aggrFS = new FunctionAggrSum(_DataCache' args[0]' scope);  					aggrFS.LevelCheck = bSimple;  					result = aggrFS;  					break;  				case "avg":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrAvg aggrFA = new FunctionAggrAvg(_DataCache' args[0]' scope);  					aggrFA.LevelCheck = bSimple;  					result = aggrFA;  					break;  				case "min":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMin aggrFMin = new FunctionAggrMin(_DataCache' args[0]' scope);  					aggrFMin.LevelCheck = bSimple;  					result = aggrFMin;  					break;  				case "max":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMax aggrFMax = new FunctionAggrMax(_DataCache' args[0]' scope);  					aggrFMax.LevelCheck = bSimple;  					result = aggrFMax;  					break;  				case "first":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrFirst(_DataCache' args[0]' scope);  					break;  				case "last":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrLast(_DataCache' args[0]' scope);  					break;  				case "next":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrNext(_DataCache' args[0]' scope);  					break;  				case "previous":  				    scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrPrevious(_DataCache' args[0]' scope);  					break;  				case "level":  					scope = ResolveAggrScope(args' 1' out bSimple);  					result = new FunctionAggrLevel(scope);  					break;                  case "aggregate":                      scope = ResolveAggrScope(args' 2' out bSimple);                      FunctionAggrArray aggr = new FunctionAggrArray(_DataCache' args[0]' scope);                      aggr.LevelCheck = bSimple;                      result = aggr;                      break;                  case "count":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCount aggrFC = new FunctionAggrCount(_DataCache' args[0]' scope);  					aggrFC.LevelCheck = bSimple;  					result = aggrFC;  					break;  				case "countrows":  					scope = ResolveAggrScope(args' 1' out bSimple);  					FunctionAggrCountRows aggrFCR = new FunctionAggrCountRows(scope);  					aggrFCR.LevelCheck = bSimple;  					result = aggrFCR;  					break;                  case "countdistinct":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCountDistinct aggrFCD = new FunctionAggrCountDistinct(_DataCache' args[0]' scope);  					aggrFCD.LevelCheck = bSimple;  					result = aggrFCD;  					break;  				case "rownumber":  					scope = ResolveAggrScope(args' 1' out bSimple);  					IExpr texpr = new ConstantDouble("0");  					result = new FunctionAggrRvCount(_DataCache' texpr' scope);  					break;  				case "runningvalue":  					if (args.Length < 2 || args.Length > 3)  						throw new ParserException(Strings.Parser_ErrorP_RunningValue_takes_2_or_3_arguments + GetLocationInfo(curToken));  					string aggrFunc = args[1].EvaluateString(null' null);  					if (aggrFunc == null)  						throw new ParserException(Strings.Parser_ErrorP_RunningValueArgumentInvalid + GetLocationInfo(curToken));  					scope = ResolveAggrScope(args' 3' out bSimple);  					switch(aggrFunc.ToLower())  					{  						case "sum":  							result = new FunctionAggrRvSum(_DataCache' args[0]' scope);  							break;  						case "avg":  							result = new FunctionAggrRvAvg(_DataCache' args[0]' scope);  							break;  						case "count":  							result = new FunctionAggrRvCount(_DataCache' args[0]' scope);  							break;  						case "max":  							result = new FunctionAggrRvMax(_DataCache' args[0]' scope);  							break;  						case "min":  							result = new FunctionAggrRvMin(_DataCache' args[0]' scope);  							break;  						case "stdev":  							result = new FunctionAggrRvStdev(_DataCache' args[0]' scope);  							break;  						case "stdevp":  							result = new FunctionAggrRvStdevp(_DataCache' args[0]' scope);  							break;  						case "var":  							result = new FunctionAggrRvVar(_DataCache' args[0]' scope);  							break;  						case "varp":  							result = new FunctionAggrRvVarp(_DataCache' args[0]' scope);  							break;  						default:  							throw new ParserException(string.Format(Strings.Parser_ErrorP_RunningValueNotSupported' aggrFunc) + GetLocationInfo(curToken));  					}  					break;  				case "stdev":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdev aggrSDev = new FunctionAggrStdev(_DataCache' args[0]' scope);  					aggrSDev.LevelCheck = bSimple;  					result = aggrSDev;  					break;  				case "stdevp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdevp aggrSDevP = new FunctionAggrStdevp(_DataCache' args[0]' scope);  					aggrSDevP.LevelCheck = bSimple;  					result = aggrSDevP;  					break;  				case "var":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVar aggrVar = new FunctionAggrVar(_DataCache' args[0]' scope);  					aggrVar.LevelCheck = bSimple;  					result = aggrVar;  					break;  				case "varp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVarp aggrVarP = new FunctionAggrVarp(_DataCache' args[0]' scope);  					aggrVarP.LevelCheck = bSimple;  					result = aggrVarP;  					break;  				default:  					result = ResolveMethodCall(fullname' args);		// through exception when fails  					break;  			}
Magic Number,fyiReporting.RDL,Parser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Parser.cs,MatchFuncIDent,The following statement contains a magic number: if (!bOnePart)				              {                  result = (firstPart == "Parameters")?                      ResolveParametersMethod(method' thirdPart' args):                      ResolveMethodCall(fullname' args);	// throw exception when fails              }  			else switch(method.ToLower())  			{  				case "iif":  					if (args.Length != 3)  						throw new ParserException(Strings.Parser_ErrorP_iff_function_requires_3_arguments + GetLocationInfo(curToken));  //  We allow any type for the first argument; it will get converted to boolean at runtime  //					if (args[0].GetTypeCode() != TypeCode.Boolean)  //						throw new ParserException("First argument to iif function must be boolean." + GetLocationInfo(curToken));  					result = new FunctionIif(args[0]' args[1]' args[2]);  					break;  				case "choose":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_ChooseRequires2Arguments + GetLocationInfo(curToken));  					switch (args[0].GetTypeCode())  					{  						case TypeCode.Double:  						case TypeCode.Single:  						case TypeCode.Int32:  						case TypeCode.Decimal:  						case TypeCode.Int16:  						case TypeCode.Int64:                          case TypeCode.UInt16:                          case TypeCode.UInt32:                          case TypeCode.UInt64:  							break;  						default:  							throw new ParserException(Strings.Parser_ErrorP_ChooseFirstArgumentMustNumeric + GetLocationInfo(curToken));  					}  					result = new FunctionChoose(args);  					break;  				case "switch":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_SwitchRequires2Arguments + GetLocationInfo(curToken));  				    if (args.Length % 2 != 0)  						throw new ParserException(Strings.Parser_ErrorP_SwitchMustEvenArguments + GetLocationInfo(curToken));  					for (int i=0; i < args.Length; i = i+2)  					{  						if (args[i].GetTypeCode() != TypeCode.Boolean)  							throw new ParserException(Strings.Parser_ErrorP_SwitchMustBoolean + GetLocationInfo(curToken));  					}  					result = new FunctionSwitch(args);  					break;  				case "format":  					if (args.Length > 2 || args.Length < 1)  						throw new ParserException(Strings.Parser_ErrorP_FormatRequires2Arguments + GetLocationInfo(curToken));  					if (args.Length == 1)  					{  						result = new FunctionFormat(args[0]' new ConstantString(""));  					}  					else  					{  						if (args[1].GetTypeCode() != TypeCode.String)  							throw new ParserException(Strings.Parser_ErrorP_SecondMustString + GetLocationInfo(curToken));  						result = new FunctionFormat(args[0]' args[1]);  					}  					break;    				case "fields":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_FieldsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionFieldCollection(idLookup.Fields' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                  TODO: generalize this code                          curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else  							throw new ParserException(string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Fields") + GetLocationInfo(curToken));                      }                      break;  				case "parameters":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ParametersRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionParameterCollection(idLookup.Parameters' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Parameters") + GetLocationInfo(curToken)));                      }                      break;  				case "reportitems":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ReportItemsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionReportItemCollection(idLookup.ReportItems' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "ReportItems") + GetLocationInfo(curToken)));                      }                      break;  				case "globals":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_GlobalsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionGlobalCollection(idLookup.Globals' args[0]);  					break;  				case "user":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_UserRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionUserCollection(idLookup.User' args[0]);  					break;  				case "sum":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrSum aggrFS = new FunctionAggrSum(_DataCache' args[0]' scope);  					aggrFS.LevelCheck = bSimple;  					result = aggrFS;  					break;  				case "avg":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrAvg aggrFA = new FunctionAggrAvg(_DataCache' args[0]' scope);  					aggrFA.LevelCheck = bSimple;  					result = aggrFA;  					break;  				case "min":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMin aggrFMin = new FunctionAggrMin(_DataCache' args[0]' scope);  					aggrFMin.LevelCheck = bSimple;  					result = aggrFMin;  					break;  				case "max":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMax aggrFMax = new FunctionAggrMax(_DataCache' args[0]' scope);  					aggrFMax.LevelCheck = bSimple;  					result = aggrFMax;  					break;  				case "first":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrFirst(_DataCache' args[0]' scope);  					break;  				case "last":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrLast(_DataCache' args[0]' scope);  					break;  				case "next":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrNext(_DataCache' args[0]' scope);  					break;  				case "previous":  				    scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrPrevious(_DataCache' args[0]' scope);  					break;  				case "level":  					scope = ResolveAggrScope(args' 1' out bSimple);  					result = new FunctionAggrLevel(scope);  					break;                  case "aggregate":                      scope = ResolveAggrScope(args' 2' out bSimple);                      FunctionAggrArray aggr = new FunctionAggrArray(_DataCache' args[0]' scope);                      aggr.LevelCheck = bSimple;                      result = aggr;                      break;                  case "count":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCount aggrFC = new FunctionAggrCount(_DataCache' args[0]' scope);  					aggrFC.LevelCheck = bSimple;  					result = aggrFC;  					break;  				case "countrows":  					scope = ResolveAggrScope(args' 1' out bSimple);  					FunctionAggrCountRows aggrFCR = new FunctionAggrCountRows(scope);  					aggrFCR.LevelCheck = bSimple;  					result = aggrFCR;  					break;                  case "countdistinct":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCountDistinct aggrFCD = new FunctionAggrCountDistinct(_DataCache' args[0]' scope);  					aggrFCD.LevelCheck = bSimple;  					result = aggrFCD;  					break;  				case "rownumber":  					scope = ResolveAggrScope(args' 1' out bSimple);  					IExpr texpr = new ConstantDouble("0");  					result = new FunctionAggrRvCount(_DataCache' texpr' scope);  					break;  				case "runningvalue":  					if (args.Length < 2 || args.Length > 3)  						throw new ParserException(Strings.Parser_ErrorP_RunningValue_takes_2_or_3_arguments + GetLocationInfo(curToken));  					string aggrFunc = args[1].EvaluateString(null' null);  					if (aggrFunc == null)  						throw new ParserException(Strings.Parser_ErrorP_RunningValueArgumentInvalid + GetLocationInfo(curToken));  					scope = ResolveAggrScope(args' 3' out bSimple);  					switch(aggrFunc.ToLower())  					{  						case "sum":  							result = new FunctionAggrRvSum(_DataCache' args[0]' scope);  							break;  						case "avg":  							result = new FunctionAggrRvAvg(_DataCache' args[0]' scope);  							break;  						case "count":  							result = new FunctionAggrRvCount(_DataCache' args[0]' scope);  							break;  						case "max":  							result = new FunctionAggrRvMax(_DataCache' args[0]' scope);  							break;  						case "min":  							result = new FunctionAggrRvMin(_DataCache' args[0]' scope);  							break;  						case "stdev":  							result = new FunctionAggrRvStdev(_DataCache' args[0]' scope);  							break;  						case "stdevp":  							result = new FunctionAggrRvStdevp(_DataCache' args[0]' scope);  							break;  						case "var":  							result = new FunctionAggrRvVar(_DataCache' args[0]' scope);  							break;  						case "varp":  							result = new FunctionAggrRvVarp(_DataCache' args[0]' scope);  							break;  						default:  							throw new ParserException(string.Format(Strings.Parser_ErrorP_RunningValueNotSupported' aggrFunc) + GetLocationInfo(curToken));  					}  					break;  				case "stdev":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdev aggrSDev = new FunctionAggrStdev(_DataCache' args[0]' scope);  					aggrSDev.LevelCheck = bSimple;  					result = aggrSDev;  					break;  				case "stdevp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdevp aggrSDevP = new FunctionAggrStdevp(_DataCache' args[0]' scope);  					aggrSDevP.LevelCheck = bSimple;  					result = aggrSDevP;  					break;  				case "var":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVar aggrVar = new FunctionAggrVar(_DataCache' args[0]' scope);  					aggrVar.LevelCheck = bSimple;  					result = aggrVar;  					break;  				case "varp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVarp aggrVarP = new FunctionAggrVarp(_DataCache' args[0]' scope);  					aggrVarP.LevelCheck = bSimple;  					result = aggrVarP;  					break;  				default:  					result = ResolveMethodCall(fullname' args);		// through exception when fails  					break;  			}
Magic Number,fyiReporting.RDL,Parser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Parser.cs,MatchFuncIDent,The following statement contains a magic number: if (!bOnePart)				              {                  result = (firstPart == "Parameters")?                      ResolveParametersMethod(method' thirdPart' args):                      ResolveMethodCall(fullname' args);	// throw exception when fails              }  			else switch(method.ToLower())  			{  				case "iif":  					if (args.Length != 3)  						throw new ParserException(Strings.Parser_ErrorP_iff_function_requires_3_arguments + GetLocationInfo(curToken));  //  We allow any type for the first argument; it will get converted to boolean at runtime  //					if (args[0].GetTypeCode() != TypeCode.Boolean)  //						throw new ParserException("First argument to iif function must be boolean." + GetLocationInfo(curToken));  					result = new FunctionIif(args[0]' args[1]' args[2]);  					break;  				case "choose":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_ChooseRequires2Arguments + GetLocationInfo(curToken));  					switch (args[0].GetTypeCode())  					{  						case TypeCode.Double:  						case TypeCode.Single:  						case TypeCode.Int32:  						case TypeCode.Decimal:  						case TypeCode.Int16:  						case TypeCode.Int64:                          case TypeCode.UInt16:                          case TypeCode.UInt32:                          case TypeCode.UInt64:  							break;  						default:  							throw new ParserException(Strings.Parser_ErrorP_ChooseFirstArgumentMustNumeric + GetLocationInfo(curToken));  					}  					result = new FunctionChoose(args);  					break;  				case "switch":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_SwitchRequires2Arguments + GetLocationInfo(curToken));  				    if (args.Length % 2 != 0)  						throw new ParserException(Strings.Parser_ErrorP_SwitchMustEvenArguments + GetLocationInfo(curToken));  					for (int i=0; i < args.Length; i = i+2)  					{  						if (args[i].GetTypeCode() != TypeCode.Boolean)  							throw new ParserException(Strings.Parser_ErrorP_SwitchMustBoolean + GetLocationInfo(curToken));  					}  					result = new FunctionSwitch(args);  					break;  				case "format":  					if (args.Length > 2 || args.Length < 1)  						throw new ParserException(Strings.Parser_ErrorP_FormatRequires2Arguments + GetLocationInfo(curToken));  					if (args.Length == 1)  					{  						result = new FunctionFormat(args[0]' new ConstantString(""));  					}  					else  					{  						if (args[1].GetTypeCode() != TypeCode.String)  							throw new ParserException(Strings.Parser_ErrorP_SecondMustString + GetLocationInfo(curToken));  						result = new FunctionFormat(args[0]' args[1]);  					}  					break;    				case "fields":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_FieldsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionFieldCollection(idLookup.Fields' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                  TODO: generalize this code                          curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else  							throw new ParserException(string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Fields") + GetLocationInfo(curToken));                      }                      break;  				case "parameters":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ParametersRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionParameterCollection(idLookup.Parameters' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Parameters") + GetLocationInfo(curToken)));                      }                      break;  				case "reportitems":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ReportItemsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionReportItemCollection(idLookup.ReportItems' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "ReportItems") + GetLocationInfo(curToken)));                      }                      break;  				case "globals":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_GlobalsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionGlobalCollection(idLookup.Globals' args[0]);  					break;  				case "user":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_UserRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionUserCollection(idLookup.User' args[0]);  					break;  				case "sum":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrSum aggrFS = new FunctionAggrSum(_DataCache' args[0]' scope);  					aggrFS.LevelCheck = bSimple;  					result = aggrFS;  					break;  				case "avg":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrAvg aggrFA = new FunctionAggrAvg(_DataCache' args[0]' scope);  					aggrFA.LevelCheck = bSimple;  					result = aggrFA;  					break;  				case "min":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMin aggrFMin = new FunctionAggrMin(_DataCache' args[0]' scope);  					aggrFMin.LevelCheck = bSimple;  					result = aggrFMin;  					break;  				case "max":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMax aggrFMax = new FunctionAggrMax(_DataCache' args[0]' scope);  					aggrFMax.LevelCheck = bSimple;  					result = aggrFMax;  					break;  				case "first":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrFirst(_DataCache' args[0]' scope);  					break;  				case "last":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrLast(_DataCache' args[0]' scope);  					break;  				case "next":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrNext(_DataCache' args[0]' scope);  					break;  				case "previous":  				    scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrPrevious(_DataCache' args[0]' scope);  					break;  				case "level":  					scope = ResolveAggrScope(args' 1' out bSimple);  					result = new FunctionAggrLevel(scope);  					break;                  case "aggregate":                      scope = ResolveAggrScope(args' 2' out bSimple);                      FunctionAggrArray aggr = new FunctionAggrArray(_DataCache' args[0]' scope);                      aggr.LevelCheck = bSimple;                      result = aggr;                      break;                  case "count":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCount aggrFC = new FunctionAggrCount(_DataCache' args[0]' scope);  					aggrFC.LevelCheck = bSimple;  					result = aggrFC;  					break;  				case "countrows":  					scope = ResolveAggrScope(args' 1' out bSimple);  					FunctionAggrCountRows aggrFCR = new FunctionAggrCountRows(scope);  					aggrFCR.LevelCheck = bSimple;  					result = aggrFCR;  					break;                  case "countdistinct":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCountDistinct aggrFCD = new FunctionAggrCountDistinct(_DataCache' args[0]' scope);  					aggrFCD.LevelCheck = bSimple;  					result = aggrFCD;  					break;  				case "rownumber":  					scope = ResolveAggrScope(args' 1' out bSimple);  					IExpr texpr = new ConstantDouble("0");  					result = new FunctionAggrRvCount(_DataCache' texpr' scope);  					break;  				case "runningvalue":  					if (args.Length < 2 || args.Length > 3)  						throw new ParserException(Strings.Parser_ErrorP_RunningValue_takes_2_or_3_arguments + GetLocationInfo(curToken));  					string aggrFunc = args[1].EvaluateString(null' null);  					if (aggrFunc == null)  						throw new ParserException(Strings.Parser_ErrorP_RunningValueArgumentInvalid + GetLocationInfo(curToken));  					scope = ResolveAggrScope(args' 3' out bSimple);  					switch(aggrFunc.ToLower())  					{  						case "sum":  							result = new FunctionAggrRvSum(_DataCache' args[0]' scope);  							break;  						case "avg":  							result = new FunctionAggrRvAvg(_DataCache' args[0]' scope);  							break;  						case "count":  							result = new FunctionAggrRvCount(_DataCache' args[0]' scope);  							break;  						case "max":  							result = new FunctionAggrRvMax(_DataCache' args[0]' scope);  							break;  						case "min":  							result = new FunctionAggrRvMin(_DataCache' args[0]' scope);  							break;  						case "stdev":  							result = new FunctionAggrRvStdev(_DataCache' args[0]' scope);  							break;  						case "stdevp":  							result = new FunctionAggrRvStdevp(_DataCache' args[0]' scope);  							break;  						case "var":  							result = new FunctionAggrRvVar(_DataCache' args[0]' scope);  							break;  						case "varp":  							result = new FunctionAggrRvVarp(_DataCache' args[0]' scope);  							break;  						default:  							throw new ParserException(string.Format(Strings.Parser_ErrorP_RunningValueNotSupported' aggrFunc) + GetLocationInfo(curToken));  					}  					break;  				case "stdev":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdev aggrSDev = new FunctionAggrStdev(_DataCache' args[0]' scope);  					aggrSDev.LevelCheck = bSimple;  					result = aggrSDev;  					break;  				case "stdevp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdevp aggrSDevP = new FunctionAggrStdevp(_DataCache' args[0]' scope);  					aggrSDevP.LevelCheck = bSimple;  					result = aggrSDevP;  					break;  				case "var":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVar aggrVar = new FunctionAggrVar(_DataCache' args[0]' scope);  					aggrVar.LevelCheck = bSimple;  					result = aggrVar;  					break;  				case "varp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVarp aggrVarP = new FunctionAggrVarp(_DataCache' args[0]' scope);  					aggrVarP.LevelCheck = bSimple;  					result = aggrVarP;  					break;  				default:  					result = ResolveMethodCall(fullname' args);		// through exception when fails  					break;  			}
Magic Number,fyiReporting.RDL,Parser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Parser.cs,MatchFuncIDent,The following statement contains a magic number: if (!bOnePart)				              {                  result = (firstPart == "Parameters")?                      ResolveParametersMethod(method' thirdPart' args):                      ResolveMethodCall(fullname' args);	// throw exception when fails              }  			else switch(method.ToLower())  			{  				case "iif":  					if (args.Length != 3)  						throw new ParserException(Strings.Parser_ErrorP_iff_function_requires_3_arguments + GetLocationInfo(curToken));  //  We allow any type for the first argument; it will get converted to boolean at runtime  //					if (args[0].GetTypeCode() != TypeCode.Boolean)  //						throw new ParserException("First argument to iif function must be boolean." + GetLocationInfo(curToken));  					result = new FunctionIif(args[0]' args[1]' args[2]);  					break;  				case "choose":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_ChooseRequires2Arguments + GetLocationInfo(curToken));  					switch (args[0].GetTypeCode())  					{  						case TypeCode.Double:  						case TypeCode.Single:  						case TypeCode.Int32:  						case TypeCode.Decimal:  						case TypeCode.Int16:  						case TypeCode.Int64:                          case TypeCode.UInt16:                          case TypeCode.UInt32:                          case TypeCode.UInt64:  							break;  						default:  							throw new ParserException(Strings.Parser_ErrorP_ChooseFirstArgumentMustNumeric + GetLocationInfo(curToken));  					}  					result = new FunctionChoose(args);  					break;  				case "switch":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_SwitchRequires2Arguments + GetLocationInfo(curToken));  				    if (args.Length % 2 != 0)  						throw new ParserException(Strings.Parser_ErrorP_SwitchMustEvenArguments + GetLocationInfo(curToken));  					for (int i=0; i < args.Length; i = i+2)  					{  						if (args[i].GetTypeCode() != TypeCode.Boolean)  							throw new ParserException(Strings.Parser_ErrorP_SwitchMustBoolean + GetLocationInfo(curToken));  					}  					result = new FunctionSwitch(args);  					break;  				case "format":  					if (args.Length > 2 || args.Length < 1)  						throw new ParserException(Strings.Parser_ErrorP_FormatRequires2Arguments + GetLocationInfo(curToken));  					if (args.Length == 1)  					{  						result = new FunctionFormat(args[0]' new ConstantString(""));  					}  					else  					{  						if (args[1].GetTypeCode() != TypeCode.String)  							throw new ParserException(Strings.Parser_ErrorP_SecondMustString + GetLocationInfo(curToken));  						result = new FunctionFormat(args[0]' args[1]);  					}  					break;    				case "fields":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_FieldsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionFieldCollection(idLookup.Fields' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                  TODO: generalize this code                          curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else  							throw new ParserException(string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Fields") + GetLocationInfo(curToken));                      }                      break;  				case "parameters":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ParametersRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionParameterCollection(idLookup.Parameters' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Parameters") + GetLocationInfo(curToken)));                      }                      break;  				case "reportitems":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ReportItemsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionReportItemCollection(idLookup.ReportItems' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "ReportItems") + GetLocationInfo(curToken)));                      }                      break;  				case "globals":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_GlobalsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionGlobalCollection(idLookup.Globals' args[0]);  					break;  				case "user":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_UserRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionUserCollection(idLookup.User' args[0]);  					break;  				case "sum":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrSum aggrFS = new FunctionAggrSum(_DataCache' args[0]' scope);  					aggrFS.LevelCheck = bSimple;  					result = aggrFS;  					break;  				case "avg":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrAvg aggrFA = new FunctionAggrAvg(_DataCache' args[0]' scope);  					aggrFA.LevelCheck = bSimple;  					result = aggrFA;  					break;  				case "min":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMin aggrFMin = new FunctionAggrMin(_DataCache' args[0]' scope);  					aggrFMin.LevelCheck = bSimple;  					result = aggrFMin;  					break;  				case "max":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMax aggrFMax = new FunctionAggrMax(_DataCache' args[0]' scope);  					aggrFMax.LevelCheck = bSimple;  					result = aggrFMax;  					break;  				case "first":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrFirst(_DataCache' args[0]' scope);  					break;  				case "last":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrLast(_DataCache' args[0]' scope);  					break;  				case "next":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrNext(_DataCache' args[0]' scope);  					break;  				case "previous":  				    scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrPrevious(_DataCache' args[0]' scope);  					break;  				case "level":  					scope = ResolveAggrScope(args' 1' out bSimple);  					result = new FunctionAggrLevel(scope);  					break;                  case "aggregate":                      scope = ResolveAggrScope(args' 2' out bSimple);                      FunctionAggrArray aggr = new FunctionAggrArray(_DataCache' args[0]' scope);                      aggr.LevelCheck = bSimple;                      result = aggr;                      break;                  case "count":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCount aggrFC = new FunctionAggrCount(_DataCache' args[0]' scope);  					aggrFC.LevelCheck = bSimple;  					result = aggrFC;  					break;  				case "countrows":  					scope = ResolveAggrScope(args' 1' out bSimple);  					FunctionAggrCountRows aggrFCR = new FunctionAggrCountRows(scope);  					aggrFCR.LevelCheck = bSimple;  					result = aggrFCR;  					break;                  case "countdistinct":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCountDistinct aggrFCD = new FunctionAggrCountDistinct(_DataCache' args[0]' scope);  					aggrFCD.LevelCheck = bSimple;  					result = aggrFCD;  					break;  				case "rownumber":  					scope = ResolveAggrScope(args' 1' out bSimple);  					IExpr texpr = new ConstantDouble("0");  					result = new FunctionAggrRvCount(_DataCache' texpr' scope);  					break;  				case "runningvalue":  					if (args.Length < 2 || args.Length > 3)  						throw new ParserException(Strings.Parser_ErrorP_RunningValue_takes_2_or_3_arguments + GetLocationInfo(curToken));  					string aggrFunc = args[1].EvaluateString(null' null);  					if (aggrFunc == null)  						throw new ParserException(Strings.Parser_ErrorP_RunningValueArgumentInvalid + GetLocationInfo(curToken));  					scope = ResolveAggrScope(args' 3' out bSimple);  					switch(aggrFunc.ToLower())  					{  						case "sum":  							result = new FunctionAggrRvSum(_DataCache' args[0]' scope);  							break;  						case "avg":  							result = new FunctionAggrRvAvg(_DataCache' args[0]' scope);  							break;  						case "count":  							result = new FunctionAggrRvCount(_DataCache' args[0]' scope);  							break;  						case "max":  							result = new FunctionAggrRvMax(_DataCache' args[0]' scope);  							break;  						case "min":  							result = new FunctionAggrRvMin(_DataCache' args[0]' scope);  							break;  						case "stdev":  							result = new FunctionAggrRvStdev(_DataCache' args[0]' scope);  							break;  						case "stdevp":  							result = new FunctionAggrRvStdevp(_DataCache' args[0]' scope);  							break;  						case "var":  							result = new FunctionAggrRvVar(_DataCache' args[0]' scope);  							break;  						case "varp":  							result = new FunctionAggrRvVarp(_DataCache' args[0]' scope);  							break;  						default:  							throw new ParserException(string.Format(Strings.Parser_ErrorP_RunningValueNotSupported' aggrFunc) + GetLocationInfo(curToken));  					}  					break;  				case "stdev":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdev aggrSDev = new FunctionAggrStdev(_DataCache' args[0]' scope);  					aggrSDev.LevelCheck = bSimple;  					result = aggrSDev;  					break;  				case "stdevp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdevp aggrSDevP = new FunctionAggrStdevp(_DataCache' args[0]' scope);  					aggrSDevP.LevelCheck = bSimple;  					result = aggrSDevP;  					break;  				case "var":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVar aggrVar = new FunctionAggrVar(_DataCache' args[0]' scope);  					aggrVar.LevelCheck = bSimple;  					result = aggrVar;  					break;  				case "varp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVarp aggrVarP = new FunctionAggrVarp(_DataCache' args[0]' scope);  					aggrVarP.LevelCheck = bSimple;  					result = aggrVarP;  					break;  				default:  					result = ResolveMethodCall(fullname' args);		// through exception when fails  					break;  			}
Magic Number,fyiReporting.RDL,Parser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Parser.cs,MatchFuncIDent,The following statement contains a magic number: if (!bOnePart)				              {                  result = (firstPart == "Parameters")?                      ResolveParametersMethod(method' thirdPart' args):                      ResolveMethodCall(fullname' args);	// throw exception when fails              }  			else switch(method.ToLower())  			{  				case "iif":  					if (args.Length != 3)  						throw new ParserException(Strings.Parser_ErrorP_iff_function_requires_3_arguments + GetLocationInfo(curToken));  //  We allow any type for the first argument; it will get converted to boolean at runtime  //					if (args[0].GetTypeCode() != TypeCode.Boolean)  //						throw new ParserException("First argument to iif function must be boolean." + GetLocationInfo(curToken));  					result = new FunctionIif(args[0]' args[1]' args[2]);  					break;  				case "choose":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_ChooseRequires2Arguments + GetLocationInfo(curToken));  					switch (args[0].GetTypeCode())  					{  						case TypeCode.Double:  						case TypeCode.Single:  						case TypeCode.Int32:  						case TypeCode.Decimal:  						case TypeCode.Int16:  						case TypeCode.Int64:                          case TypeCode.UInt16:                          case TypeCode.UInt32:                          case TypeCode.UInt64:  							break;  						default:  							throw new ParserException(Strings.Parser_ErrorP_ChooseFirstArgumentMustNumeric + GetLocationInfo(curToken));  					}  					result = new FunctionChoose(args);  					break;  				case "switch":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_SwitchRequires2Arguments + GetLocationInfo(curToken));  				    if (args.Length % 2 != 0)  						throw new ParserException(Strings.Parser_ErrorP_SwitchMustEvenArguments + GetLocationInfo(curToken));  					for (int i=0; i < args.Length; i = i+2)  					{  						if (args[i].GetTypeCode() != TypeCode.Boolean)  							throw new ParserException(Strings.Parser_ErrorP_SwitchMustBoolean + GetLocationInfo(curToken));  					}  					result = new FunctionSwitch(args);  					break;  				case "format":  					if (args.Length > 2 || args.Length < 1)  						throw new ParserException(Strings.Parser_ErrorP_FormatRequires2Arguments + GetLocationInfo(curToken));  					if (args.Length == 1)  					{  						result = new FunctionFormat(args[0]' new ConstantString(""));  					}  					else  					{  						if (args[1].GetTypeCode() != TypeCode.String)  							throw new ParserException(Strings.Parser_ErrorP_SecondMustString + GetLocationInfo(curToken));  						result = new FunctionFormat(args[0]' args[1]);  					}  					break;    				case "fields":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_FieldsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionFieldCollection(idLookup.Fields' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                  TODO: generalize this code                          curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else  							throw new ParserException(string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Fields") + GetLocationInfo(curToken));                      }                      break;  				case "parameters":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ParametersRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionParameterCollection(idLookup.Parameters' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Parameters") + GetLocationInfo(curToken)));                      }                      break;  				case "reportitems":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ReportItemsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionReportItemCollection(idLookup.ReportItems' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "ReportItems") + GetLocationInfo(curToken)));                      }                      break;  				case "globals":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_GlobalsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionGlobalCollection(idLookup.Globals' args[0]);  					break;  				case "user":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_UserRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionUserCollection(idLookup.User' args[0]);  					break;  				case "sum":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrSum aggrFS = new FunctionAggrSum(_DataCache' args[0]' scope);  					aggrFS.LevelCheck = bSimple;  					result = aggrFS;  					break;  				case "avg":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrAvg aggrFA = new FunctionAggrAvg(_DataCache' args[0]' scope);  					aggrFA.LevelCheck = bSimple;  					result = aggrFA;  					break;  				case "min":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMin aggrFMin = new FunctionAggrMin(_DataCache' args[0]' scope);  					aggrFMin.LevelCheck = bSimple;  					result = aggrFMin;  					break;  				case "max":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMax aggrFMax = new FunctionAggrMax(_DataCache' args[0]' scope);  					aggrFMax.LevelCheck = bSimple;  					result = aggrFMax;  					break;  				case "first":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrFirst(_DataCache' args[0]' scope);  					break;  				case "last":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrLast(_DataCache' args[0]' scope);  					break;  				case "next":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrNext(_DataCache' args[0]' scope);  					break;  				case "previous":  				    scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrPrevious(_DataCache' args[0]' scope);  					break;  				case "level":  					scope = ResolveAggrScope(args' 1' out bSimple);  					result = new FunctionAggrLevel(scope);  					break;                  case "aggregate":                      scope = ResolveAggrScope(args' 2' out bSimple);                      FunctionAggrArray aggr = new FunctionAggrArray(_DataCache' args[0]' scope);                      aggr.LevelCheck = bSimple;                      result = aggr;                      break;                  case "count":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCount aggrFC = new FunctionAggrCount(_DataCache' args[0]' scope);  					aggrFC.LevelCheck = bSimple;  					result = aggrFC;  					break;  				case "countrows":  					scope = ResolveAggrScope(args' 1' out bSimple);  					FunctionAggrCountRows aggrFCR = new FunctionAggrCountRows(scope);  					aggrFCR.LevelCheck = bSimple;  					result = aggrFCR;  					break;                  case "countdistinct":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCountDistinct aggrFCD = new FunctionAggrCountDistinct(_DataCache' args[0]' scope);  					aggrFCD.LevelCheck = bSimple;  					result = aggrFCD;  					break;  				case "rownumber":  					scope = ResolveAggrScope(args' 1' out bSimple);  					IExpr texpr = new ConstantDouble("0");  					result = new FunctionAggrRvCount(_DataCache' texpr' scope);  					break;  				case "runningvalue":  					if (args.Length < 2 || args.Length > 3)  						throw new ParserException(Strings.Parser_ErrorP_RunningValue_takes_2_or_3_arguments + GetLocationInfo(curToken));  					string aggrFunc = args[1].EvaluateString(null' null);  					if (aggrFunc == null)  						throw new ParserException(Strings.Parser_ErrorP_RunningValueArgumentInvalid + GetLocationInfo(curToken));  					scope = ResolveAggrScope(args' 3' out bSimple);  					switch(aggrFunc.ToLower())  					{  						case "sum":  							result = new FunctionAggrRvSum(_DataCache' args[0]' scope);  							break;  						case "avg":  							result = new FunctionAggrRvAvg(_DataCache' args[0]' scope);  							break;  						case "count":  							result = new FunctionAggrRvCount(_DataCache' args[0]' scope);  							break;  						case "max":  							result = new FunctionAggrRvMax(_DataCache' args[0]' scope);  							break;  						case "min":  							result = new FunctionAggrRvMin(_DataCache' args[0]' scope);  							break;  						case "stdev":  							result = new FunctionAggrRvStdev(_DataCache' args[0]' scope);  							break;  						case "stdevp":  							result = new FunctionAggrRvStdevp(_DataCache' args[0]' scope);  							break;  						case "var":  							result = new FunctionAggrRvVar(_DataCache' args[0]' scope);  							break;  						case "varp":  							result = new FunctionAggrRvVarp(_DataCache' args[0]' scope);  							break;  						default:  							throw new ParserException(string.Format(Strings.Parser_ErrorP_RunningValueNotSupported' aggrFunc) + GetLocationInfo(curToken));  					}  					break;  				case "stdev":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdev aggrSDev = new FunctionAggrStdev(_DataCache' args[0]' scope);  					aggrSDev.LevelCheck = bSimple;  					result = aggrSDev;  					break;  				case "stdevp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdevp aggrSDevP = new FunctionAggrStdevp(_DataCache' args[0]' scope);  					aggrSDevP.LevelCheck = bSimple;  					result = aggrSDevP;  					break;  				case "var":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVar aggrVar = new FunctionAggrVar(_DataCache' args[0]' scope);  					aggrVar.LevelCheck = bSimple;  					result = aggrVar;  					break;  				case "varp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVarp aggrVarP = new FunctionAggrVarp(_DataCache' args[0]' scope);  					aggrVarP.LevelCheck = bSimple;  					result = aggrVarP;  					break;  				default:  					result = ResolveMethodCall(fullname' args);		// through exception when fails  					break;  			}
Magic Number,fyiReporting.RDL,Parser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Parser.cs,MatchFuncIDent,The following statement contains a magic number: if (!bOnePart)				              {                  result = (firstPart == "Parameters")?                      ResolveParametersMethod(method' thirdPart' args):                      ResolveMethodCall(fullname' args);	// throw exception when fails              }  			else switch(method.ToLower())  			{  				case "iif":  					if (args.Length != 3)  						throw new ParserException(Strings.Parser_ErrorP_iff_function_requires_3_arguments + GetLocationInfo(curToken));  //  We allow any type for the first argument; it will get converted to boolean at runtime  //					if (args[0].GetTypeCode() != TypeCode.Boolean)  //						throw new ParserException("First argument to iif function must be boolean." + GetLocationInfo(curToken));  					result = new FunctionIif(args[0]' args[1]' args[2]);  					break;  				case "choose":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_ChooseRequires2Arguments + GetLocationInfo(curToken));  					switch (args[0].GetTypeCode())  					{  						case TypeCode.Double:  						case TypeCode.Single:  						case TypeCode.Int32:  						case TypeCode.Decimal:  						case TypeCode.Int16:  						case TypeCode.Int64:                          case TypeCode.UInt16:                          case TypeCode.UInt32:                          case TypeCode.UInt64:  							break;  						default:  							throw new ParserException(Strings.Parser_ErrorP_ChooseFirstArgumentMustNumeric + GetLocationInfo(curToken));  					}  					result = new FunctionChoose(args);  					break;  				case "switch":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_SwitchRequires2Arguments + GetLocationInfo(curToken));  				    if (args.Length % 2 != 0)  						throw new ParserException(Strings.Parser_ErrorP_SwitchMustEvenArguments + GetLocationInfo(curToken));  					for (int i=0; i < args.Length; i = i+2)  					{  						if (args[i].GetTypeCode() != TypeCode.Boolean)  							throw new ParserException(Strings.Parser_ErrorP_SwitchMustBoolean + GetLocationInfo(curToken));  					}  					result = new FunctionSwitch(args);  					break;  				case "format":  					if (args.Length > 2 || args.Length < 1)  						throw new ParserException(Strings.Parser_ErrorP_FormatRequires2Arguments + GetLocationInfo(curToken));  					if (args.Length == 1)  					{  						result = new FunctionFormat(args[0]' new ConstantString(""));  					}  					else  					{  						if (args[1].GetTypeCode() != TypeCode.String)  							throw new ParserException(Strings.Parser_ErrorP_SecondMustString + GetLocationInfo(curToken));  						result = new FunctionFormat(args[0]' args[1]);  					}  					break;    				case "fields":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_FieldsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionFieldCollection(idLookup.Fields' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                  TODO: generalize this code                          curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else  							throw new ParserException(string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Fields") + GetLocationInfo(curToken));                      }                      break;  				case "parameters":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ParametersRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionParameterCollection(idLookup.Parameters' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Parameters") + GetLocationInfo(curToken)));                      }                      break;  				case "reportitems":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ReportItemsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionReportItemCollection(idLookup.ReportItems' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "ReportItems") + GetLocationInfo(curToken)));                      }                      break;  				case "globals":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_GlobalsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionGlobalCollection(idLookup.Globals' args[0]);  					break;  				case "user":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_UserRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionUserCollection(idLookup.User' args[0]);  					break;  				case "sum":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrSum aggrFS = new FunctionAggrSum(_DataCache' args[0]' scope);  					aggrFS.LevelCheck = bSimple;  					result = aggrFS;  					break;  				case "avg":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrAvg aggrFA = new FunctionAggrAvg(_DataCache' args[0]' scope);  					aggrFA.LevelCheck = bSimple;  					result = aggrFA;  					break;  				case "min":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMin aggrFMin = new FunctionAggrMin(_DataCache' args[0]' scope);  					aggrFMin.LevelCheck = bSimple;  					result = aggrFMin;  					break;  				case "max":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMax aggrFMax = new FunctionAggrMax(_DataCache' args[0]' scope);  					aggrFMax.LevelCheck = bSimple;  					result = aggrFMax;  					break;  				case "first":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrFirst(_DataCache' args[0]' scope);  					break;  				case "last":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrLast(_DataCache' args[0]' scope);  					break;  				case "next":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrNext(_DataCache' args[0]' scope);  					break;  				case "previous":  				    scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrPrevious(_DataCache' args[0]' scope);  					break;  				case "level":  					scope = ResolveAggrScope(args' 1' out bSimple);  					result = new FunctionAggrLevel(scope);  					break;                  case "aggregate":                      scope = ResolveAggrScope(args' 2' out bSimple);                      FunctionAggrArray aggr = new FunctionAggrArray(_DataCache' args[0]' scope);                      aggr.LevelCheck = bSimple;                      result = aggr;                      break;                  case "count":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCount aggrFC = new FunctionAggrCount(_DataCache' args[0]' scope);  					aggrFC.LevelCheck = bSimple;  					result = aggrFC;  					break;  				case "countrows":  					scope = ResolveAggrScope(args' 1' out bSimple);  					FunctionAggrCountRows aggrFCR = new FunctionAggrCountRows(scope);  					aggrFCR.LevelCheck = bSimple;  					result = aggrFCR;  					break;                  case "countdistinct":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCountDistinct aggrFCD = new FunctionAggrCountDistinct(_DataCache' args[0]' scope);  					aggrFCD.LevelCheck = bSimple;  					result = aggrFCD;  					break;  				case "rownumber":  					scope = ResolveAggrScope(args' 1' out bSimple);  					IExpr texpr = new ConstantDouble("0");  					result = new FunctionAggrRvCount(_DataCache' texpr' scope);  					break;  				case "runningvalue":  					if (args.Length < 2 || args.Length > 3)  						throw new ParserException(Strings.Parser_ErrorP_RunningValue_takes_2_or_3_arguments + GetLocationInfo(curToken));  					string aggrFunc = args[1].EvaluateString(null' null);  					if (aggrFunc == null)  						throw new ParserException(Strings.Parser_ErrorP_RunningValueArgumentInvalid + GetLocationInfo(curToken));  					scope = ResolveAggrScope(args' 3' out bSimple);  					switch(aggrFunc.ToLower())  					{  						case "sum":  							result = new FunctionAggrRvSum(_DataCache' args[0]' scope);  							break;  						case "avg":  							result = new FunctionAggrRvAvg(_DataCache' args[0]' scope);  							break;  						case "count":  							result = new FunctionAggrRvCount(_DataCache' args[0]' scope);  							break;  						case "max":  							result = new FunctionAggrRvMax(_DataCache' args[0]' scope);  							break;  						case "min":  							result = new FunctionAggrRvMin(_DataCache' args[0]' scope);  							break;  						case "stdev":  							result = new FunctionAggrRvStdev(_DataCache' args[0]' scope);  							break;  						case "stdevp":  							result = new FunctionAggrRvStdevp(_DataCache' args[0]' scope);  							break;  						case "var":  							result = new FunctionAggrRvVar(_DataCache' args[0]' scope);  							break;  						case "varp":  							result = new FunctionAggrRvVarp(_DataCache' args[0]' scope);  							break;  						default:  							throw new ParserException(string.Format(Strings.Parser_ErrorP_RunningValueNotSupported' aggrFunc) + GetLocationInfo(curToken));  					}  					break;  				case "stdev":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdev aggrSDev = new FunctionAggrStdev(_DataCache' args[0]' scope);  					aggrSDev.LevelCheck = bSimple;  					result = aggrSDev;  					break;  				case "stdevp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdevp aggrSDevP = new FunctionAggrStdevp(_DataCache' args[0]' scope);  					aggrSDevP.LevelCheck = bSimple;  					result = aggrSDevP;  					break;  				case "var":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVar aggrVar = new FunctionAggrVar(_DataCache' args[0]' scope);  					aggrVar.LevelCheck = bSimple;  					result = aggrVar;  					break;  				case "varp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVarp aggrVarP = new FunctionAggrVarp(_DataCache' args[0]' scope);  					aggrVarP.LevelCheck = bSimple;  					result = aggrVarP;  					break;  				default:  					result = ResolveMethodCall(fullname' args);		// through exception when fails  					break;  			}
Magic Number,fyiReporting.RDL,Parser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Parser.cs,MatchFuncIDent,The following statement contains a magic number: if (!bOnePart)				              {                  result = (firstPart == "Parameters")?                      ResolveParametersMethod(method' thirdPart' args):                      ResolveMethodCall(fullname' args);	// throw exception when fails              }  			else switch(method.ToLower())  			{  				case "iif":  					if (args.Length != 3)  						throw new ParserException(Strings.Parser_ErrorP_iff_function_requires_3_arguments + GetLocationInfo(curToken));  //  We allow any type for the first argument; it will get converted to boolean at runtime  //					if (args[0].GetTypeCode() != TypeCode.Boolean)  //						throw new ParserException("First argument to iif function must be boolean." + GetLocationInfo(curToken));  					result = new FunctionIif(args[0]' args[1]' args[2]);  					break;  				case "choose":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_ChooseRequires2Arguments + GetLocationInfo(curToken));  					switch (args[0].GetTypeCode())  					{  						case TypeCode.Double:  						case TypeCode.Single:  						case TypeCode.Int32:  						case TypeCode.Decimal:  						case TypeCode.Int16:  						case TypeCode.Int64:                          case TypeCode.UInt16:                          case TypeCode.UInt32:                          case TypeCode.UInt64:  							break;  						default:  							throw new ParserException(Strings.Parser_ErrorP_ChooseFirstArgumentMustNumeric + GetLocationInfo(curToken));  					}  					result = new FunctionChoose(args);  					break;  				case "switch":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_SwitchRequires2Arguments + GetLocationInfo(curToken));  				    if (args.Length % 2 != 0)  						throw new ParserException(Strings.Parser_ErrorP_SwitchMustEvenArguments + GetLocationInfo(curToken));  					for (int i=0; i < args.Length; i = i+2)  					{  						if (args[i].GetTypeCode() != TypeCode.Boolean)  							throw new ParserException(Strings.Parser_ErrorP_SwitchMustBoolean + GetLocationInfo(curToken));  					}  					result = new FunctionSwitch(args);  					break;  				case "format":  					if (args.Length > 2 || args.Length < 1)  						throw new ParserException(Strings.Parser_ErrorP_FormatRequires2Arguments + GetLocationInfo(curToken));  					if (args.Length == 1)  					{  						result = new FunctionFormat(args[0]' new ConstantString(""));  					}  					else  					{  						if (args[1].GetTypeCode() != TypeCode.String)  							throw new ParserException(Strings.Parser_ErrorP_SecondMustString + GetLocationInfo(curToken));  						result = new FunctionFormat(args[0]' args[1]);  					}  					break;    				case "fields":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_FieldsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionFieldCollection(idLookup.Fields' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                  TODO: generalize this code                          curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else  							throw new ParserException(string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Fields") + GetLocationInfo(curToken));                      }                      break;  				case "parameters":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ParametersRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionParameterCollection(idLookup.Parameters' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Parameters") + GetLocationInfo(curToken)));                      }                      break;  				case "reportitems":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ReportItemsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionReportItemCollection(idLookup.ReportItems' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "ReportItems") + GetLocationInfo(curToken)));                      }                      break;  				case "globals":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_GlobalsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionGlobalCollection(idLookup.Globals' args[0]);  					break;  				case "user":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_UserRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionUserCollection(idLookup.User' args[0]);  					break;  				case "sum":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrSum aggrFS = new FunctionAggrSum(_DataCache' args[0]' scope);  					aggrFS.LevelCheck = bSimple;  					result = aggrFS;  					break;  				case "avg":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrAvg aggrFA = new FunctionAggrAvg(_DataCache' args[0]' scope);  					aggrFA.LevelCheck = bSimple;  					result = aggrFA;  					break;  				case "min":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMin aggrFMin = new FunctionAggrMin(_DataCache' args[0]' scope);  					aggrFMin.LevelCheck = bSimple;  					result = aggrFMin;  					break;  				case "max":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMax aggrFMax = new FunctionAggrMax(_DataCache' args[0]' scope);  					aggrFMax.LevelCheck = bSimple;  					result = aggrFMax;  					break;  				case "first":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrFirst(_DataCache' args[0]' scope);  					break;  				case "last":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrLast(_DataCache' args[0]' scope);  					break;  				case "next":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrNext(_DataCache' args[0]' scope);  					break;  				case "previous":  				    scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrPrevious(_DataCache' args[0]' scope);  					break;  				case "level":  					scope = ResolveAggrScope(args' 1' out bSimple);  					result = new FunctionAggrLevel(scope);  					break;                  case "aggregate":                      scope = ResolveAggrScope(args' 2' out bSimple);                      FunctionAggrArray aggr = new FunctionAggrArray(_DataCache' args[0]' scope);                      aggr.LevelCheck = bSimple;                      result = aggr;                      break;                  case "count":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCount aggrFC = new FunctionAggrCount(_DataCache' args[0]' scope);  					aggrFC.LevelCheck = bSimple;  					result = aggrFC;  					break;  				case "countrows":  					scope = ResolveAggrScope(args' 1' out bSimple);  					FunctionAggrCountRows aggrFCR = new FunctionAggrCountRows(scope);  					aggrFCR.LevelCheck = bSimple;  					result = aggrFCR;  					break;                  case "countdistinct":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCountDistinct aggrFCD = new FunctionAggrCountDistinct(_DataCache' args[0]' scope);  					aggrFCD.LevelCheck = bSimple;  					result = aggrFCD;  					break;  				case "rownumber":  					scope = ResolveAggrScope(args' 1' out bSimple);  					IExpr texpr = new ConstantDouble("0");  					result = new FunctionAggrRvCount(_DataCache' texpr' scope);  					break;  				case "runningvalue":  					if (args.Length < 2 || args.Length > 3)  						throw new ParserException(Strings.Parser_ErrorP_RunningValue_takes_2_or_3_arguments + GetLocationInfo(curToken));  					string aggrFunc = args[1].EvaluateString(null' null);  					if (aggrFunc == null)  						throw new ParserException(Strings.Parser_ErrorP_RunningValueArgumentInvalid + GetLocationInfo(curToken));  					scope = ResolveAggrScope(args' 3' out bSimple);  					switch(aggrFunc.ToLower())  					{  						case "sum":  							result = new FunctionAggrRvSum(_DataCache' args[0]' scope);  							break;  						case "avg":  							result = new FunctionAggrRvAvg(_DataCache' args[0]' scope);  							break;  						case "count":  							result = new FunctionAggrRvCount(_DataCache' args[0]' scope);  							break;  						case "max":  							result = new FunctionAggrRvMax(_DataCache' args[0]' scope);  							break;  						case "min":  							result = new FunctionAggrRvMin(_DataCache' args[0]' scope);  							break;  						case "stdev":  							result = new FunctionAggrRvStdev(_DataCache' args[0]' scope);  							break;  						case "stdevp":  							result = new FunctionAggrRvStdevp(_DataCache' args[0]' scope);  							break;  						case "var":  							result = new FunctionAggrRvVar(_DataCache' args[0]' scope);  							break;  						case "varp":  							result = new FunctionAggrRvVarp(_DataCache' args[0]' scope);  							break;  						default:  							throw new ParserException(string.Format(Strings.Parser_ErrorP_RunningValueNotSupported' aggrFunc) + GetLocationInfo(curToken));  					}  					break;  				case "stdev":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdev aggrSDev = new FunctionAggrStdev(_DataCache' args[0]' scope);  					aggrSDev.LevelCheck = bSimple;  					result = aggrSDev;  					break;  				case "stdevp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdevp aggrSDevP = new FunctionAggrStdevp(_DataCache' args[0]' scope);  					aggrSDevP.LevelCheck = bSimple;  					result = aggrSDevP;  					break;  				case "var":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVar aggrVar = new FunctionAggrVar(_DataCache' args[0]' scope);  					aggrVar.LevelCheck = bSimple;  					result = aggrVar;  					break;  				case "varp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVarp aggrVarP = new FunctionAggrVarp(_DataCache' args[0]' scope);  					aggrVarP.LevelCheck = bSimple;  					result = aggrVarP;  					break;  				default:  					result = ResolveMethodCall(fullname' args);		// through exception when fails  					break;  			}
Magic Number,fyiReporting.RDL,Parser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Parser.cs,MatchFuncIDent,The following statement contains a magic number: if (!bOnePart)				              {                  result = (firstPart == "Parameters")?                      ResolveParametersMethod(method' thirdPart' args):                      ResolveMethodCall(fullname' args);	// throw exception when fails              }  			else switch(method.ToLower())  			{  				case "iif":  					if (args.Length != 3)  						throw new ParserException(Strings.Parser_ErrorP_iff_function_requires_3_arguments + GetLocationInfo(curToken));  //  We allow any type for the first argument; it will get converted to boolean at runtime  //					if (args[0].GetTypeCode() != TypeCode.Boolean)  //						throw new ParserException("First argument to iif function must be boolean." + GetLocationInfo(curToken));  					result = new FunctionIif(args[0]' args[1]' args[2]);  					break;  				case "choose":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_ChooseRequires2Arguments + GetLocationInfo(curToken));  					switch (args[0].GetTypeCode())  					{  						case TypeCode.Double:  						case TypeCode.Single:  						case TypeCode.Int32:  						case TypeCode.Decimal:  						case TypeCode.Int16:  						case TypeCode.Int64:                          case TypeCode.UInt16:                          case TypeCode.UInt32:                          case TypeCode.UInt64:  							break;  						default:  							throw new ParserException(Strings.Parser_ErrorP_ChooseFirstArgumentMustNumeric + GetLocationInfo(curToken));  					}  					result = new FunctionChoose(args);  					break;  				case "switch":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_SwitchRequires2Arguments + GetLocationInfo(curToken));  				    if (args.Length % 2 != 0)  						throw new ParserException(Strings.Parser_ErrorP_SwitchMustEvenArguments + GetLocationInfo(curToken));  					for (int i=0; i < args.Length; i = i+2)  					{  						if (args[i].GetTypeCode() != TypeCode.Boolean)  							throw new ParserException(Strings.Parser_ErrorP_SwitchMustBoolean + GetLocationInfo(curToken));  					}  					result = new FunctionSwitch(args);  					break;  				case "format":  					if (args.Length > 2 || args.Length < 1)  						throw new ParserException(Strings.Parser_ErrorP_FormatRequires2Arguments + GetLocationInfo(curToken));  					if (args.Length == 1)  					{  						result = new FunctionFormat(args[0]' new ConstantString(""));  					}  					else  					{  						if (args[1].GetTypeCode() != TypeCode.String)  							throw new ParserException(Strings.Parser_ErrorP_SecondMustString + GetLocationInfo(curToken));  						result = new FunctionFormat(args[0]' args[1]);  					}  					break;    				case "fields":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_FieldsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionFieldCollection(idLookup.Fields' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                  TODO: generalize this code                          curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else  							throw new ParserException(string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Fields") + GetLocationInfo(curToken));                      }                      break;  				case "parameters":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ParametersRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionParameterCollection(idLookup.Parameters' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Parameters") + GetLocationInfo(curToken)));                      }                      break;  				case "reportitems":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ReportItemsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionReportItemCollection(idLookup.ReportItems' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "ReportItems") + GetLocationInfo(curToken)));                      }                      break;  				case "globals":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_GlobalsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionGlobalCollection(idLookup.Globals' args[0]);  					break;  				case "user":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_UserRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionUserCollection(idLookup.User' args[0]);  					break;  				case "sum":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrSum aggrFS = new FunctionAggrSum(_DataCache' args[0]' scope);  					aggrFS.LevelCheck = bSimple;  					result = aggrFS;  					break;  				case "avg":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrAvg aggrFA = new FunctionAggrAvg(_DataCache' args[0]' scope);  					aggrFA.LevelCheck = bSimple;  					result = aggrFA;  					break;  				case "min":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMin aggrFMin = new FunctionAggrMin(_DataCache' args[0]' scope);  					aggrFMin.LevelCheck = bSimple;  					result = aggrFMin;  					break;  				case "max":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMax aggrFMax = new FunctionAggrMax(_DataCache' args[0]' scope);  					aggrFMax.LevelCheck = bSimple;  					result = aggrFMax;  					break;  				case "first":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrFirst(_DataCache' args[0]' scope);  					break;  				case "last":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrLast(_DataCache' args[0]' scope);  					break;  				case "next":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrNext(_DataCache' args[0]' scope);  					break;  				case "previous":  				    scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrPrevious(_DataCache' args[0]' scope);  					break;  				case "level":  					scope = ResolveAggrScope(args' 1' out bSimple);  					result = new FunctionAggrLevel(scope);  					break;                  case "aggregate":                      scope = ResolveAggrScope(args' 2' out bSimple);                      FunctionAggrArray aggr = new FunctionAggrArray(_DataCache' args[0]' scope);                      aggr.LevelCheck = bSimple;                      result = aggr;                      break;                  case "count":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCount aggrFC = new FunctionAggrCount(_DataCache' args[0]' scope);  					aggrFC.LevelCheck = bSimple;  					result = aggrFC;  					break;  				case "countrows":  					scope = ResolveAggrScope(args' 1' out bSimple);  					FunctionAggrCountRows aggrFCR = new FunctionAggrCountRows(scope);  					aggrFCR.LevelCheck = bSimple;  					result = aggrFCR;  					break;                  case "countdistinct":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCountDistinct aggrFCD = new FunctionAggrCountDistinct(_DataCache' args[0]' scope);  					aggrFCD.LevelCheck = bSimple;  					result = aggrFCD;  					break;  				case "rownumber":  					scope = ResolveAggrScope(args' 1' out bSimple);  					IExpr texpr = new ConstantDouble("0");  					result = new FunctionAggrRvCount(_DataCache' texpr' scope);  					break;  				case "runningvalue":  					if (args.Length < 2 || args.Length > 3)  						throw new ParserException(Strings.Parser_ErrorP_RunningValue_takes_2_or_3_arguments + GetLocationInfo(curToken));  					string aggrFunc = args[1].EvaluateString(null' null);  					if (aggrFunc == null)  						throw new ParserException(Strings.Parser_ErrorP_RunningValueArgumentInvalid + GetLocationInfo(curToken));  					scope = ResolveAggrScope(args' 3' out bSimple);  					switch(aggrFunc.ToLower())  					{  						case "sum":  							result = new FunctionAggrRvSum(_DataCache' args[0]' scope);  							break;  						case "avg":  							result = new FunctionAggrRvAvg(_DataCache' args[0]' scope);  							break;  						case "count":  							result = new FunctionAggrRvCount(_DataCache' args[0]' scope);  							break;  						case "max":  							result = new FunctionAggrRvMax(_DataCache' args[0]' scope);  							break;  						case "min":  							result = new FunctionAggrRvMin(_DataCache' args[0]' scope);  							break;  						case "stdev":  							result = new FunctionAggrRvStdev(_DataCache' args[0]' scope);  							break;  						case "stdevp":  							result = new FunctionAggrRvStdevp(_DataCache' args[0]' scope);  							break;  						case "var":  							result = new FunctionAggrRvVar(_DataCache' args[0]' scope);  							break;  						case "varp":  							result = new FunctionAggrRvVarp(_DataCache' args[0]' scope);  							break;  						default:  							throw new ParserException(string.Format(Strings.Parser_ErrorP_RunningValueNotSupported' aggrFunc) + GetLocationInfo(curToken));  					}  					break;  				case "stdev":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdev aggrSDev = new FunctionAggrStdev(_DataCache' args[0]' scope);  					aggrSDev.LevelCheck = bSimple;  					result = aggrSDev;  					break;  				case "stdevp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdevp aggrSDevP = new FunctionAggrStdevp(_DataCache' args[0]' scope);  					aggrSDevP.LevelCheck = bSimple;  					result = aggrSDevP;  					break;  				case "var":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVar aggrVar = new FunctionAggrVar(_DataCache' args[0]' scope);  					aggrVar.LevelCheck = bSimple;  					result = aggrVar;  					break;  				case "varp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVarp aggrVarP = new FunctionAggrVarp(_DataCache' args[0]' scope);  					aggrVarP.LevelCheck = bSimple;  					result = aggrVarP;  					break;  				default:  					result = ResolveMethodCall(fullname' args);		// through exception when fails  					break;  			}
Magic Number,fyiReporting.RDL,Parser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Parser.cs,MatchFuncIDent,The following statement contains a magic number: if (!bOnePart)				              {                  result = (firstPart == "Parameters")?                      ResolveParametersMethod(method' thirdPart' args):                      ResolveMethodCall(fullname' args);	// throw exception when fails              }  			else switch(method.ToLower())  			{  				case "iif":  					if (args.Length != 3)  						throw new ParserException(Strings.Parser_ErrorP_iff_function_requires_3_arguments + GetLocationInfo(curToken));  //  We allow any type for the first argument; it will get converted to boolean at runtime  //					if (args[0].GetTypeCode() != TypeCode.Boolean)  //						throw new ParserException("First argument to iif function must be boolean." + GetLocationInfo(curToken));  					result = new FunctionIif(args[0]' args[1]' args[2]);  					break;  				case "choose":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_ChooseRequires2Arguments + GetLocationInfo(curToken));  					switch (args[0].GetTypeCode())  					{  						case TypeCode.Double:  						case TypeCode.Single:  						case TypeCode.Int32:  						case TypeCode.Decimal:  						case TypeCode.Int16:  						case TypeCode.Int64:                          case TypeCode.UInt16:                          case TypeCode.UInt32:                          case TypeCode.UInt64:  							break;  						default:  							throw new ParserException(Strings.Parser_ErrorP_ChooseFirstArgumentMustNumeric + GetLocationInfo(curToken));  					}  					result = new FunctionChoose(args);  					break;  				case "switch":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_SwitchRequires2Arguments + GetLocationInfo(curToken));  				    if (args.Length % 2 != 0)  						throw new ParserException(Strings.Parser_ErrorP_SwitchMustEvenArguments + GetLocationInfo(curToken));  					for (int i=0; i < args.Length; i = i+2)  					{  						if (args[i].GetTypeCode() != TypeCode.Boolean)  							throw new ParserException(Strings.Parser_ErrorP_SwitchMustBoolean + GetLocationInfo(curToken));  					}  					result = new FunctionSwitch(args);  					break;  				case "format":  					if (args.Length > 2 || args.Length < 1)  						throw new ParserException(Strings.Parser_ErrorP_FormatRequires2Arguments + GetLocationInfo(curToken));  					if (args.Length == 1)  					{  						result = new FunctionFormat(args[0]' new ConstantString(""));  					}  					else  					{  						if (args[1].GetTypeCode() != TypeCode.String)  							throw new ParserException(Strings.Parser_ErrorP_SecondMustString + GetLocationInfo(curToken));  						result = new FunctionFormat(args[0]' args[1]);  					}  					break;    				case "fields":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_FieldsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionFieldCollection(idLookup.Fields' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                  TODO: generalize this code                          curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else  							throw new ParserException(string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Fields") + GetLocationInfo(curToken));                      }                      break;  				case "parameters":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ParametersRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionParameterCollection(idLookup.Parameters' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Parameters") + GetLocationInfo(curToken)));                      }                      break;  				case "reportitems":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ReportItemsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionReportItemCollection(idLookup.ReportItems' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "ReportItems") + GetLocationInfo(curToken)));                      }                      break;  				case "globals":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_GlobalsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionGlobalCollection(idLookup.Globals' args[0]);  					break;  				case "user":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_UserRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionUserCollection(idLookup.User' args[0]);  					break;  				case "sum":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrSum aggrFS = new FunctionAggrSum(_DataCache' args[0]' scope);  					aggrFS.LevelCheck = bSimple;  					result = aggrFS;  					break;  				case "avg":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrAvg aggrFA = new FunctionAggrAvg(_DataCache' args[0]' scope);  					aggrFA.LevelCheck = bSimple;  					result = aggrFA;  					break;  				case "min":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMin aggrFMin = new FunctionAggrMin(_DataCache' args[0]' scope);  					aggrFMin.LevelCheck = bSimple;  					result = aggrFMin;  					break;  				case "max":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMax aggrFMax = new FunctionAggrMax(_DataCache' args[0]' scope);  					aggrFMax.LevelCheck = bSimple;  					result = aggrFMax;  					break;  				case "first":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrFirst(_DataCache' args[0]' scope);  					break;  				case "last":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrLast(_DataCache' args[0]' scope);  					break;  				case "next":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrNext(_DataCache' args[0]' scope);  					break;  				case "previous":  				    scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrPrevious(_DataCache' args[0]' scope);  					break;  				case "level":  					scope = ResolveAggrScope(args' 1' out bSimple);  					result = new FunctionAggrLevel(scope);  					break;                  case "aggregate":                      scope = ResolveAggrScope(args' 2' out bSimple);                      FunctionAggrArray aggr = new FunctionAggrArray(_DataCache' args[0]' scope);                      aggr.LevelCheck = bSimple;                      result = aggr;                      break;                  case "count":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCount aggrFC = new FunctionAggrCount(_DataCache' args[0]' scope);  					aggrFC.LevelCheck = bSimple;  					result = aggrFC;  					break;  				case "countrows":  					scope = ResolveAggrScope(args' 1' out bSimple);  					FunctionAggrCountRows aggrFCR = new FunctionAggrCountRows(scope);  					aggrFCR.LevelCheck = bSimple;  					result = aggrFCR;  					break;                  case "countdistinct":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCountDistinct aggrFCD = new FunctionAggrCountDistinct(_DataCache' args[0]' scope);  					aggrFCD.LevelCheck = bSimple;  					result = aggrFCD;  					break;  				case "rownumber":  					scope = ResolveAggrScope(args' 1' out bSimple);  					IExpr texpr = new ConstantDouble("0");  					result = new FunctionAggrRvCount(_DataCache' texpr' scope);  					break;  				case "runningvalue":  					if (args.Length < 2 || args.Length > 3)  						throw new ParserException(Strings.Parser_ErrorP_RunningValue_takes_2_or_3_arguments + GetLocationInfo(curToken));  					string aggrFunc = args[1].EvaluateString(null' null);  					if (aggrFunc == null)  						throw new ParserException(Strings.Parser_ErrorP_RunningValueArgumentInvalid + GetLocationInfo(curToken));  					scope = ResolveAggrScope(args' 3' out bSimple);  					switch(aggrFunc.ToLower())  					{  						case "sum":  							result = new FunctionAggrRvSum(_DataCache' args[0]' scope);  							break;  						case "avg":  							result = new FunctionAggrRvAvg(_DataCache' args[0]' scope);  							break;  						case "count":  							result = new FunctionAggrRvCount(_DataCache' args[0]' scope);  							break;  						case "max":  							result = new FunctionAggrRvMax(_DataCache' args[0]' scope);  							break;  						case "min":  							result = new FunctionAggrRvMin(_DataCache' args[0]' scope);  							break;  						case "stdev":  							result = new FunctionAggrRvStdev(_DataCache' args[0]' scope);  							break;  						case "stdevp":  							result = new FunctionAggrRvStdevp(_DataCache' args[0]' scope);  							break;  						case "var":  							result = new FunctionAggrRvVar(_DataCache' args[0]' scope);  							break;  						case "varp":  							result = new FunctionAggrRvVarp(_DataCache' args[0]' scope);  							break;  						default:  							throw new ParserException(string.Format(Strings.Parser_ErrorP_RunningValueNotSupported' aggrFunc) + GetLocationInfo(curToken));  					}  					break;  				case "stdev":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdev aggrSDev = new FunctionAggrStdev(_DataCache' args[0]' scope);  					aggrSDev.LevelCheck = bSimple;  					result = aggrSDev;  					break;  				case "stdevp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdevp aggrSDevP = new FunctionAggrStdevp(_DataCache' args[0]' scope);  					aggrSDevP.LevelCheck = bSimple;  					result = aggrSDevP;  					break;  				case "var":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVar aggrVar = new FunctionAggrVar(_DataCache' args[0]' scope);  					aggrVar.LevelCheck = bSimple;  					result = aggrVar;  					break;  				case "varp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVarp aggrVarP = new FunctionAggrVarp(_DataCache' args[0]' scope);  					aggrVarP.LevelCheck = bSimple;  					result = aggrVarP;  					break;  				default:  					result = ResolveMethodCall(fullname' args);		// through exception when fails  					break;  			}
Magic Number,fyiReporting.RDL,Parser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Parser.cs,MatchFuncIDent,The following statement contains a magic number: if (!bOnePart)				              {                  result = (firstPart == "Parameters")?                      ResolveParametersMethod(method' thirdPart' args):                      ResolveMethodCall(fullname' args);	// throw exception when fails              }  			else switch(method.ToLower())  			{  				case "iif":  					if (args.Length != 3)  						throw new ParserException(Strings.Parser_ErrorP_iff_function_requires_3_arguments + GetLocationInfo(curToken));  //  We allow any type for the first argument; it will get converted to boolean at runtime  //					if (args[0].GetTypeCode() != TypeCode.Boolean)  //						throw new ParserException("First argument to iif function must be boolean." + GetLocationInfo(curToken));  					result = new FunctionIif(args[0]' args[1]' args[2]);  					break;  				case "choose":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_ChooseRequires2Arguments + GetLocationInfo(curToken));  					switch (args[0].GetTypeCode())  					{  						case TypeCode.Double:  						case TypeCode.Single:  						case TypeCode.Int32:  						case TypeCode.Decimal:  						case TypeCode.Int16:  						case TypeCode.Int64:                          case TypeCode.UInt16:                          case TypeCode.UInt32:                          case TypeCode.UInt64:  							break;  						default:  							throw new ParserException(Strings.Parser_ErrorP_ChooseFirstArgumentMustNumeric + GetLocationInfo(curToken));  					}  					result = new FunctionChoose(args);  					break;  				case "switch":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_SwitchRequires2Arguments + GetLocationInfo(curToken));  				    if (args.Length % 2 != 0)  						throw new ParserException(Strings.Parser_ErrorP_SwitchMustEvenArguments + GetLocationInfo(curToken));  					for (int i=0; i < args.Length; i = i+2)  					{  						if (args[i].GetTypeCode() != TypeCode.Boolean)  							throw new ParserException(Strings.Parser_ErrorP_SwitchMustBoolean + GetLocationInfo(curToken));  					}  					result = new FunctionSwitch(args);  					break;  				case "format":  					if (args.Length > 2 || args.Length < 1)  						throw new ParserException(Strings.Parser_ErrorP_FormatRequires2Arguments + GetLocationInfo(curToken));  					if (args.Length == 1)  					{  						result = new FunctionFormat(args[0]' new ConstantString(""));  					}  					else  					{  						if (args[1].GetTypeCode() != TypeCode.String)  							throw new ParserException(Strings.Parser_ErrorP_SecondMustString + GetLocationInfo(curToken));  						result = new FunctionFormat(args[0]' args[1]);  					}  					break;    				case "fields":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_FieldsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionFieldCollection(idLookup.Fields' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                  TODO: generalize this code                          curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else  							throw new ParserException(string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Fields") + GetLocationInfo(curToken));                      }                      break;  				case "parameters":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ParametersRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionParameterCollection(idLookup.Parameters' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Parameters") + GetLocationInfo(curToken)));                      }                      break;  				case "reportitems":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ReportItemsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionReportItemCollection(idLookup.ReportItems' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "ReportItems") + GetLocationInfo(curToken)));                      }                      break;  				case "globals":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_GlobalsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionGlobalCollection(idLookup.Globals' args[0]);  					break;  				case "user":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_UserRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionUserCollection(idLookup.User' args[0]);  					break;  				case "sum":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrSum aggrFS = new FunctionAggrSum(_DataCache' args[0]' scope);  					aggrFS.LevelCheck = bSimple;  					result = aggrFS;  					break;  				case "avg":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrAvg aggrFA = new FunctionAggrAvg(_DataCache' args[0]' scope);  					aggrFA.LevelCheck = bSimple;  					result = aggrFA;  					break;  				case "min":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMin aggrFMin = new FunctionAggrMin(_DataCache' args[0]' scope);  					aggrFMin.LevelCheck = bSimple;  					result = aggrFMin;  					break;  				case "max":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMax aggrFMax = new FunctionAggrMax(_DataCache' args[0]' scope);  					aggrFMax.LevelCheck = bSimple;  					result = aggrFMax;  					break;  				case "first":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrFirst(_DataCache' args[0]' scope);  					break;  				case "last":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrLast(_DataCache' args[0]' scope);  					break;  				case "next":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrNext(_DataCache' args[0]' scope);  					break;  				case "previous":  				    scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrPrevious(_DataCache' args[0]' scope);  					break;  				case "level":  					scope = ResolveAggrScope(args' 1' out bSimple);  					result = new FunctionAggrLevel(scope);  					break;                  case "aggregate":                      scope = ResolveAggrScope(args' 2' out bSimple);                      FunctionAggrArray aggr = new FunctionAggrArray(_DataCache' args[0]' scope);                      aggr.LevelCheck = bSimple;                      result = aggr;                      break;                  case "count":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCount aggrFC = new FunctionAggrCount(_DataCache' args[0]' scope);  					aggrFC.LevelCheck = bSimple;  					result = aggrFC;  					break;  				case "countrows":  					scope = ResolveAggrScope(args' 1' out bSimple);  					FunctionAggrCountRows aggrFCR = new FunctionAggrCountRows(scope);  					aggrFCR.LevelCheck = bSimple;  					result = aggrFCR;  					break;                  case "countdistinct":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCountDistinct aggrFCD = new FunctionAggrCountDistinct(_DataCache' args[0]' scope);  					aggrFCD.LevelCheck = bSimple;  					result = aggrFCD;  					break;  				case "rownumber":  					scope = ResolveAggrScope(args' 1' out bSimple);  					IExpr texpr = new ConstantDouble("0");  					result = new FunctionAggrRvCount(_DataCache' texpr' scope);  					break;  				case "runningvalue":  					if (args.Length < 2 || args.Length > 3)  						throw new ParserException(Strings.Parser_ErrorP_RunningValue_takes_2_or_3_arguments + GetLocationInfo(curToken));  					string aggrFunc = args[1].EvaluateString(null' null);  					if (aggrFunc == null)  						throw new ParserException(Strings.Parser_ErrorP_RunningValueArgumentInvalid + GetLocationInfo(curToken));  					scope = ResolveAggrScope(args' 3' out bSimple);  					switch(aggrFunc.ToLower())  					{  						case "sum":  							result = new FunctionAggrRvSum(_DataCache' args[0]' scope);  							break;  						case "avg":  							result = new FunctionAggrRvAvg(_DataCache' args[0]' scope);  							break;  						case "count":  							result = new FunctionAggrRvCount(_DataCache' args[0]' scope);  							break;  						case "max":  							result = new FunctionAggrRvMax(_DataCache' args[0]' scope);  							break;  						case "min":  							result = new FunctionAggrRvMin(_DataCache' args[0]' scope);  							break;  						case "stdev":  							result = new FunctionAggrRvStdev(_DataCache' args[0]' scope);  							break;  						case "stdevp":  							result = new FunctionAggrRvStdevp(_DataCache' args[0]' scope);  							break;  						case "var":  							result = new FunctionAggrRvVar(_DataCache' args[0]' scope);  							break;  						case "varp":  							result = new FunctionAggrRvVarp(_DataCache' args[0]' scope);  							break;  						default:  							throw new ParserException(string.Format(Strings.Parser_ErrorP_RunningValueNotSupported' aggrFunc) + GetLocationInfo(curToken));  					}  					break;  				case "stdev":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdev aggrSDev = new FunctionAggrStdev(_DataCache' args[0]' scope);  					aggrSDev.LevelCheck = bSimple;  					result = aggrSDev;  					break;  				case "stdevp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdevp aggrSDevP = new FunctionAggrStdevp(_DataCache' args[0]' scope);  					aggrSDevP.LevelCheck = bSimple;  					result = aggrSDevP;  					break;  				case "var":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVar aggrVar = new FunctionAggrVar(_DataCache' args[0]' scope);  					aggrVar.LevelCheck = bSimple;  					result = aggrVar;  					break;  				case "varp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVarp aggrVarP = new FunctionAggrVarp(_DataCache' args[0]' scope);  					aggrVarP.LevelCheck = bSimple;  					result = aggrVarP;  					break;  				default:  					result = ResolveMethodCall(fullname' args);		// through exception when fails  					break;  			}
Magic Number,fyiReporting.RDL,Parser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Parser.cs,MatchFuncIDent,The following statement contains a magic number: if (!bOnePart)				              {                  result = (firstPart == "Parameters")?                      ResolveParametersMethod(method' thirdPart' args):                      ResolveMethodCall(fullname' args);	// throw exception when fails              }  			else switch(method.ToLower())  			{  				case "iif":  					if (args.Length != 3)  						throw new ParserException(Strings.Parser_ErrorP_iff_function_requires_3_arguments + GetLocationInfo(curToken));  //  We allow any type for the first argument; it will get converted to boolean at runtime  //					if (args[0].GetTypeCode() != TypeCode.Boolean)  //						throw new ParserException("First argument to iif function must be boolean." + GetLocationInfo(curToken));  					result = new FunctionIif(args[0]' args[1]' args[2]);  					break;  				case "choose":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_ChooseRequires2Arguments + GetLocationInfo(curToken));  					switch (args[0].GetTypeCode())  					{  						case TypeCode.Double:  						case TypeCode.Single:  						case TypeCode.Int32:  						case TypeCode.Decimal:  						case TypeCode.Int16:  						case TypeCode.Int64:                          case TypeCode.UInt16:                          case TypeCode.UInt32:                          case TypeCode.UInt64:  							break;  						default:  							throw new ParserException(Strings.Parser_ErrorP_ChooseFirstArgumentMustNumeric + GetLocationInfo(curToken));  					}  					result = new FunctionChoose(args);  					break;  				case "switch":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_SwitchRequires2Arguments + GetLocationInfo(curToken));  				    if (args.Length % 2 != 0)  						throw new ParserException(Strings.Parser_ErrorP_SwitchMustEvenArguments + GetLocationInfo(curToken));  					for (int i=0; i < args.Length; i = i+2)  					{  						if (args[i].GetTypeCode() != TypeCode.Boolean)  							throw new ParserException(Strings.Parser_ErrorP_SwitchMustBoolean + GetLocationInfo(curToken));  					}  					result = new FunctionSwitch(args);  					break;  				case "format":  					if (args.Length > 2 || args.Length < 1)  						throw new ParserException(Strings.Parser_ErrorP_FormatRequires2Arguments + GetLocationInfo(curToken));  					if (args.Length == 1)  					{  						result = new FunctionFormat(args[0]' new ConstantString(""));  					}  					else  					{  						if (args[1].GetTypeCode() != TypeCode.String)  							throw new ParserException(Strings.Parser_ErrorP_SecondMustString + GetLocationInfo(curToken));  						result = new FunctionFormat(args[0]' args[1]);  					}  					break;    				case "fields":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_FieldsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionFieldCollection(idLookup.Fields' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                  TODO: generalize this code                          curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else  							throw new ParserException(string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Fields") + GetLocationInfo(curToken));                      }                      break;  				case "parameters":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ParametersRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionParameterCollection(idLookup.Parameters' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Parameters") + GetLocationInfo(curToken)));                      }                      break;  				case "reportitems":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ReportItemsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionReportItemCollection(idLookup.ReportItems' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "ReportItems") + GetLocationInfo(curToken)));                      }                      break;  				case "globals":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_GlobalsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionGlobalCollection(idLookup.Globals' args[0]);  					break;  				case "user":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_UserRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionUserCollection(idLookup.User' args[0]);  					break;  				case "sum":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrSum aggrFS = new FunctionAggrSum(_DataCache' args[0]' scope);  					aggrFS.LevelCheck = bSimple;  					result = aggrFS;  					break;  				case "avg":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrAvg aggrFA = new FunctionAggrAvg(_DataCache' args[0]' scope);  					aggrFA.LevelCheck = bSimple;  					result = aggrFA;  					break;  				case "min":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMin aggrFMin = new FunctionAggrMin(_DataCache' args[0]' scope);  					aggrFMin.LevelCheck = bSimple;  					result = aggrFMin;  					break;  				case "max":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMax aggrFMax = new FunctionAggrMax(_DataCache' args[0]' scope);  					aggrFMax.LevelCheck = bSimple;  					result = aggrFMax;  					break;  				case "first":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrFirst(_DataCache' args[0]' scope);  					break;  				case "last":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrLast(_DataCache' args[0]' scope);  					break;  				case "next":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrNext(_DataCache' args[0]' scope);  					break;  				case "previous":  				    scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrPrevious(_DataCache' args[0]' scope);  					break;  				case "level":  					scope = ResolveAggrScope(args' 1' out bSimple);  					result = new FunctionAggrLevel(scope);  					break;                  case "aggregate":                      scope = ResolveAggrScope(args' 2' out bSimple);                      FunctionAggrArray aggr = new FunctionAggrArray(_DataCache' args[0]' scope);                      aggr.LevelCheck = bSimple;                      result = aggr;                      break;                  case "count":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCount aggrFC = new FunctionAggrCount(_DataCache' args[0]' scope);  					aggrFC.LevelCheck = bSimple;  					result = aggrFC;  					break;  				case "countrows":  					scope = ResolveAggrScope(args' 1' out bSimple);  					FunctionAggrCountRows aggrFCR = new FunctionAggrCountRows(scope);  					aggrFCR.LevelCheck = bSimple;  					result = aggrFCR;  					break;                  case "countdistinct":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCountDistinct aggrFCD = new FunctionAggrCountDistinct(_DataCache' args[0]' scope);  					aggrFCD.LevelCheck = bSimple;  					result = aggrFCD;  					break;  				case "rownumber":  					scope = ResolveAggrScope(args' 1' out bSimple);  					IExpr texpr = new ConstantDouble("0");  					result = new FunctionAggrRvCount(_DataCache' texpr' scope);  					break;  				case "runningvalue":  					if (args.Length < 2 || args.Length > 3)  						throw new ParserException(Strings.Parser_ErrorP_RunningValue_takes_2_or_3_arguments + GetLocationInfo(curToken));  					string aggrFunc = args[1].EvaluateString(null' null);  					if (aggrFunc == null)  						throw new ParserException(Strings.Parser_ErrorP_RunningValueArgumentInvalid + GetLocationInfo(curToken));  					scope = ResolveAggrScope(args' 3' out bSimple);  					switch(aggrFunc.ToLower())  					{  						case "sum":  							result = new FunctionAggrRvSum(_DataCache' args[0]' scope);  							break;  						case "avg":  							result = new FunctionAggrRvAvg(_DataCache' args[0]' scope);  							break;  						case "count":  							result = new FunctionAggrRvCount(_DataCache' args[0]' scope);  							break;  						case "max":  							result = new FunctionAggrRvMax(_DataCache' args[0]' scope);  							break;  						case "min":  							result = new FunctionAggrRvMin(_DataCache' args[0]' scope);  							break;  						case "stdev":  							result = new FunctionAggrRvStdev(_DataCache' args[0]' scope);  							break;  						case "stdevp":  							result = new FunctionAggrRvStdevp(_DataCache' args[0]' scope);  							break;  						case "var":  							result = new FunctionAggrRvVar(_DataCache' args[0]' scope);  							break;  						case "varp":  							result = new FunctionAggrRvVarp(_DataCache' args[0]' scope);  							break;  						default:  							throw new ParserException(string.Format(Strings.Parser_ErrorP_RunningValueNotSupported' aggrFunc) + GetLocationInfo(curToken));  					}  					break;  				case "stdev":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdev aggrSDev = new FunctionAggrStdev(_DataCache' args[0]' scope);  					aggrSDev.LevelCheck = bSimple;  					result = aggrSDev;  					break;  				case "stdevp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdevp aggrSDevP = new FunctionAggrStdevp(_DataCache' args[0]' scope);  					aggrSDevP.LevelCheck = bSimple;  					result = aggrSDevP;  					break;  				case "var":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVar aggrVar = new FunctionAggrVar(_DataCache' args[0]' scope);  					aggrVar.LevelCheck = bSimple;  					result = aggrVar;  					break;  				case "varp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVarp aggrVarP = new FunctionAggrVarp(_DataCache' args[0]' scope);  					aggrVarP.LevelCheck = bSimple;  					result = aggrVarP;  					break;  				default:  					result = ResolveMethodCall(fullname' args);		// through exception when fails  					break;  			}
Magic Number,fyiReporting.RDL,Parser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Parser.cs,MatchFuncIDent,The following statement contains a magic number: if (!bOnePart)				              {                  result = (firstPart == "Parameters")?                      ResolveParametersMethod(method' thirdPart' args):                      ResolveMethodCall(fullname' args);	// throw exception when fails              }  			else switch(method.ToLower())  			{  				case "iif":  					if (args.Length != 3)  						throw new ParserException(Strings.Parser_ErrorP_iff_function_requires_3_arguments + GetLocationInfo(curToken));  //  We allow any type for the first argument; it will get converted to boolean at runtime  //					if (args[0].GetTypeCode() != TypeCode.Boolean)  //						throw new ParserException("First argument to iif function must be boolean." + GetLocationInfo(curToken));  					result = new FunctionIif(args[0]' args[1]' args[2]);  					break;  				case "choose":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_ChooseRequires2Arguments + GetLocationInfo(curToken));  					switch (args[0].GetTypeCode())  					{  						case TypeCode.Double:  						case TypeCode.Single:  						case TypeCode.Int32:  						case TypeCode.Decimal:  						case TypeCode.Int16:  						case TypeCode.Int64:                          case TypeCode.UInt16:                          case TypeCode.UInt32:                          case TypeCode.UInt64:  							break;  						default:  							throw new ParserException(Strings.Parser_ErrorP_ChooseFirstArgumentMustNumeric + GetLocationInfo(curToken));  					}  					result = new FunctionChoose(args);  					break;  				case "switch":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_SwitchRequires2Arguments + GetLocationInfo(curToken));  				    if (args.Length % 2 != 0)  						throw new ParserException(Strings.Parser_ErrorP_SwitchMustEvenArguments + GetLocationInfo(curToken));  					for (int i=0; i < args.Length; i = i+2)  					{  						if (args[i].GetTypeCode() != TypeCode.Boolean)  							throw new ParserException(Strings.Parser_ErrorP_SwitchMustBoolean + GetLocationInfo(curToken));  					}  					result = new FunctionSwitch(args);  					break;  				case "format":  					if (args.Length > 2 || args.Length < 1)  						throw new ParserException(Strings.Parser_ErrorP_FormatRequires2Arguments + GetLocationInfo(curToken));  					if (args.Length == 1)  					{  						result = new FunctionFormat(args[0]' new ConstantString(""));  					}  					else  					{  						if (args[1].GetTypeCode() != TypeCode.String)  							throw new ParserException(Strings.Parser_ErrorP_SecondMustString + GetLocationInfo(curToken));  						result = new FunctionFormat(args[0]' args[1]);  					}  					break;    				case "fields":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_FieldsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionFieldCollection(idLookup.Fields' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                  TODO: generalize this code                          curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else  							throw new ParserException(string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Fields") + GetLocationInfo(curToken));                      }                      break;  				case "parameters":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ParametersRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionParameterCollection(idLookup.Parameters' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Parameters") + GetLocationInfo(curToken)));                      }                      break;  				case "reportitems":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ReportItemsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionReportItemCollection(idLookup.ReportItems' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "ReportItems") + GetLocationInfo(curToken)));                      }                      break;  				case "globals":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_GlobalsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionGlobalCollection(idLookup.Globals' args[0]);  					break;  				case "user":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_UserRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionUserCollection(idLookup.User' args[0]);  					break;  				case "sum":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrSum aggrFS = new FunctionAggrSum(_DataCache' args[0]' scope);  					aggrFS.LevelCheck = bSimple;  					result = aggrFS;  					break;  				case "avg":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrAvg aggrFA = new FunctionAggrAvg(_DataCache' args[0]' scope);  					aggrFA.LevelCheck = bSimple;  					result = aggrFA;  					break;  				case "min":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMin aggrFMin = new FunctionAggrMin(_DataCache' args[0]' scope);  					aggrFMin.LevelCheck = bSimple;  					result = aggrFMin;  					break;  				case "max":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMax aggrFMax = new FunctionAggrMax(_DataCache' args[0]' scope);  					aggrFMax.LevelCheck = bSimple;  					result = aggrFMax;  					break;  				case "first":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrFirst(_DataCache' args[0]' scope);  					break;  				case "last":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrLast(_DataCache' args[0]' scope);  					break;  				case "next":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrNext(_DataCache' args[0]' scope);  					break;  				case "previous":  				    scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrPrevious(_DataCache' args[0]' scope);  					break;  				case "level":  					scope = ResolveAggrScope(args' 1' out bSimple);  					result = new FunctionAggrLevel(scope);  					break;                  case "aggregate":                      scope = ResolveAggrScope(args' 2' out bSimple);                      FunctionAggrArray aggr = new FunctionAggrArray(_DataCache' args[0]' scope);                      aggr.LevelCheck = bSimple;                      result = aggr;                      break;                  case "count":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCount aggrFC = new FunctionAggrCount(_DataCache' args[0]' scope);  					aggrFC.LevelCheck = bSimple;  					result = aggrFC;  					break;  				case "countrows":  					scope = ResolveAggrScope(args' 1' out bSimple);  					FunctionAggrCountRows aggrFCR = new FunctionAggrCountRows(scope);  					aggrFCR.LevelCheck = bSimple;  					result = aggrFCR;  					break;                  case "countdistinct":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCountDistinct aggrFCD = new FunctionAggrCountDistinct(_DataCache' args[0]' scope);  					aggrFCD.LevelCheck = bSimple;  					result = aggrFCD;  					break;  				case "rownumber":  					scope = ResolveAggrScope(args' 1' out bSimple);  					IExpr texpr = new ConstantDouble("0");  					result = new FunctionAggrRvCount(_DataCache' texpr' scope);  					break;  				case "runningvalue":  					if (args.Length < 2 || args.Length > 3)  						throw new ParserException(Strings.Parser_ErrorP_RunningValue_takes_2_or_3_arguments + GetLocationInfo(curToken));  					string aggrFunc = args[1].EvaluateString(null' null);  					if (aggrFunc == null)  						throw new ParserException(Strings.Parser_ErrorP_RunningValueArgumentInvalid + GetLocationInfo(curToken));  					scope = ResolveAggrScope(args' 3' out bSimple);  					switch(aggrFunc.ToLower())  					{  						case "sum":  							result = new FunctionAggrRvSum(_DataCache' args[0]' scope);  							break;  						case "avg":  							result = new FunctionAggrRvAvg(_DataCache' args[0]' scope);  							break;  						case "count":  							result = new FunctionAggrRvCount(_DataCache' args[0]' scope);  							break;  						case "max":  							result = new FunctionAggrRvMax(_DataCache' args[0]' scope);  							break;  						case "min":  							result = new FunctionAggrRvMin(_DataCache' args[0]' scope);  							break;  						case "stdev":  							result = new FunctionAggrRvStdev(_DataCache' args[0]' scope);  							break;  						case "stdevp":  							result = new FunctionAggrRvStdevp(_DataCache' args[0]' scope);  							break;  						case "var":  							result = new FunctionAggrRvVar(_DataCache' args[0]' scope);  							break;  						case "varp":  							result = new FunctionAggrRvVarp(_DataCache' args[0]' scope);  							break;  						default:  							throw new ParserException(string.Format(Strings.Parser_ErrorP_RunningValueNotSupported' aggrFunc) + GetLocationInfo(curToken));  					}  					break;  				case "stdev":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdev aggrSDev = new FunctionAggrStdev(_DataCache' args[0]' scope);  					aggrSDev.LevelCheck = bSimple;  					result = aggrSDev;  					break;  				case "stdevp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdevp aggrSDevP = new FunctionAggrStdevp(_DataCache' args[0]' scope);  					aggrSDevP.LevelCheck = bSimple;  					result = aggrSDevP;  					break;  				case "var":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVar aggrVar = new FunctionAggrVar(_DataCache' args[0]' scope);  					aggrVar.LevelCheck = bSimple;  					result = aggrVar;  					break;  				case "varp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVarp aggrVarP = new FunctionAggrVarp(_DataCache' args[0]' scope);  					aggrVarP.LevelCheck = bSimple;  					result = aggrVarP;  					break;  				default:  					result = ResolveMethodCall(fullname' args);		// through exception when fails  					break;  			}
Magic Number,fyiReporting.RDL,Parser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Parser.cs,MatchFuncIDent,The following statement contains a magic number: if (!bOnePart)				              {                  result = (firstPart == "Parameters")?                      ResolveParametersMethod(method' thirdPart' args):                      ResolveMethodCall(fullname' args);	// throw exception when fails              }  			else switch(method.ToLower())  			{  				case "iif":  					if (args.Length != 3)  						throw new ParserException(Strings.Parser_ErrorP_iff_function_requires_3_arguments + GetLocationInfo(curToken));  //  We allow any type for the first argument; it will get converted to boolean at runtime  //					if (args[0].GetTypeCode() != TypeCode.Boolean)  //						throw new ParserException("First argument to iif function must be boolean." + GetLocationInfo(curToken));  					result = new FunctionIif(args[0]' args[1]' args[2]);  					break;  				case "choose":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_ChooseRequires2Arguments + GetLocationInfo(curToken));  					switch (args[0].GetTypeCode())  					{  						case TypeCode.Double:  						case TypeCode.Single:  						case TypeCode.Int32:  						case TypeCode.Decimal:  						case TypeCode.Int16:  						case TypeCode.Int64:                          case TypeCode.UInt16:                          case TypeCode.UInt32:                          case TypeCode.UInt64:  							break;  						default:  							throw new ParserException(Strings.Parser_ErrorP_ChooseFirstArgumentMustNumeric + GetLocationInfo(curToken));  					}  					result = new FunctionChoose(args);  					break;  				case "switch":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_SwitchRequires2Arguments + GetLocationInfo(curToken));  				    if (args.Length % 2 != 0)  						throw new ParserException(Strings.Parser_ErrorP_SwitchMustEvenArguments + GetLocationInfo(curToken));  					for (int i=0; i < args.Length; i = i+2)  					{  						if (args[i].GetTypeCode() != TypeCode.Boolean)  							throw new ParserException(Strings.Parser_ErrorP_SwitchMustBoolean + GetLocationInfo(curToken));  					}  					result = new FunctionSwitch(args);  					break;  				case "format":  					if (args.Length > 2 || args.Length < 1)  						throw new ParserException(Strings.Parser_ErrorP_FormatRequires2Arguments + GetLocationInfo(curToken));  					if (args.Length == 1)  					{  						result = new FunctionFormat(args[0]' new ConstantString(""));  					}  					else  					{  						if (args[1].GetTypeCode() != TypeCode.String)  							throw new ParserException(Strings.Parser_ErrorP_SecondMustString + GetLocationInfo(curToken));  						result = new FunctionFormat(args[0]' args[1]);  					}  					break;    				case "fields":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_FieldsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionFieldCollection(idLookup.Fields' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                  TODO: generalize this code                          curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else  							throw new ParserException(string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Fields") + GetLocationInfo(curToken));                      }                      break;  				case "parameters":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ParametersRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionParameterCollection(idLookup.Parameters' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Parameters") + GetLocationInfo(curToken)));                      }                      break;  				case "reportitems":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ReportItemsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionReportItemCollection(idLookup.ReportItems' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "ReportItems") + GetLocationInfo(curToken)));                      }                      break;  				case "globals":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_GlobalsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionGlobalCollection(idLookup.Globals' args[0]);  					break;  				case "user":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_UserRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionUserCollection(idLookup.User' args[0]);  					break;  				case "sum":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrSum aggrFS = new FunctionAggrSum(_DataCache' args[0]' scope);  					aggrFS.LevelCheck = bSimple;  					result = aggrFS;  					break;  				case "avg":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrAvg aggrFA = new FunctionAggrAvg(_DataCache' args[0]' scope);  					aggrFA.LevelCheck = bSimple;  					result = aggrFA;  					break;  				case "min":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMin aggrFMin = new FunctionAggrMin(_DataCache' args[0]' scope);  					aggrFMin.LevelCheck = bSimple;  					result = aggrFMin;  					break;  				case "max":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMax aggrFMax = new FunctionAggrMax(_DataCache' args[0]' scope);  					aggrFMax.LevelCheck = bSimple;  					result = aggrFMax;  					break;  				case "first":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrFirst(_DataCache' args[0]' scope);  					break;  				case "last":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrLast(_DataCache' args[0]' scope);  					break;  				case "next":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrNext(_DataCache' args[0]' scope);  					break;  				case "previous":  				    scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrPrevious(_DataCache' args[0]' scope);  					break;  				case "level":  					scope = ResolveAggrScope(args' 1' out bSimple);  					result = new FunctionAggrLevel(scope);  					break;                  case "aggregate":                      scope = ResolveAggrScope(args' 2' out bSimple);                      FunctionAggrArray aggr = new FunctionAggrArray(_DataCache' args[0]' scope);                      aggr.LevelCheck = bSimple;                      result = aggr;                      break;                  case "count":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCount aggrFC = new FunctionAggrCount(_DataCache' args[0]' scope);  					aggrFC.LevelCheck = bSimple;  					result = aggrFC;  					break;  				case "countrows":  					scope = ResolveAggrScope(args' 1' out bSimple);  					FunctionAggrCountRows aggrFCR = new FunctionAggrCountRows(scope);  					aggrFCR.LevelCheck = bSimple;  					result = aggrFCR;  					break;                  case "countdistinct":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCountDistinct aggrFCD = new FunctionAggrCountDistinct(_DataCache' args[0]' scope);  					aggrFCD.LevelCheck = bSimple;  					result = aggrFCD;  					break;  				case "rownumber":  					scope = ResolveAggrScope(args' 1' out bSimple);  					IExpr texpr = new ConstantDouble("0");  					result = new FunctionAggrRvCount(_DataCache' texpr' scope);  					break;  				case "runningvalue":  					if (args.Length < 2 || args.Length > 3)  						throw new ParserException(Strings.Parser_ErrorP_RunningValue_takes_2_or_3_arguments + GetLocationInfo(curToken));  					string aggrFunc = args[1].EvaluateString(null' null);  					if (aggrFunc == null)  						throw new ParserException(Strings.Parser_ErrorP_RunningValueArgumentInvalid + GetLocationInfo(curToken));  					scope = ResolveAggrScope(args' 3' out bSimple);  					switch(aggrFunc.ToLower())  					{  						case "sum":  							result = new FunctionAggrRvSum(_DataCache' args[0]' scope);  							break;  						case "avg":  							result = new FunctionAggrRvAvg(_DataCache' args[0]' scope);  							break;  						case "count":  							result = new FunctionAggrRvCount(_DataCache' args[0]' scope);  							break;  						case "max":  							result = new FunctionAggrRvMax(_DataCache' args[0]' scope);  							break;  						case "min":  							result = new FunctionAggrRvMin(_DataCache' args[0]' scope);  							break;  						case "stdev":  							result = new FunctionAggrRvStdev(_DataCache' args[0]' scope);  							break;  						case "stdevp":  							result = new FunctionAggrRvStdevp(_DataCache' args[0]' scope);  							break;  						case "var":  							result = new FunctionAggrRvVar(_DataCache' args[0]' scope);  							break;  						case "varp":  							result = new FunctionAggrRvVarp(_DataCache' args[0]' scope);  							break;  						default:  							throw new ParserException(string.Format(Strings.Parser_ErrorP_RunningValueNotSupported' aggrFunc) + GetLocationInfo(curToken));  					}  					break;  				case "stdev":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdev aggrSDev = new FunctionAggrStdev(_DataCache' args[0]' scope);  					aggrSDev.LevelCheck = bSimple;  					result = aggrSDev;  					break;  				case "stdevp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdevp aggrSDevP = new FunctionAggrStdevp(_DataCache' args[0]' scope);  					aggrSDevP.LevelCheck = bSimple;  					result = aggrSDevP;  					break;  				case "var":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVar aggrVar = new FunctionAggrVar(_DataCache' args[0]' scope);  					aggrVar.LevelCheck = bSimple;  					result = aggrVar;  					break;  				case "varp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVarp aggrVarP = new FunctionAggrVarp(_DataCache' args[0]' scope);  					aggrVarP.LevelCheck = bSimple;  					result = aggrVarP;  					break;  				default:  					result = ResolveMethodCall(fullname' args);		// through exception when fails  					break;  			}
Magic Number,fyiReporting.RDL,Parser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Parser.cs,MatchFuncIDent,The following statement contains a magic number: if (!bOnePart)				              {                  result = (firstPart == "Parameters")?                      ResolveParametersMethod(method' thirdPart' args):                      ResolveMethodCall(fullname' args);	// throw exception when fails              }  			else switch(method.ToLower())  			{  				case "iif":  					if (args.Length != 3)  						throw new ParserException(Strings.Parser_ErrorP_iff_function_requires_3_arguments + GetLocationInfo(curToken));  //  We allow any type for the first argument; it will get converted to boolean at runtime  //					if (args[0].GetTypeCode() != TypeCode.Boolean)  //						throw new ParserException("First argument to iif function must be boolean." + GetLocationInfo(curToken));  					result = new FunctionIif(args[0]' args[1]' args[2]);  					break;  				case "choose":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_ChooseRequires2Arguments + GetLocationInfo(curToken));  					switch (args[0].GetTypeCode())  					{  						case TypeCode.Double:  						case TypeCode.Single:  						case TypeCode.Int32:  						case TypeCode.Decimal:  						case TypeCode.Int16:  						case TypeCode.Int64:                          case TypeCode.UInt16:                          case TypeCode.UInt32:                          case TypeCode.UInt64:  							break;  						default:  							throw new ParserException(Strings.Parser_ErrorP_ChooseFirstArgumentMustNumeric + GetLocationInfo(curToken));  					}  					result = new FunctionChoose(args);  					break;  				case "switch":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_SwitchRequires2Arguments + GetLocationInfo(curToken));  				    if (args.Length % 2 != 0)  						throw new ParserException(Strings.Parser_ErrorP_SwitchMustEvenArguments + GetLocationInfo(curToken));  					for (int i=0; i < args.Length; i = i+2)  					{  						if (args[i].GetTypeCode() != TypeCode.Boolean)  							throw new ParserException(Strings.Parser_ErrorP_SwitchMustBoolean + GetLocationInfo(curToken));  					}  					result = new FunctionSwitch(args);  					break;  				case "format":  					if (args.Length > 2 || args.Length < 1)  						throw new ParserException(Strings.Parser_ErrorP_FormatRequires2Arguments + GetLocationInfo(curToken));  					if (args.Length == 1)  					{  						result = new FunctionFormat(args[0]' new ConstantString(""));  					}  					else  					{  						if (args[1].GetTypeCode() != TypeCode.String)  							throw new ParserException(Strings.Parser_ErrorP_SecondMustString + GetLocationInfo(curToken));  						result = new FunctionFormat(args[0]' args[1]);  					}  					break;    				case "fields":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_FieldsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionFieldCollection(idLookup.Fields' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                  TODO: generalize this code                          curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else  							throw new ParserException(string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Fields") + GetLocationInfo(curToken));                      }                      break;  				case "parameters":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ParametersRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionParameterCollection(idLookup.Parameters' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Parameters") + GetLocationInfo(curToken)));                      }                      break;  				case "reportitems":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ReportItemsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionReportItemCollection(idLookup.ReportItems' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "ReportItems") + GetLocationInfo(curToken)));                      }                      break;  				case "globals":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_GlobalsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionGlobalCollection(idLookup.Globals' args[0]);  					break;  				case "user":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_UserRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionUserCollection(idLookup.User' args[0]);  					break;  				case "sum":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrSum aggrFS = new FunctionAggrSum(_DataCache' args[0]' scope);  					aggrFS.LevelCheck = bSimple;  					result = aggrFS;  					break;  				case "avg":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrAvg aggrFA = new FunctionAggrAvg(_DataCache' args[0]' scope);  					aggrFA.LevelCheck = bSimple;  					result = aggrFA;  					break;  				case "min":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMin aggrFMin = new FunctionAggrMin(_DataCache' args[0]' scope);  					aggrFMin.LevelCheck = bSimple;  					result = aggrFMin;  					break;  				case "max":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMax aggrFMax = new FunctionAggrMax(_DataCache' args[0]' scope);  					aggrFMax.LevelCheck = bSimple;  					result = aggrFMax;  					break;  				case "first":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrFirst(_DataCache' args[0]' scope);  					break;  				case "last":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrLast(_DataCache' args[0]' scope);  					break;  				case "next":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrNext(_DataCache' args[0]' scope);  					break;  				case "previous":  				    scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrPrevious(_DataCache' args[0]' scope);  					break;  				case "level":  					scope = ResolveAggrScope(args' 1' out bSimple);  					result = new FunctionAggrLevel(scope);  					break;                  case "aggregate":                      scope = ResolveAggrScope(args' 2' out bSimple);                      FunctionAggrArray aggr = new FunctionAggrArray(_DataCache' args[0]' scope);                      aggr.LevelCheck = bSimple;                      result = aggr;                      break;                  case "count":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCount aggrFC = new FunctionAggrCount(_DataCache' args[0]' scope);  					aggrFC.LevelCheck = bSimple;  					result = aggrFC;  					break;  				case "countrows":  					scope = ResolveAggrScope(args' 1' out bSimple);  					FunctionAggrCountRows aggrFCR = new FunctionAggrCountRows(scope);  					aggrFCR.LevelCheck = bSimple;  					result = aggrFCR;  					break;                  case "countdistinct":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCountDistinct aggrFCD = new FunctionAggrCountDistinct(_DataCache' args[0]' scope);  					aggrFCD.LevelCheck = bSimple;  					result = aggrFCD;  					break;  				case "rownumber":  					scope = ResolveAggrScope(args' 1' out bSimple);  					IExpr texpr = new ConstantDouble("0");  					result = new FunctionAggrRvCount(_DataCache' texpr' scope);  					break;  				case "runningvalue":  					if (args.Length < 2 || args.Length > 3)  						throw new ParserException(Strings.Parser_ErrorP_RunningValue_takes_2_or_3_arguments + GetLocationInfo(curToken));  					string aggrFunc = args[1].EvaluateString(null' null);  					if (aggrFunc == null)  						throw new ParserException(Strings.Parser_ErrorP_RunningValueArgumentInvalid + GetLocationInfo(curToken));  					scope = ResolveAggrScope(args' 3' out bSimple);  					switch(aggrFunc.ToLower())  					{  						case "sum":  							result = new FunctionAggrRvSum(_DataCache' args[0]' scope);  							break;  						case "avg":  							result = new FunctionAggrRvAvg(_DataCache' args[0]' scope);  							break;  						case "count":  							result = new FunctionAggrRvCount(_DataCache' args[0]' scope);  							break;  						case "max":  							result = new FunctionAggrRvMax(_DataCache' args[0]' scope);  							break;  						case "min":  							result = new FunctionAggrRvMin(_DataCache' args[0]' scope);  							break;  						case "stdev":  							result = new FunctionAggrRvStdev(_DataCache' args[0]' scope);  							break;  						case "stdevp":  							result = new FunctionAggrRvStdevp(_DataCache' args[0]' scope);  							break;  						case "var":  							result = new FunctionAggrRvVar(_DataCache' args[0]' scope);  							break;  						case "varp":  							result = new FunctionAggrRvVarp(_DataCache' args[0]' scope);  							break;  						default:  							throw new ParserException(string.Format(Strings.Parser_ErrorP_RunningValueNotSupported' aggrFunc) + GetLocationInfo(curToken));  					}  					break;  				case "stdev":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdev aggrSDev = new FunctionAggrStdev(_DataCache' args[0]' scope);  					aggrSDev.LevelCheck = bSimple;  					result = aggrSDev;  					break;  				case "stdevp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdevp aggrSDevP = new FunctionAggrStdevp(_DataCache' args[0]' scope);  					aggrSDevP.LevelCheck = bSimple;  					result = aggrSDevP;  					break;  				case "var":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVar aggrVar = new FunctionAggrVar(_DataCache' args[0]' scope);  					aggrVar.LevelCheck = bSimple;  					result = aggrVar;  					break;  				case "varp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVarp aggrVarP = new FunctionAggrVarp(_DataCache' args[0]' scope);  					aggrVarP.LevelCheck = bSimple;  					result = aggrVarP;  					break;  				default:  					result = ResolveMethodCall(fullname' args);		// through exception when fails  					break;  			}
Magic Number,fyiReporting.RDL,Parser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Parser.cs,MatchFuncIDent,The following statement contains a magic number: if (!bOnePart)				              {                  result = (firstPart == "Parameters")?                      ResolveParametersMethod(method' thirdPart' args):                      ResolveMethodCall(fullname' args);	// throw exception when fails              }  			else switch(method.ToLower())  			{  				case "iif":  					if (args.Length != 3)  						throw new ParserException(Strings.Parser_ErrorP_iff_function_requires_3_arguments + GetLocationInfo(curToken));  //  We allow any type for the first argument; it will get converted to boolean at runtime  //					if (args[0].GetTypeCode() != TypeCode.Boolean)  //						throw new ParserException("First argument to iif function must be boolean." + GetLocationInfo(curToken));  					result = new FunctionIif(args[0]' args[1]' args[2]);  					break;  				case "choose":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_ChooseRequires2Arguments + GetLocationInfo(curToken));  					switch (args[0].GetTypeCode())  					{  						case TypeCode.Double:  						case TypeCode.Single:  						case TypeCode.Int32:  						case TypeCode.Decimal:  						case TypeCode.Int16:  						case TypeCode.Int64:                          case TypeCode.UInt16:                          case TypeCode.UInt32:                          case TypeCode.UInt64:  							break;  						default:  							throw new ParserException(Strings.Parser_ErrorP_ChooseFirstArgumentMustNumeric + GetLocationInfo(curToken));  					}  					result = new FunctionChoose(args);  					break;  				case "switch":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_SwitchRequires2Arguments + GetLocationInfo(curToken));  				    if (args.Length % 2 != 0)  						throw new ParserException(Strings.Parser_ErrorP_SwitchMustEvenArguments + GetLocationInfo(curToken));  					for (int i=0; i < args.Length; i = i+2)  					{  						if (args[i].GetTypeCode() != TypeCode.Boolean)  							throw new ParserException(Strings.Parser_ErrorP_SwitchMustBoolean + GetLocationInfo(curToken));  					}  					result = new FunctionSwitch(args);  					break;  				case "format":  					if (args.Length > 2 || args.Length < 1)  						throw new ParserException(Strings.Parser_ErrorP_FormatRequires2Arguments + GetLocationInfo(curToken));  					if (args.Length == 1)  					{  						result = new FunctionFormat(args[0]' new ConstantString(""));  					}  					else  					{  						if (args[1].GetTypeCode() != TypeCode.String)  							throw new ParserException(Strings.Parser_ErrorP_SecondMustString + GetLocationInfo(curToken));  						result = new FunctionFormat(args[0]' args[1]);  					}  					break;    				case "fields":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_FieldsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionFieldCollection(idLookup.Fields' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                  TODO: generalize this code                          curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else  							throw new ParserException(string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Fields") + GetLocationInfo(curToken));                      }                      break;  				case "parameters":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ParametersRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionParameterCollection(idLookup.Parameters' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Parameters") + GetLocationInfo(curToken)));                      }                      break;  				case "reportitems":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ReportItemsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionReportItemCollection(idLookup.ReportItems' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "ReportItems") + GetLocationInfo(curToken)));                      }                      break;  				case "globals":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_GlobalsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionGlobalCollection(idLookup.Globals' args[0]);  					break;  				case "user":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_UserRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionUserCollection(idLookup.User' args[0]);  					break;  				case "sum":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrSum aggrFS = new FunctionAggrSum(_DataCache' args[0]' scope);  					aggrFS.LevelCheck = bSimple;  					result = aggrFS;  					break;  				case "avg":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrAvg aggrFA = new FunctionAggrAvg(_DataCache' args[0]' scope);  					aggrFA.LevelCheck = bSimple;  					result = aggrFA;  					break;  				case "min":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMin aggrFMin = new FunctionAggrMin(_DataCache' args[0]' scope);  					aggrFMin.LevelCheck = bSimple;  					result = aggrFMin;  					break;  				case "max":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMax aggrFMax = new FunctionAggrMax(_DataCache' args[0]' scope);  					aggrFMax.LevelCheck = bSimple;  					result = aggrFMax;  					break;  				case "first":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrFirst(_DataCache' args[0]' scope);  					break;  				case "last":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrLast(_DataCache' args[0]' scope);  					break;  				case "next":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrNext(_DataCache' args[0]' scope);  					break;  				case "previous":  				    scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrPrevious(_DataCache' args[0]' scope);  					break;  				case "level":  					scope = ResolveAggrScope(args' 1' out bSimple);  					result = new FunctionAggrLevel(scope);  					break;                  case "aggregate":                      scope = ResolveAggrScope(args' 2' out bSimple);                      FunctionAggrArray aggr = new FunctionAggrArray(_DataCache' args[0]' scope);                      aggr.LevelCheck = bSimple;                      result = aggr;                      break;                  case "count":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCount aggrFC = new FunctionAggrCount(_DataCache' args[0]' scope);  					aggrFC.LevelCheck = bSimple;  					result = aggrFC;  					break;  				case "countrows":  					scope = ResolveAggrScope(args' 1' out bSimple);  					FunctionAggrCountRows aggrFCR = new FunctionAggrCountRows(scope);  					aggrFCR.LevelCheck = bSimple;  					result = aggrFCR;  					break;                  case "countdistinct":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCountDistinct aggrFCD = new FunctionAggrCountDistinct(_DataCache' args[0]' scope);  					aggrFCD.LevelCheck = bSimple;  					result = aggrFCD;  					break;  				case "rownumber":  					scope = ResolveAggrScope(args' 1' out bSimple);  					IExpr texpr = new ConstantDouble("0");  					result = new FunctionAggrRvCount(_DataCache' texpr' scope);  					break;  				case "runningvalue":  					if (args.Length < 2 || args.Length > 3)  						throw new ParserException(Strings.Parser_ErrorP_RunningValue_takes_2_or_3_arguments + GetLocationInfo(curToken));  					string aggrFunc = args[1].EvaluateString(null' null);  					if (aggrFunc == null)  						throw new ParserException(Strings.Parser_ErrorP_RunningValueArgumentInvalid + GetLocationInfo(curToken));  					scope = ResolveAggrScope(args' 3' out bSimple);  					switch(aggrFunc.ToLower())  					{  						case "sum":  							result = new FunctionAggrRvSum(_DataCache' args[0]' scope);  							break;  						case "avg":  							result = new FunctionAggrRvAvg(_DataCache' args[0]' scope);  							break;  						case "count":  							result = new FunctionAggrRvCount(_DataCache' args[0]' scope);  							break;  						case "max":  							result = new FunctionAggrRvMax(_DataCache' args[0]' scope);  							break;  						case "min":  							result = new FunctionAggrRvMin(_DataCache' args[0]' scope);  							break;  						case "stdev":  							result = new FunctionAggrRvStdev(_DataCache' args[0]' scope);  							break;  						case "stdevp":  							result = new FunctionAggrRvStdevp(_DataCache' args[0]' scope);  							break;  						case "var":  							result = new FunctionAggrRvVar(_DataCache' args[0]' scope);  							break;  						case "varp":  							result = new FunctionAggrRvVarp(_DataCache' args[0]' scope);  							break;  						default:  							throw new ParserException(string.Format(Strings.Parser_ErrorP_RunningValueNotSupported' aggrFunc) + GetLocationInfo(curToken));  					}  					break;  				case "stdev":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdev aggrSDev = new FunctionAggrStdev(_DataCache' args[0]' scope);  					aggrSDev.LevelCheck = bSimple;  					result = aggrSDev;  					break;  				case "stdevp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdevp aggrSDevP = new FunctionAggrStdevp(_DataCache' args[0]' scope);  					aggrSDevP.LevelCheck = bSimple;  					result = aggrSDevP;  					break;  				case "var":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVar aggrVar = new FunctionAggrVar(_DataCache' args[0]' scope);  					aggrVar.LevelCheck = bSimple;  					result = aggrVar;  					break;  				case "varp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVarp aggrVarP = new FunctionAggrVarp(_DataCache' args[0]' scope);  					aggrVarP.LevelCheck = bSimple;  					result = aggrVarP;  					break;  				default:  					result = ResolveMethodCall(fullname' args);		// through exception when fails  					break;  			}
Magic Number,fyiReporting.RDL,Parser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Parser.cs,MatchFuncIDent,The following statement contains a magic number: if (!bOnePart)				              {                  result = (firstPart == "Parameters")?                      ResolveParametersMethod(method' thirdPart' args):                      ResolveMethodCall(fullname' args);	// throw exception when fails              }  			else switch(method.ToLower())  			{  				case "iif":  					if (args.Length != 3)  						throw new ParserException(Strings.Parser_ErrorP_iff_function_requires_3_arguments + GetLocationInfo(curToken));  //  We allow any type for the first argument; it will get converted to boolean at runtime  //					if (args[0].GetTypeCode() != TypeCode.Boolean)  //						throw new ParserException("First argument to iif function must be boolean." + GetLocationInfo(curToken));  					result = new FunctionIif(args[0]' args[1]' args[2]);  					break;  				case "choose":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_ChooseRequires2Arguments + GetLocationInfo(curToken));  					switch (args[0].GetTypeCode())  					{  						case TypeCode.Double:  						case TypeCode.Single:  						case TypeCode.Int32:  						case TypeCode.Decimal:  						case TypeCode.Int16:  						case TypeCode.Int64:                          case TypeCode.UInt16:                          case TypeCode.UInt32:                          case TypeCode.UInt64:  							break;  						default:  							throw new ParserException(Strings.Parser_ErrorP_ChooseFirstArgumentMustNumeric + GetLocationInfo(curToken));  					}  					result = new FunctionChoose(args);  					break;  				case "switch":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_SwitchRequires2Arguments + GetLocationInfo(curToken));  				    if (args.Length % 2 != 0)  						throw new ParserException(Strings.Parser_ErrorP_SwitchMustEvenArguments + GetLocationInfo(curToken));  					for (int i=0; i < args.Length; i = i+2)  					{  						if (args[i].GetTypeCode() != TypeCode.Boolean)  							throw new ParserException(Strings.Parser_ErrorP_SwitchMustBoolean + GetLocationInfo(curToken));  					}  					result = new FunctionSwitch(args);  					break;  				case "format":  					if (args.Length > 2 || args.Length < 1)  						throw new ParserException(Strings.Parser_ErrorP_FormatRequires2Arguments + GetLocationInfo(curToken));  					if (args.Length == 1)  					{  						result = new FunctionFormat(args[0]' new ConstantString(""));  					}  					else  					{  						if (args[1].GetTypeCode() != TypeCode.String)  							throw new ParserException(Strings.Parser_ErrorP_SecondMustString + GetLocationInfo(curToken));  						result = new FunctionFormat(args[0]' args[1]);  					}  					break;    				case "fields":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_FieldsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionFieldCollection(idLookup.Fields' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                  TODO: generalize this code                          curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else  							throw new ParserException(string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Fields") + GetLocationInfo(curToken));                      }                      break;  				case "parameters":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ParametersRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionParameterCollection(idLookup.Parameters' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Parameters") + GetLocationInfo(curToken)));                      }                      break;  				case "reportitems":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ReportItemsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionReportItemCollection(idLookup.ReportItems' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "ReportItems") + GetLocationInfo(curToken)));                      }                      break;  				case "globals":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_GlobalsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionGlobalCollection(idLookup.Globals' args[0]);  					break;  				case "user":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_UserRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionUserCollection(idLookup.User' args[0]);  					break;  				case "sum":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrSum aggrFS = new FunctionAggrSum(_DataCache' args[0]' scope);  					aggrFS.LevelCheck = bSimple;  					result = aggrFS;  					break;  				case "avg":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrAvg aggrFA = new FunctionAggrAvg(_DataCache' args[0]' scope);  					aggrFA.LevelCheck = bSimple;  					result = aggrFA;  					break;  				case "min":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMin aggrFMin = new FunctionAggrMin(_DataCache' args[0]' scope);  					aggrFMin.LevelCheck = bSimple;  					result = aggrFMin;  					break;  				case "max":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMax aggrFMax = new FunctionAggrMax(_DataCache' args[0]' scope);  					aggrFMax.LevelCheck = bSimple;  					result = aggrFMax;  					break;  				case "first":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrFirst(_DataCache' args[0]' scope);  					break;  				case "last":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrLast(_DataCache' args[0]' scope);  					break;  				case "next":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrNext(_DataCache' args[0]' scope);  					break;  				case "previous":  				    scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrPrevious(_DataCache' args[0]' scope);  					break;  				case "level":  					scope = ResolveAggrScope(args' 1' out bSimple);  					result = new FunctionAggrLevel(scope);  					break;                  case "aggregate":                      scope = ResolveAggrScope(args' 2' out bSimple);                      FunctionAggrArray aggr = new FunctionAggrArray(_DataCache' args[0]' scope);                      aggr.LevelCheck = bSimple;                      result = aggr;                      break;                  case "count":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCount aggrFC = new FunctionAggrCount(_DataCache' args[0]' scope);  					aggrFC.LevelCheck = bSimple;  					result = aggrFC;  					break;  				case "countrows":  					scope = ResolveAggrScope(args' 1' out bSimple);  					FunctionAggrCountRows aggrFCR = new FunctionAggrCountRows(scope);  					aggrFCR.LevelCheck = bSimple;  					result = aggrFCR;  					break;                  case "countdistinct":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCountDistinct aggrFCD = new FunctionAggrCountDistinct(_DataCache' args[0]' scope);  					aggrFCD.LevelCheck = bSimple;  					result = aggrFCD;  					break;  				case "rownumber":  					scope = ResolveAggrScope(args' 1' out bSimple);  					IExpr texpr = new ConstantDouble("0");  					result = new FunctionAggrRvCount(_DataCache' texpr' scope);  					break;  				case "runningvalue":  					if (args.Length < 2 || args.Length > 3)  						throw new ParserException(Strings.Parser_ErrorP_RunningValue_takes_2_or_3_arguments + GetLocationInfo(curToken));  					string aggrFunc = args[1].EvaluateString(null' null);  					if (aggrFunc == null)  						throw new ParserException(Strings.Parser_ErrorP_RunningValueArgumentInvalid + GetLocationInfo(curToken));  					scope = ResolveAggrScope(args' 3' out bSimple);  					switch(aggrFunc.ToLower())  					{  						case "sum":  							result = new FunctionAggrRvSum(_DataCache' args[0]' scope);  							break;  						case "avg":  							result = new FunctionAggrRvAvg(_DataCache' args[0]' scope);  							break;  						case "count":  							result = new FunctionAggrRvCount(_DataCache' args[0]' scope);  							break;  						case "max":  							result = new FunctionAggrRvMax(_DataCache' args[0]' scope);  							break;  						case "min":  							result = new FunctionAggrRvMin(_DataCache' args[0]' scope);  							break;  						case "stdev":  							result = new FunctionAggrRvStdev(_DataCache' args[0]' scope);  							break;  						case "stdevp":  							result = new FunctionAggrRvStdevp(_DataCache' args[0]' scope);  							break;  						case "var":  							result = new FunctionAggrRvVar(_DataCache' args[0]' scope);  							break;  						case "varp":  							result = new FunctionAggrRvVarp(_DataCache' args[0]' scope);  							break;  						default:  							throw new ParserException(string.Format(Strings.Parser_ErrorP_RunningValueNotSupported' aggrFunc) + GetLocationInfo(curToken));  					}  					break;  				case "stdev":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdev aggrSDev = new FunctionAggrStdev(_DataCache' args[0]' scope);  					aggrSDev.LevelCheck = bSimple;  					result = aggrSDev;  					break;  				case "stdevp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdevp aggrSDevP = new FunctionAggrStdevp(_DataCache' args[0]' scope);  					aggrSDevP.LevelCheck = bSimple;  					result = aggrSDevP;  					break;  				case "var":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVar aggrVar = new FunctionAggrVar(_DataCache' args[0]' scope);  					aggrVar.LevelCheck = bSimple;  					result = aggrVar;  					break;  				case "varp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVarp aggrVarP = new FunctionAggrVarp(_DataCache' args[0]' scope);  					aggrVarP.LevelCheck = bSimple;  					result = aggrVarP;  					break;  				default:  					result = ResolveMethodCall(fullname' args);		// through exception when fails  					break;  			}
Magic Number,fyiReporting.RDL,Parser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Parser.cs,MatchFuncIDent,The following statement contains a magic number: if (!bOnePart)				              {                  result = (firstPart == "Parameters")?                      ResolveParametersMethod(method' thirdPart' args):                      ResolveMethodCall(fullname' args);	// throw exception when fails              }  			else switch(method.ToLower())  			{  				case "iif":  					if (args.Length != 3)  						throw new ParserException(Strings.Parser_ErrorP_iff_function_requires_3_arguments + GetLocationInfo(curToken));  //  We allow any type for the first argument; it will get converted to boolean at runtime  //					if (args[0].GetTypeCode() != TypeCode.Boolean)  //						throw new ParserException("First argument to iif function must be boolean." + GetLocationInfo(curToken));  					result = new FunctionIif(args[0]' args[1]' args[2]);  					break;  				case "choose":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_ChooseRequires2Arguments + GetLocationInfo(curToken));  					switch (args[0].GetTypeCode())  					{  						case TypeCode.Double:  						case TypeCode.Single:  						case TypeCode.Int32:  						case TypeCode.Decimal:  						case TypeCode.Int16:  						case TypeCode.Int64:                          case TypeCode.UInt16:                          case TypeCode.UInt32:                          case TypeCode.UInt64:  							break;  						default:  							throw new ParserException(Strings.Parser_ErrorP_ChooseFirstArgumentMustNumeric + GetLocationInfo(curToken));  					}  					result = new FunctionChoose(args);  					break;  				case "switch":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_SwitchRequires2Arguments + GetLocationInfo(curToken));  				    if (args.Length % 2 != 0)  						throw new ParserException(Strings.Parser_ErrorP_SwitchMustEvenArguments + GetLocationInfo(curToken));  					for (int i=0; i < args.Length; i = i+2)  					{  						if (args[i].GetTypeCode() != TypeCode.Boolean)  							throw new ParserException(Strings.Parser_ErrorP_SwitchMustBoolean + GetLocationInfo(curToken));  					}  					result = new FunctionSwitch(args);  					break;  				case "format":  					if (args.Length > 2 || args.Length < 1)  						throw new ParserException(Strings.Parser_ErrorP_FormatRequires2Arguments + GetLocationInfo(curToken));  					if (args.Length == 1)  					{  						result = new FunctionFormat(args[0]' new ConstantString(""));  					}  					else  					{  						if (args[1].GetTypeCode() != TypeCode.String)  							throw new ParserException(Strings.Parser_ErrorP_SecondMustString + GetLocationInfo(curToken));  						result = new FunctionFormat(args[0]' args[1]);  					}  					break;    				case "fields":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_FieldsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionFieldCollection(idLookup.Fields' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                  TODO: generalize this code                          curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else  							throw new ParserException(string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Fields") + GetLocationInfo(curToken));                      }                      break;  				case "parameters":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ParametersRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionParameterCollection(idLookup.Parameters' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Parameters") + GetLocationInfo(curToken)));                      }                      break;  				case "reportitems":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ReportItemsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionReportItemCollection(idLookup.ReportItems' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "ReportItems") + GetLocationInfo(curToken)));                      }                      break;  				case "globals":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_GlobalsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionGlobalCollection(idLookup.Globals' args[0]);  					break;  				case "user":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_UserRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionUserCollection(idLookup.User' args[0]);  					break;  				case "sum":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrSum aggrFS = new FunctionAggrSum(_DataCache' args[0]' scope);  					aggrFS.LevelCheck = bSimple;  					result = aggrFS;  					break;  				case "avg":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrAvg aggrFA = new FunctionAggrAvg(_DataCache' args[0]' scope);  					aggrFA.LevelCheck = bSimple;  					result = aggrFA;  					break;  				case "min":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMin aggrFMin = new FunctionAggrMin(_DataCache' args[0]' scope);  					aggrFMin.LevelCheck = bSimple;  					result = aggrFMin;  					break;  				case "max":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMax aggrFMax = new FunctionAggrMax(_DataCache' args[0]' scope);  					aggrFMax.LevelCheck = bSimple;  					result = aggrFMax;  					break;  				case "first":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrFirst(_DataCache' args[0]' scope);  					break;  				case "last":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrLast(_DataCache' args[0]' scope);  					break;  				case "next":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrNext(_DataCache' args[0]' scope);  					break;  				case "previous":  				    scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrPrevious(_DataCache' args[0]' scope);  					break;  				case "level":  					scope = ResolveAggrScope(args' 1' out bSimple);  					result = new FunctionAggrLevel(scope);  					break;                  case "aggregate":                      scope = ResolveAggrScope(args' 2' out bSimple);                      FunctionAggrArray aggr = new FunctionAggrArray(_DataCache' args[0]' scope);                      aggr.LevelCheck = bSimple;                      result = aggr;                      break;                  case "count":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCount aggrFC = new FunctionAggrCount(_DataCache' args[0]' scope);  					aggrFC.LevelCheck = bSimple;  					result = aggrFC;  					break;  				case "countrows":  					scope = ResolveAggrScope(args' 1' out bSimple);  					FunctionAggrCountRows aggrFCR = new FunctionAggrCountRows(scope);  					aggrFCR.LevelCheck = bSimple;  					result = aggrFCR;  					break;                  case "countdistinct":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCountDistinct aggrFCD = new FunctionAggrCountDistinct(_DataCache' args[0]' scope);  					aggrFCD.LevelCheck = bSimple;  					result = aggrFCD;  					break;  				case "rownumber":  					scope = ResolveAggrScope(args' 1' out bSimple);  					IExpr texpr = new ConstantDouble("0");  					result = new FunctionAggrRvCount(_DataCache' texpr' scope);  					break;  				case "runningvalue":  					if (args.Length < 2 || args.Length > 3)  						throw new ParserException(Strings.Parser_ErrorP_RunningValue_takes_2_or_3_arguments + GetLocationInfo(curToken));  					string aggrFunc = args[1].EvaluateString(null' null);  					if (aggrFunc == null)  						throw new ParserException(Strings.Parser_ErrorP_RunningValueArgumentInvalid + GetLocationInfo(curToken));  					scope = ResolveAggrScope(args' 3' out bSimple);  					switch(aggrFunc.ToLower())  					{  						case "sum":  							result = new FunctionAggrRvSum(_DataCache' args[0]' scope);  							break;  						case "avg":  							result = new FunctionAggrRvAvg(_DataCache' args[0]' scope);  							break;  						case "count":  							result = new FunctionAggrRvCount(_DataCache' args[0]' scope);  							break;  						case "max":  							result = new FunctionAggrRvMax(_DataCache' args[0]' scope);  							break;  						case "min":  							result = new FunctionAggrRvMin(_DataCache' args[0]' scope);  							break;  						case "stdev":  							result = new FunctionAggrRvStdev(_DataCache' args[0]' scope);  							break;  						case "stdevp":  							result = new FunctionAggrRvStdevp(_DataCache' args[0]' scope);  							break;  						case "var":  							result = new FunctionAggrRvVar(_DataCache' args[0]' scope);  							break;  						case "varp":  							result = new FunctionAggrRvVarp(_DataCache' args[0]' scope);  							break;  						default:  							throw new ParserException(string.Format(Strings.Parser_ErrorP_RunningValueNotSupported' aggrFunc) + GetLocationInfo(curToken));  					}  					break;  				case "stdev":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdev aggrSDev = new FunctionAggrStdev(_DataCache' args[0]' scope);  					aggrSDev.LevelCheck = bSimple;  					result = aggrSDev;  					break;  				case "stdevp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdevp aggrSDevP = new FunctionAggrStdevp(_DataCache' args[0]' scope);  					aggrSDevP.LevelCheck = bSimple;  					result = aggrSDevP;  					break;  				case "var":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVar aggrVar = new FunctionAggrVar(_DataCache' args[0]' scope);  					aggrVar.LevelCheck = bSimple;  					result = aggrVar;  					break;  				case "varp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVarp aggrVarP = new FunctionAggrVarp(_DataCache' args[0]' scope);  					aggrVarP.LevelCheck = bSimple;  					result = aggrVarP;  					break;  				default:  					result = ResolveMethodCall(fullname' args);		// through exception when fails  					break;  			}
Magic Number,fyiReporting.RDL,Parser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Parser.cs,MatchFuncIDent,The following statement contains a magic number: if (!bOnePart)				              {                  result = (firstPart == "Parameters")?                      ResolveParametersMethod(method' thirdPart' args):                      ResolveMethodCall(fullname' args);	// throw exception when fails              }  			else switch(method.ToLower())  			{  				case "iif":  					if (args.Length != 3)  						throw new ParserException(Strings.Parser_ErrorP_iff_function_requires_3_arguments + GetLocationInfo(curToken));  //  We allow any type for the first argument; it will get converted to boolean at runtime  //					if (args[0].GetTypeCode() != TypeCode.Boolean)  //						throw new ParserException("First argument to iif function must be boolean." + GetLocationInfo(curToken));  					result = new FunctionIif(args[0]' args[1]' args[2]);  					break;  				case "choose":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_ChooseRequires2Arguments + GetLocationInfo(curToken));  					switch (args[0].GetTypeCode())  					{  						case TypeCode.Double:  						case TypeCode.Single:  						case TypeCode.Int32:  						case TypeCode.Decimal:  						case TypeCode.Int16:  						case TypeCode.Int64:                          case TypeCode.UInt16:                          case TypeCode.UInt32:                          case TypeCode.UInt64:  							break;  						default:  							throw new ParserException(Strings.Parser_ErrorP_ChooseFirstArgumentMustNumeric + GetLocationInfo(curToken));  					}  					result = new FunctionChoose(args);  					break;  				case "switch":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_SwitchRequires2Arguments + GetLocationInfo(curToken));  				    if (args.Length % 2 != 0)  						throw new ParserException(Strings.Parser_ErrorP_SwitchMustEvenArguments + GetLocationInfo(curToken));  					for (int i=0; i < args.Length; i = i+2)  					{  						if (args[i].GetTypeCode() != TypeCode.Boolean)  							throw new ParserException(Strings.Parser_ErrorP_SwitchMustBoolean + GetLocationInfo(curToken));  					}  					result = new FunctionSwitch(args);  					break;  				case "format":  					if (args.Length > 2 || args.Length < 1)  						throw new ParserException(Strings.Parser_ErrorP_FormatRequires2Arguments + GetLocationInfo(curToken));  					if (args.Length == 1)  					{  						result = new FunctionFormat(args[0]' new ConstantString(""));  					}  					else  					{  						if (args[1].GetTypeCode() != TypeCode.String)  							throw new ParserException(Strings.Parser_ErrorP_SecondMustString + GetLocationInfo(curToken));  						result = new FunctionFormat(args[0]' args[1]);  					}  					break;    				case "fields":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_FieldsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionFieldCollection(idLookup.Fields' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                  TODO: generalize this code                          curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else  							throw new ParserException(string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Fields") + GetLocationInfo(curToken));                      }                      break;  				case "parameters":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ParametersRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionParameterCollection(idLookup.Parameters' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Parameters") + GetLocationInfo(curToken)));                      }                      break;  				case "reportitems":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ReportItemsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionReportItemCollection(idLookup.ReportItems' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "ReportItems") + GetLocationInfo(curToken)));                      }                      break;  				case "globals":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_GlobalsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionGlobalCollection(idLookup.Globals' args[0]);  					break;  				case "user":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_UserRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionUserCollection(idLookup.User' args[0]);  					break;  				case "sum":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrSum aggrFS = new FunctionAggrSum(_DataCache' args[0]' scope);  					aggrFS.LevelCheck = bSimple;  					result = aggrFS;  					break;  				case "avg":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrAvg aggrFA = new FunctionAggrAvg(_DataCache' args[0]' scope);  					aggrFA.LevelCheck = bSimple;  					result = aggrFA;  					break;  				case "min":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMin aggrFMin = new FunctionAggrMin(_DataCache' args[0]' scope);  					aggrFMin.LevelCheck = bSimple;  					result = aggrFMin;  					break;  				case "max":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMax aggrFMax = new FunctionAggrMax(_DataCache' args[0]' scope);  					aggrFMax.LevelCheck = bSimple;  					result = aggrFMax;  					break;  				case "first":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrFirst(_DataCache' args[0]' scope);  					break;  				case "last":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrLast(_DataCache' args[0]' scope);  					break;  				case "next":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrNext(_DataCache' args[0]' scope);  					break;  				case "previous":  				    scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrPrevious(_DataCache' args[0]' scope);  					break;  				case "level":  					scope = ResolveAggrScope(args' 1' out bSimple);  					result = new FunctionAggrLevel(scope);  					break;                  case "aggregate":                      scope = ResolveAggrScope(args' 2' out bSimple);                      FunctionAggrArray aggr = new FunctionAggrArray(_DataCache' args[0]' scope);                      aggr.LevelCheck = bSimple;                      result = aggr;                      break;                  case "count":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCount aggrFC = new FunctionAggrCount(_DataCache' args[0]' scope);  					aggrFC.LevelCheck = bSimple;  					result = aggrFC;  					break;  				case "countrows":  					scope = ResolveAggrScope(args' 1' out bSimple);  					FunctionAggrCountRows aggrFCR = new FunctionAggrCountRows(scope);  					aggrFCR.LevelCheck = bSimple;  					result = aggrFCR;  					break;                  case "countdistinct":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCountDistinct aggrFCD = new FunctionAggrCountDistinct(_DataCache' args[0]' scope);  					aggrFCD.LevelCheck = bSimple;  					result = aggrFCD;  					break;  				case "rownumber":  					scope = ResolveAggrScope(args' 1' out bSimple);  					IExpr texpr = new ConstantDouble("0");  					result = new FunctionAggrRvCount(_DataCache' texpr' scope);  					break;  				case "runningvalue":  					if (args.Length < 2 || args.Length > 3)  						throw new ParserException(Strings.Parser_ErrorP_RunningValue_takes_2_or_3_arguments + GetLocationInfo(curToken));  					string aggrFunc = args[1].EvaluateString(null' null);  					if (aggrFunc == null)  						throw new ParserException(Strings.Parser_ErrorP_RunningValueArgumentInvalid + GetLocationInfo(curToken));  					scope = ResolveAggrScope(args' 3' out bSimple);  					switch(aggrFunc.ToLower())  					{  						case "sum":  							result = new FunctionAggrRvSum(_DataCache' args[0]' scope);  							break;  						case "avg":  							result = new FunctionAggrRvAvg(_DataCache' args[0]' scope);  							break;  						case "count":  							result = new FunctionAggrRvCount(_DataCache' args[0]' scope);  							break;  						case "max":  							result = new FunctionAggrRvMax(_DataCache' args[0]' scope);  							break;  						case "min":  							result = new FunctionAggrRvMin(_DataCache' args[0]' scope);  							break;  						case "stdev":  							result = new FunctionAggrRvStdev(_DataCache' args[0]' scope);  							break;  						case "stdevp":  							result = new FunctionAggrRvStdevp(_DataCache' args[0]' scope);  							break;  						case "var":  							result = new FunctionAggrRvVar(_DataCache' args[0]' scope);  							break;  						case "varp":  							result = new FunctionAggrRvVarp(_DataCache' args[0]' scope);  							break;  						default:  							throw new ParserException(string.Format(Strings.Parser_ErrorP_RunningValueNotSupported' aggrFunc) + GetLocationInfo(curToken));  					}  					break;  				case "stdev":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdev aggrSDev = new FunctionAggrStdev(_DataCache' args[0]' scope);  					aggrSDev.LevelCheck = bSimple;  					result = aggrSDev;  					break;  				case "stdevp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdevp aggrSDevP = new FunctionAggrStdevp(_DataCache' args[0]' scope);  					aggrSDevP.LevelCheck = bSimple;  					result = aggrSDevP;  					break;  				case "var":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVar aggrVar = new FunctionAggrVar(_DataCache' args[0]' scope);  					aggrVar.LevelCheck = bSimple;  					result = aggrVar;  					break;  				case "varp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVarp aggrVarP = new FunctionAggrVarp(_DataCache' args[0]' scope);  					aggrVarP.LevelCheck = bSimple;  					result = aggrVarP;  					break;  				default:  					result = ResolveMethodCall(fullname' args);		// through exception when fails  					break;  			}
Magic Number,fyiReporting.RDL,Parser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Parser.cs,MatchFuncIDent,The following statement contains a magic number: if (!bOnePart)				              {                  result = (firstPart == "Parameters")?                      ResolveParametersMethod(method' thirdPart' args):                      ResolveMethodCall(fullname' args);	// throw exception when fails              }  			else switch(method.ToLower())  			{  				case "iif":  					if (args.Length != 3)  						throw new ParserException(Strings.Parser_ErrorP_iff_function_requires_3_arguments + GetLocationInfo(curToken));  //  We allow any type for the first argument; it will get converted to boolean at runtime  //					if (args[0].GetTypeCode() != TypeCode.Boolean)  //						throw new ParserException("First argument to iif function must be boolean." + GetLocationInfo(curToken));  					result = new FunctionIif(args[0]' args[1]' args[2]);  					break;  				case "choose":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_ChooseRequires2Arguments + GetLocationInfo(curToken));  					switch (args[0].GetTypeCode())  					{  						case TypeCode.Double:  						case TypeCode.Single:  						case TypeCode.Int32:  						case TypeCode.Decimal:  						case TypeCode.Int16:  						case TypeCode.Int64:                          case TypeCode.UInt16:                          case TypeCode.UInt32:                          case TypeCode.UInt64:  							break;  						default:  							throw new ParserException(Strings.Parser_ErrorP_ChooseFirstArgumentMustNumeric + GetLocationInfo(curToken));  					}  					result = new FunctionChoose(args);  					break;  				case "switch":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_SwitchRequires2Arguments + GetLocationInfo(curToken));  				    if (args.Length % 2 != 0)  						throw new ParserException(Strings.Parser_ErrorP_SwitchMustEvenArguments + GetLocationInfo(curToken));  					for (int i=0; i < args.Length; i = i+2)  					{  						if (args[i].GetTypeCode() != TypeCode.Boolean)  							throw new ParserException(Strings.Parser_ErrorP_SwitchMustBoolean + GetLocationInfo(curToken));  					}  					result = new FunctionSwitch(args);  					break;  				case "format":  					if (args.Length > 2 || args.Length < 1)  						throw new ParserException(Strings.Parser_ErrorP_FormatRequires2Arguments + GetLocationInfo(curToken));  					if (args.Length == 1)  					{  						result = new FunctionFormat(args[0]' new ConstantString(""));  					}  					else  					{  						if (args[1].GetTypeCode() != TypeCode.String)  							throw new ParserException(Strings.Parser_ErrorP_SecondMustString + GetLocationInfo(curToken));  						result = new FunctionFormat(args[0]' args[1]);  					}  					break;    				case "fields":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_FieldsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionFieldCollection(idLookup.Fields' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                  TODO: generalize this code                          curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else  							throw new ParserException(string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Fields") + GetLocationInfo(curToken));                      }                      break;  				case "parameters":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ParametersRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionParameterCollection(idLookup.Parameters' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Parameters") + GetLocationInfo(curToken)));                      }                      break;  				case "reportitems":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ReportItemsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionReportItemCollection(idLookup.ReportItems' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "ReportItems") + GetLocationInfo(curToken)));                      }                      break;  				case "globals":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_GlobalsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionGlobalCollection(idLookup.Globals' args[0]);  					break;  				case "user":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_UserRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionUserCollection(idLookup.User' args[0]);  					break;  				case "sum":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrSum aggrFS = new FunctionAggrSum(_DataCache' args[0]' scope);  					aggrFS.LevelCheck = bSimple;  					result = aggrFS;  					break;  				case "avg":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrAvg aggrFA = new FunctionAggrAvg(_DataCache' args[0]' scope);  					aggrFA.LevelCheck = bSimple;  					result = aggrFA;  					break;  				case "min":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMin aggrFMin = new FunctionAggrMin(_DataCache' args[0]' scope);  					aggrFMin.LevelCheck = bSimple;  					result = aggrFMin;  					break;  				case "max":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMax aggrFMax = new FunctionAggrMax(_DataCache' args[0]' scope);  					aggrFMax.LevelCheck = bSimple;  					result = aggrFMax;  					break;  				case "first":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrFirst(_DataCache' args[0]' scope);  					break;  				case "last":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrLast(_DataCache' args[0]' scope);  					break;  				case "next":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrNext(_DataCache' args[0]' scope);  					break;  				case "previous":  				    scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrPrevious(_DataCache' args[0]' scope);  					break;  				case "level":  					scope = ResolveAggrScope(args' 1' out bSimple);  					result = new FunctionAggrLevel(scope);  					break;                  case "aggregate":                      scope = ResolveAggrScope(args' 2' out bSimple);                      FunctionAggrArray aggr = new FunctionAggrArray(_DataCache' args[0]' scope);                      aggr.LevelCheck = bSimple;                      result = aggr;                      break;                  case "count":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCount aggrFC = new FunctionAggrCount(_DataCache' args[0]' scope);  					aggrFC.LevelCheck = bSimple;  					result = aggrFC;  					break;  				case "countrows":  					scope = ResolveAggrScope(args' 1' out bSimple);  					FunctionAggrCountRows aggrFCR = new FunctionAggrCountRows(scope);  					aggrFCR.LevelCheck = bSimple;  					result = aggrFCR;  					break;                  case "countdistinct":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCountDistinct aggrFCD = new FunctionAggrCountDistinct(_DataCache' args[0]' scope);  					aggrFCD.LevelCheck = bSimple;  					result = aggrFCD;  					break;  				case "rownumber":  					scope = ResolveAggrScope(args' 1' out bSimple);  					IExpr texpr = new ConstantDouble("0");  					result = new FunctionAggrRvCount(_DataCache' texpr' scope);  					break;  				case "runningvalue":  					if (args.Length < 2 || args.Length > 3)  						throw new ParserException(Strings.Parser_ErrorP_RunningValue_takes_2_or_3_arguments + GetLocationInfo(curToken));  					string aggrFunc = args[1].EvaluateString(null' null);  					if (aggrFunc == null)  						throw new ParserException(Strings.Parser_ErrorP_RunningValueArgumentInvalid + GetLocationInfo(curToken));  					scope = ResolveAggrScope(args' 3' out bSimple);  					switch(aggrFunc.ToLower())  					{  						case "sum":  							result = new FunctionAggrRvSum(_DataCache' args[0]' scope);  							break;  						case "avg":  							result = new FunctionAggrRvAvg(_DataCache' args[0]' scope);  							break;  						case "count":  							result = new FunctionAggrRvCount(_DataCache' args[0]' scope);  							break;  						case "max":  							result = new FunctionAggrRvMax(_DataCache' args[0]' scope);  							break;  						case "min":  							result = new FunctionAggrRvMin(_DataCache' args[0]' scope);  							break;  						case "stdev":  							result = new FunctionAggrRvStdev(_DataCache' args[0]' scope);  							break;  						case "stdevp":  							result = new FunctionAggrRvStdevp(_DataCache' args[0]' scope);  							break;  						case "var":  							result = new FunctionAggrRvVar(_DataCache' args[0]' scope);  							break;  						case "varp":  							result = new FunctionAggrRvVarp(_DataCache' args[0]' scope);  							break;  						default:  							throw new ParserException(string.Format(Strings.Parser_ErrorP_RunningValueNotSupported' aggrFunc) + GetLocationInfo(curToken));  					}  					break;  				case "stdev":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdev aggrSDev = new FunctionAggrStdev(_DataCache' args[0]' scope);  					aggrSDev.LevelCheck = bSimple;  					result = aggrSDev;  					break;  				case "stdevp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdevp aggrSDevP = new FunctionAggrStdevp(_DataCache' args[0]' scope);  					aggrSDevP.LevelCheck = bSimple;  					result = aggrSDevP;  					break;  				case "var":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVar aggrVar = new FunctionAggrVar(_DataCache' args[0]' scope);  					aggrVar.LevelCheck = bSimple;  					result = aggrVar;  					break;  				case "varp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVarp aggrVarP = new FunctionAggrVarp(_DataCache' args[0]' scope);  					aggrVarP.LevelCheck = bSimple;  					result = aggrVarP;  					break;  				default:  					result = ResolveMethodCall(fullname' args);		// through exception when fails  					break;  			}
Magic Number,fyiReporting.RDL,Parser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Parser.cs,MatchFuncIDent,The following statement contains a magic number: if (!bOnePart)				              {                  result = (firstPart == "Parameters")?                      ResolveParametersMethod(method' thirdPart' args):                      ResolveMethodCall(fullname' args);	// throw exception when fails              }  			else switch(method.ToLower())  			{  				case "iif":  					if (args.Length != 3)  						throw new ParserException(Strings.Parser_ErrorP_iff_function_requires_3_arguments + GetLocationInfo(curToken));  //  We allow any type for the first argument; it will get converted to boolean at runtime  //					if (args[0].GetTypeCode() != TypeCode.Boolean)  //						throw new ParserException("First argument to iif function must be boolean." + GetLocationInfo(curToken));  					result = new FunctionIif(args[0]' args[1]' args[2]);  					break;  				case "choose":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_ChooseRequires2Arguments + GetLocationInfo(curToken));  					switch (args[0].GetTypeCode())  					{  						case TypeCode.Double:  						case TypeCode.Single:  						case TypeCode.Int32:  						case TypeCode.Decimal:  						case TypeCode.Int16:  						case TypeCode.Int64:                          case TypeCode.UInt16:                          case TypeCode.UInt32:                          case TypeCode.UInt64:  							break;  						default:  							throw new ParserException(Strings.Parser_ErrorP_ChooseFirstArgumentMustNumeric + GetLocationInfo(curToken));  					}  					result = new FunctionChoose(args);  					break;  				case "switch":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_SwitchRequires2Arguments + GetLocationInfo(curToken));  				    if (args.Length % 2 != 0)  						throw new ParserException(Strings.Parser_ErrorP_SwitchMustEvenArguments + GetLocationInfo(curToken));  					for (int i=0; i < args.Length; i = i+2)  					{  						if (args[i].GetTypeCode() != TypeCode.Boolean)  							throw new ParserException(Strings.Parser_ErrorP_SwitchMustBoolean + GetLocationInfo(curToken));  					}  					result = new FunctionSwitch(args);  					break;  				case "format":  					if (args.Length > 2 || args.Length < 1)  						throw new ParserException(Strings.Parser_ErrorP_FormatRequires2Arguments + GetLocationInfo(curToken));  					if (args.Length == 1)  					{  						result = new FunctionFormat(args[0]' new ConstantString(""));  					}  					else  					{  						if (args[1].GetTypeCode() != TypeCode.String)  							throw new ParserException(Strings.Parser_ErrorP_SecondMustString + GetLocationInfo(curToken));  						result = new FunctionFormat(args[0]' args[1]);  					}  					break;    				case "fields":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_FieldsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionFieldCollection(idLookup.Fields' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                  TODO: generalize this code                          curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else  							throw new ParserException(string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Fields") + GetLocationInfo(curToken));                      }                      break;  				case "parameters":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ParametersRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionParameterCollection(idLookup.Parameters' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Parameters") + GetLocationInfo(curToken)));                      }                      break;  				case "reportitems":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ReportItemsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionReportItemCollection(idLookup.ReportItems' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "ReportItems") + GetLocationInfo(curToken)));                      }                      break;  				case "globals":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_GlobalsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionGlobalCollection(idLookup.Globals' args[0]);  					break;  				case "user":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_UserRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionUserCollection(idLookup.User' args[0]);  					break;  				case "sum":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrSum aggrFS = new FunctionAggrSum(_DataCache' args[0]' scope);  					aggrFS.LevelCheck = bSimple;  					result = aggrFS;  					break;  				case "avg":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrAvg aggrFA = new FunctionAggrAvg(_DataCache' args[0]' scope);  					aggrFA.LevelCheck = bSimple;  					result = aggrFA;  					break;  				case "min":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMin aggrFMin = new FunctionAggrMin(_DataCache' args[0]' scope);  					aggrFMin.LevelCheck = bSimple;  					result = aggrFMin;  					break;  				case "max":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMax aggrFMax = new FunctionAggrMax(_DataCache' args[0]' scope);  					aggrFMax.LevelCheck = bSimple;  					result = aggrFMax;  					break;  				case "first":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrFirst(_DataCache' args[0]' scope);  					break;  				case "last":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrLast(_DataCache' args[0]' scope);  					break;  				case "next":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrNext(_DataCache' args[0]' scope);  					break;  				case "previous":  				    scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrPrevious(_DataCache' args[0]' scope);  					break;  				case "level":  					scope = ResolveAggrScope(args' 1' out bSimple);  					result = new FunctionAggrLevel(scope);  					break;                  case "aggregate":                      scope = ResolveAggrScope(args' 2' out bSimple);                      FunctionAggrArray aggr = new FunctionAggrArray(_DataCache' args[0]' scope);                      aggr.LevelCheck = bSimple;                      result = aggr;                      break;                  case "count":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCount aggrFC = new FunctionAggrCount(_DataCache' args[0]' scope);  					aggrFC.LevelCheck = bSimple;  					result = aggrFC;  					break;  				case "countrows":  					scope = ResolveAggrScope(args' 1' out bSimple);  					FunctionAggrCountRows aggrFCR = new FunctionAggrCountRows(scope);  					aggrFCR.LevelCheck = bSimple;  					result = aggrFCR;  					break;                  case "countdistinct":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCountDistinct aggrFCD = new FunctionAggrCountDistinct(_DataCache' args[0]' scope);  					aggrFCD.LevelCheck = bSimple;  					result = aggrFCD;  					break;  				case "rownumber":  					scope = ResolveAggrScope(args' 1' out bSimple);  					IExpr texpr = new ConstantDouble("0");  					result = new FunctionAggrRvCount(_DataCache' texpr' scope);  					break;  				case "runningvalue":  					if (args.Length < 2 || args.Length > 3)  						throw new ParserException(Strings.Parser_ErrorP_RunningValue_takes_2_or_3_arguments + GetLocationInfo(curToken));  					string aggrFunc = args[1].EvaluateString(null' null);  					if (aggrFunc == null)  						throw new ParserException(Strings.Parser_ErrorP_RunningValueArgumentInvalid + GetLocationInfo(curToken));  					scope = ResolveAggrScope(args' 3' out bSimple);  					switch(aggrFunc.ToLower())  					{  						case "sum":  							result = new FunctionAggrRvSum(_DataCache' args[0]' scope);  							break;  						case "avg":  							result = new FunctionAggrRvAvg(_DataCache' args[0]' scope);  							break;  						case "count":  							result = new FunctionAggrRvCount(_DataCache' args[0]' scope);  							break;  						case "max":  							result = new FunctionAggrRvMax(_DataCache' args[0]' scope);  							break;  						case "min":  							result = new FunctionAggrRvMin(_DataCache' args[0]' scope);  							break;  						case "stdev":  							result = new FunctionAggrRvStdev(_DataCache' args[0]' scope);  							break;  						case "stdevp":  							result = new FunctionAggrRvStdevp(_DataCache' args[0]' scope);  							break;  						case "var":  							result = new FunctionAggrRvVar(_DataCache' args[0]' scope);  							break;  						case "varp":  							result = new FunctionAggrRvVarp(_DataCache' args[0]' scope);  							break;  						default:  							throw new ParserException(string.Format(Strings.Parser_ErrorP_RunningValueNotSupported' aggrFunc) + GetLocationInfo(curToken));  					}  					break;  				case "stdev":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdev aggrSDev = new FunctionAggrStdev(_DataCache' args[0]' scope);  					aggrSDev.LevelCheck = bSimple;  					result = aggrSDev;  					break;  				case "stdevp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdevp aggrSDevP = new FunctionAggrStdevp(_DataCache' args[0]' scope);  					aggrSDevP.LevelCheck = bSimple;  					result = aggrSDevP;  					break;  				case "var":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVar aggrVar = new FunctionAggrVar(_DataCache' args[0]' scope);  					aggrVar.LevelCheck = bSimple;  					result = aggrVar;  					break;  				case "varp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVarp aggrVarP = new FunctionAggrVarp(_DataCache' args[0]' scope);  					aggrVarP.LevelCheck = bSimple;  					result = aggrVarP;  					break;  				default:  					result = ResolveMethodCall(fullname' args);		// through exception when fails  					break;  			}
Magic Number,fyiReporting.RDL,Parser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Parser.cs,MatchFuncIDent,The following statement contains a magic number: if (!bOnePart)				              {                  result = (firstPart == "Parameters")?                      ResolveParametersMethod(method' thirdPart' args):                      ResolveMethodCall(fullname' args);	// throw exception when fails              }  			else switch(method.ToLower())  			{  				case "iif":  					if (args.Length != 3)  						throw new ParserException(Strings.Parser_ErrorP_iff_function_requires_3_arguments + GetLocationInfo(curToken));  //  We allow any type for the first argument; it will get converted to boolean at runtime  //					if (args[0].GetTypeCode() != TypeCode.Boolean)  //						throw new ParserException("First argument to iif function must be boolean." + GetLocationInfo(curToken));  					result = new FunctionIif(args[0]' args[1]' args[2]);  					break;  				case "choose":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_ChooseRequires2Arguments + GetLocationInfo(curToken));  					switch (args[0].GetTypeCode())  					{  						case TypeCode.Double:  						case TypeCode.Single:  						case TypeCode.Int32:  						case TypeCode.Decimal:  						case TypeCode.Int16:  						case TypeCode.Int64:                          case TypeCode.UInt16:                          case TypeCode.UInt32:                          case TypeCode.UInt64:  							break;  						default:  							throw new ParserException(Strings.Parser_ErrorP_ChooseFirstArgumentMustNumeric + GetLocationInfo(curToken));  					}  					result = new FunctionChoose(args);  					break;  				case "switch":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_SwitchRequires2Arguments + GetLocationInfo(curToken));  				    if (args.Length % 2 != 0)  						throw new ParserException(Strings.Parser_ErrorP_SwitchMustEvenArguments + GetLocationInfo(curToken));  					for (int i=0; i < args.Length; i = i+2)  					{  						if (args[i].GetTypeCode() != TypeCode.Boolean)  							throw new ParserException(Strings.Parser_ErrorP_SwitchMustBoolean + GetLocationInfo(curToken));  					}  					result = new FunctionSwitch(args);  					break;  				case "format":  					if (args.Length > 2 || args.Length < 1)  						throw new ParserException(Strings.Parser_ErrorP_FormatRequires2Arguments + GetLocationInfo(curToken));  					if (args.Length == 1)  					{  						result = new FunctionFormat(args[0]' new ConstantString(""));  					}  					else  					{  						if (args[1].GetTypeCode() != TypeCode.String)  							throw new ParserException(Strings.Parser_ErrorP_SecondMustString + GetLocationInfo(curToken));  						result = new FunctionFormat(args[0]' args[1]);  					}  					break;    				case "fields":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_FieldsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionFieldCollection(idLookup.Fields' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                  TODO: generalize this code                          curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else  							throw new ParserException(string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Fields") + GetLocationInfo(curToken));                      }                      break;  				case "parameters":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ParametersRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionParameterCollection(idLookup.Parameters' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Parameters") + GetLocationInfo(curToken)));                      }                      break;  				case "reportitems":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ReportItemsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionReportItemCollection(idLookup.ReportItems' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "ReportItems") + GetLocationInfo(curToken)));                      }                      break;  				case "globals":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_GlobalsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionGlobalCollection(idLookup.Globals' args[0]);  					break;  				case "user":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_UserRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionUserCollection(idLookup.User' args[0]);  					break;  				case "sum":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrSum aggrFS = new FunctionAggrSum(_DataCache' args[0]' scope);  					aggrFS.LevelCheck = bSimple;  					result = aggrFS;  					break;  				case "avg":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrAvg aggrFA = new FunctionAggrAvg(_DataCache' args[0]' scope);  					aggrFA.LevelCheck = bSimple;  					result = aggrFA;  					break;  				case "min":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMin aggrFMin = new FunctionAggrMin(_DataCache' args[0]' scope);  					aggrFMin.LevelCheck = bSimple;  					result = aggrFMin;  					break;  				case "max":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMax aggrFMax = new FunctionAggrMax(_DataCache' args[0]' scope);  					aggrFMax.LevelCheck = bSimple;  					result = aggrFMax;  					break;  				case "first":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrFirst(_DataCache' args[0]' scope);  					break;  				case "last":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrLast(_DataCache' args[0]' scope);  					break;  				case "next":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrNext(_DataCache' args[0]' scope);  					break;  				case "previous":  				    scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrPrevious(_DataCache' args[0]' scope);  					break;  				case "level":  					scope = ResolveAggrScope(args' 1' out bSimple);  					result = new FunctionAggrLevel(scope);  					break;                  case "aggregate":                      scope = ResolveAggrScope(args' 2' out bSimple);                      FunctionAggrArray aggr = new FunctionAggrArray(_DataCache' args[0]' scope);                      aggr.LevelCheck = bSimple;                      result = aggr;                      break;                  case "count":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCount aggrFC = new FunctionAggrCount(_DataCache' args[0]' scope);  					aggrFC.LevelCheck = bSimple;  					result = aggrFC;  					break;  				case "countrows":  					scope = ResolveAggrScope(args' 1' out bSimple);  					FunctionAggrCountRows aggrFCR = new FunctionAggrCountRows(scope);  					aggrFCR.LevelCheck = bSimple;  					result = aggrFCR;  					break;                  case "countdistinct":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCountDistinct aggrFCD = new FunctionAggrCountDistinct(_DataCache' args[0]' scope);  					aggrFCD.LevelCheck = bSimple;  					result = aggrFCD;  					break;  				case "rownumber":  					scope = ResolveAggrScope(args' 1' out bSimple);  					IExpr texpr = new ConstantDouble("0");  					result = new FunctionAggrRvCount(_DataCache' texpr' scope);  					break;  				case "runningvalue":  					if (args.Length < 2 || args.Length > 3)  						throw new ParserException(Strings.Parser_ErrorP_RunningValue_takes_2_or_3_arguments + GetLocationInfo(curToken));  					string aggrFunc = args[1].EvaluateString(null' null);  					if (aggrFunc == null)  						throw new ParserException(Strings.Parser_ErrorP_RunningValueArgumentInvalid + GetLocationInfo(curToken));  					scope = ResolveAggrScope(args' 3' out bSimple);  					switch(aggrFunc.ToLower())  					{  						case "sum":  							result = new FunctionAggrRvSum(_DataCache' args[0]' scope);  							break;  						case "avg":  							result = new FunctionAggrRvAvg(_DataCache' args[0]' scope);  							break;  						case "count":  							result = new FunctionAggrRvCount(_DataCache' args[0]' scope);  							break;  						case "max":  							result = new FunctionAggrRvMax(_DataCache' args[0]' scope);  							break;  						case "min":  							result = new FunctionAggrRvMin(_DataCache' args[0]' scope);  							break;  						case "stdev":  							result = new FunctionAggrRvStdev(_DataCache' args[0]' scope);  							break;  						case "stdevp":  							result = new FunctionAggrRvStdevp(_DataCache' args[0]' scope);  							break;  						case "var":  							result = new FunctionAggrRvVar(_DataCache' args[0]' scope);  							break;  						case "varp":  							result = new FunctionAggrRvVarp(_DataCache' args[0]' scope);  							break;  						default:  							throw new ParserException(string.Format(Strings.Parser_ErrorP_RunningValueNotSupported' aggrFunc) + GetLocationInfo(curToken));  					}  					break;  				case "stdev":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdev aggrSDev = new FunctionAggrStdev(_DataCache' args[0]' scope);  					aggrSDev.LevelCheck = bSimple;  					result = aggrSDev;  					break;  				case "stdevp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdevp aggrSDevP = new FunctionAggrStdevp(_DataCache' args[0]' scope);  					aggrSDevP.LevelCheck = bSimple;  					result = aggrSDevP;  					break;  				case "var":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVar aggrVar = new FunctionAggrVar(_DataCache' args[0]' scope);  					aggrVar.LevelCheck = bSimple;  					result = aggrVar;  					break;  				case "varp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVarp aggrVarP = new FunctionAggrVarp(_DataCache' args[0]' scope);  					aggrVarP.LevelCheck = bSimple;  					result = aggrVarP;  					break;  				default:  					result = ResolveMethodCall(fullname' args);		// through exception when fails  					break;  			}
Magic Number,fyiReporting.RDL,Parser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Parser.cs,MatchFuncIDent,The following statement contains a magic number: if (!bOnePart)				              {                  result = (firstPart == "Parameters")?                      ResolveParametersMethod(method' thirdPart' args):                      ResolveMethodCall(fullname' args);	// throw exception when fails              }  			else switch(method.ToLower())  			{  				case "iif":  					if (args.Length != 3)  						throw new ParserException(Strings.Parser_ErrorP_iff_function_requires_3_arguments + GetLocationInfo(curToken));  //  We allow any type for the first argument; it will get converted to boolean at runtime  //					if (args[0].GetTypeCode() != TypeCode.Boolean)  //						throw new ParserException("First argument to iif function must be boolean." + GetLocationInfo(curToken));  					result = new FunctionIif(args[0]' args[1]' args[2]);  					break;  				case "choose":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_ChooseRequires2Arguments + GetLocationInfo(curToken));  					switch (args[0].GetTypeCode())  					{  						case TypeCode.Double:  						case TypeCode.Single:  						case TypeCode.Int32:  						case TypeCode.Decimal:  						case TypeCode.Int16:  						case TypeCode.Int64:                          case TypeCode.UInt16:                          case TypeCode.UInt32:                          case TypeCode.UInt64:  							break;  						default:  							throw new ParserException(Strings.Parser_ErrorP_ChooseFirstArgumentMustNumeric + GetLocationInfo(curToken));  					}  					result = new FunctionChoose(args);  					break;  				case "switch":  					if (args.Length <= 2)  						throw new ParserException(Strings.Parser_ErrorP_SwitchRequires2Arguments + GetLocationInfo(curToken));  				    if (args.Length % 2 != 0)  						throw new ParserException(Strings.Parser_ErrorP_SwitchMustEvenArguments + GetLocationInfo(curToken));  					for (int i=0; i < args.Length; i = i+2)  					{  						if (args[i].GetTypeCode() != TypeCode.Boolean)  							throw new ParserException(Strings.Parser_ErrorP_SwitchMustBoolean + GetLocationInfo(curToken));  					}  					result = new FunctionSwitch(args);  					break;  				case "format":  					if (args.Length > 2 || args.Length < 1)  						throw new ParserException(Strings.Parser_ErrorP_FormatRequires2Arguments + GetLocationInfo(curToken));  					if (args.Length == 1)  					{  						result = new FunctionFormat(args[0]' new ConstantString(""));  					}  					else  					{  						if (args[1].GetTypeCode() != TypeCode.String)  							throw new ParserException(Strings.Parser_ErrorP_SecondMustString + GetLocationInfo(curToken));  						result = new FunctionFormat(args[0]' args[1]);  					}  					break;    				case "fields":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_FieldsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionFieldCollection(idLookup.Fields' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                  TODO: generalize this code                          curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else  							throw new ParserException(string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Fields") + GetLocationInfo(curToken));                      }                      break;  				case "parameters":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ParametersRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionParameterCollection(idLookup.Parameters' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "Parameters") + GetLocationInfo(curToken)));                      }                      break;  				case "reportitems":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_ReportItemsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionReportItemCollection(idLookup.ReportItems' args[0]);                      if (curToken.Type == TokenTypes.DOT)                      {	// user placed "."                           curToken = tokens.Extract();                // skip past dot operator                          if (curToken.Type == TokenTypes.IDENTIFIER && curToken.Value.ToLowerInvariant() == "value")                              curToken = tokens.Extract();            // only support "value" property for now                          else                              throw new ParserException((string.Format(Strings.Parser_ErrorP_UnknownProperty' curToken.Value' "ReportItems") + GetLocationInfo(curToken)));                      }                      break;  				case "globals":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_GlobalsRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionGlobalCollection(idLookup.Globals' args[0]);  					break;  				case "user":  					if (args.Length != 1)  						throw new ParserException(Strings.Parser_ErrorP_UserRequires1Argument + GetLocationInfo(curToken));  					result = new FunctionUserCollection(idLookup.User' args[0]);  					break;  				case "sum":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrSum aggrFS = new FunctionAggrSum(_DataCache' args[0]' scope);  					aggrFS.LevelCheck = bSimple;  					result = aggrFS;  					break;  				case "avg":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrAvg aggrFA = new FunctionAggrAvg(_DataCache' args[0]' scope);  					aggrFA.LevelCheck = bSimple;  					result = aggrFA;  					break;  				case "min":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMin aggrFMin = new FunctionAggrMin(_DataCache' args[0]' scope);  					aggrFMin.LevelCheck = bSimple;  					result = aggrFMin;  					break;  				case "max":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrMax aggrFMax = new FunctionAggrMax(_DataCache' args[0]' scope);  					aggrFMax.LevelCheck = bSimple;  					result = aggrFMax;  					break;  				case "first":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrFirst(_DataCache' args[0]' scope);  					break;  				case "last":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrLast(_DataCache' args[0]' scope);  					break;  				case "next":  					scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrNext(_DataCache' args[0]' scope);  					break;  				case "previous":  				    scope = ResolveAggrScope(args' 2' out bSimple);  					result = new FunctionAggrPrevious(_DataCache' args[0]' scope);  					break;  				case "level":  					scope = ResolveAggrScope(args' 1' out bSimple);  					result = new FunctionAggrLevel(scope);  					break;                  case "aggregate":                      scope = ResolveAggrScope(args' 2' out bSimple);                      FunctionAggrArray aggr = new FunctionAggrArray(_DataCache' args[0]' scope);                      aggr.LevelCheck = bSimple;                      result = aggr;                      break;                  case "count":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCount aggrFC = new FunctionAggrCount(_DataCache' args[0]' scope);  					aggrFC.LevelCheck = bSimple;  					result = aggrFC;  					break;  				case "countrows":  					scope = ResolveAggrScope(args' 1' out bSimple);  					FunctionAggrCountRows aggrFCR = new FunctionAggrCountRows(scope);  					aggrFCR.LevelCheck = bSimple;  					result = aggrFCR;  					break;                  case "countdistinct":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrCountDistinct aggrFCD = new FunctionAggrCountDistinct(_DataCache' args[0]' scope);  					aggrFCD.LevelCheck = bSimple;  					result = aggrFCD;  					break;  				case "rownumber":  					scope = ResolveAggrScope(args' 1' out bSimple);  					IExpr texpr = new ConstantDouble("0");  					result = new FunctionAggrRvCount(_DataCache' texpr' scope);  					break;  				case "runningvalue":  					if (args.Length < 2 || args.Length > 3)  						throw new ParserException(Strings.Parser_ErrorP_RunningValue_takes_2_or_3_arguments + GetLocationInfo(curToken));  					string aggrFunc = args[1].EvaluateString(null' null);  					if (aggrFunc == null)  						throw new ParserException(Strings.Parser_ErrorP_RunningValueArgumentInvalid + GetLocationInfo(curToken));  					scope = ResolveAggrScope(args' 3' out bSimple);  					switch(aggrFunc.ToLower())  					{  						case "sum":  							result = new FunctionAggrRvSum(_DataCache' args[0]' scope);  							break;  						case "avg":  							result = new FunctionAggrRvAvg(_DataCache' args[0]' scope);  							break;  						case "count":  							result = new FunctionAggrRvCount(_DataCache' args[0]' scope);  							break;  						case "max":  							result = new FunctionAggrRvMax(_DataCache' args[0]' scope);  							break;  						case "min":  							result = new FunctionAggrRvMin(_DataCache' args[0]' scope);  							break;  						case "stdev":  							result = new FunctionAggrRvStdev(_DataCache' args[0]' scope);  							break;  						case "stdevp":  							result = new FunctionAggrRvStdevp(_DataCache' args[0]' scope);  							break;  						case "var":  							result = new FunctionAggrRvVar(_DataCache' args[0]' scope);  							break;  						case "varp":  							result = new FunctionAggrRvVarp(_DataCache' args[0]' scope);  							break;  						default:  							throw new ParserException(string.Format(Strings.Parser_ErrorP_RunningValueNotSupported' aggrFunc) + GetLocationInfo(curToken));  					}  					break;  				case "stdev":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdev aggrSDev = new FunctionAggrStdev(_DataCache' args[0]' scope);  					aggrSDev.LevelCheck = bSimple;  					result = aggrSDev;  					break;  				case "stdevp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrStdevp aggrSDevP = new FunctionAggrStdevp(_DataCache' args[0]' scope);  					aggrSDevP.LevelCheck = bSimple;  					result = aggrSDevP;  					break;  				case "var":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVar aggrVar = new FunctionAggrVar(_DataCache' args[0]' scope);  					aggrVar.LevelCheck = bSimple;  					result = aggrVar;  					break;  				case "varp":  					scope = ResolveAggrScope(args' 2' out bSimple);  					FunctionAggrVarp aggrVarP = new FunctionAggrVarp(_DataCache' args[0]' scope);  					aggrVarP.LevelCheck = bSimple;  					result = aggrVarP;  					break;  				default:  					result = ResolveMethodCall(fullname' args);		// through exception when fails  					break;  			}
Magic Number,fyiReporting.RDL,Financial,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\Financial.cs,DDB,The following statement contains a magic number: return DDB(cost' salvage' life' period' 2);
Magic Number,fyiReporting.RDL,Financial,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\Financial.cs,Rate,The following statement contains a magic number: double gLower= guess > .1? guess-.1: 0;
Magic Number,fyiReporting.RDL,Financial,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\Financial.cs,Rate,The following statement contains a magic number: double gLower= guess > .1? guess-.1: 0;
Magic Number,fyiReporting.RDL,Financial,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\Financial.cs,Rate,The following statement contains a magic number: double power2=.1;
Magic Number,fyiReporting.RDL,Financial,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\Financial.cs,Rate,The following statement contains a magic number: while (RateGuess(periods' pmt' presentValue' futureValue' type' gLower) > 0)  			{  				gLower -= power2;  				power2 *= 2;  			}
Magic Number,fyiReporting.RDL,Financial,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\Financial.cs,Rate,The following statement contains a magic number: double gUpper= guess+.1;
Magic Number,fyiReporting.RDL,Financial,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\Financial.cs,Rate,The following statement contains a magic number: power2=.1;
Magic Number,fyiReporting.RDL,Financial,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\Financial.cs,Rate,The following statement contains a magic number: while (RateGuess(periods' pmt' presentValue' futureValue' type' gUpper) < 0)  			{  				gUpper += power2;  				power2 *= 2;  			}
Magic Number,fyiReporting.RDL,Financial,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\Financial.cs,Rate,The following statement contains a magic number: for (int i= 0; i<30; i++)  			{  				z = RateGuess(periods'pmt'presentValue'futureValue' type' guess);    				if (z > 0)  				{  					gUpper = guess;  					incr = (guess - gLower)/2;  					newguess = guess - incr;  				}  				else  				{  					gLower = guess;  					incr = (gUpper - guess)/2;  					newguess = guess + incr;  				}  				if (incr < 0.0000001)		// Is the difference within our margin of error?  					return guess;  				guess = newguess;  			}
Magic Number,fyiReporting.RDL,Financial,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\Financial.cs,Rate,The following statement contains a magic number: for (int i= 0; i<30; i++)  			{  				z = RateGuess(periods'pmt'presentValue'futureValue' type' guess);    				if (z > 0)  				{  					gUpper = guess;  					incr = (guess - gLower)/2;  					newguess = guess - incr;  				}  				else  				{  					gLower = guess;  					incr = (gUpper - guess)/2;  					newguess = guess + incr;  				}  				if (incr < 0.0000001)		// Is the difference within our margin of error?  					return guess;  				guess = newguess;  			}
Magic Number,fyiReporting.RDL,Financial,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\Financial.cs,Rate,The following statement contains a magic number: for (int i= 0; i<30; i++)  			{  				z = RateGuess(periods'pmt'presentValue'futureValue' type' guess);    				if (z > 0)  				{  					gUpper = guess;  					incr = (guess - gLower)/2;  					newguess = guess - incr;  				}  				else  				{  					gLower = guess;  					incr = (gUpper - guess)/2;  					newguess = guess + incr;  				}  				if (incr < 0.0000001)		// Is the difference within our margin of error?  					return guess;  				guess = newguess;  			}
Magic Number,fyiReporting.RDL,Financial,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\Financial.cs,Rate,The following statement contains a magic number: for (int i= 0; i<30; i++)  			{  				z = RateGuess(periods'pmt'presentValue'futureValue' type' guess);    				if (z > 0)  				{  					gUpper = guess;  					incr = (guess - gLower)/2;  					newguess = guess - incr;  				}  				else  				{  					gLower = guess;  					incr = (gUpper - guess)/2;  					newguess = guess + incr;  				}  				if (incr < 0.0000001)		// Is the difference within our margin of error?  					return guess;  				guess = newguess;  			}
Magic Number,fyiReporting.RDL,Financial,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\Financial.cs,SYD,The following statement contains a magic number: if (life % 2 == 0)						// sum = n/2 * (n+1) when even  				sumOfPeriods = life/2 * (life + 1);  			else									// sum = (n+1)/2 * n when odd  				sumOfPeriods = (life+1)/2 * life;
Magic Number,fyiReporting.RDL,Financial,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\Financial.cs,SYD,The following statement contains a magic number: if (life % 2 == 0)						// sum = n/2 * (n+1) when even  				sumOfPeriods = life/2 * (life + 1);  			else									// sum = (n+1)/2 * n when odd  				sumOfPeriods = (life+1)/2 * life;
Magic Number,fyiReporting.RDL,Financial,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\Financial.cs,SYD,The following statement contains a magic number: if (life % 2 == 0)						// sum = n/2 * (n+1) when even  				sumOfPeriods = life/2 * (life + 1);  			else									// sum = (n+1)/2 * n when odd  				sumOfPeriods = (life+1)/2 * life;
Magic Number,fyiReporting.RDL,FunctionAggrCountDistinct,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\FunctionAggrCountDistinct.cs,EvaluateInt32,The following statement contains a magic number: if (v < 0)  			{  				object temp;  				int count = Math.Max(2' re.LastRow - re.FirstRow);  				Hashtable ht = new Hashtable(count);  				foreach (Row r in re)  				{  					temp = _Expr.Evaluate(rpt' r);  					if (temp != null)  					{  						object o = ht[temp];	// search for it  						if (o == null)			// if not found; add it to the hash table  						{  							ht.Add(temp' temp);  						}  					}  				}  				v = ht.Count;  				if (bSave)  					SetValue(rpt' v);  			}
Magic Number,fyiReporting.RDL,FunctionFormat,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\FunctionFormat.cs,EvaluateString,The following statement contains a magic number: try  			{  				result = String.Format("{0:" + format + "}"' o);  			}  			catch (Exception ex) 		// invalid format string specified  			{           //    treat as a weak error  				rpt.rl.LogError(2' String.Format("Format string:{1} Value Type:{2} Exception:{0}"' ex.Message' format' o.GetType().Name));  				result = o.ToString();  			}
Magic Number,fyiReporting.RDL,FunctionSwitch,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\FunctionSwitch.cs,Evaluate,The following statement contains a magic number: for (int i=0; i < _expr.Length; i = i+2)  			{  				result = _expr[i].EvaluateBoolean(rpt' row);  				if (result)  				{  					object o = _expr[i+1].Evaluate(rpt' row);  					// We may need to convert to same type as first type  					if (i == 0 || _tc == _expr[i+1].GetTypeCode())	// first typecode will always match   						return o;    					return Convert.ChangeType(o' _tc);  				}  			}
Magic Number,fyiReporting.RDL,VBFunctions,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\VBFunctions.cs,Weekday,The following statement contains a magic number: switch (dt.DayOfWeek)  			{  				case DayOfWeek.Sunday:  					dow=1;  					break;  				case DayOfWeek.Monday:  					dow=2;  					break;  				case DayOfWeek.Tuesday:  					dow=3;  					break;  				case DayOfWeek.Wednesday:  					dow=4;  					break;  				case DayOfWeek.Thursday:  					dow=5;  					break;  				case DayOfWeek.Friday:  					dow=6;  					break;  				case DayOfWeek.Saturday:  					dow=7;  					break;  				default:			// should never happen  					dow=1;  					break;  			}
Magic Number,fyiReporting.RDL,VBFunctions,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\VBFunctions.cs,Weekday,The following statement contains a magic number: switch (dt.DayOfWeek)  			{  				case DayOfWeek.Sunday:  					dow=1;  					break;  				case DayOfWeek.Monday:  					dow=2;  					break;  				case DayOfWeek.Tuesday:  					dow=3;  					break;  				case DayOfWeek.Wednesday:  					dow=4;  					break;  				case DayOfWeek.Thursday:  					dow=5;  					break;  				case DayOfWeek.Friday:  					dow=6;  					break;  				case DayOfWeek.Saturday:  					dow=7;  					break;  				default:			// should never happen  					dow=1;  					break;  			}
Magic Number,fyiReporting.RDL,VBFunctions,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\VBFunctions.cs,Weekday,The following statement contains a magic number: switch (dt.DayOfWeek)  			{  				case DayOfWeek.Sunday:  					dow=1;  					break;  				case DayOfWeek.Monday:  					dow=2;  					break;  				case DayOfWeek.Tuesday:  					dow=3;  					break;  				case DayOfWeek.Wednesday:  					dow=4;  					break;  				case DayOfWeek.Thursday:  					dow=5;  					break;  				case DayOfWeek.Friday:  					dow=6;  					break;  				case DayOfWeek.Saturday:  					dow=7;  					break;  				default:			// should never happen  					dow=1;  					break;  			}
Magic Number,fyiReporting.RDL,VBFunctions,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\VBFunctions.cs,Weekday,The following statement contains a magic number: switch (dt.DayOfWeek)  			{  				case DayOfWeek.Sunday:  					dow=1;  					break;  				case DayOfWeek.Monday:  					dow=2;  					break;  				case DayOfWeek.Tuesday:  					dow=3;  					break;  				case DayOfWeek.Wednesday:  					dow=4;  					break;  				case DayOfWeek.Thursday:  					dow=5;  					break;  				case DayOfWeek.Friday:  					dow=6;  					break;  				case DayOfWeek.Saturday:  					dow=7;  					break;  				default:			// should never happen  					dow=1;  					break;  			}
Magic Number,fyiReporting.RDL,VBFunctions,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\VBFunctions.cs,Weekday,The following statement contains a magic number: switch (dt.DayOfWeek)  			{  				case DayOfWeek.Sunday:  					dow=1;  					break;  				case DayOfWeek.Monday:  					dow=2;  					break;  				case DayOfWeek.Tuesday:  					dow=3;  					break;  				case DayOfWeek.Wednesday:  					dow=4;  					break;  				case DayOfWeek.Thursday:  					dow=5;  					break;  				case DayOfWeek.Friday:  					dow=6;  					break;  				case DayOfWeek.Saturday:  					dow=7;  					break;  				default:			// should never happen  					dow=1;  					break;  			}
Magic Number,fyiReporting.RDL,VBFunctions,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\VBFunctions.cs,Weekday,The following statement contains a magic number: switch (dt.DayOfWeek)  			{  				case DayOfWeek.Sunday:  					dow=1;  					break;  				case DayOfWeek.Monday:  					dow=2;  					break;  				case DayOfWeek.Tuesday:  					dow=3;  					break;  				case DayOfWeek.Wednesday:  					dow=4;  					break;  				case DayOfWeek.Thursday:  					dow=5;  					break;  				case DayOfWeek.Friday:  					dow=6;  					break;  				case DayOfWeek.Saturday:  					dow=7;  					break;  				default:			// should never happen  					dow=1;  					break;  			}
Magic Number,fyiReporting.RDL,VBFunctions,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\VBFunctions.cs,WeekdayName,The following statement contains a magic number: DateTime dt = new DateTime(2005' 5' d);
Magic Number,fyiReporting.RDL,VBFunctions,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\VBFunctions.cs,WeekdayName,The following statement contains a magic number: DateTime dt = new DateTime(2005' 5' d);
Magic Number,fyiReporting.RDL,VBFunctions,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\VBFunctions.cs,MonthName,The following statement contains a magic number: DateTime dt = new DateTime(2005' m' 1);
Magic Number,fyiReporting.RDL,VBFunctions,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\VBFunctions.cs,Hex,The following statement contains a magic number: return Convert.ToString(o' 16);
Magic Number,fyiReporting.RDL,VBFunctions,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\VBFunctions.cs,Oct,The following statement contains a magic number: return Convert.ToString(o' 8);
Magic Number,fyiReporting.RDL,VBFunctions,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\VBFunctions.cs,DateAdd,The following statement contains a magic number: switch (interval)              {                  case "yyyy":        // year                       date = date.AddYears((int) Math.Round(number' 0));                      break;                  case "m":           // month                       date = date.AddMonths((int)Math.Round(number' 0));                      break;                  case "d":           // day                       date = date.AddDays(number);                      break;                  case "h":           // hour                       date = date.AddHours(number);                      break;                  case "n":           // minute                       date = date.AddMinutes(number);                      break;                  case "s":           // second                       date = date.AddSeconds(number);                      break;                  case "y":           // day of year                      date = date.AddDays(number);                      break;                  case "q":           // quarter                       date = date.AddMonths((int)Math.Round(number' 0) * 3);                      break;                  case "w":           // weekday                       date = date.AddDays(number);                      break;                  case "ww":          // week of year                       date = date.AddDays((int)Math.Round(number' 0) * 7);                      break;                  default:                      throw new ArgumentException(string.Format("Interval '{0}' is invalid or unsupported."' interval));              }
Magic Number,fyiReporting.RDL,VBFunctions,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\VBFunctions.cs,DateAdd,The following statement contains a magic number: switch (interval)              {                  case "yyyy":        // year                       date = date.AddYears((int) Math.Round(number' 0));                      break;                  case "m":           // month                       date = date.AddMonths((int)Math.Round(number' 0));                      break;                  case "d":           // day                       date = date.AddDays(number);                      break;                  case "h":           // hour                       date = date.AddHours(number);                      break;                  case "n":           // minute                       date = date.AddMinutes(number);                      break;                  case "s":           // second                       date = date.AddSeconds(number);                      break;                  case "y":           // day of year                      date = date.AddDays(number);                      break;                  case "q":           // quarter                       date = date.AddMonths((int)Math.Round(number' 0) * 3);                      break;                  case "w":           // weekday                       date = date.AddDays(number);                      break;                  case "ww":          // week of year                       date = date.AddDays((int)Math.Round(number' 0) * 7);                      break;                  default:                      throw new ArgumentException(string.Format("Interval '{0}' is invalid or unsupported."' interval));              }
Magic Number,fyiReporting.RDL,VBFunctions,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Functions\VBFunctions.cs,StrReverse,The following statement contains a magic number: if (str == null || str.Length < 2)  				return str;
Magic Number,fyiReporting.RDL,MhtBuilder,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtBuilder.cs,AppendMhtHeader,The following statement contains a magic number: if (title != null)              {                  if (title.Length > 260)                      title = title.Substring(0' 260);                  if (title.IndexOf('\n') != -1)                      title = title.Replace('\n'' ' ');                  if (title.IndexOf(Environment.NewLine) != -1)                      title = title.Replace(Environment.NewLine' " ");              }
Magic Number,fyiReporting.RDL,MhtBuilder,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtBuilder.cs,AppendMhtHeader,The following statement contains a magic number: if (title != null)              {                  if (title.Length > 260)                      title = title.Substring(0' 260);                  if (title.IndexOf('\n') != -1)                      title = title.Replace('\n'' ' ');                  if (title.IndexOf(Environment.NewLine) != -1)                      title = title.Replace(Environment.NewLine' " ");              }
Magic Number,fyiReporting.RDL,MhtBuilder,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtBuilder.cs,AppendMhtHeader,The following statement contains a magic number: AppendMhtLine(Convert.ToChar(9).ToString() + "type=\"text/html\";");
Magic Number,fyiReporting.RDL,MhtBuilder,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtBuilder.cs,AppendMhtHeader,The following statement contains a magic number: AppendMhtLine(Convert.ToChar(9).ToString() + "boundary=\"----=_NextPart_000_00\"");
Magic Number,fyiReporting.RDL,MhtBuilder,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtBuilder.cs,AppendMhtTextFile,The following statement contains a magic number: AppendMhtLine(Convert.ToChar(9).ToString() + @"charset="" + ef.TextEncoding.WebName + @""");
Magic Number,fyiReporting.RDL,MhtBuilder,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtBuilder.cs,QuotedPrintableEncode,The following statement contains a magic number: foreach (char c in s)  			{  				int ascii = Convert.ToInt32(c);  				if (ascii == 61 || ascii > 126)  				{  					if (ascii <= 255)  					{  						sb.Append("=");  						sb.Append(Convert.ToString(ascii' 16).ToUpper());  						lineLength += 3;  					}  					else  					{  						// double-byte land..  						foreach (byte b in e.GetBytes(c.ToString()))  						{  							sb.Append("=");  							sb.Append(Convert.ToString(b' 16).ToUpper());  							lineLength += 3;  						}  					}  				}  				else  				{  					sb.Append(c);  					lineLength++;  					if (ascii == 32)  						lastSpace = sb.Length;  				}    				if (lineLength >= 73)  				{  					if (lastSpace == 0)  					{  						sb.Insert(sb.Length' "=" + Environment.NewLine);  						lineLength = 0;  					}  					else  					{  						sb.Insert(lastSpace' "=" + Environment.NewLine);  						lineLength = sb.Length - lastSpace - 1;  					}  					lineBreaks++;  					lastSpace = 0;  				}  			}
Magic Number,fyiReporting.RDL,MhtBuilder,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtBuilder.cs,QuotedPrintableEncode,The following statement contains a magic number: foreach (char c in s)  			{  				int ascii = Convert.ToInt32(c);  				if (ascii == 61 || ascii > 126)  				{  					if (ascii <= 255)  					{  						sb.Append("=");  						sb.Append(Convert.ToString(ascii' 16).ToUpper());  						lineLength += 3;  					}  					else  					{  						// double-byte land..  						foreach (byte b in e.GetBytes(c.ToString()))  						{  							sb.Append("=");  							sb.Append(Convert.ToString(b' 16).ToUpper());  							lineLength += 3;  						}  					}  				}  				else  				{  					sb.Append(c);  					lineLength++;  					if (ascii == 32)  						lastSpace = sb.Length;  				}    				if (lineLength >= 73)  				{  					if (lastSpace == 0)  					{  						sb.Insert(sb.Length' "=" + Environment.NewLine);  						lineLength = 0;  					}  					else  					{  						sb.Insert(lastSpace' "=" + Environment.NewLine);  						lineLength = sb.Length - lastSpace - 1;  					}  					lineBreaks++;  					lastSpace = 0;  				}  			}
Magic Number,fyiReporting.RDL,MhtBuilder,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtBuilder.cs,QuotedPrintableEncode,The following statement contains a magic number: foreach (char c in s)  			{  				int ascii = Convert.ToInt32(c);  				if (ascii == 61 || ascii > 126)  				{  					if (ascii <= 255)  					{  						sb.Append("=");  						sb.Append(Convert.ToString(ascii' 16).ToUpper());  						lineLength += 3;  					}  					else  					{  						// double-byte land..  						foreach (byte b in e.GetBytes(c.ToString()))  						{  							sb.Append("=");  							sb.Append(Convert.ToString(b' 16).ToUpper());  							lineLength += 3;  						}  					}  				}  				else  				{  					sb.Append(c);  					lineLength++;  					if (ascii == 32)  						lastSpace = sb.Length;  				}    				if (lineLength >= 73)  				{  					if (lastSpace == 0)  					{  						sb.Insert(sb.Length' "=" + Environment.NewLine);  						lineLength = 0;  					}  					else  					{  						sb.Insert(lastSpace' "=" + Environment.NewLine);  						lineLength = sb.Length - lastSpace - 1;  					}  					lineBreaks++;  					lastSpace = 0;  				}  			}
Magic Number,fyiReporting.RDL,MhtBuilder,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtBuilder.cs,QuotedPrintableEncode,The following statement contains a magic number: foreach (char c in s)  			{  				int ascii = Convert.ToInt32(c);  				if (ascii == 61 || ascii > 126)  				{  					if (ascii <= 255)  					{  						sb.Append("=");  						sb.Append(Convert.ToString(ascii' 16).ToUpper());  						lineLength += 3;  					}  					else  					{  						// double-byte land..  						foreach (byte b in e.GetBytes(c.ToString()))  						{  							sb.Append("=");  							sb.Append(Convert.ToString(b' 16).ToUpper());  							lineLength += 3;  						}  					}  				}  				else  				{  					sb.Append(c);  					lineLength++;  					if (ascii == 32)  						lastSpace = sb.Length;  				}    				if (lineLength >= 73)  				{  					if (lastSpace == 0)  					{  						sb.Insert(sb.Length' "=" + Environment.NewLine);  						lineLength = 0;  					}  					else  					{  						sb.Insert(lastSpace' "=" + Environment.NewLine);  						lineLength = sb.Length - lastSpace - 1;  					}  					lineBreaks++;  					lastSpace = 0;  				}  			}
Magic Number,fyiReporting.RDL,MhtBuilder,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtBuilder.cs,QuotedPrintableEncode,The following statement contains a magic number: foreach (char c in s)  			{  				int ascii = Convert.ToInt32(c);  				if (ascii == 61 || ascii > 126)  				{  					if (ascii <= 255)  					{  						sb.Append("=");  						sb.Append(Convert.ToString(ascii' 16).ToUpper());  						lineLength += 3;  					}  					else  					{  						// double-byte land..  						foreach (byte b in e.GetBytes(c.ToString()))  						{  							sb.Append("=");  							sb.Append(Convert.ToString(b' 16).ToUpper());  							lineLength += 3;  						}  					}  				}  				else  				{  					sb.Append(c);  					lineLength++;  					if (ascii == 32)  						lastSpace = sb.Length;  				}    				if (lineLength >= 73)  				{  					if (lastSpace == 0)  					{  						sb.Insert(sb.Length' "=" + Environment.NewLine);  						lineLength = 0;  					}  					else  					{  						sb.Insert(lastSpace' "=" + Environment.NewLine);  						lineLength = sb.Length - lastSpace - 1;  					}  					lineBreaks++;  					lastSpace = 0;  				}  			}
Magic Number,fyiReporting.RDL,MhtBuilder,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtBuilder.cs,QuotedPrintableEncode,The following statement contains a magic number: foreach (char c in s)  			{  				int ascii = Convert.ToInt32(c);  				if (ascii == 61 || ascii > 126)  				{  					if (ascii <= 255)  					{  						sb.Append("=");  						sb.Append(Convert.ToString(ascii' 16).ToUpper());  						lineLength += 3;  					}  					else  					{  						// double-byte land..  						foreach (byte b in e.GetBytes(c.ToString()))  						{  							sb.Append("=");  							sb.Append(Convert.ToString(b' 16).ToUpper());  							lineLength += 3;  						}  					}  				}  				else  				{  					sb.Append(c);  					lineLength++;  					if (ascii == 32)  						lastSpace = sb.Length;  				}    				if (lineLength >= 73)  				{  					if (lastSpace == 0)  					{  						sb.Insert(sb.Length' "=" + Environment.NewLine);  						lineLength = 0;  					}  					else  					{  						sb.Insert(lastSpace' "=" + Environment.NewLine);  						lineLength = sb.Length - lastSpace - 1;  					}  					lineBreaks++;  					lastSpace = 0;  				}  			}
Magic Number,fyiReporting.RDL,MhtBuilder,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtBuilder.cs,QuotedPrintableEncode,The following statement contains a magic number: foreach (char c in s)  			{  				int ascii = Convert.ToInt32(c);  				if (ascii == 61 || ascii > 126)  				{  					if (ascii <= 255)  					{  						sb.Append("=");  						sb.Append(Convert.ToString(ascii' 16).ToUpper());  						lineLength += 3;  					}  					else  					{  						// double-byte land..  						foreach (byte b in e.GetBytes(c.ToString()))  						{  							sb.Append("=");  							sb.Append(Convert.ToString(b' 16).ToUpper());  							lineLength += 3;  						}  					}  				}  				else  				{  					sb.Append(c);  					lineLength++;  					if (ascii == 32)  						lastSpace = sb.Length;  				}    				if (lineLength >= 73)  				{  					if (lastSpace == 0)  					{  						sb.Insert(sb.Length' "=" + Environment.NewLine);  						lineLength = 0;  					}  					else  					{  						sb.Insert(lastSpace' "=" + Environment.NewLine);  						lineLength = sb.Length - lastSpace - 1;  					}  					lineBreaks++;  					lastSpace = 0;  				}  			}
Magic Number,fyiReporting.RDL,MhtBuilder,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtBuilder.cs,QuotedPrintableEncode,The following statement contains a magic number: foreach (char c in s)  			{  				int ascii = Convert.ToInt32(c);  				if (ascii == 61 || ascii > 126)  				{  					if (ascii <= 255)  					{  						sb.Append("=");  						sb.Append(Convert.ToString(ascii' 16).ToUpper());  						lineLength += 3;  					}  					else  					{  						// double-byte land..  						foreach (byte b in e.GetBytes(c.ToString()))  						{  							sb.Append("=");  							sb.Append(Convert.ToString(b' 16).ToUpper());  							lineLength += 3;  						}  					}  				}  				else  				{  					sb.Append(c);  					lineLength++;  					if (ascii == 32)  						lastSpace = sb.Length;  				}    				if (lineLength >= 73)  				{  					if (lastSpace == 0)  					{  						sb.Insert(sb.Length' "=" + Environment.NewLine);  						lineLength = 0;  					}  					else  					{  						sb.Insert(lastSpace' "=" + Environment.NewLine);  						lineLength = sb.Length - lastSpace - 1;  					}  					lineBreaks++;  					lastSpace = 0;  				}  			}
Magic Number,fyiReporting.RDL,MhtBuilder,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtBuilder.cs,QuotedPrintableEncode,The following statement contains a magic number: foreach (char c in s)  			{  				int ascii = Convert.ToInt32(c);  				if (ascii == 61 || ascii > 126)  				{  					if (ascii <= 255)  					{  						sb.Append("=");  						sb.Append(Convert.ToString(ascii' 16).ToUpper());  						lineLength += 3;  					}  					else  					{  						// double-byte land..  						foreach (byte b in e.GetBytes(c.ToString()))  						{  							sb.Append("=");  							sb.Append(Convert.ToString(b' 16).ToUpper());  							lineLength += 3;  						}  					}  				}  				else  				{  					sb.Append(c);  					lineLength++;  					if (ascii == 32)  						lastSpace = sb.Length;  				}    				if (lineLength >= 73)  				{  					if (lastSpace == 0)  					{  						sb.Insert(sb.Length' "=" + Environment.NewLine);  						lineLength = 0;  					}  					else  					{  						sb.Insert(lastSpace' "=" + Environment.NewLine);  						lineLength = sb.Length - lastSpace - 1;  					}  					lineBreaks++;  					lastSpace = 0;  				}  			}
Magic Number,fyiReporting.RDL,ExtendedBinaryReader,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtWebClientLocal.cs,ReadToEnd,The following statement contains a magic number: while (chunk > 0)  				{  					read += chunk;    					// If the end of the buffer is reached' check to see if there is  					// any more data.  					if (read == buffer.Length)  					{  						int nextByte = BaseStream.ReadByte();  						  						// If the end of the stream is reached' we are done.  						if (nextByte == -1)  							return buffer;  						  						// Nope.  Resize the buffer' put in the byte we have just  						// read' and continue.  						byte[] newBuffer = new byte[buffer.Length * 2];  						Buffer.BlockCopy(buffer' 0' newBuffer' 0' buffer.Length);  						//						Array.Copy(buffer' newBuffer' buffer.Length);  						newBuffer[read] = (byte) nextByte;  						buffer = newBuffer;  						read++;  					}    					chunk = BaseStream.Read(buffer' read' buffer.Length - read);  				}
Magic Number,fyiReporting.RDL,MhtWebFile,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtWebFile.cs,MakeValidFilename,The following statement contains a magic number: if (name.Length > 25)              {                  string ext = Path.GetExtension(name);                  name = name.Substring(0' 25 - ext.Length) + ext;              }
Magic Number,fyiReporting.RDL,MhtWebFile,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtWebFile.cs,MakeValidFilename,The following statement contains a magic number: if (name.Length > 25)              {                  string ext = Path.GetExtension(name);                  name = name.Substring(0' 25 - ext.Length) + ext;              }
Magic Number,fyiReporting.RDL,MhtWebFile,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtWebFile.cs,SetUrl,The following statement contains a magic number: if (this._Url.LastIndexOf("/") > 7)  				this._UrlFolder = this._Url.Substring(0' this._Url.LastIndexOf("/"));  			else  				this._UrlFolder = this._UrlRoot;
Magic Number,fyiReporting.RDL,MhtWebFile,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtWebFile.cs,HtmlDecode,The following statement contains a magic number: for (int i = 0; i < s.Length; i++)  			{  				char currentChar = s[i];  				if (currentChar != '&')  				{  					writer.Write(currentChar);  					continue;  				}    				int pos = s.IndexOf(';'' i + 1);  				if (pos <= 0)  				{  					writer.Write(currentChar);  					continue;  				}    				string subText = s.Substring(i + 1' (pos - i) - 1);  				if (subText[0] == '#' && subText.Length > 1)  				{  					try  					{  						if ((subText[1] == 'x') || (subText[1] == 'X'))  							writer.Write((char) ((ushort) int.Parse(subText.Substring(2)'   								System.Globalization.NumberStyles.AllowHexSpecifier)));  						else  							writer.Write((char) ((ushort) int.Parse(subText.Substring(1))));  						i = pos;  					}  					catch (FormatException)  					{  						i++;  					}  					catch (ArgumentException)  					{  						i++;  					}  				}  				else  				{  					i = pos;  					currentChar = HtmlLookup(subText);  					if (currentChar != '\0')  					{  						writer.Write(currentChar);  					}  					else  					{  						writer.Write('&');  						writer.Write(subText);  						writer.Write(';');  					}  				}  			}
Magic Number,fyiReporting.RDL,MhtWebFile,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\MhtConverter\MhtWebFile.cs,HtmlLookup,The following statement contains a magic number: if (htmlEntitiesTable == null)  			{  				lock (typeof(MhtWebFile))  				{  					if (htmlEntitiesTable == null)  					{  						htmlEntitiesTable = new Hashtable();  						string[] htmlEntities = new string[]   						{   							"\"-quot"' "&-amp"' "<-lt"' ">-gt"' "\x00a0-nbsp"' "\x00a1-iexcl"' "\x00a2-cent"' "\x00a3-pound"' "\x00a4-curren"' "\x00a5-yen"' "\x00a6-brvbar"' "\x00a7-sect"' "\x00a8-uml"' "\x00a9-copy"' "\x00aa-ordf"' "\x00ab-laquo"'   							"\x00ac-not"' "\x00ad-shy"' "\x00ae-reg"' "\x00af-macr"' "\x00b0-deg"' "\x00b1-plusmn"' "\x00b2-sup2"' "\x00b3-sup3"' "\x00b4-acute"' "\x00b5-micro"' "\x00b6-para"' "\x00b7-middot"' "\x00b8-cedil"' "\x00b9-sup1"' "\x00ba-ordm"' "\x00bb-raquo"'   							"\x00bc-frac14"' "\x00bd-frac12"' "\x00be-frac34"' "\x00bf-iquest"' "\x00c0-Agrave"' "\x00c1-Aacute"' "\x00c2-Acirc"' "\x00c3-Atilde"' "\x00c4-Auml"' "\x00c5-Aring"' "\x00c6-AElig"' "\x00c7-Ccedil"' "\x00c8-Egrave"' "\x00c9-Eacute"' "\x00ca-Ecirc"' "\x00cb-Euml"'   							"\x00cc-Igrave"' "\x00cd-Iacute"' "\x00ce-Icirc"' "\x00cf-Iuml"' "\x00d0-ETH"' "\x00d1-Ntilde"' "\x00d2-Ograve"' "\x00d3-Oacute"' "\x00d4-Ocirc"' "\x00d5-Otilde"' "\x00d6-Ouml"' "\x00d7-times"' "\x00d8-Oslash"' "\x00d9-Ugrave"' "\x00da-Uacute"' "\x00db-Ucirc"'   							"\x00dc-Uuml"' "\x00dd-Yacute"' "\x00de-THORN"' "\x00df-szlig"' "\x00e0-agrave"' "\x00e1-aacute"' "\x00e2-acirc"' "\x00e3-atilde"' "\x00e4-auml"' "\x00e5-aring"' "\x00e6-aelig"' "\x00e7-ccedil"' "\x00e8-egrave"' "\x00e9-eacute"' "\x00ea-ecirc"' "\x00eb-euml"'   							"\x00ec-igrave"' "\x00ed-iacute"' "\x00ee-icirc"' "\x00ef-iuml"' "\x00f0-eth"' "\x00f1-ntilde"' "\x00f2-ograve"' "\x00f3-oacute"' "\x00f4-ocirc"' "\x00f5-otilde"' "\x00f6-ouml"' "\x00f7-divide"' "\x00f8-oslash"' "\x00f9-ugrave"' "\x00fa-uacute"' "\x00fb-ucirc"'   							"\x00fc-uuml"' "\x00fd-yacute"' "\x00fe-thorn"' "\x00ff-yuml"' "\u0152-OElig"' "\u0153-oelig"' "\u0160-Scaron"' "\u0161-scaron"' "\u0178-Yuml"' "\u0192-fnof"' "\u02c6-circ"' "\u02dc-tilde"' "\u0391-Alpha"' "\u0392-Beta"' "\u0393-Gamma"' "\u0394-Delta"'   							"\u0395-Epsilon"' "\u0396-Zeta"' "\u0397-Eta"' "\u0398-Theta"' "\u0399-Iota"' "\u039a-Kappa"' "\u039b-Lambda"' "\u039c-Mu"' "\u039d-Nu"' "\u039e-Xi"' "\u039f-Omicron"' "\u03a0-Pi"' "\u03a1-Rho"' "\u03a3-Sigma"' "\u03a4-Tau"' "\u03a5-Upsilon"'   							"\u03a6-Phi"' "\u03a7-Chi"' "\u03a8-Psi"' "\u03a9-Omega"' "\u03b1-alpha"' "\u03b2-beta"' "\u03b3-gamma"' "\u03b4-delta"' "\u03b5-epsilon"' "\u03b6-zeta"' "\u03b7-eta"' "\u03b8-theta"' "\u03b9-iota"' "\u03ba-kappa"' "\u03bb-lambda"' "\u03bc-mu"'   							"\u03bd-nu"' "\u03be-xi"' "\u03bf-omicron"' "\u03c0-pi"' "\u03c1-rho"' "\u03c2-sigmaf"' "\u03c3-sigma"' "\u03c4-tau"' "\u03c5-upsilon"' "\u03c6-phi"' "\u03c7-chi"' "\u03c8-psi"' "\u03c9-omega"' "\u03d1-thetasym"' "\u03d2-upsih"' "\u03d6-piv"'   							"\u2002-ensp"' "\u2003-emsp"' "\u2009-thinsp"' "\u200c-zwnj"' "\u200d-zwj"' "\u200e-lrm"' "\u200f-rlm"' "\u2013-ndash"' "\u2014-mdash"' "\u2018-lsquo"' "\u2019-rsquo"' "\u201a-sbquo"' "\u201c-ldquo"' "\u201d-rdquo"' "\u201e-bdquo"' "\u2020-dagger"'   							"\u2021-Dagger"' "\u2022-bull"' "\u2026-hellip"' "\u2030-permil"' "\u2032-prime"' "\u2033-Prime"' "\u2039-lsaquo"' "\u203a-rsaquo"' "\u203e-oline"' "\u2044-frasl"' "\u20ac-euro"' "\u2111-image"' "\u2118-weierp"' "\u211c-real"' "\u2122-trade"' "\u2135-alefsym"'   							"\u2190-larr"' "\u2191-uarr"' "\u2192-rarr"' "\u2193-darr"' "\u2194-harr"' "\u21b5-crarr"' "\u21d0-lArr"' "\u21d1-uArr"' "\u21d2-rArr"' "\u21d3-dArr"' "\u21d4-hArr"' "\u2200-forall"' "\u2202-part"' "\u2203-exist"' "\u2205-empty"' "\u2207-nabla"'   							"\u2208-isin"' "\u2209-notin"' "\u220b-ni"' "\u220f-prod"' "\u2211-sum"' "\u2212-minus"' "\u2217-lowast"' "\u221a-radic"' "\u221d-prop"' "\u221e-infin"' "\u2220-ang"' "\u2227-and"' "\u2228-or"' "\u2229-cap"' "\u222a-cup"' "\u222b-int"'   							"\u2234-there4"' "\u223c-sim"' "\u2245-cong"' "\u2248-asymp"' "\u2260-ne"' "\u2261-equiv"' "\u2264-le"' "\u2265-ge"' "\u2282-sub"' "\u2283-sup"' "\u2284-nsub"' "\u2286-sube"' "\u2287-supe"' "\u2295-oplus"' "\u2297-otimes"' "\u22a5-perp"'   							"\u22c5-sdot"' "\u2308-lceil"' "\u2309-rceil"' "\u230a-lfloor"' "\u230b-rfloor"' "\u2329-lang"' "\u232a-rang"' "\u25ca-loz"' "\u2660-spades"' "\u2663-clubs"' "\u2665-hearts"' "\u2666-diams"  						};    						for (int i = 0; i < htmlEntities.Length; i++)  						{  							string current = htmlEntities[i];  							htmlEntitiesTable[current.Substring(2)] = current[0];  						}  					}  				}  			}
Magic Number,fyiReporting.RDL,PdfBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfBase.cs,GetUTF8Bytes,The following statement contains a magic number: Encoding enc = Encoding.GetEncoding(65001);
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddLine,The following statement contains a magic number: red = Math.Round((red/255)'3);
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddLine,The following statement contains a magic number: red = Math.Round((red/255)'3);
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddLine,The following statement contains a magic number: green = Math.Round((green/255)'3);
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddLine,The following statement contains a magic number: green = Math.Round((green/255)'3);
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddLine,The following statement contains a magic number: blue = Math.Round((blue/255)'3);
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddLine,The following statement contains a magic number: blue = Math.Round((blue/255)'3);
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddFillRect,The following statement contains a magic number: red = Math.Round((red/255)'3);
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddFillRect,The following statement contains a magic number: red = Math.Round((red/255)'3);
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddFillRect,The following statement contains a magic number: green = Math.Round((green/255)'3);
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddFillRect,The following statement contains a magic number: green = Math.Round((green/255)'3);
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddFillRect,The following statement contains a magic number: blue = Math.Round((blue/255)'3);
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddFillRect,The following statement contains a magic number: blue = Math.Round((blue/255)'3);
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddFillRect,The following statement contains a magic number: red = Math.Round((red/255)'3);
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddFillRect,The following statement contains a magic number: red = Math.Round((red/255)'3);
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddFillRect,The following statement contains a magic number: green = Math.Round((green/255)'3);
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddFillRect,The following statement contains a magic number: green = Math.Round((green/255)'3);
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddFillRect,The following statement contains a magic number: blue = Math.Round((blue/255)'3);
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddFillRect,The following statement contains a magic number: blue = Math.Round((blue/255)'3);
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddFillRect,The following statement contains a magic number: if (si.PatternType != patternTypeEnum.None)  			{			  				string p = patterns.GetPdfPattern(si.PatternType.ToString());                  				c = si.Color;                				red = Math.Round((c.R/255.0)'3);  				green = Math.Round((c.G/255.0)'3);  				blue = Math.Round((c.B/255.0)'3);  				elements.AppendFormat("\r\nq");			  				elements.AppendFormat("\r\n /CS1 cs");  				elements.AppendFormat("\r\n {0} {1} {2} /{3} scn"'red'green'blue'p);  				elements.AppendFormat("\r\n {0} {1} {2} RG"'red'green'blue);  				elements.AppendFormat("\r\n {0} {1} {2} {3} re\tf"'x' pSize.yHeight-y-height' width' height);  				elements.AppendFormat("\tQ");  			}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddFillRect,The following statement contains a magic number: if (si.PatternType != patternTypeEnum.None)  			{			  				string p = patterns.GetPdfPattern(si.PatternType.ToString());                  				c = si.Color;                				red = Math.Round((c.R/255.0)'3);  				green = Math.Round((c.G/255.0)'3);  				blue = Math.Round((c.B/255.0)'3);  				elements.AppendFormat("\r\nq");			  				elements.AppendFormat("\r\n /CS1 cs");  				elements.AppendFormat("\r\n {0} {1} {2} /{3} scn"'red'green'blue'p);  				elements.AppendFormat("\r\n {0} {1} {2} RG"'red'green'blue);  				elements.AppendFormat("\r\n {0} {1} {2} {3} re\tf"'x' pSize.yHeight-y-height' width' height);  				elements.AppendFormat("\tQ");  			}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddFillRect,The following statement contains a magic number: if (si.PatternType != patternTypeEnum.None)  			{			  				string p = patterns.GetPdfPattern(si.PatternType.ToString());                  				c = si.Color;                				red = Math.Round((c.R/255.0)'3);  				green = Math.Round((c.G/255.0)'3);  				blue = Math.Round((c.B/255.0)'3);  				elements.AppendFormat("\r\nq");			  				elements.AppendFormat("\r\n /CS1 cs");  				elements.AppendFormat("\r\n {0} {1} {2} /{3} scn"'red'green'blue'p);  				elements.AppendFormat("\r\n {0} {1} {2} RG"'red'green'blue);  				elements.AppendFormat("\r\n {0} {1} {2} {3} re\tf"'x' pSize.yHeight-y-height' width' height);  				elements.AppendFormat("\tQ");  			}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddFillRect,The following statement contains a magic number: if (si.PatternType != patternTypeEnum.None)  			{			  				string p = patterns.GetPdfPattern(si.PatternType.ToString());                  				c = si.Color;                				red = Math.Round((c.R/255.0)'3);  				green = Math.Round((c.G/255.0)'3);  				blue = Math.Round((c.B/255.0)'3);  				elements.AppendFormat("\r\nq");			  				elements.AppendFormat("\r\n /CS1 cs");  				elements.AppendFormat("\r\n {0} {1} {2} /{3} scn"'red'green'blue'p);  				elements.AppendFormat("\r\n {0} {1} {2} RG"'red'green'blue);  				elements.AppendFormat("\r\n {0} {1} {2} {3} re\tf"'x' pSize.yHeight-y-height' width' height);  				elements.AppendFormat("\tQ");  			}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddFillRect,The following statement contains a magic number: if (si.PatternType != patternTypeEnum.None)  			{			  				string p = patterns.GetPdfPattern(si.PatternType.ToString());                  				c = si.Color;                				red = Math.Round((c.R/255.0)'3);  				green = Math.Round((c.G/255.0)'3);  				blue = Math.Round((c.B/255.0)'3);  				elements.AppendFormat("\r\nq");			  				elements.AppendFormat("\r\n /CS1 cs");  				elements.AppendFormat("\r\n {0} {1} {2} /{3} scn"'red'green'blue'p);  				elements.AppendFormat("\r\n {0} {1} {2} RG"'red'green'blue);  				elements.AppendFormat("\r\n {0} {1} {2} {3} re\tf"'x' pSize.yHeight-y-height' width' height);  				elements.AppendFormat("\tQ");  			}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddFillRect,The following statement contains a magic number: if (si.PatternType != patternTypeEnum.None)  			{			  				string p = patterns.GetPdfPattern(si.PatternType.ToString());                  				c = si.Color;                				red = Math.Round((c.R/255.0)'3);  				green = Math.Round((c.G/255.0)'3);  				blue = Math.Round((c.B/255.0)'3);  				elements.AppendFormat("\r\nq");			  				elements.AppendFormat("\r\n /CS1 cs");  				elements.AppendFormat("\r\n {0} {1} {2} /{3} scn"'red'green'blue'p);  				elements.AppendFormat("\r\n {0} {1} {2} RG"'red'green'blue);  				elements.AppendFormat("\r\n {0} {1} {2} {3} re\tf"'x' pSize.yHeight-y-height' width' height);  				elements.AppendFormat("\tQ");  			}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddPolygon,The following statement contains a magic number: red = Math.Round((red / 255)' 3);
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddPolygon,The following statement contains a magic number: red = Math.Round((red / 255)' 3);
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddPolygon,The following statement contains a magic number: green = Math.Round((green / 255)' 3);
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddPolygon,The following statement contains a magic number: green = Math.Round((green / 255)' 3);
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddPolygon,The following statement contains a magic number: blue = Math.Round((blue / 255)' 3);
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddPolygon,The following statement contains a magic number: blue = Math.Round((blue / 255)' 3);
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddPolygon,The following statement contains a magic number: if (si.PatternType != patternTypeEnum.None)              {                  string p = patterns.GetPdfPattern(si.PatternType.ToString());                  c = si.Color;                  red = Math.Round((c.R / 255.0)' 3);                  green = Math.Round((c.G / 255.0)' 3);                  blue = Math.Round((c.B / 255.0)' 3);                  elements.AppendFormat("\r\nq");                  elements.AppendFormat("\r\n /CS1 cs");                  elements.AppendFormat("\r\n {0} {1} {2} /{3} scn"' red' green' blue' p);                  elements.AppendFormat("\r\n {0} {1} {2} RG"' red' green' blue);                  AddPoints(elements' pts);              }
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddPolygon,The following statement contains a magic number: if (si.PatternType != patternTypeEnum.None)              {                  string p = patterns.GetPdfPattern(si.PatternType.ToString());                  c = si.Color;                  red = Math.Round((c.R / 255.0)' 3);                  green = Math.Round((c.G / 255.0)' 3);                  blue = Math.Round((c.B / 255.0)' 3);                  elements.AppendFormat("\r\nq");                  elements.AppendFormat("\r\n /CS1 cs");                  elements.AppendFormat("\r\n {0} {1} {2} /{3} scn"' red' green' blue' p);                  elements.AppendFormat("\r\n {0} {1} {2} RG"' red' green' blue);                  AddPoints(elements' pts);              }
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddPolygon,The following statement contains a magic number: if (si.PatternType != patternTypeEnum.None)              {                  string p = patterns.GetPdfPattern(si.PatternType.ToString());                  c = si.Color;                  red = Math.Round((c.R / 255.0)' 3);                  green = Math.Round((c.G / 255.0)' 3);                  blue = Math.Round((c.B / 255.0)' 3);                  elements.AppendFormat("\r\nq");                  elements.AppendFormat("\r\n /CS1 cs");                  elements.AppendFormat("\r\n {0} {1} {2} /{3} scn"' red' green' blue' p);                  elements.AppendFormat("\r\n {0} {1} {2} RG"' red' green' blue);                  AddPoints(elements' pts);              }
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddPolygon,The following statement contains a magic number: if (si.PatternType != patternTypeEnum.None)              {                  string p = patterns.GetPdfPattern(si.PatternType.ToString());                  c = si.Color;                  red = Math.Round((c.R / 255.0)' 3);                  green = Math.Round((c.G / 255.0)' 3);                  blue = Math.Round((c.B / 255.0)' 3);                  elements.AppendFormat("\r\nq");                  elements.AppendFormat("\r\n /CS1 cs");                  elements.AppendFormat("\r\n {0} {1} {2} /{3} scn"' red' green' blue' p);                  elements.AppendFormat("\r\n {0} {1} {2} RG"' red' green' blue);                  AddPoints(elements' pts);              }
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddPolygon,The following statement contains a magic number: if (si.PatternType != patternTypeEnum.None)              {                  string p = patterns.GetPdfPattern(si.PatternType.ToString());                  c = si.Color;                  red = Math.Round((c.R / 255.0)' 3);                  green = Math.Round((c.G / 255.0)' 3);                  blue = Math.Round((c.B / 255.0)' 3);                  elements.AppendFormat("\r\nq");                  elements.AppendFormat("\r\n /CS1 cs");                  elements.AppendFormat("\r\n {0} {1} {2} /{3} scn"' red' green' blue' p);                  elements.AppendFormat("\r\n {0} {1} {2} RG"' red' green' blue);                  AddPoints(elements' pts);              }
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddPolygon,The following statement contains a magic number: if (si.PatternType != patternTypeEnum.None)              {                  string p = patterns.GetPdfPattern(si.PatternType.ToString());                  c = si.Color;                  red = Math.Round((c.R / 255.0)' 3);                  green = Math.Round((c.G / 255.0)' 3);                  blue = Math.Round((c.B / 255.0)' 3);                  elements.AppendFormat("\r\nq");                  elements.AppendFormat("\r\n /CS1 cs");                  elements.AppendFormat("\r\n {0} {1} {2} /{3} scn"' red' green' blue' p);                  elements.AppendFormat("\r\n {0} {1} {2} RG"' red' green' blue);                  AddPoints(elements' pts);              }
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddCurve,The following statement contains a magic number: if (pts.Length > 2)              {   // do a spline curve                  PointF[] tangents = GetCurveTangents(pts);                  DoCurve(pts' tangents' si);              }              else              {   // we only have two points; just do a line segment                  AddLine(pts[0].X' pts[0].Y' pts[1].X' pts[1].Y' si);              }
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,GetCurveTangents,The following statement contains a magic number: if (tangents.Length <= 2)                  return tangents;
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddCurve,The following statement contains a magic number: if (si.BStyleTop != BorderStyleEnum.None)  			{				  				elements.AppendFormat("{0} w\t {1} \t"'si.BWidthTop'linestyle);  				elements.AppendFormat("{0} {1} {2} RG\t"' Math.Round(si.BColorTop.R / 255.0' 3)' Math.Round(si.BColorTop.G / 255.0' 3)' Math.Round(si.BColorTop.B / 255.0' 3)); //Set Stroking colours  			}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddCurve,The following statement contains a magic number: if (si.BStyleTop != BorderStyleEnum.None)  			{				  				elements.AppendFormat("{0} w\t {1} \t"'si.BWidthTop'linestyle);  				elements.AppendFormat("{0} {1} {2} RG\t"' Math.Round(si.BColorTop.R / 255.0' 3)' Math.Round(si.BColorTop.G / 255.0' 3)' Math.Round(si.BColorTop.B / 255.0' 3)); //Set Stroking colours  			}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddCurve,The following statement contains a magic number: if (si.BStyleTop != BorderStyleEnum.None)  			{				  				elements.AppendFormat("{0} w\t {1} \t"'si.BWidthTop'linestyle);  				elements.AppendFormat("{0} {1} {2} RG\t"' Math.Round(si.BColorTop.R / 255.0' 3)' Math.Round(si.BColorTop.G / 255.0' 3)' Math.Round(si.BColorTop.B / 255.0' 3)); //Set Stroking colours  			}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddCurve,The following statement contains a magic number: if (si.BStyleTop != BorderStyleEnum.None)  			{				  				elements.AppendFormat("{0} w\t {1} \t"'si.BWidthTop'linestyle);  				elements.AppendFormat("{0} {1} {2} RG\t"' Math.Round(si.BColorTop.R / 255.0' 3)' Math.Round(si.BColorTop.G / 255.0' 3)' Math.Round(si.BColorTop.B / 255.0' 3)); //Set Stroking colours  			}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddCurve,The following statement contains a magic number: if (si.BStyleTop != BorderStyleEnum.None)  			{				  				elements.AppendFormat("{0} w\t {1} \t"'si.BWidthTop'linestyle);  				elements.AppendFormat("{0} {1} {2} RG\t"' Math.Round(si.BColorTop.R / 255.0' 3)' Math.Round(si.BColorTop.G / 255.0' 3)' Math.Round(si.BColorTop.B / 255.0' 3)); //Set Stroking colours  			}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddCurve,The following statement contains a magic number: if (si.BStyleTop != BorderStyleEnum.None)  			{				  				elements.AppendFormat("{0} w\t {1} \t"'si.BWidthTop'linestyle);  				elements.AppendFormat("{0} {1} {2} RG\t"' Math.Round(si.BColorTop.R / 255.0' 3)' Math.Round(si.BColorTop.G / 255.0' 3)' Math.Round(si.BColorTop.B / 255.0' 3)); //Set Stroking colours  			}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddCurve,The following statement contains a magic number: if (!si.BackgroundColor.IsEmpty)  			{  				elements.AppendFormat("{0} {1} {2} rg\t"' Math.Round(si.BackgroundColor.R / 255.0' 3)' Math.Round(si.BackgroundColor.G / 255.0' 3)' Math.Round(si.BackgroundColor.B / 255.0' 3)); //Set Non Stroking colours  			}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddCurve,The following statement contains a magic number: if (!si.BackgroundColor.IsEmpty)  			{  				elements.AppendFormat("{0} {1} {2} rg\t"' Math.Round(si.BackgroundColor.R / 255.0' 3)' Math.Round(si.BackgroundColor.G / 255.0' 3)' Math.Round(si.BackgroundColor.B / 255.0' 3)); //Set Non Stroking colours  			}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddCurve,The following statement contains a magic number: if (!si.BackgroundColor.IsEmpty)  			{  				elements.AppendFormat("{0} {1} {2} rg\t"' Math.Round(si.BackgroundColor.R / 255.0' 3)' Math.Round(si.BackgroundColor.G / 255.0' 3)' Math.Round(si.BackgroundColor.B / 255.0' 3)); //Set Non Stroking colours  			}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddCurve,The following statement contains a magic number: if (!si.BackgroundColor.IsEmpty)  			{  				elements.AppendFormat("{0} {1} {2} rg\t"' Math.Round(si.BackgroundColor.R / 255.0' 3)' Math.Round(si.BackgroundColor.G / 255.0' 3)' Math.Round(si.BackgroundColor.B / 255.0' 3)); //Set Non Stroking colours  			}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddCurve,The following statement contains a magic number: if (!si.BackgroundColor.IsEmpty)  			{  				elements.AppendFormat("{0} {1} {2} rg\t"' Math.Round(si.BackgroundColor.R / 255.0' 3)' Math.Round(si.BackgroundColor.G / 255.0' 3)' Math.Round(si.BackgroundColor.B / 255.0' 3)); //Set Non Stroking colours  			}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddCurve,The following statement contains a magic number: if (!si.BackgroundColor.IsEmpty)  			{  				elements.AppendFormat("{0} {1} {2} rg\t"' Math.Round(si.BackgroundColor.R / 255.0' 3)' Math.Round(si.BackgroundColor.G / 255.0' 3)' Math.Round(si.BackgroundColor.B / 255.0' 3)); //Set Non Stroking colours  			}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddEllipse,The following statement contains a magic number: if (si.BStyleTop != BorderStyleEnum.None)	              	{              		string linestyle;				  					switch (si.BStyleTop)  					{  						case BorderStyleEnum.Dashed:  							linestyle="[3 2] 0 d";  							break;  						case BorderStyleEnum.Dotted:  							linestyle="[2] 0 d";  							break;  						case BorderStyleEnum.Solid:  						default:  							linestyle="[] 0 d";  							break;  					}  					elements.AppendFormat("{0} w\t {1} \t"'si.BWidthTop'linestyle);  					elements.AppendFormat("{0} {1} {2} RG\t"' Math.Round(si.BColorTop.R / 255.0' 3)' Math.Round(si.BColorTop.G / 255.0' 3)' Math.Round(si.BColorTop.B / 255.0' 3)); //Set Stroking colours  				}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddEllipse,The following statement contains a magic number: if (si.BStyleTop != BorderStyleEnum.None)	              	{              		string linestyle;				  					switch (si.BStyleTop)  					{  						case BorderStyleEnum.Dashed:  							linestyle="[3 2] 0 d";  							break;  						case BorderStyleEnum.Dotted:  							linestyle="[2] 0 d";  							break;  						case BorderStyleEnum.Solid:  						default:  							linestyle="[] 0 d";  							break;  					}  					elements.AppendFormat("{0} w\t {1} \t"'si.BWidthTop'linestyle);  					elements.AppendFormat("{0} {1} {2} RG\t"' Math.Round(si.BColorTop.R / 255.0' 3)' Math.Round(si.BColorTop.G / 255.0' 3)' Math.Round(si.BColorTop.B / 255.0' 3)); //Set Stroking colours  				}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddEllipse,The following statement contains a magic number: if (si.BStyleTop != BorderStyleEnum.None)	              	{              		string linestyle;				  					switch (si.BStyleTop)  					{  						case BorderStyleEnum.Dashed:  							linestyle="[3 2] 0 d";  							break;  						case BorderStyleEnum.Dotted:  							linestyle="[2] 0 d";  							break;  						case BorderStyleEnum.Solid:  						default:  							linestyle="[] 0 d";  							break;  					}  					elements.AppendFormat("{0} w\t {1} \t"'si.BWidthTop'linestyle);  					elements.AppendFormat("{0} {1} {2} RG\t"' Math.Round(si.BColorTop.R / 255.0' 3)' Math.Round(si.BColorTop.G / 255.0' 3)' Math.Round(si.BColorTop.B / 255.0' 3)); //Set Stroking colours  				}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddEllipse,The following statement contains a magic number: if (si.BStyleTop != BorderStyleEnum.None)	              	{              		string linestyle;				  					switch (si.BStyleTop)  					{  						case BorderStyleEnum.Dashed:  							linestyle="[3 2] 0 d";  							break;  						case BorderStyleEnum.Dotted:  							linestyle="[2] 0 d";  							break;  						case BorderStyleEnum.Solid:  						default:  							linestyle="[] 0 d";  							break;  					}  					elements.AppendFormat("{0} w\t {1} \t"'si.BWidthTop'linestyle);  					elements.AppendFormat("{0} {1} {2} RG\t"' Math.Round(si.BColorTop.R / 255.0' 3)' Math.Round(si.BColorTop.G / 255.0' 3)' Math.Round(si.BColorTop.B / 255.0' 3)); //Set Stroking colours  				}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddEllipse,The following statement contains a magic number: if (si.BStyleTop != BorderStyleEnum.None)	              	{              		string linestyle;				  					switch (si.BStyleTop)  					{  						case BorderStyleEnum.Dashed:  							linestyle="[3 2] 0 d";  							break;  						case BorderStyleEnum.Dotted:  							linestyle="[2] 0 d";  							break;  						case BorderStyleEnum.Solid:  						default:  							linestyle="[] 0 d";  							break;  					}  					elements.AppendFormat("{0} w\t {1} \t"'si.BWidthTop'linestyle);  					elements.AppendFormat("{0} {1} {2} RG\t"' Math.Round(si.BColorTop.R / 255.0' 3)' Math.Round(si.BColorTop.G / 255.0' 3)' Math.Round(si.BColorTop.B / 255.0' 3)); //Set Stroking colours  				}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddEllipse,The following statement contains a magic number: if (si.BStyleTop != BorderStyleEnum.None)	              	{              		string linestyle;				  					switch (si.BStyleTop)  					{  						case BorderStyleEnum.Dashed:  							linestyle="[3 2] 0 d";  							break;  						case BorderStyleEnum.Dotted:  							linestyle="[2] 0 d";  							break;  						case BorderStyleEnum.Solid:  						default:  							linestyle="[] 0 d";  							break;  					}  					elements.AppendFormat("{0} w\t {1} \t"'si.BWidthTop'linestyle);  					elements.AppendFormat("{0} {1} {2} RG\t"' Math.Round(si.BColorTop.R / 255.0' 3)' Math.Round(si.BColorTop.G / 255.0' 3)' Math.Round(si.BColorTop.B / 255.0' 3)); //Set Stroking colours  				}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddEllipse,The following statement contains a magic number: if (!si.BackgroundColor.IsEmpty)  				{  					elements.AppendFormat("{0} {1} {2} rg\t"' Math.Round(si.BackgroundColor.R / 255.0' 3)' Math.Round(si.BackgroundColor.G / 255.0' 3)' Math.Round(si.BackgroundColor.B / 255.0' 3)); //Set Non Stroking colours  				}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddEllipse,The following statement contains a magic number: if (!si.BackgroundColor.IsEmpty)  				{  					elements.AppendFormat("{0} {1} {2} rg\t"' Math.Round(si.BackgroundColor.R / 255.0' 3)' Math.Round(si.BackgroundColor.G / 255.0' 3)' Math.Round(si.BackgroundColor.B / 255.0' 3)); //Set Non Stroking colours  				}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddEllipse,The following statement contains a magic number: if (!si.BackgroundColor.IsEmpty)  				{  					elements.AppendFormat("{0} {1} {2} rg\t"' Math.Round(si.BackgroundColor.R / 255.0' 3)' Math.Round(si.BackgroundColor.G / 255.0' 3)' Math.Round(si.BackgroundColor.B / 255.0' 3)); //Set Non Stroking colours  				}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddEllipse,The following statement contains a magic number: if (!si.BackgroundColor.IsEmpty)  				{  					elements.AppendFormat("{0} {1} {2} rg\t"' Math.Round(si.BackgroundColor.R / 255.0' 3)' Math.Round(si.BackgroundColor.G / 255.0' 3)' Math.Round(si.BackgroundColor.B / 255.0' 3)); //Set Non Stroking colours  				}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddEllipse,The following statement contains a magic number: if (!si.BackgroundColor.IsEmpty)  				{  					elements.AppendFormat("{0} {1} {2} rg\t"' Math.Round(si.BackgroundColor.R / 255.0' 3)' Math.Round(si.BackgroundColor.G / 255.0' 3)' Math.Round(si.BackgroundColor.B / 255.0' 3)); //Set Non Stroking colours  				}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddEllipse,The following statement contains a magic number: if (!si.BackgroundColor.IsEmpty)  				{  					elements.AppendFormat("{0} {1} {2} rg\t"' Math.Round(si.BackgroundColor.R / 255.0' 3)' Math.Round(si.BackgroundColor.G / 255.0' 3)' Math.Round(si.BackgroundColor.B / 255.0' 3)); //Set Non Stroking colours  				}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddEllipse,The following statement contains a magic number: X1 += 2 * RadiusX;
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddEllipse,The following statement contains a magic number: X3 += 2 * kRx;
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddEllipse,The following statement contains a magic number: Y2 += 2 * kRy;
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddEllipse,The following statement contains a magic number: Y3 += 2 * RadiusY;
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddEllipse,The following statement contains a magic number: X1 -= 2 * RadiusX;
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddEllipse,The following statement contains a magic number: X3 -= 2 * kRx;
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddText,The following statement contains a magic number: r = Math.Round((r/255)'3);
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddText,The following statement contains a magic number: r = Math.Round((r/255)'3);
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddText,The following statement contains a magic number: g = Math.Round((g/255)'3);
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddText,The following statement contains a magic number: g = Math.Round((g/255)'3);
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddText,The following statement contains a magic number: b = Math.Round((b/255)'3);
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddText,The following statement contains a magic number: b = Math.Round((b/255)'3);
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddText,The following statement contains a magic number: for (int i=0; i < sa.Length; i++)  			{  				string text = sa[i];  				float textwidth = tw[i];  				// Calculate the x position  				float startX = x + si.PaddingLeft;						// TODO: handle tb_rl  				float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl    				if (si.WritingMode == WritingModeEnum.lr_tb)  				{	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now  					switch(si.TextAlign)  					{  						case TextAlignEnum.Center:  							if (width > 0)  								startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight)/2 - textwidth/2;	   							break;  						case TextAlignEnum.Right:  							if (width > 0)  								startX = x + width - textwidth - si.PaddingRight;	  							break;  						case TextAlignEnum.Left:  						default:  							break;  					}    					// Calculate the y position  					switch(si.VerticalAlign)  					{  						case VerticalAlignEnum.Middle:  							if (height <= 0)  								break;    							// calculate the middle of the region  							startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom)/2 - si.FontSize/2;	   							// now go up or down depending on which line  							if (sa.Length == 1)  								break;  							if (sa.Length % 2 == 0)	// even number  							{  								startY = startY - ((sa.Length/2 - i) * si.FontSize) + si.FontSize/2;  							}  							else  							{  								startY = startY - ((sa.Length/2 - i) * si.FontSize);  							}  							break;  						case VerticalAlignEnum.Bottom:  							if (height <= 0)  								break;  							  							startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length-i));	  							break;  						case VerticalAlignEnum.Top:  						default:  							break;  					}  				}                  else                  {  					//25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                                           switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                     }    				// Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)  				if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)  				{	// background color' height and width are specified  					AddFillRect(x' y' width' height' si.BackgroundColor);  				}    				// Set the clipping path  				if (height > 0 && width > 0)  				{  					if (bNoClip)	// no clipping but we still want URL checking  						elements.Append("\r\nq\t");  					else  						elements.AppendFormat(NumberFormatInfo.InvariantInfo'  							"\r\nq\t{0} {1} {2} {3} re W n"'  							x' pSize.yHeight-y-height' width' height);  					if (url != null)  						p.AddHyperlink(x' pSize.yHeight-y' height' width' url);                      if (tooltip != null)                          p.AddToolTip(x' pSize.yHeight - y' height' width' tooltip);    				}  				else  					elements.Append("\r\nq\t");    				// Escape the text                  string newtext = PdfUtility.UTF16StringQuoter(text);                  //string newtext = text.Replace("\\"' "\\\\");                  //newtext = newtext.Replace("("' "\\(");                  //newtext = newtext.Replace(")"' "\\)");  				if (si.WritingMode == WritingModeEnum.lr_tb)  				{  					elements.AppendFormat(NumberFormatInfo.InvariantInfo'  						"\r\nBT/{0} {1} Tf\t{5} {6} {7} rg\t{2} {3} Td \t({4}) Tj\tET\tQ\t"'  						pdfFont'si.FontSize'startX'(pSize.yHeight-startY-si.FontSize)'newtext' r' g' b);  				}  				else  				{	// Rotate text -90 degrees=-.5 radians (this works for english don't know about true tb-rl language)  					//   had to play with reader to find best approximation for this rotation; didn't do what I expected  					//    see pdf spec section 4.2.2 pg 141  "Common Transformations"    					elements.AppendFormat(NumberFormatInfo.InvariantInfo'  						"\r\nBT/{0} {1} Tf\t{5} {6} {7} rg\t{8} {9} {10} {11} {2} {3} Tm \t({4}) Tj\tET\tQ\t"'  						pdfFont'si.FontSize'startX'(pSize.yHeight-startY)'newtext' r' g' b'  						radsCos' radsSin' -radsSin' radsCos);  				}    				// Handle underlining etc.  				float maxX;  				switch (si.TextDecoration)  				{  					case TextDecorationEnum.Underline:  						maxX = width > 0? Math.Min(x + width' startX+textwidth): startX+textwidth;  						AddLine(startX' startY+si.FontSize+1' maxX' startY+si.FontSize+1' 1' si.Color' BorderStyleEnum.Solid);  						break;  					case TextDecorationEnum.LineThrough:  						maxX = width > 0? Math.Min(x + width' startX+textwidth): startX+textwidth;  						AddLine(startX' startY+(si.FontSize/2)+1' maxX' startY+(si.FontSize/2)+1' 1' si.Color' BorderStyleEnum.Solid);  						break;  					case TextDecorationEnum.Overline:  						maxX = width > 0? Math.Min(x + width' startX+textwidth): startX+textwidth;  						AddLine(startX' startY+1' maxX' startY+1' 1' si.Color' BorderStyleEnum.Solid);  						break;  					case TextDecorationEnum.None:  					default:  						break;  				}  			}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddText,The following statement contains a magic number: for (int i=0; i < sa.Length; i++)  			{  				string text = sa[i];  				float textwidth = tw[i];  				// Calculate the x position  				float startX = x + si.PaddingLeft;						// TODO: handle tb_rl  				float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl    				if (si.WritingMode == WritingModeEnum.lr_tb)  				{	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now  					switch(si.TextAlign)  					{  						case TextAlignEnum.Center:  							if (width > 0)  								startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight)/2 - textwidth/2;	   							break;  						case TextAlignEnum.Right:  							if (width > 0)  								startX = x + width - textwidth - si.PaddingRight;	  							break;  						case TextAlignEnum.Left:  						default:  							break;  					}    					// Calculate the y position  					switch(si.VerticalAlign)  					{  						case VerticalAlignEnum.Middle:  							if (height <= 0)  								break;    							// calculate the middle of the region  							startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom)/2 - si.FontSize/2;	   							// now go up or down depending on which line  							if (sa.Length == 1)  								break;  							if (sa.Length % 2 == 0)	// even number  							{  								startY = startY - ((sa.Length/2 - i) * si.FontSize) + si.FontSize/2;  							}  							else  							{  								startY = startY - ((sa.Length/2 - i) * si.FontSize);  							}  							break;  						case VerticalAlignEnum.Bottom:  							if (height <= 0)  								break;  							  							startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length-i));	  							break;  						case VerticalAlignEnum.Top:  						default:  							break;  					}  				}                  else                  {  					//25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                                           switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                     }    				// Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)  				if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)  				{	// background color' height and width are specified  					AddFillRect(x' y' width' height' si.BackgroundColor);  				}    				// Set the clipping path  				if (height > 0 && width > 0)  				{  					if (bNoClip)	// no clipping but we still want URL checking  						elements.Append("\r\nq\t");  					else  						elements.AppendFormat(NumberFormatInfo.InvariantInfo'  							"\r\nq\t{0} {1} {2} {3} re W n"'  							x' pSize.yHeight-y-height' width' height);  					if (url != null)  						p.AddHyperlink(x' pSize.yHeight-y' height' width' url);                      if (tooltip != null)                          p.AddToolTip(x' pSize.yHeight - y' height' width' tooltip);    				}  				else  					elements.Append("\r\nq\t");    				// Escape the text                  string newtext = PdfUtility.UTF16StringQuoter(text);                  //string newtext = text.Replace("\\"' "\\\\");                  //newtext = newtext.Replace("("' "\\(");                  //newtext = newtext.Replace(")"' "\\)");  				if (si.WritingMode == WritingModeEnum.lr_tb)  				{  					elements.AppendFormat(NumberFormatInfo.InvariantInfo'  						"\r\nBT/{0} {1} Tf\t{5} {6} {7} rg\t{2} {3} Td \t({4}) Tj\tET\tQ\t"'  						pdfFont'si.FontSize'startX'(pSize.yHeight-startY-si.FontSize)'newtext' r' g' b);  				}  				else  				{	// Rotate text -90 degrees=-.5 radians (this works for english don't know about true tb-rl language)  					//   had to play with reader to find best approximation for this rotation; didn't do what I expected  					//    see pdf spec section 4.2.2 pg 141  "Common Transformations"    					elements.AppendFormat(NumberFormatInfo.InvariantInfo'  						"\r\nBT/{0} {1} Tf\t{5} {6} {7} rg\t{8} {9} {10} {11} {2} {3} Tm \t({4}) Tj\tET\tQ\t"'  						pdfFont'si.FontSize'startX'(pSize.yHeight-startY)'newtext' r' g' b'  						radsCos' radsSin' -radsSin' radsCos);  				}    				// Handle underlining etc.  				float maxX;  				switch (si.TextDecoration)  				{  					case TextDecorationEnum.Underline:  						maxX = width > 0? Math.Min(x + width' startX+textwidth): startX+textwidth;  						AddLine(startX' startY+si.FontSize+1' maxX' startY+si.FontSize+1' 1' si.Color' BorderStyleEnum.Solid);  						break;  					case TextDecorationEnum.LineThrough:  						maxX = width > 0? Math.Min(x + width' startX+textwidth): startX+textwidth;  						AddLine(startX' startY+(si.FontSize/2)+1' maxX' startY+(si.FontSize/2)+1' 1' si.Color' BorderStyleEnum.Solid);  						break;  					case TextDecorationEnum.Overline:  						maxX = width > 0? Math.Min(x + width' startX+textwidth): startX+textwidth;  						AddLine(startX' startY+1' maxX' startY+1' 1' si.Color' BorderStyleEnum.Solid);  						break;  					case TextDecorationEnum.None:  					default:  						break;  				}  			}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddText,The following statement contains a magic number: for (int i=0; i < sa.Length; i++)  			{  				string text = sa[i];  				float textwidth = tw[i];  				// Calculate the x position  				float startX = x + si.PaddingLeft;						// TODO: handle tb_rl  				float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl    				if (si.WritingMode == WritingModeEnum.lr_tb)  				{	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now  					switch(si.TextAlign)  					{  						case TextAlignEnum.Center:  							if (width > 0)  								startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight)/2 - textwidth/2;	   							break;  						case TextAlignEnum.Right:  							if (width > 0)  								startX = x + width - textwidth - si.PaddingRight;	  							break;  						case TextAlignEnum.Left:  						default:  							break;  					}    					// Calculate the y position  					switch(si.VerticalAlign)  					{  						case VerticalAlignEnum.Middle:  							if (height <= 0)  								break;    							// calculate the middle of the region  							startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom)/2 - si.FontSize/2;	   							// now go up or down depending on which line  							if (sa.Length == 1)  								break;  							if (sa.Length % 2 == 0)	// even number  							{  								startY = startY - ((sa.Length/2 - i) * si.FontSize) + si.FontSize/2;  							}  							else  							{  								startY = startY - ((sa.Length/2 - i) * si.FontSize);  							}  							break;  						case VerticalAlignEnum.Bottom:  							if (height <= 0)  								break;  							  							startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length-i));	  							break;  						case VerticalAlignEnum.Top:  						default:  							break;  					}  				}                  else                  {  					//25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                                           switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                     }    				// Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)  				if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)  				{	// background color' height and width are specified  					AddFillRect(x' y' width' height' si.BackgroundColor);  				}    				// Set the clipping path  				if (height > 0 && width > 0)  				{  					if (bNoClip)	// no clipping but we still want URL checking  						elements.Append("\r\nq\t");  					else  						elements.AppendFormat(NumberFormatInfo.InvariantInfo'  							"\r\nq\t{0} {1} {2} {3} re W n"'  							x' pSize.yHeight-y-height' width' height);  					if (url != null)  						p.AddHyperlink(x' pSize.yHeight-y' height' width' url);                      if (tooltip != null)                          p.AddToolTip(x' pSize.yHeight - y' height' width' tooltip);    				}  				else  					elements.Append("\r\nq\t");    				// Escape the text                  string newtext = PdfUtility.UTF16StringQuoter(text);                  //string newtext = text.Replace("\\"' "\\\\");                  //newtext = newtext.Replace("("' "\\(");                  //newtext = newtext.Replace(")"' "\\)");  				if (si.WritingMode == WritingModeEnum.lr_tb)  				{  					elements.AppendFormat(NumberFormatInfo.InvariantInfo'  						"\r\nBT/{0} {1} Tf\t{5} {6} {7} rg\t{2} {3} Td \t({4}) Tj\tET\tQ\t"'  						pdfFont'si.FontSize'startX'(pSize.yHeight-startY-si.FontSize)'newtext' r' g' b);  				}  				else  				{	// Rotate text -90 degrees=-.5 radians (this works for english don't know about true tb-rl language)  					//   had to play with reader to find best approximation for this rotation; didn't do what I expected  					//    see pdf spec section 4.2.2 pg 141  "Common Transformations"    					elements.AppendFormat(NumberFormatInfo.InvariantInfo'  						"\r\nBT/{0} {1} Tf\t{5} {6} {7} rg\t{8} {9} {10} {11} {2} {3} Tm \t({4}) Tj\tET\tQ\t"'  						pdfFont'si.FontSize'startX'(pSize.yHeight-startY)'newtext' r' g' b'  						radsCos' radsSin' -radsSin' radsCos);  				}    				// Handle underlining etc.  				float maxX;  				switch (si.TextDecoration)  				{  					case TextDecorationEnum.Underline:  						maxX = width > 0? Math.Min(x + width' startX+textwidth): startX+textwidth;  						AddLine(startX' startY+si.FontSize+1' maxX' startY+si.FontSize+1' 1' si.Color' BorderStyleEnum.Solid);  						break;  					case TextDecorationEnum.LineThrough:  						maxX = width > 0? Math.Min(x + width' startX+textwidth): startX+textwidth;  						AddLine(startX' startY+(si.FontSize/2)+1' maxX' startY+(si.FontSize/2)+1' 1' si.Color' BorderStyleEnum.Solid);  						break;  					case TextDecorationEnum.Overline:  						maxX = width > 0? Math.Min(x + width' startX+textwidth): startX+textwidth;  						AddLine(startX' startY+1' maxX' startY+1' 1' si.Color' BorderStyleEnum.Solid);  						break;  					case TextDecorationEnum.None:  					default:  						break;  				}  			}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddText,The following statement contains a magic number: for (int i=0; i < sa.Length; i++)  			{  				string text = sa[i];  				float textwidth = tw[i];  				// Calculate the x position  				float startX = x + si.PaddingLeft;						// TODO: handle tb_rl  				float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl    				if (si.WritingMode == WritingModeEnum.lr_tb)  				{	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now  					switch(si.TextAlign)  					{  						case TextAlignEnum.Center:  							if (width > 0)  								startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight)/2 - textwidth/2;	   							break;  						case TextAlignEnum.Right:  							if (width > 0)  								startX = x + width - textwidth - si.PaddingRight;	  							break;  						case TextAlignEnum.Left:  						default:  							break;  					}    					// Calculate the y position  					switch(si.VerticalAlign)  					{  						case VerticalAlignEnum.Middle:  							if (height <= 0)  								break;    							// calculate the middle of the region  							startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom)/2 - si.FontSize/2;	   							// now go up or down depending on which line  							if (sa.Length == 1)  								break;  							if (sa.Length % 2 == 0)	// even number  							{  								startY = startY - ((sa.Length/2 - i) * si.FontSize) + si.FontSize/2;  							}  							else  							{  								startY = startY - ((sa.Length/2 - i) * si.FontSize);  							}  							break;  						case VerticalAlignEnum.Bottom:  							if (height <= 0)  								break;  							  							startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length-i));	  							break;  						case VerticalAlignEnum.Top:  						default:  							break;  					}  				}                  else                  {  					//25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                                           switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                     }    				// Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)  				if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)  				{	// background color' height and width are specified  					AddFillRect(x' y' width' height' si.BackgroundColor);  				}    				// Set the clipping path  				if (height > 0 && width > 0)  				{  					if (bNoClip)	// no clipping but we still want URL checking  						elements.Append("\r\nq\t");  					else  						elements.AppendFormat(NumberFormatInfo.InvariantInfo'  							"\r\nq\t{0} {1} {2} {3} re W n"'  							x' pSize.yHeight-y-height' width' height);  					if (url != null)  						p.AddHyperlink(x' pSize.yHeight-y' height' width' url);                      if (tooltip != null)                          p.AddToolTip(x' pSize.yHeight - y' height' width' tooltip);    				}  				else  					elements.Append("\r\nq\t");    				// Escape the text                  string newtext = PdfUtility.UTF16StringQuoter(text);                  //string newtext = text.Replace("\\"' "\\\\");                  //newtext = newtext.Replace("("' "\\(");                  //newtext = newtext.Replace(")"' "\\)");  				if (si.WritingMode == WritingModeEnum.lr_tb)  				{  					elements.AppendFormat(NumberFormatInfo.InvariantInfo'  						"\r\nBT/{0} {1} Tf\t{5} {6} {7} rg\t{2} {3} Td \t({4}) Tj\tET\tQ\t"'  						pdfFont'si.FontSize'startX'(pSize.yHeight-startY-si.FontSize)'newtext' r' g' b);  				}  				else  				{	// Rotate text -90 degrees=-.5 radians (this works for english don't know about true tb-rl language)  					//   had to play with reader to find best approximation for this rotation; didn't do what I expected  					//    see pdf spec section 4.2.2 pg 141  "Common Transformations"    					elements.AppendFormat(NumberFormatInfo.InvariantInfo'  						"\r\nBT/{0} {1} Tf\t{5} {6} {7} rg\t{8} {9} {10} {11} {2} {3} Tm \t({4}) Tj\tET\tQ\t"'  						pdfFont'si.FontSize'startX'(pSize.yHeight-startY)'newtext' r' g' b'  						radsCos' radsSin' -radsSin' radsCos);  				}    				// Handle underlining etc.  				float maxX;  				switch (si.TextDecoration)  				{  					case TextDecorationEnum.Underline:  						maxX = width > 0? Math.Min(x + width' startX+textwidth): startX+textwidth;  						AddLine(startX' startY+si.FontSize+1' maxX' startY+si.FontSize+1' 1' si.Color' BorderStyleEnum.Solid);  						break;  					case TextDecorationEnum.LineThrough:  						maxX = width > 0? Math.Min(x + width' startX+textwidth): startX+textwidth;  						AddLine(startX' startY+(si.FontSize/2)+1' maxX' startY+(si.FontSize/2)+1' 1' si.Color' BorderStyleEnum.Solid);  						break;  					case TextDecorationEnum.Overline:  						maxX = width > 0? Math.Min(x + width' startX+textwidth): startX+textwidth;  						AddLine(startX' startY+1' maxX' startY+1' 1' si.Color' BorderStyleEnum.Solid);  						break;  					case TextDecorationEnum.None:  					default:  						break;  				}  			}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddText,The following statement contains a magic number: for (int i=0; i < sa.Length; i++)  			{  				string text = sa[i];  				float textwidth = tw[i];  				// Calculate the x position  				float startX = x + si.PaddingLeft;						// TODO: handle tb_rl  				float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl    				if (si.WritingMode == WritingModeEnum.lr_tb)  				{	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now  					switch(si.TextAlign)  					{  						case TextAlignEnum.Center:  							if (width > 0)  								startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight)/2 - textwidth/2;	   							break;  						case TextAlignEnum.Right:  							if (width > 0)  								startX = x + width - textwidth - si.PaddingRight;	  							break;  						case TextAlignEnum.Left:  						default:  							break;  					}    					// Calculate the y position  					switch(si.VerticalAlign)  					{  						case VerticalAlignEnum.Middle:  							if (height <= 0)  								break;    							// calculate the middle of the region  							startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom)/2 - si.FontSize/2;	   							// now go up or down depending on which line  							if (sa.Length == 1)  								break;  							if (sa.Length % 2 == 0)	// even number  							{  								startY = startY - ((sa.Length/2 - i) * si.FontSize) + si.FontSize/2;  							}  							else  							{  								startY = startY - ((sa.Length/2 - i) * si.FontSize);  							}  							break;  						case VerticalAlignEnum.Bottom:  							if (height <= 0)  								break;  							  							startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length-i));	  							break;  						case VerticalAlignEnum.Top:  						default:  							break;  					}  				}                  else                  {  					//25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                                           switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                     }    				// Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)  				if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)  				{	// background color' height and width are specified  					AddFillRect(x' y' width' height' si.BackgroundColor);  				}    				// Set the clipping path  				if (height > 0 && width > 0)  				{  					if (bNoClip)	// no clipping but we still want URL checking  						elements.Append("\r\nq\t");  					else  						elements.AppendFormat(NumberFormatInfo.InvariantInfo'  							"\r\nq\t{0} {1} {2} {3} re W n"'  							x' pSize.yHeight-y-height' width' height);  					if (url != null)  						p.AddHyperlink(x' pSize.yHeight-y' height' width' url);                      if (tooltip != null)                          p.AddToolTip(x' pSize.yHeight - y' height' width' tooltip);    				}  				else  					elements.Append("\r\nq\t");    				// Escape the text                  string newtext = PdfUtility.UTF16StringQuoter(text);                  //string newtext = text.Replace("\\"' "\\\\");                  //newtext = newtext.Replace("("' "\\(");                  //newtext = newtext.Replace(")"' "\\)");  				if (si.WritingMode == WritingModeEnum.lr_tb)  				{  					elements.AppendFormat(NumberFormatInfo.InvariantInfo'  						"\r\nBT/{0} {1} Tf\t{5} {6} {7} rg\t{2} {3} Td \t({4}) Tj\tET\tQ\t"'  						pdfFont'si.FontSize'startX'(pSize.yHeight-startY-si.FontSize)'newtext' r' g' b);  				}  				else  				{	// Rotate text -90 degrees=-.5 radians (this works for english don't know about true tb-rl language)  					//   had to play with reader to find best approximation for this rotation; didn't do what I expected  					//    see pdf spec section 4.2.2 pg 141  "Common Transformations"    					elements.AppendFormat(NumberFormatInfo.InvariantInfo'  						"\r\nBT/{0} {1} Tf\t{5} {6} {7} rg\t{8} {9} {10} {11} {2} {3} Tm \t({4}) Tj\tET\tQ\t"'  						pdfFont'si.FontSize'startX'(pSize.yHeight-startY)'newtext' r' g' b'  						radsCos' radsSin' -radsSin' radsCos);  				}    				// Handle underlining etc.  				float maxX;  				switch (si.TextDecoration)  				{  					case TextDecorationEnum.Underline:  						maxX = width > 0? Math.Min(x + width' startX+textwidth): startX+textwidth;  						AddLine(startX' startY+si.FontSize+1' maxX' startY+si.FontSize+1' 1' si.Color' BorderStyleEnum.Solid);  						break;  					case TextDecorationEnum.LineThrough:  						maxX = width > 0? Math.Min(x + width' startX+textwidth): startX+textwidth;  						AddLine(startX' startY+(si.FontSize/2)+1' maxX' startY+(si.FontSize/2)+1' 1' si.Color' BorderStyleEnum.Solid);  						break;  					case TextDecorationEnum.Overline:  						maxX = width > 0? Math.Min(x + width' startX+textwidth): startX+textwidth;  						AddLine(startX' startY+1' maxX' startY+1' 1' si.Color' BorderStyleEnum.Solid);  						break;  					case TextDecorationEnum.None:  					default:  						break;  				}  			}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddText,The following statement contains a magic number: for (int i=0; i < sa.Length; i++)  			{  				string text = sa[i];  				float textwidth = tw[i];  				// Calculate the x position  				float startX = x + si.PaddingLeft;						// TODO: handle tb_rl  				float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl    				if (si.WritingMode == WritingModeEnum.lr_tb)  				{	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now  					switch(si.TextAlign)  					{  						case TextAlignEnum.Center:  							if (width > 0)  								startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight)/2 - textwidth/2;	   							break;  						case TextAlignEnum.Right:  							if (width > 0)  								startX = x + width - textwidth - si.PaddingRight;	  							break;  						case TextAlignEnum.Left:  						default:  							break;  					}    					// Calculate the y position  					switch(si.VerticalAlign)  					{  						case VerticalAlignEnum.Middle:  							if (height <= 0)  								break;    							// calculate the middle of the region  							startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom)/2 - si.FontSize/2;	   							// now go up or down depending on which line  							if (sa.Length == 1)  								break;  							if (sa.Length % 2 == 0)	// even number  							{  								startY = startY - ((sa.Length/2 - i) * si.FontSize) + si.FontSize/2;  							}  							else  							{  								startY = startY - ((sa.Length/2 - i) * si.FontSize);  							}  							break;  						case VerticalAlignEnum.Bottom:  							if (height <= 0)  								break;  							  							startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length-i));	  							break;  						case VerticalAlignEnum.Top:  						default:  							break;  					}  				}                  else                  {  					//25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                                           switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                     }    				// Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)  				if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)  				{	// background color' height and width are specified  					AddFillRect(x' y' width' height' si.BackgroundColor);  				}    				// Set the clipping path  				if (height > 0 && width > 0)  				{  					if (bNoClip)	// no clipping but we still want URL checking  						elements.Append("\r\nq\t");  					else  						elements.AppendFormat(NumberFormatInfo.InvariantInfo'  							"\r\nq\t{0} {1} {2} {3} re W n"'  							x' pSize.yHeight-y-height' width' height);  					if (url != null)  						p.AddHyperlink(x' pSize.yHeight-y' height' width' url);                      if (tooltip != null)                          p.AddToolTip(x' pSize.yHeight - y' height' width' tooltip);    				}  				else  					elements.Append("\r\nq\t");    				// Escape the text                  string newtext = PdfUtility.UTF16StringQuoter(text);                  //string newtext = text.Replace("\\"' "\\\\");                  //newtext = newtext.Replace("("' "\\(");                  //newtext = newtext.Replace(")"' "\\)");  				if (si.WritingMode == WritingModeEnum.lr_tb)  				{  					elements.AppendFormat(NumberFormatInfo.InvariantInfo'  						"\r\nBT/{0} {1} Tf\t{5} {6} {7} rg\t{2} {3} Td \t({4}) Tj\tET\tQ\t"'  						pdfFont'si.FontSize'startX'(pSize.yHeight-startY-si.FontSize)'newtext' r' g' b);  				}  				else  				{	// Rotate text -90 degrees=-.5 radians (this works for english don't know about true tb-rl language)  					//   had to play with reader to find best approximation for this rotation; didn't do what I expected  					//    see pdf spec section 4.2.2 pg 141  "Common Transformations"    					elements.AppendFormat(NumberFormatInfo.InvariantInfo'  						"\r\nBT/{0} {1} Tf\t{5} {6} {7} rg\t{8} {9} {10} {11} {2} {3} Tm \t({4}) Tj\tET\tQ\t"'  						pdfFont'si.FontSize'startX'(pSize.yHeight-startY)'newtext' r' g' b'  						radsCos' radsSin' -radsSin' radsCos);  				}    				// Handle underlining etc.  				float maxX;  				switch (si.TextDecoration)  				{  					case TextDecorationEnum.Underline:  						maxX = width > 0? Math.Min(x + width' startX+textwidth): startX+textwidth;  						AddLine(startX' startY+si.FontSize+1' maxX' startY+si.FontSize+1' 1' si.Color' BorderStyleEnum.Solid);  						break;  					case TextDecorationEnum.LineThrough:  						maxX = width > 0? Math.Min(x + width' startX+textwidth): startX+textwidth;  						AddLine(startX' startY+(si.FontSize/2)+1' maxX' startY+(si.FontSize/2)+1' 1' si.Color' BorderStyleEnum.Solid);  						break;  					case TextDecorationEnum.Overline:  						maxX = width > 0? Math.Min(x + width' startX+textwidth): startX+textwidth;  						AddLine(startX' startY+1' maxX' startY+1' 1' si.Color' BorderStyleEnum.Solid);  						break;  					case TextDecorationEnum.None:  					default:  						break;  				}  			}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddText,The following statement contains a magic number: for (int i=0; i < sa.Length; i++)  			{  				string text = sa[i];  				float textwidth = tw[i];  				// Calculate the x position  				float startX = x + si.PaddingLeft;						// TODO: handle tb_rl  				float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl    				if (si.WritingMode == WritingModeEnum.lr_tb)  				{	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now  					switch(si.TextAlign)  					{  						case TextAlignEnum.Center:  							if (width > 0)  								startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight)/2 - textwidth/2;	   							break;  						case TextAlignEnum.Right:  							if (width > 0)  								startX = x + width - textwidth - si.PaddingRight;	  							break;  						case TextAlignEnum.Left:  						default:  							break;  					}    					// Calculate the y position  					switch(si.VerticalAlign)  					{  						case VerticalAlignEnum.Middle:  							if (height <= 0)  								break;    							// calculate the middle of the region  							startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom)/2 - si.FontSize/2;	   							// now go up or down depending on which line  							if (sa.Length == 1)  								break;  							if (sa.Length % 2 == 0)	// even number  							{  								startY = startY - ((sa.Length/2 - i) * si.FontSize) + si.FontSize/2;  							}  							else  							{  								startY = startY - ((sa.Length/2 - i) * si.FontSize);  							}  							break;  						case VerticalAlignEnum.Bottom:  							if (height <= 0)  								break;  							  							startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length-i));	  							break;  						case VerticalAlignEnum.Top:  						default:  							break;  					}  				}                  else                  {  					//25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                                           switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                     }    				// Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)  				if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)  				{	// background color' height and width are specified  					AddFillRect(x' y' width' height' si.BackgroundColor);  				}    				// Set the clipping path  				if (height > 0 && width > 0)  				{  					if (bNoClip)	// no clipping but we still want URL checking  						elements.Append("\r\nq\t");  					else  						elements.AppendFormat(NumberFormatInfo.InvariantInfo'  							"\r\nq\t{0} {1} {2} {3} re W n"'  							x' pSize.yHeight-y-height' width' height);  					if (url != null)  						p.AddHyperlink(x' pSize.yHeight-y' height' width' url);                      if (tooltip != null)                          p.AddToolTip(x' pSize.yHeight - y' height' width' tooltip);    				}  				else  					elements.Append("\r\nq\t");    				// Escape the text                  string newtext = PdfUtility.UTF16StringQuoter(text);                  //string newtext = text.Replace("\\"' "\\\\");                  //newtext = newtext.Replace("("' "\\(");                  //newtext = newtext.Replace(")"' "\\)");  				if (si.WritingMode == WritingModeEnum.lr_tb)  				{  					elements.AppendFormat(NumberFormatInfo.InvariantInfo'  						"\r\nBT/{0} {1} Tf\t{5} {6} {7} rg\t{2} {3} Td \t({4}) Tj\tET\tQ\t"'  						pdfFont'si.FontSize'startX'(pSize.yHeight-startY-si.FontSize)'newtext' r' g' b);  				}  				else  				{	// Rotate text -90 degrees=-.5 radians (this works for english don't know about true tb-rl language)  					//   had to play with reader to find best approximation for this rotation; didn't do what I expected  					//    see pdf spec section 4.2.2 pg 141  "Common Transformations"    					elements.AppendFormat(NumberFormatInfo.InvariantInfo'  						"\r\nBT/{0} {1} Tf\t{5} {6} {7} rg\t{8} {9} {10} {11} {2} {3} Tm \t({4}) Tj\tET\tQ\t"'  						pdfFont'si.FontSize'startX'(pSize.yHeight-startY)'newtext' r' g' b'  						radsCos' radsSin' -radsSin' radsCos);  				}    				// Handle underlining etc.  				float maxX;  				switch (si.TextDecoration)  				{  					case TextDecorationEnum.Underline:  						maxX = width > 0? Math.Min(x + width' startX+textwidth): startX+textwidth;  						AddLine(startX' startY+si.FontSize+1' maxX' startY+si.FontSize+1' 1' si.Color' BorderStyleEnum.Solid);  						break;  					case TextDecorationEnum.LineThrough:  						maxX = width > 0? Math.Min(x + width' startX+textwidth): startX+textwidth;  						AddLine(startX' startY+(si.FontSize/2)+1' maxX' startY+(si.FontSize/2)+1' 1' si.Color' BorderStyleEnum.Solid);  						break;  					case TextDecorationEnum.Overline:  						maxX = width > 0? Math.Min(x + width' startX+textwidth): startX+textwidth;  						AddLine(startX' startY+1' maxX' startY+1' 1' si.Color' BorderStyleEnum.Solid);  						break;  					case TextDecorationEnum.None:  					default:  						break;  				}  			}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddText,The following statement contains a magic number: for (int i=0; i < sa.Length; i++)  			{  				string text = sa[i];  				float textwidth = tw[i];  				// Calculate the x position  				float startX = x + si.PaddingLeft;						// TODO: handle tb_rl  				float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl    				if (si.WritingMode == WritingModeEnum.lr_tb)  				{	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now  					switch(si.TextAlign)  					{  						case TextAlignEnum.Center:  							if (width > 0)  								startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight)/2 - textwidth/2;	   							break;  						case TextAlignEnum.Right:  							if (width > 0)  								startX = x + width - textwidth - si.PaddingRight;	  							break;  						case TextAlignEnum.Left:  						default:  							break;  					}    					// Calculate the y position  					switch(si.VerticalAlign)  					{  						case VerticalAlignEnum.Middle:  							if (height <= 0)  								break;    							// calculate the middle of the region  							startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom)/2 - si.FontSize/2;	   							// now go up or down depending on which line  							if (sa.Length == 1)  								break;  							if (sa.Length % 2 == 0)	// even number  							{  								startY = startY - ((sa.Length/2 - i) * si.FontSize) + si.FontSize/2;  							}  							else  							{  								startY = startY - ((sa.Length/2 - i) * si.FontSize);  							}  							break;  						case VerticalAlignEnum.Bottom:  							if (height <= 0)  								break;  							  							startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length-i));	  							break;  						case VerticalAlignEnum.Top:  						default:  							break;  					}  				}                  else                  {  					//25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                                           switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                     }    				// Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)  				if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)  				{	// background color' height and width are specified  					AddFillRect(x' y' width' height' si.BackgroundColor);  				}    				// Set the clipping path  				if (height > 0 && width > 0)  				{  					if (bNoClip)	// no clipping but we still want URL checking  						elements.Append("\r\nq\t");  					else  						elements.AppendFormat(NumberFormatInfo.InvariantInfo'  							"\r\nq\t{0} {1} {2} {3} re W n"'  							x' pSize.yHeight-y-height' width' height);  					if (url != null)  						p.AddHyperlink(x' pSize.yHeight-y' height' width' url);                      if (tooltip != null)                          p.AddToolTip(x' pSize.yHeight - y' height' width' tooltip);    				}  				else  					elements.Append("\r\nq\t");    				// Escape the text                  string newtext = PdfUtility.UTF16StringQuoter(text);                  //string newtext = text.Replace("\\"' "\\\\");                  //newtext = newtext.Replace("("' "\\(");                  //newtext = newtext.Replace(")"' "\\)");  				if (si.WritingMode == WritingModeEnum.lr_tb)  				{  					elements.AppendFormat(NumberFormatInfo.InvariantInfo'  						"\r\nBT/{0} {1} Tf\t{5} {6} {7} rg\t{2} {3} Td \t({4}) Tj\tET\tQ\t"'  						pdfFont'si.FontSize'startX'(pSize.yHeight-startY-si.FontSize)'newtext' r' g' b);  				}  				else  				{	// Rotate text -90 degrees=-.5 radians (this works for english don't know about true tb-rl language)  					//   had to play with reader to find best approximation for this rotation; didn't do what I expected  					//    see pdf spec section 4.2.2 pg 141  "Common Transformations"    					elements.AppendFormat(NumberFormatInfo.InvariantInfo'  						"\r\nBT/{0} {1} Tf\t{5} {6} {7} rg\t{8} {9} {10} {11} {2} {3} Tm \t({4}) Tj\tET\tQ\t"'  						pdfFont'si.FontSize'startX'(pSize.yHeight-startY)'newtext' r' g' b'  						radsCos' radsSin' -radsSin' radsCos);  				}    				// Handle underlining etc.  				float maxX;  				switch (si.TextDecoration)  				{  					case TextDecorationEnum.Underline:  						maxX = width > 0? Math.Min(x + width' startX+textwidth): startX+textwidth;  						AddLine(startX' startY+si.FontSize+1' maxX' startY+si.FontSize+1' 1' si.Color' BorderStyleEnum.Solid);  						break;  					case TextDecorationEnum.LineThrough:  						maxX = width > 0? Math.Min(x + width' startX+textwidth): startX+textwidth;  						AddLine(startX' startY+(si.FontSize/2)+1' maxX' startY+(si.FontSize/2)+1' 1' si.Color' BorderStyleEnum.Solid);  						break;  					case TextDecorationEnum.Overline:  						maxX = width > 0? Math.Min(x + width' startX+textwidth): startX+textwidth;  						AddLine(startX' startY+1' maxX' startY+1' 1' si.Color' BorderStyleEnum.Solid);  						break;  					case TextDecorationEnum.None:  					default:  						break;  				}  			}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddText,The following statement contains a magic number: for (int i=0; i < sa.Length; i++)  			{  				string text = sa[i];  				float textwidth = tw[i];  				// Calculate the x position  				float startX = x + si.PaddingLeft;						// TODO: handle tb_rl  				float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl    				if (si.WritingMode == WritingModeEnum.lr_tb)  				{	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now  					switch(si.TextAlign)  					{  						case TextAlignEnum.Center:  							if (width > 0)  								startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight)/2 - textwidth/2;	   							break;  						case TextAlignEnum.Right:  							if (width > 0)  								startX = x + width - textwidth - si.PaddingRight;	  							break;  						case TextAlignEnum.Left:  						default:  							break;  					}    					// Calculate the y position  					switch(si.VerticalAlign)  					{  						case VerticalAlignEnum.Middle:  							if (height <= 0)  								break;    							// calculate the middle of the region  							startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom)/2 - si.FontSize/2;	   							// now go up or down depending on which line  							if (sa.Length == 1)  								break;  							if (sa.Length % 2 == 0)	// even number  							{  								startY = startY - ((sa.Length/2 - i) * si.FontSize) + si.FontSize/2;  							}  							else  							{  								startY = startY - ((sa.Length/2 - i) * si.FontSize);  							}  							break;  						case VerticalAlignEnum.Bottom:  							if (height <= 0)  								break;  							  							startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length-i));	  							break;  						case VerticalAlignEnum.Top:  						default:  							break;  					}  				}                  else                  {  					//25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                                           switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                     }    				// Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)  				if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)  				{	// background color' height and width are specified  					AddFillRect(x' y' width' height' si.BackgroundColor);  				}    				// Set the clipping path  				if (height > 0 && width > 0)  				{  					if (bNoClip)	// no clipping but we still want URL checking  						elements.Append("\r\nq\t");  					else  						elements.AppendFormat(NumberFormatInfo.InvariantInfo'  							"\r\nq\t{0} {1} {2} {3} re W n"'  							x' pSize.yHeight-y-height' width' height);  					if (url != null)  						p.AddHyperlink(x' pSize.yHeight-y' height' width' url);                      if (tooltip != null)                          p.AddToolTip(x' pSize.yHeight - y' height' width' tooltip);    				}  				else  					elements.Append("\r\nq\t");    				// Escape the text                  string newtext = PdfUtility.UTF16StringQuoter(text);                  //string newtext = text.Replace("\\"' "\\\\");                  //newtext = newtext.Replace("("' "\\(");                  //newtext = newtext.Replace(")"' "\\)");  				if (si.WritingMode == WritingModeEnum.lr_tb)  				{  					elements.AppendFormat(NumberFormatInfo.InvariantInfo'  						"\r\nBT/{0} {1} Tf\t{5} {6} {7} rg\t{2} {3} Td \t({4}) Tj\tET\tQ\t"'  						pdfFont'si.FontSize'startX'(pSize.yHeight-startY-si.FontSize)'newtext' r' g' b);  				}  				else  				{	// Rotate text -90 degrees=-.5 radians (this works for english don't know about true tb-rl language)  					//   had to play with reader to find best approximation for this rotation; didn't do what I expected  					//    see pdf spec section 4.2.2 pg 141  "Common Transformations"    					elements.AppendFormat(NumberFormatInfo.InvariantInfo'  						"\r\nBT/{0} {1} Tf\t{5} {6} {7} rg\t{8} {9} {10} {11} {2} {3} Tm \t({4}) Tj\tET\tQ\t"'  						pdfFont'si.FontSize'startX'(pSize.yHeight-startY)'newtext' r' g' b'  						radsCos' radsSin' -radsSin' radsCos);  				}    				// Handle underlining etc.  				float maxX;  				switch (si.TextDecoration)  				{  					case TextDecorationEnum.Underline:  						maxX = width > 0? Math.Min(x + width' startX+textwidth): startX+textwidth;  						AddLine(startX' startY+si.FontSize+1' maxX' startY+si.FontSize+1' 1' si.Color' BorderStyleEnum.Solid);  						break;  					case TextDecorationEnum.LineThrough:  						maxX = width > 0? Math.Min(x + width' startX+textwidth): startX+textwidth;  						AddLine(startX' startY+(si.FontSize/2)+1' maxX' startY+(si.FontSize/2)+1' 1' si.Color' BorderStyleEnum.Solid);  						break;  					case TextDecorationEnum.Overline:  						maxX = width > 0? Math.Min(x + width' startX+textwidth): startX+textwidth;  						AddLine(startX' startY+1' maxX' startY+1' 1' si.Color' BorderStyleEnum.Solid);  						break;  					case TextDecorationEnum.None:  					default:  						break;  				}  			}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddText,The following statement contains a magic number: for (int i=0; i < sa.Length; i++)  			{  				string text = sa[i];  				float textwidth = tw[i];  				// Calculate the x position  				float startX = x + si.PaddingLeft;						// TODO: handle tb_rl  				float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl    				if (si.WritingMode == WritingModeEnum.lr_tb)  				{	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now  					switch(si.TextAlign)  					{  						case TextAlignEnum.Center:  							if (width > 0)  								startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight)/2 - textwidth/2;	   							break;  						case TextAlignEnum.Right:  							if (width > 0)  								startX = x + width - textwidth - si.PaddingRight;	  							break;  						case TextAlignEnum.Left:  						default:  							break;  					}    					// Calculate the y position  					switch(si.VerticalAlign)  					{  						case VerticalAlignEnum.Middle:  							if (height <= 0)  								break;    							// calculate the middle of the region  							startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom)/2 - si.FontSize/2;	   							// now go up or down depending on which line  							if (sa.Length == 1)  								break;  							if (sa.Length % 2 == 0)	// even number  							{  								startY = startY - ((sa.Length/2 - i) * si.FontSize) + si.FontSize/2;  							}  							else  							{  								startY = startY - ((sa.Length/2 - i) * si.FontSize);  							}  							break;  						case VerticalAlignEnum.Bottom:  							if (height <= 0)  								break;  							  							startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length-i));	  							break;  						case VerticalAlignEnum.Top:  						default:  							break;  					}  				}                  else                  {  					//25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                                           switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                     }    				// Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)  				if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)  				{	// background color' height and width are specified  					AddFillRect(x' y' width' height' si.BackgroundColor);  				}    				// Set the clipping path  				if (height > 0 && width > 0)  				{  					if (bNoClip)	// no clipping but we still want URL checking  						elements.Append("\r\nq\t");  					else  						elements.AppendFormat(NumberFormatInfo.InvariantInfo'  							"\r\nq\t{0} {1} {2} {3} re W n"'  							x' pSize.yHeight-y-height' width' height);  					if (url != null)  						p.AddHyperlink(x' pSize.yHeight-y' height' width' url);                      if (tooltip != null)                          p.AddToolTip(x' pSize.yHeight - y' height' width' tooltip);    				}  				else  					elements.Append("\r\nq\t");    				// Escape the text                  string newtext = PdfUtility.UTF16StringQuoter(text);                  //string newtext = text.Replace("\\"' "\\\\");                  //newtext = newtext.Replace("("' "\\(");                  //newtext = newtext.Replace(")"' "\\)");  				if (si.WritingMode == WritingModeEnum.lr_tb)  				{  					elements.AppendFormat(NumberFormatInfo.InvariantInfo'  						"\r\nBT/{0} {1} Tf\t{5} {6} {7} rg\t{2} {3} Td \t({4}) Tj\tET\tQ\t"'  						pdfFont'si.FontSize'startX'(pSize.yHeight-startY-si.FontSize)'newtext' r' g' b);  				}  				else  				{	// Rotate text -90 degrees=-.5 radians (this works for english don't know about true tb-rl language)  					//   had to play with reader to find best approximation for this rotation; didn't do what I expected  					//    see pdf spec section 4.2.2 pg 141  "Common Transformations"    					elements.AppendFormat(NumberFormatInfo.InvariantInfo'  						"\r\nBT/{0} {1} Tf\t{5} {6} {7} rg\t{8} {9} {10} {11} {2} {3} Tm \t({4}) Tj\tET\tQ\t"'  						pdfFont'si.FontSize'startX'(pSize.yHeight-startY)'newtext' r' g' b'  						radsCos' radsSin' -radsSin' radsCos);  				}    				// Handle underlining etc.  				float maxX;  				switch (si.TextDecoration)  				{  					case TextDecorationEnum.Underline:  						maxX = width > 0? Math.Min(x + width' startX+textwidth): startX+textwidth;  						AddLine(startX' startY+si.FontSize+1' maxX' startY+si.FontSize+1' 1' si.Color' BorderStyleEnum.Solid);  						break;  					case TextDecorationEnum.LineThrough:  						maxX = width > 0? Math.Min(x + width' startX+textwidth): startX+textwidth;  						AddLine(startX' startY+(si.FontSize/2)+1' maxX' startY+(si.FontSize/2)+1' 1' si.Color' BorderStyleEnum.Solid);  						break;  					case TextDecorationEnum.Overline:  						maxX = width > 0? Math.Min(x + width' startX+textwidth): startX+textwidth;  						AddLine(startX' startY+1' maxX' startY+1' 1' si.Color' BorderStyleEnum.Solid);  						break;  					case TextDecorationEnum.None:  					default:  						break;  				}  			}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddText,The following statement contains a magic number: for (int i=0; i < sa.Length; i++)  			{  				string text = sa[i];  				float textwidth = tw[i];  				// Calculate the x position  				float startX = x + si.PaddingLeft;						// TODO: handle tb_rl  				float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl    				if (si.WritingMode == WritingModeEnum.lr_tb)  				{	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now  					switch(si.TextAlign)  					{  						case TextAlignEnum.Center:  							if (width > 0)  								startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight)/2 - textwidth/2;	   							break;  						case TextAlignEnum.Right:  							if (width > 0)  								startX = x + width - textwidth - si.PaddingRight;	  							break;  						case TextAlignEnum.Left:  						default:  							break;  					}    					// Calculate the y position  					switch(si.VerticalAlign)  					{  						case VerticalAlignEnum.Middle:  							if (height <= 0)  								break;    							// calculate the middle of the region  							startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom)/2 - si.FontSize/2;	   							// now go up or down depending on which line  							if (sa.Length == 1)  								break;  							if (sa.Length % 2 == 0)	// even number  							{  								startY = startY - ((sa.Length/2 - i) * si.FontSize) + si.FontSize/2;  							}  							else  							{  								startY = startY - ((sa.Length/2 - i) * si.FontSize);  							}  							break;  						case VerticalAlignEnum.Bottom:  							if (height <= 0)  								break;  							  							startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length-i));	  							break;  						case VerticalAlignEnum.Top:  						default:  							break;  					}  				}                  else                  {  					//25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                                           switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                     }    				// Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)  				if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)  				{	// background color' height and width are specified  					AddFillRect(x' y' width' height' si.BackgroundColor);  				}    				// Set the clipping path  				if (height > 0 && width > 0)  				{  					if (bNoClip)	// no clipping but we still want URL checking  						elements.Append("\r\nq\t");  					else  						elements.AppendFormat(NumberFormatInfo.InvariantInfo'  							"\r\nq\t{0} {1} {2} {3} re W n"'  							x' pSize.yHeight-y-height' width' height);  					if (url != null)  						p.AddHyperlink(x' pSize.yHeight-y' height' width' url);                      if (tooltip != null)                          p.AddToolTip(x' pSize.yHeight - y' height' width' tooltip);    				}  				else  					elements.Append("\r\nq\t");    				// Escape the text                  string newtext = PdfUtility.UTF16StringQuoter(text);                  //string newtext = text.Replace("\\"' "\\\\");                  //newtext = newtext.Replace("("' "\\(");                  //newtext = newtext.Replace(")"' "\\)");  				if (si.WritingMode == WritingModeEnum.lr_tb)  				{  					elements.AppendFormat(NumberFormatInfo.InvariantInfo'  						"\r\nBT/{0} {1} Tf\t{5} {6} {7} rg\t{2} {3} Td \t({4}) Tj\tET\tQ\t"'  						pdfFont'si.FontSize'startX'(pSize.yHeight-startY-si.FontSize)'newtext' r' g' b);  				}  				else  				{	// Rotate text -90 degrees=-.5 radians (this works for english don't know about true tb-rl language)  					//   had to play with reader to find best approximation for this rotation; didn't do what I expected  					//    see pdf spec section 4.2.2 pg 141  "Common Transformations"    					elements.AppendFormat(NumberFormatInfo.InvariantInfo'  						"\r\nBT/{0} {1} Tf\t{5} {6} {7} rg\t{8} {9} {10} {11} {2} {3} Tm \t({4}) Tj\tET\tQ\t"'  						pdfFont'si.FontSize'startX'(pSize.yHeight-startY)'newtext' r' g' b'  						radsCos' radsSin' -radsSin' radsCos);  				}    				// Handle underlining etc.  				float maxX;  				switch (si.TextDecoration)  				{  					case TextDecorationEnum.Underline:  						maxX = width > 0? Math.Min(x + width' startX+textwidth): startX+textwidth;  						AddLine(startX' startY+si.FontSize+1' maxX' startY+si.FontSize+1' 1' si.Color' BorderStyleEnum.Solid);  						break;  					case TextDecorationEnum.LineThrough:  						maxX = width > 0? Math.Min(x + width' startX+textwidth): startX+textwidth;  						AddLine(startX' startY+(si.FontSize/2)+1' maxX' startY+(si.FontSize/2)+1' 1' si.Color' BorderStyleEnum.Solid);  						break;  					case TextDecorationEnum.Overline:  						maxX = width > 0? Math.Min(x + width' startX+textwidth): startX+textwidth;  						AddLine(startX' startY+1' maxX' startY+1' 1' si.Color' BorderStyleEnum.Solid);  						break;  					case TextDecorationEnum.None:  					default:  						break;  				}  			}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddText,The following statement contains a magic number: for (int i=0; i < sa.Length; i++)  			{  				string text = sa[i];  				float textwidth = tw[i];  				// Calculate the x position  				float startX = x + si.PaddingLeft;						// TODO: handle tb_rl  				float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl    				if (si.WritingMode == WritingModeEnum.lr_tb)  				{	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now  					switch(si.TextAlign)  					{  						case TextAlignEnum.Center:  							if (width > 0)  								startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight)/2 - textwidth/2;	   							break;  						case TextAlignEnum.Right:  							if (width > 0)  								startX = x + width - textwidth - si.PaddingRight;	  							break;  						case TextAlignEnum.Left:  						default:  							break;  					}    					// Calculate the y position  					switch(si.VerticalAlign)  					{  						case VerticalAlignEnum.Middle:  							if (height <= 0)  								break;    							// calculate the middle of the region  							startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom)/2 - si.FontSize/2;	   							// now go up or down depending on which line  							if (sa.Length == 1)  								break;  							if (sa.Length % 2 == 0)	// even number  							{  								startY = startY - ((sa.Length/2 - i) * si.FontSize) + si.FontSize/2;  							}  							else  							{  								startY = startY - ((sa.Length/2 - i) * si.FontSize);  							}  							break;  						case VerticalAlignEnum.Bottom:  							if (height <= 0)  								break;  							  							startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length-i));	  							break;  						case VerticalAlignEnum.Top:  						default:  							break;  					}  				}                  else                  {  					//25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                                           switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                     }    				// Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)  				if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)  				{	// background color' height and width are specified  					AddFillRect(x' y' width' height' si.BackgroundColor);  				}    				// Set the clipping path  				if (height > 0 && width > 0)  				{  					if (bNoClip)	// no clipping but we still want URL checking  						elements.Append("\r\nq\t");  					else  						elements.AppendFormat(NumberFormatInfo.InvariantInfo'  							"\r\nq\t{0} {1} {2} {3} re W n"'  							x' pSize.yHeight-y-height' width' height);  					if (url != null)  						p.AddHyperlink(x' pSize.yHeight-y' height' width' url);                      if (tooltip != null)                          p.AddToolTip(x' pSize.yHeight - y' height' width' tooltip);    				}  				else  					elements.Append("\r\nq\t");    				// Escape the text                  string newtext = PdfUtility.UTF16StringQuoter(text);                  //string newtext = text.Replace("\\"' "\\\\");                  //newtext = newtext.Replace("("' "\\(");                  //newtext = newtext.Replace(")"' "\\)");  				if (si.WritingMode == WritingModeEnum.lr_tb)  				{  					elements.AppendFormat(NumberFormatInfo.InvariantInfo'  						"\r\nBT/{0} {1} Tf\t{5} {6} {7} rg\t{2} {3} Td \t({4}) Tj\tET\tQ\t"'  						pdfFont'si.FontSize'startX'(pSize.yHeight-startY-si.FontSize)'newtext' r' g' b);  				}  				else  				{	// Rotate text -90 degrees=-.5 radians (this works for english don't know about true tb-rl language)  					//   had to play with reader to find best approximation for this rotation; didn't do what I expected  					//    see pdf spec section 4.2.2 pg 141  "Common Transformations"    					elements.AppendFormat(NumberFormatInfo.InvariantInfo'  						"\r\nBT/{0} {1} Tf\t{5} {6} {7} rg\t{8} {9} {10} {11} {2} {3} Tm \t({4}) Tj\tET\tQ\t"'  						pdfFont'si.FontSize'startX'(pSize.yHeight-startY)'newtext' r' g' b'  						radsCos' radsSin' -radsSin' radsCos);  				}    				// Handle underlining etc.  				float maxX;  				switch (si.TextDecoration)  				{  					case TextDecorationEnum.Underline:  						maxX = width > 0? Math.Min(x + width' startX+textwidth): startX+textwidth;  						AddLine(startX' startY+si.FontSize+1' maxX' startY+si.FontSize+1' 1' si.Color' BorderStyleEnum.Solid);  						break;  					case TextDecorationEnum.LineThrough:  						maxX = width > 0? Math.Min(x + width' startX+textwidth): startX+textwidth;  						AddLine(startX' startY+(si.FontSize/2)+1' maxX' startY+(si.FontSize/2)+1' 1' si.Color' BorderStyleEnum.Solid);  						break;  					case TextDecorationEnum.Overline:  						maxX = width > 0? Math.Min(x + width' startX+textwidth): startX+textwidth;  						AddLine(startX' startY+1' maxX' startY+1' 1' si.Color' BorderStyleEnum.Solid);  						break;  					case TextDecorationEnum.None:  					default:  						break;  				}  			}
Magic Number,fyiReporting.RDL,PdfElements,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfElements.cs,AddText,The following statement contains a magic number: for (int i=0; i < sa.Length; i++)  			{  				string text = sa[i];  				float textwidth = tw[i];  				// Calculate the x position  				float startX = x + si.PaddingLeft;						// TODO: handle tb_rl  				float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl    				if (si.WritingMode == WritingModeEnum.lr_tb)  				{	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now  					switch(si.TextAlign)  					{  						case TextAlignEnum.Center:  							if (width > 0)  								startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight)/2 - textwidth/2;	   							break;  						case TextAlignEnum.Right:  							if (width > 0)  								startX = x + width - textwidth - si.PaddingRight;	  							break;  						case TextAlignEnum.Left:  						default:  							break;  					}    					// Calculate the y position  					switch(si.VerticalAlign)  					{  						case VerticalAlignEnum.Middle:  							if (height <= 0)  								break;    							// calculate the middle of the region  							startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom)/2 - si.FontSize/2;	   							// now go up or down depending on which line  							if (sa.Length == 1)  								break;  							if (sa.Length % 2 == 0)	// even number  							{  								startY = startY - ((sa.Length/2 - i) * si.FontSize) + si.FontSize/2;  							}  							else  							{  								startY = startY - ((sa.Length/2 - i) * si.FontSize);  							}  							break;  						case VerticalAlignEnum.Bottom:  							if (height <= 0)  								break;  							  							startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length-i));	  							break;  						case VerticalAlignEnum.Top:  						default:  							break;  					}  				}                  else                  {  					//25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                                           switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                     }    				// Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)  				if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)  				{	// background color' height and width are specified  					AddFillRect(x' y' width' height' si.BackgroundColor);  				}    				// Set the clipping path  				if (height > 0 && width > 0)  				{  					if (bNoClip)	// no clipping but we still want URL checking  						elements.Append("\r\nq\t");  					else  						elements.AppendFormat(NumberFormatInfo.InvariantInfo'  							"\r\nq\t{0} {1} {2} {3} re W n"'  							x' pSize.yHeight-y-height' width' height);  					if (url != null)  						p.AddHyperlink(x' pSize.yHeight-y' height' width' url);                      if (tooltip != null)                          p.AddToolTip(x' pSize.yHeight - y' height' width' tooltip);    				}  				else  					elements.Append("\r\nq\t");    				// Escape the text                  string newtext = PdfUtility.UTF16StringQuoter(text);                  //string newtext = text.Replace("\\"' "\\\\");                  //newtext = newtext.Replace("("' "\\(");                  //newtext = newtext.Replace(")"' "\\)");  				if (si.WritingMode == WritingModeEnum.lr_tb)  				{  					elements.AppendFormat(NumberFormatInfo.InvariantInfo'  						"\r\nBT/{0} {1} Tf\t{5} {6} {7} rg\t{2} {3} Td \t({4}) Tj\tET\tQ\t"'  						pdfFont'si.FontSize'startX'(pSize.yHeight-startY-si.FontSize)'newtext' r' g' b);  				}  				else  				{	// Rotate text -90 degrees=-.5 radians (this works for english don't know about true tb-rl language)  					//   had to play with reader to find best approximation for this rotation; didn't do what I expected  					//    see pdf spec section 4.2.2 pg 141  "Common Transformations"    					elements.AppendFormat(NumberFormatInfo.InvariantInfo'  						"\r\nBT/{0} {1} Tf\t{5} {6} {7} rg\t{8} {9} {10} {11} {2} {3} Tm \t({4}) Tj\tET\tQ\t"'  						pdfFont'si.FontSize'startX'(pSize.yHeight-startY)'newtext' r' g' b'  						radsCos' radsSin' -radsSin' radsCos);  				}    				// Handle underlining etc.  				float maxX;  				switch (si.TextDecoration)  				{  					case TextDecorationEnum.Underline:  						maxX = width > 0? Math.Min(x + width' startX+textwidth): startX+textwidth;  						AddLine(startX' startY+si.FontSize+1' maxX' startY+si.FontSize+1' 1' si.Color' BorderStyleEnum.Solid);  						break;  					case TextDecorationEnum.LineThrough:  						maxX = width > 0? Math.Min(x + width' startX+textwidth): startX+textwidth;  						AddLine(startX' startY+(si.FontSize/2)+1' maxX' startY+(si.FontSize/2)+1' 1' si.Color' BorderStyleEnum.Solid);  						break;  					case TextDecorationEnum.Overline:  						maxX = width > 0? Math.Min(x + width' startX+textwidth): startX+textwidth;  						AddLine(startX' startY+1' maxX' startY+1' 1' si.Color' BorderStyleEnum.Solid);  						break;  					case TextDecorationEnum.None:  					default:  						break;  				}  			}
Magic Number,fyiReporting.RDL,PdfImageEntry,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfImage.cs,PdfImageEntry,The following statement contains a magic number: if (imf == ImageFormat.Jpeg)              {                  filter = "/DCTDecode";                    switch (JpgParser.GetColorSpace(ref im))                  {                         case 0:                          colorSpace = "/DeviceRGB";                          break;                      case 1:                          colorSpace = "/DeviceGray";                          break;                      case 3:                          colorSpace = "/DeviceRGB";                          break;                      case 4:                          colorSpace = "/DeviceCMYK";                          break;                      default:                          colorSpace = "/DeviceRGB";                          break;                  }              }              else if (imf == ImageFormat.Png)    // TODO: this still doesn't work              {                  filter = "/FlateDecode /DecodeParms <</Predictor 15 /Colors 3 /BitsPerComponent 8 /Columns 80>>";                  colorSpace = "/DeviceRGB";              }              else if (imf == ImageFormat.Gif)    // TODO: this still doesn't work              {                  filter = "/LZWDecode";                  colorSpace = "/DeviceRGB";              }              else              {                  filter = "";                  colorSpace = "";              }
Magic Number,fyiReporting.RDL,PdfImageEntry,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfImage.cs,PdfImageEntry,The following statement contains a magic number: if (imf == ImageFormat.Jpeg)              {                  filter = "/DCTDecode";                    switch (JpgParser.GetColorSpace(ref im))                  {                         case 0:                          colorSpace = "/DeviceRGB";                          break;                      case 1:                          colorSpace = "/DeviceGray";                          break;                      case 3:                          colorSpace = "/DeviceRGB";                          break;                      case 4:                          colorSpace = "/DeviceCMYK";                          break;                      default:                          colorSpace = "/DeviceRGB";                          break;                  }              }              else if (imf == ImageFormat.Png)    // TODO: this still doesn't work              {                  filter = "/FlateDecode /DecodeParms <</Predictor 15 /Colors 3 /BitsPerComponent 8 /Columns 80>>";                  colorSpace = "/DeviceRGB";              }              else if (imf == ImageFormat.Gif)    // TODO: this still doesn't work              {                  filter = "/LZWDecode";                  colorSpace = "/DeviceRGB";              }              else              {                  filter = "";                  colorSpace = "";              }
Magic Number,fyiReporting.RDL,JpgParser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfImage.cs,GetColorSpace,The following statement contains a magic number: try              {                  if (jpg[0] != 255 && jpg[1] != 216)                      //Not Jpeg                       return 0;                    int jpgLen = jpg.GetLength(0);                  for (int i = 2; i < jpgLen; i++)                  {                      if (i + 1 < jpgLen && jpg[i] == 0xff && jpg[i + 1] == 0xc0) //S0F0                       {                          return jpg[i + 9];                      }                  }              }              catch { return 0; }
Magic Number,fyiReporting.RDL,JpgParser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfImage.cs,GetColorSpace,The following statement contains a magic number: try              {                  if (jpg[0] != 255 && jpg[1] != 216)                      //Not Jpeg                       return 0;                    int jpgLen = jpg.GetLength(0);                  for (int i = 2; i < jpgLen; i++)                  {                      if (i + 1 < jpgLen && jpg[i] == 0xff && jpg[i + 1] == 0xc0) //S0F0                       {                          return jpg[i + 9];                      }                  }              }              catch { return 0; }
Magic Number,fyiReporting.RDL,JpgParser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfImage.cs,GetColorSpace,The following statement contains a magic number: try              {                  if (jpg[0] != 255 && jpg[1] != 216)                      //Not Jpeg                       return 0;                    int jpgLen = jpg.GetLength(0);                  for (int i = 2; i < jpgLen; i++)                  {                      if (i + 1 < jpgLen && jpg[i] == 0xff && jpg[i + 1] == 0xc0) //S0F0                       {                          return jpg[i + 9];                      }                  }              }              catch { return 0; }
Magic Number,fyiReporting.RDL,JpgParser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfImage.cs,GetColorSpace,The following statement contains a magic number: try              {                  if (jpg[0] != 255 && jpg[1] != 216)                      //Not Jpeg                       return 0;                    int jpgLen = jpg.GetLength(0);                  for (int i = 2; i < jpgLen; i++)                  {                      if (i + 1 < jpgLen && jpg[i] == 0xff && jpg[i + 1] == 0xc0) //S0F0                       {                          return jpg[i + 9];                      }                  }              }              catch { return 0; }
Magic Number,fyiReporting.RDL,PdfInfo,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfInfo.cs,GetDateTime,The following statement contains a magic number: pdfDate+=string.Format("{0}{1}'{2}'"'sign'uHour.ToString().PadLeft(2''0')'uMinute.ToString().PadLeft(2''0'));
Magic Number,fyiReporting.RDL,PdfInfo,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfInfo.cs,GetDateTime,The following statement contains a magic number: pdfDate+=string.Format("{0}{1}'{2}'"'sign'uHour.ToString().PadLeft(2''0')'uMinute.ToString().PadLeft(2''0'));
Magic Number,fyiReporting.RDL,PdfUtility,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfUtility.cs,CreateXrefTable,The following statement contains a magic number: try              {                  ObjectList objList = new ObjectList(0' fileOffset);                  pa.offsets.Add(objList);                  pa.offsets.Sort();                  numTableEntries = (int)pa.offsets.Count;                  table = string.Format("\r\nxref {0} {1}\r\n0000000000 65535 f\r\n"' 0' numTableEntries);                  for (int entries = 1; entries < numTableEntries; entries++)                  {                      ObjectList obj = pa.offsets[entries];                      table += obj.offset.ToString().PadLeft(10' '0');                      table += " 00000 n\r\n";                  }              }              catch (Exception e)              {                  Exception error = new Exception(e.Message + " In Utility.CreateXrefTable()");                  throw error;              }
Magic Number,fyiReporting.RDL,PdfUtility,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfUtility.cs,GetUTF8Bytes,The following statement contains a magic number: try              {                  //byte[] ubuf = Encoding.Unicode.GetBytes(str);                  //Encoding enc = Encoding.GetEncoding(1252);                  //byte[] abuf = Encoding.Convert(Encoding.Unicode' enc' ubuf);                    byte[] ubuf = Encoding.Unicode.GetBytes(str);                  Encoding enc = Encoding.GetEncoding(65001); // utf-8                  byte[] abuf = Encoding.Convert(Encoding.Unicode' enc' ubuf);                                    size = abuf.Length;                  return abuf;              }              catch (Exception e)              {                  Exception error = new Exception(e.Message + " In Utility.GetUTF8Bytes()");                  throw error;              }
Magic Number,fyiReporting.RDL,PdfUtility,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfUtility.cs,UTF16StringQuoter,The following statement contains a magic number: buffer = new StringBuilder((baseString.Length + 1) * 8);
Magic Number,fyiReporting.RDL,PdfUtility,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfUtility.cs,UTF16StringQuoter,The following statement contains a magic number: for (int i = 0; i < baseString.Length; i++)              {                  char character = baseString[i];                  if (character > 0x0000ffff)                  {                      // What can we do?! I haven't implemented handling for                      // Unicode characters greater than U+FFFF                      //System.err.println("Ack! The input string had a 4-byte "                      //+ "Unicode character in it!");                      buffer.Append("\\000 "); // Represent the char with a space                  }                  else                  {                      appendQuotedOctet(buffer' (byte)((character >> 8) & 0x00ff));                      appendQuotedOctet(buffer' (byte)(character & 0x00ff));                  }              }
Magic Number,fyiReporting.RDL,PdfUtility,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfUtility.cs,appendQuotedOctet,The following statement contains a magic number: if (octet == '\\' || octet == '(' || octet == ')')              {                  // PDF requires that we quote \' (' and ) characters with                  // a backslash.                  buffer.Append('\\');                  buffer.Append((char)octet);              }              else if (octet < ' ' || octet > '~')              {                  // Escape any other non-printable ASCII characters using                  // octal notation.                  //FIX                  if (octet != 172)                  {                      buffer.Append(escapeOctetOctal(octet));                  }                  else                  {                      buffer.Append("\\200");                  }                  //END FIX               }              else              {                  // Printable ASCII characters are inserted as literals.                  buffer.Append((char)octet);              }
Magic Number,fyiReporting.RDL,PdfUtility,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfUtility.cs,escapeOctetOctal,The following statement contains a magic number: return "\\"              + (char)(0x30 + ((octet >> 6) & 0x0003))              + (char)(0x30 + ((octet >> 3) & 0x0007))              + (char)(0x30 + (octet & 0x0007));
Magic Number,fyiReporting.RDL,PdfUtility,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfUtility.cs,escapeOctetOctal,The following statement contains a magic number: return "\\"              + (char)(0x30 + ((octet >> 6) & 0x0003))              + (char)(0x30 + ((octet >> 3) & 0x0007))              + (char)(0x30 + (octet & 0x0007));
Magic Number,fyiReporting.RDL,Ascii85Encode,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfUtility.cs,ToString,The following statement contains a magic number: pos = 2;
Magic Number,fyiReporting.RDL,Ascii85Encode,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfUtility.cs,ToString,The following statement contains a magic number: for (int i =0; i < bain.Length; i++)  			{  				b = bain[i];  				switch (count++)   				{  					case 0:	tuple |= ((uint)b << 24); break;  					case 1: tuple |= ((uint)b << 16); break;  					case 2:	tuple |= ((uint)b <<  8); break;  					case 3:  						tuple |= b;  						if (tuple == 0)   						{  							sw.Write('z');  							if (pos++ >= width)   							{  								pos = 0;  								sw.Write('\n');  							}  						}   						else  						{  							encode(tuple' count);  						}  						tuple = 0;  						count = 0;  						break;  				}  			}
Magic Number,fyiReporting.RDL,Ascii85Encode,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfUtility.cs,ToString,The following statement contains a magic number: for (int i =0; i < bain.Length; i++)  			{  				b = bain[i];  				switch (count++)   				{  					case 0:	tuple |= ((uint)b << 24); break;  					case 1: tuple |= ((uint)b << 16); break;  					case 2:	tuple |= ((uint)b <<  8); break;  					case 3:  						tuple |= b;  						if (tuple == 0)   						{  							sw.Write('z');  							if (pos++ >= width)   							{  								pos = 0;  								sw.Write('\n');  							}  						}   						else  						{  							encode(tuple' count);  						}  						tuple = 0;  						count = 0;  						break;  				}  			}
Magic Number,fyiReporting.RDL,Ascii85Encode,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfUtility.cs,ToString,The following statement contains a magic number: for (int i =0; i < bain.Length; i++)  			{  				b = bain[i];  				switch (count++)   				{  					case 0:	tuple |= ((uint)b << 24); break;  					case 1: tuple |= ((uint)b << 16); break;  					case 2:	tuple |= ((uint)b <<  8); break;  					case 3:  						tuple |= b;  						if (tuple == 0)   						{  							sw.Write('z');  							if (pos++ >= width)   							{  								pos = 0;  								sw.Write('\n');  							}  						}   						else  						{  							encode(tuple' count);  						}  						tuple = 0;  						count = 0;  						break;  				}  			}
Magic Number,fyiReporting.RDL,Ascii85Encode,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfUtility.cs,ToString,The following statement contains a magic number: for (int i =0; i < bain.Length; i++)  			{  				b = bain[i];  				switch (count++)   				{  					case 0:	tuple |= ((uint)b << 24); break;  					case 1: tuple |= ((uint)b << 16); break;  					case 2:	tuple |= ((uint)b <<  8); break;  					case 3:  						tuple |= b;  						if (tuple == 0)   						{  							sw.Write('z');  							if (pos++ >= width)   							{  								pos = 0;  								sw.Write('\n');  							}  						}   						else  						{  							encode(tuple' count);  						}  						tuple = 0;  						count = 0;  						break;  				}  			}
Magic Number,fyiReporting.RDL,Ascii85Encode,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfUtility.cs,ToString,The following statement contains a magic number: for (int i =0; i < bain.Length; i++)  			{  				b = bain[i];  				switch (count++)   				{  					case 0:	tuple |= ((uint)b << 24); break;  					case 1: tuple |= ((uint)b << 16); break;  					case 2:	tuple |= ((uint)b <<  8); break;  					case 3:  						tuple |= b;  						if (tuple == 0)   						{  							sw.Write('z');  							if (pos++ >= width)   							{  								pos = 0;  								sw.Write('\n');  							}  						}   						else  						{  							encode(tuple' count);  						}  						tuple = 0;  						count = 0;  						break;  				}  			}
Magic Number,fyiReporting.RDL,Ascii85Encode,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfUtility.cs,ToString,The following statement contains a magic number: if (pos + 2 > width)  				sw.Write('\n');
Magic Number,fyiReporting.RDL,Ascii85Encode,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfUtility.cs,encode,The following statement contains a magic number: char[] buf = new char[5];
Magic Number,fyiReporting.RDL,Ascii85Encode,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfUtility.cs,encode,The following statement contains a magic number: j = 5;
Magic Number,fyiReporting.RDL,Ascii85Encode,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfUtility.cs,encode,The following statement contains a magic number: do   			{  				buf[s++] = (char) (tuple % 85);  				tuple /= 85;  			} while (--j > 0);
Magic Number,fyiReporting.RDL,Ascii85Encode,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfUtility.cs,encode,The following statement contains a magic number: do   			{  				buf[s++] = (char) (tuple % 85);  				tuple /= 85;  			} while (--j > 0);
Magic Number,fyiReporting.RDL,AsciiHexEncode,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfUtility.cs,ToString,The following statement contains a magic number: for (int i =0; i < bain.Length; i++)  			{  				if (pos >= width)  				{  					sw.Write('\n');  					pos = 0;  				}    				string t = Convert.ToString(bain[i]' 16);  				if (t.Length == 1)  					t = "0" + t;  				sw.Write(t);  				pos += 2;  			}
Magic Number,fyiReporting.RDL,AsciiHexEncode,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfUtility.cs,ToString,The following statement contains a magic number: for (int i =0; i < bain.Length; i++)  			{  				if (pos >= width)  				{  					sw.Write('\n');  					pos = 0;  				}    				string t = Convert.ToString(bain[i]' 16);  				if (t.Length == 1)  					t = "0" + t;  				sw.Write(t);  				pos += 2;  			}
Magic Number,fyiReporting.RDL,ProcessReport,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ProcessReport.cs,ProcessReport,The following statement contains a magic number: if (rep.rl.MaxSeverity > 4)  				throw new Exception(Strings.ProcessReport_Error_ReportHasErrors);
Magic Number,fyiReporting.RDL,ProcessReport,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\ProcessReport.cs,ProcessReport,The following statement contains a magic number: if (rep.rl.MaxSeverity > 4)  				throw new Exception(Strings.ProcessReport_Error_ReportHasErrors);
Magic Number,fyiReporting.RDL,RenderHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderHtml.cs,Image,The following statement contains a magic number: try  			{     				if (ioin.CanSeek)		// ioin.Length requires Seek support  				{  					byte[] ba = new byte[ioin.Length];  					ioin.Read(ba' 0' ba.Length);  					io.Write(ba' 0' ba.Length);  				}  				else  				{  					byte[] ba = new byte[1000];		// read a 1000 bytes at a time  					while (true)  					{  						int length = ioin.Read(ba' 0' ba.Length);  						if (length <= 0)  							break;  						io.Write(ba' 0' length);  					}  				}  			}  			finally  			{  				io.Flush();  				io.Close();  			}
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddLine,The following statement contains a magic number: switch (ls)              {                  case BorderStyleEnum.Dashed:                      cb.SetLineDash(new float[] { width*3' width  }' 0);                      break;                  case BorderStyleEnum.Dotted:                      cb.SetLineDash(new float[] { width }'0);                      break;                  case BorderStyleEnum.Solid:                  default:                      cb.SetLineDash(new float[] { }' 0);                      break;              }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddFillRect,The following statement contains a magic number: if (si.PatternType != patternTypeEnum.None)              {                  string p = patterns.GetPdfPattern(si.PatternType.ToString());                  c = si.Color;                  double red = Math.Round((c.R / 255.0)' 3);                  double green = Math.Round((c.G / 255.0)' 3);                  double blue = Math.Round((c.B / 255.0)' 3);                  StringBuilder elements = new StringBuilder();                  elements.AppendFormat("\r\nq");                  elements.AppendFormat("\r\n /CS1 cs");                  elements.AppendFormat("\r\n {0} {1} {2} /{3} scn"' red' green' blue' p);                  elements.AppendFormat("\r\n {0} {1} {2} RG"' red' green' blue);                  elements.AppendFormat("\r\n {0} {1} {2} {3} re\tf"' x' _pSize.yHeight - y - height' width' height);                  elements.AppendFormat("\tQ");                  PdfPatternPainter pdfp = cb.CreatePattern(60f' 60f' 60f' 60f);                  pdfp.SetLiteral(elements.ToString());                  cb.SetPatternFill(pdfp);              }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddFillRect,The following statement contains a magic number: if (si.PatternType != patternTypeEnum.None)              {                  string p = patterns.GetPdfPattern(si.PatternType.ToString());                  c = si.Color;                  double red = Math.Round((c.R / 255.0)' 3);                  double green = Math.Round((c.G / 255.0)' 3);                  double blue = Math.Round((c.B / 255.0)' 3);                  StringBuilder elements = new StringBuilder();                  elements.AppendFormat("\r\nq");                  elements.AppendFormat("\r\n /CS1 cs");                  elements.AppendFormat("\r\n {0} {1} {2} /{3} scn"' red' green' blue' p);                  elements.AppendFormat("\r\n {0} {1} {2} RG"' red' green' blue);                  elements.AppendFormat("\r\n {0} {1} {2} {3} re\tf"' x' _pSize.yHeight - y - height' width' height);                  elements.AppendFormat("\tQ");                  PdfPatternPainter pdfp = cb.CreatePattern(60f' 60f' 60f' 60f);                  pdfp.SetLiteral(elements.ToString());                  cb.SetPatternFill(pdfp);              }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddFillRect,The following statement contains a magic number: if (si.PatternType != patternTypeEnum.None)              {                  string p = patterns.GetPdfPattern(si.PatternType.ToString());                  c = si.Color;                  double red = Math.Round((c.R / 255.0)' 3);                  double green = Math.Round((c.G / 255.0)' 3);                  double blue = Math.Round((c.B / 255.0)' 3);                  StringBuilder elements = new StringBuilder();                  elements.AppendFormat("\r\nq");                  elements.AppendFormat("\r\n /CS1 cs");                  elements.AppendFormat("\r\n {0} {1} {2} /{3} scn"' red' green' blue' p);                  elements.AppendFormat("\r\n {0} {1} {2} RG"' red' green' blue);                  elements.AppendFormat("\r\n {0} {1} {2} {3} re\tf"' x' _pSize.yHeight - y - height' width' height);                  elements.AppendFormat("\tQ");                  PdfPatternPainter pdfp = cb.CreatePattern(60f' 60f' 60f' 60f);                  pdfp.SetLiteral(elements.ToString());                  cb.SetPatternFill(pdfp);              }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddFillRect,The following statement contains a magic number: if (si.PatternType != patternTypeEnum.None)              {                  string p = patterns.GetPdfPattern(si.PatternType.ToString());                  c = si.Color;                  double red = Math.Round((c.R / 255.0)' 3);                  double green = Math.Round((c.G / 255.0)' 3);                  double blue = Math.Round((c.B / 255.0)' 3);                  StringBuilder elements = new StringBuilder();                  elements.AppendFormat("\r\nq");                  elements.AppendFormat("\r\n /CS1 cs");                  elements.AppendFormat("\r\n {0} {1} {2} /{3} scn"' red' green' blue' p);                  elements.AppendFormat("\r\n {0} {1} {2} RG"' red' green' blue);                  elements.AppendFormat("\r\n {0} {1} {2} {3} re\tf"' x' _pSize.yHeight - y - height' width' height);                  elements.AppendFormat("\tQ");                  PdfPatternPainter pdfp = cb.CreatePattern(60f' 60f' 60f' 60f);                  pdfp.SetLiteral(elements.ToString());                  cb.SetPatternFill(pdfp);              }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddFillRect,The following statement contains a magic number: if (si.PatternType != patternTypeEnum.None)              {                  string p = patterns.GetPdfPattern(si.PatternType.ToString());                  c = si.Color;                  double red = Math.Round((c.R / 255.0)' 3);                  double green = Math.Round((c.G / 255.0)' 3);                  double blue = Math.Round((c.B / 255.0)' 3);                  StringBuilder elements = new StringBuilder();                  elements.AppendFormat("\r\nq");                  elements.AppendFormat("\r\n /CS1 cs");                  elements.AppendFormat("\r\n {0} {1} {2} /{3} scn"' red' green' blue' p);                  elements.AppendFormat("\r\n {0} {1} {2} RG"' red' green' blue);                  elements.AppendFormat("\r\n {0} {1} {2} {3} re\tf"' x' _pSize.yHeight - y - height' width' height);                  elements.AppendFormat("\tQ");                  PdfPatternPainter pdfp = cb.CreatePattern(60f' 60f' 60f' 60f);                  pdfp.SetLiteral(elements.ToString());                  cb.SetPatternFill(pdfp);              }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddFillRect,The following statement contains a magic number: if (si.PatternType != patternTypeEnum.None)              {                  string p = patterns.GetPdfPattern(si.PatternType.ToString());                  c = si.Color;                  double red = Math.Round((c.R / 255.0)' 3);                  double green = Math.Round((c.G / 255.0)' 3);                  double blue = Math.Round((c.B / 255.0)' 3);                  StringBuilder elements = new StringBuilder();                  elements.AppendFormat("\r\nq");                  elements.AppendFormat("\r\n /CS1 cs");                  elements.AppendFormat("\r\n {0} {1} {2} /{3} scn"' red' green' blue' p);                  elements.AppendFormat("\r\n {0} {1} {2} RG"' red' green' blue);                  elements.AppendFormat("\r\n {0} {1} {2} {3} re\tf"' x' _pSize.yHeight - y - height' width' height);                  elements.AppendFormat("\tQ");                  PdfPatternPainter pdfp = cb.CreatePattern(60f' 60f' 60f' 60f);                  pdfp.SetLiteral(elements.ToString());                  cb.SetPatternFill(pdfp);              }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddPolygon,The following statement contains a magic number: if (si.PatternType != patternTypeEnum.None)              {                  string p = patterns.GetPdfPattern(si.PatternType.ToString());                  StringBuilder elements = new StringBuilder();                  c = si.Color;                  double red = Math.Round((c.R / 255.0)' 3);                  double green = Math.Round((c.G / 255.0)' 3);                  double blue = Math.Round((c.B / 255.0)' 3);                  elements.AppendFormat("\r\nq");                  elements.AppendFormat("\r\n /CS1 cs");                  elements.AppendFormat("\r\n {0} {1} {2} /{3} scn"' red' green' blue' p);                  elements.AppendFormat("\r\n {0} {1} {2} RG"' red' green' blue);                  elements.AppendFormat("\tQ");                  PdfPatternPainter pdfp = cb.CreatePattern(60f' 60f' 60f' 60f);                  pdfp.SetLiteral(elements.ToString());                  cb.SetPatternFill(pdfp);                  iAddPoints(pts);                  cb.ClosePathFillStroke();              }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddPolygon,The following statement contains a magic number: if (si.PatternType != patternTypeEnum.None)              {                  string p = patterns.GetPdfPattern(si.PatternType.ToString());                  StringBuilder elements = new StringBuilder();                  c = si.Color;                  double red = Math.Round((c.R / 255.0)' 3);                  double green = Math.Round((c.G / 255.0)' 3);                  double blue = Math.Round((c.B / 255.0)' 3);                  elements.AppendFormat("\r\nq");                  elements.AppendFormat("\r\n /CS1 cs");                  elements.AppendFormat("\r\n {0} {1} {2} /{3} scn"' red' green' blue' p);                  elements.AppendFormat("\r\n {0} {1} {2} RG"' red' green' blue);                  elements.AppendFormat("\tQ");                  PdfPatternPainter pdfp = cb.CreatePattern(60f' 60f' 60f' 60f);                  pdfp.SetLiteral(elements.ToString());                  cb.SetPatternFill(pdfp);                  iAddPoints(pts);                  cb.ClosePathFillStroke();              }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddPolygon,The following statement contains a magic number: if (si.PatternType != patternTypeEnum.None)              {                  string p = patterns.GetPdfPattern(si.PatternType.ToString());                  StringBuilder elements = new StringBuilder();                  c = si.Color;                  double red = Math.Round((c.R / 255.0)' 3);                  double green = Math.Round((c.G / 255.0)' 3);                  double blue = Math.Round((c.B / 255.0)' 3);                  elements.AppendFormat("\r\nq");                  elements.AppendFormat("\r\n /CS1 cs");                  elements.AppendFormat("\r\n {0} {1} {2} /{3} scn"' red' green' blue' p);                  elements.AppendFormat("\r\n {0} {1} {2} RG"' red' green' blue);                  elements.AppendFormat("\tQ");                  PdfPatternPainter pdfp = cb.CreatePattern(60f' 60f' 60f' 60f);                  pdfp.SetLiteral(elements.ToString());                  cb.SetPatternFill(pdfp);                  iAddPoints(pts);                  cb.ClosePathFillStroke();              }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddPolygon,The following statement contains a magic number: if (si.PatternType != patternTypeEnum.None)              {                  string p = patterns.GetPdfPattern(si.PatternType.ToString());                  StringBuilder elements = new StringBuilder();                  c = si.Color;                  double red = Math.Round((c.R / 255.0)' 3);                  double green = Math.Round((c.G / 255.0)' 3);                  double blue = Math.Round((c.B / 255.0)' 3);                  elements.AppendFormat("\r\nq");                  elements.AppendFormat("\r\n /CS1 cs");                  elements.AppendFormat("\r\n {0} {1} {2} /{3} scn"' red' green' blue' p);                  elements.AppendFormat("\r\n {0} {1} {2} RG"' red' green' blue);                  elements.AppendFormat("\tQ");                  PdfPatternPainter pdfp = cb.CreatePattern(60f' 60f' 60f' 60f);                  pdfp.SetLiteral(elements.ToString());                  cb.SetPatternFill(pdfp);                  iAddPoints(pts);                  cb.ClosePathFillStroke();              }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddPolygon,The following statement contains a magic number: if (si.PatternType != patternTypeEnum.None)              {                  string p = patterns.GetPdfPattern(si.PatternType.ToString());                  StringBuilder elements = new StringBuilder();                  c = si.Color;                  double red = Math.Round((c.R / 255.0)' 3);                  double green = Math.Round((c.G / 255.0)' 3);                  double blue = Math.Round((c.B / 255.0)' 3);                  elements.AppendFormat("\r\nq");                  elements.AppendFormat("\r\n /CS1 cs");                  elements.AppendFormat("\r\n {0} {1} {2} /{3} scn"' red' green' blue' p);                  elements.AppendFormat("\r\n {0} {1} {2} RG"' red' green' blue);                  elements.AppendFormat("\tQ");                  PdfPatternPainter pdfp = cb.CreatePattern(60f' 60f' 60f' 60f);                  pdfp.SetLiteral(elements.ToString());                  cb.SetPatternFill(pdfp);                  iAddPoints(pts);                  cb.ClosePathFillStroke();              }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddPolygon,The following statement contains a magic number: if (si.PatternType != patternTypeEnum.None)              {                  string p = patterns.GetPdfPattern(si.PatternType.ToString());                  StringBuilder elements = new StringBuilder();                  c = si.Color;                  double red = Math.Round((c.R / 255.0)' 3);                  double green = Math.Round((c.G / 255.0)' 3);                  double blue = Math.Round((c.B / 255.0)' 3);                  elements.AppendFormat("\r\nq");                  elements.AppendFormat("\r\n /CS1 cs");                  elements.AppendFormat("\r\n {0} {1} {2} /{3} scn"' red' green' blue' p);                  elements.AppendFormat("\r\n {0} {1} {2} RG"' red' green' blue);                  elements.AppendFormat("\tQ");                  PdfPatternPainter pdfp = cb.CreatePattern(60f' 60f' 60f' 60f);                  pdfp.SetLiteral(elements.ToString());                  cb.SetPatternFill(pdfp);                  iAddPoints(pts);                  cb.ClosePathFillStroke();              }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddCurve,The following statement contains a magic number: if (pts.Length > 2)              {   // do a spline curve                  PointF[] tangents = iGetCurveTangents(pts);                  iDoCurve(pts' tangents' si);              }              else              {   // we only have two points; just do a line segment                  iAddLine(pts[0].X' pts[0].Y' pts[1].X' pts[1].Y' si);              }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iGetCurveTangents,The following statement contains a magic number: if (tangents.Length <= 2)                  return tangents;
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: if (face == "Times-Roman") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldItalicMT";  						fontname = "Times New Roman Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold Italic" : "Times-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-BoldItalic.ttf" : "timesbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-BoldMT";  						fontname = "Times New Roman Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Bold" : "Times-Bold";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Bold.ttf" : "timesbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPS-ItalicMT";  						fontname = "Times New Roman Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed Italic" : "Times-Italic";  						fontname = (dejavuFonts ? "DejaVuSerifCondensed-Italic.ttf" : "timesi.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "TimesNewRomanPSMT";  						fontname = "Times New Roman.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Serif Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSerifCondensed.ttf" : "times.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Arial") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial BoldItalicMT";  						fontname = "Arial Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold Oblique" : "Arial-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-BoldOblique.ttf" : "arialbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-BoldMT";  						fontname = "Arial Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Bold" : "Arial-Bold";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Bold.ttf" : "arialbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "Arial-ItalicMT";  						fontname = "Arial Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed Oblique" : "Arial-Italic";  						fontname = (dejavuFonts ? "DejaVuSansCondensed-Oblique.ttf" : "ariali.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "ArialMT";  						fontname = "Arial.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Condensed" : face;  						fontname = (dejavuFonts ? "DejaVuSansCondensed.ttf" : "arial.ttf");  					}  				}  				fonttype1 = false;  			} else if (face == "Courier New") {  				if (si.IsFontBold () && si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldItalicMT";  						fontname = "Courier New Bold Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold Oblique" : "Courier New-BoldItalic";  						fontname = (dejavuFonts ? "DejaVuSansMono-BoldOblique.ttf" : "courbi.ttf");  					}  				} else if (si.IsFontBold ()) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-BoldMT";  						fontname = "Courier New Bold.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Bold" : "Courier New-Bold";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "courbd.ttf");  					}  				} else if (si.FontStyle == FontStyleEnum.Italic) {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPS-ItalicMT";  						fontname = "Courier New Italic.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono Oblique" : "Courier New-Italic";  						fontname = (dejavuFonts ? "DejaVuSansMono-Oblique.ttf" : "couri.ttf");  					}  				} else {  					//OSX  					if ((platform == 4 || platform == 6 || platform == 128) && version > 8) {  						face = "CourierNewPSMT";  						fontname = "Courier New.ttf";  					} else {  						face = dejavuFonts ? "DejaVu Sans Mono" : face;  						fontname = (dejavuFonts ? "DejaVuSansMono.ttf" : "cour.ttf");  					}  				}  				fonttype1 = false;  			} else {                          if (si.IsFontBold() &&                      si.FontStyle == FontStyleEnum.Italic)   // bold and italic?                              face = face + "-BoldOblique";                          else if (si.IsFontBold())           // just bold?                              face = face + "-Bold";                          else if (si.FontStyle == FontStyleEnum.Italic)                              face = face + "-Oblique";                          fonttype1 = true;                      }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: for (int i = 0; i < sa.Length; i++)              {                  string text = sa[i];                  float textwidth = tw[i];                  // Calculate the x positino                  float startX = x + si.PaddingLeft;						// TODO: handle tb_rl                  float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl                  int align = 0;                  if (si.WritingMode == WritingModeEnum.lr_tb)                  {	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now                      switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (width > 0)                              {                                  startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                                  align = Element.ALIGN_CENTER;                              }                              break;                          case TextAlignEnum.Right:                              if (width > 0)                              {                                  startX = x + width - textwidth - si.PaddingRight;                                  align = Element.ALIGN_RIGHT;                              }                              break;                          case TextAlignEnum.Left:                          default:                              align = Element.ALIGN_LEFT;                              break;                      }                        // Calculate the y position                      switch (si.VerticalAlign)                      {                          case VerticalAlignEnum.Middle:                              if (height <= 0)                                  break;                                // calculate the middle of the region                              startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom) / 2 - si.FontSize / 2;                              // now go up or down depending on which line                              if (sa.Length == 1)                                  break;                              if (sa.Length % 2 == 0)	// even number                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize) + si.FontSize / 2;                              }                              else                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize);                              }                              break;                          case VerticalAlignEnum.Bottom:                              if (height <= 0)                                  break;                                startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length - i));                              break;                          case VerticalAlignEnum.Top:                          default:                              break;                      }                  }                  else                  {                      //25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                        switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                    }                    // Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)                  if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)                  {	// background color' height and width are specified                      iAddFillRect(x' y' width' height' si.BackgroundColor);                  }                    // Set the clipping path' (Itext have no clip)                  if (height > 0 && width > 0)                  {                      cb.SetRGBColorFill(si.Color.R' si.Color.G' si.Color.B);                        if (si.WritingMode == WritingModeEnum.lr_tb)                      {                          //If textline after measure with word break can fit just simple show Text                          if (width >= textwidth)                          {                              cb.BeginText();                              cb.SetFontAndSize(bf' si.FontSize);                              cb.SetTextMatrix(startX' (_pSize.yHeight - startY - si.FontSize));                              cb.ShowText(text);                              cb.EndText();                          }                          else                          {                              //else use Column text to wrap or clip (wrap: for example a text like an URL so word break is not working here' itextsharp ColumnText do the work for us)                              ColumnText ct = new ColumnText(cb);                              Phrase myPhrase = new Phrase(text' new iTextSharp.text.Font(bf' si.FontSize));                              ct.SetSimpleColumn(myPhrase' x + si.PaddingLeft' _pSize.yHeight - startY' x + width - si.PaddingRight' _pSize.yHeight - y - si.PaddingBottom - height' 10f' align);                              ct.Go();                          }                      }                      else                      {                          //Not checked                          double rads = -283.0 / 180.0;                          double radsCos = Math.Cos(rads);                          double radsSin = Math.Sin(rads);                          cb.BeginText();                          cb.SetFontAndSize(bf' si.FontSize);                          cb.SetTextMatrix((float)radsCos' (float)radsSin' (float)-radsSin' (float)radsCos' startX' _pSize.yHeight - startY);                          cb.ShowText(text);                          cb.EndText();                      }                        //add URL                      if (url != null)  						pdfdocument.Add(new Annotation(x' _pSize.yHeight - (y + height)' width + x' _pSize.yHeight - y' url));                      //add tooltip                      if (tooltip != null)  						pdfdocument.Add(new Annotation(x' _pSize.yHeight - (y + height)' width + x' _pSize.yHeight - y' tooltip));                    }                    // Handle underlining etc.                  float maxX;                  switch (si.TextDecoration)                  {                      case TextDecorationEnum.Underline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + si.FontSize + 1' maxX' startY + si.FontSize + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.LineThrough:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + (si.FontSize / 2) + 1' maxX' startY + (si.FontSize / 2) + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.Overline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + 1' maxX' startY + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.None:                      default:                          break;                  }              }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: for (int i = 0; i < sa.Length; i++)              {                  string text = sa[i];                  float textwidth = tw[i];                  // Calculate the x positino                  float startX = x + si.PaddingLeft;						// TODO: handle tb_rl                  float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl                  int align = 0;                  if (si.WritingMode == WritingModeEnum.lr_tb)                  {	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now                      switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (width > 0)                              {                                  startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                                  align = Element.ALIGN_CENTER;                              }                              break;                          case TextAlignEnum.Right:                              if (width > 0)                              {                                  startX = x + width - textwidth - si.PaddingRight;                                  align = Element.ALIGN_RIGHT;                              }                              break;                          case TextAlignEnum.Left:                          default:                              align = Element.ALIGN_LEFT;                              break;                      }                        // Calculate the y position                      switch (si.VerticalAlign)                      {                          case VerticalAlignEnum.Middle:                              if (height <= 0)                                  break;                                // calculate the middle of the region                              startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom) / 2 - si.FontSize / 2;                              // now go up or down depending on which line                              if (sa.Length == 1)                                  break;                              if (sa.Length % 2 == 0)	// even number                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize) + si.FontSize / 2;                              }                              else                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize);                              }                              break;                          case VerticalAlignEnum.Bottom:                              if (height <= 0)                                  break;                                startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length - i));                              break;                          case VerticalAlignEnum.Top:                          default:                              break;                      }                  }                  else                  {                      //25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                        switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                    }                    // Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)                  if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)                  {	// background color' height and width are specified                      iAddFillRect(x' y' width' height' si.BackgroundColor);                  }                    // Set the clipping path' (Itext have no clip)                  if (height > 0 && width > 0)                  {                      cb.SetRGBColorFill(si.Color.R' si.Color.G' si.Color.B);                        if (si.WritingMode == WritingModeEnum.lr_tb)                      {                          //If textline after measure with word break can fit just simple show Text                          if (width >= textwidth)                          {                              cb.BeginText();                              cb.SetFontAndSize(bf' si.FontSize);                              cb.SetTextMatrix(startX' (_pSize.yHeight - startY - si.FontSize));                              cb.ShowText(text);                              cb.EndText();                          }                          else                          {                              //else use Column text to wrap or clip (wrap: for example a text like an URL so word break is not working here' itextsharp ColumnText do the work for us)                              ColumnText ct = new ColumnText(cb);                              Phrase myPhrase = new Phrase(text' new iTextSharp.text.Font(bf' si.FontSize));                              ct.SetSimpleColumn(myPhrase' x + si.PaddingLeft' _pSize.yHeight - startY' x + width - si.PaddingRight' _pSize.yHeight - y - si.PaddingBottom - height' 10f' align);                              ct.Go();                          }                      }                      else                      {                          //Not checked                          double rads = -283.0 / 180.0;                          double radsCos = Math.Cos(rads);                          double radsSin = Math.Sin(rads);                          cb.BeginText();                          cb.SetFontAndSize(bf' si.FontSize);                          cb.SetTextMatrix((float)radsCos' (float)radsSin' (float)-radsSin' (float)radsCos' startX' _pSize.yHeight - startY);                          cb.ShowText(text);                          cb.EndText();                      }                        //add URL                      if (url != null)  						pdfdocument.Add(new Annotation(x' _pSize.yHeight - (y + height)' width + x' _pSize.yHeight - y' url));                      //add tooltip                      if (tooltip != null)  						pdfdocument.Add(new Annotation(x' _pSize.yHeight - (y + height)' width + x' _pSize.yHeight - y' tooltip));                    }                    // Handle underlining etc.                  float maxX;                  switch (si.TextDecoration)                  {                      case TextDecorationEnum.Underline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + si.FontSize + 1' maxX' startY + si.FontSize + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.LineThrough:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + (si.FontSize / 2) + 1' maxX' startY + (si.FontSize / 2) + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.Overline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + 1' maxX' startY + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.None:                      default:                          break;                  }              }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: for (int i = 0; i < sa.Length; i++)              {                  string text = sa[i];                  float textwidth = tw[i];                  // Calculate the x positino                  float startX = x + si.PaddingLeft;						// TODO: handle tb_rl                  float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl                  int align = 0;                  if (si.WritingMode == WritingModeEnum.lr_tb)                  {	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now                      switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (width > 0)                              {                                  startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                                  align = Element.ALIGN_CENTER;                              }                              break;                          case TextAlignEnum.Right:                              if (width > 0)                              {                                  startX = x + width - textwidth - si.PaddingRight;                                  align = Element.ALIGN_RIGHT;                              }                              break;                          case TextAlignEnum.Left:                          default:                              align = Element.ALIGN_LEFT;                              break;                      }                        // Calculate the y position                      switch (si.VerticalAlign)                      {                          case VerticalAlignEnum.Middle:                              if (height <= 0)                                  break;                                // calculate the middle of the region                              startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom) / 2 - si.FontSize / 2;                              // now go up or down depending on which line                              if (sa.Length == 1)                                  break;                              if (sa.Length % 2 == 0)	// even number                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize) + si.FontSize / 2;                              }                              else                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize);                              }                              break;                          case VerticalAlignEnum.Bottom:                              if (height <= 0)                                  break;                                startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length - i));                              break;                          case VerticalAlignEnum.Top:                          default:                              break;                      }                  }                  else                  {                      //25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                        switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                    }                    // Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)                  if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)                  {	// background color' height and width are specified                      iAddFillRect(x' y' width' height' si.BackgroundColor);                  }                    // Set the clipping path' (Itext have no clip)                  if (height > 0 && width > 0)                  {                      cb.SetRGBColorFill(si.Color.R' si.Color.G' si.Color.B);                        if (si.WritingMode == WritingModeEnum.lr_tb)                      {                          //If textline after measure with word break can fit just simple show Text                          if (width >= textwidth)                          {                              cb.BeginText();                              cb.SetFontAndSize(bf' si.FontSize);                              cb.SetTextMatrix(startX' (_pSize.yHeight - startY - si.FontSize));                              cb.ShowText(text);                              cb.EndText();                          }                          else                          {                              //else use Column text to wrap or clip (wrap: for example a text like an URL so word break is not working here' itextsharp ColumnText do the work for us)                              ColumnText ct = new ColumnText(cb);                              Phrase myPhrase = new Phrase(text' new iTextSharp.text.Font(bf' si.FontSize));                              ct.SetSimpleColumn(myPhrase' x + si.PaddingLeft' _pSize.yHeight - startY' x + width - si.PaddingRight' _pSize.yHeight - y - si.PaddingBottom - height' 10f' align);                              ct.Go();                          }                      }                      else                      {                          //Not checked                          double rads = -283.0 / 180.0;                          double radsCos = Math.Cos(rads);                          double radsSin = Math.Sin(rads);                          cb.BeginText();                          cb.SetFontAndSize(bf' si.FontSize);                          cb.SetTextMatrix((float)radsCos' (float)radsSin' (float)-radsSin' (float)radsCos' startX' _pSize.yHeight - startY);                          cb.ShowText(text);                          cb.EndText();                      }                        //add URL                      if (url != null)  						pdfdocument.Add(new Annotation(x' _pSize.yHeight - (y + height)' width + x' _pSize.yHeight - y' url));                      //add tooltip                      if (tooltip != null)  						pdfdocument.Add(new Annotation(x' _pSize.yHeight - (y + height)' width + x' _pSize.yHeight - y' tooltip));                    }                    // Handle underlining etc.                  float maxX;                  switch (si.TextDecoration)                  {                      case TextDecorationEnum.Underline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + si.FontSize + 1' maxX' startY + si.FontSize + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.LineThrough:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + (si.FontSize / 2) + 1' maxX' startY + (si.FontSize / 2) + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.Overline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + 1' maxX' startY + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.None:                      default:                          break;                  }              }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: for (int i = 0; i < sa.Length; i++)              {                  string text = sa[i];                  float textwidth = tw[i];                  // Calculate the x positino                  float startX = x + si.PaddingLeft;						// TODO: handle tb_rl                  float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl                  int align = 0;                  if (si.WritingMode == WritingModeEnum.lr_tb)                  {	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now                      switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (width > 0)                              {                                  startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                                  align = Element.ALIGN_CENTER;                              }                              break;                          case TextAlignEnum.Right:                              if (width > 0)                              {                                  startX = x + width - textwidth - si.PaddingRight;                                  align = Element.ALIGN_RIGHT;                              }                              break;                          case TextAlignEnum.Left:                          default:                              align = Element.ALIGN_LEFT;                              break;                      }                        // Calculate the y position                      switch (si.VerticalAlign)                      {                          case VerticalAlignEnum.Middle:                              if (height <= 0)                                  break;                                // calculate the middle of the region                              startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom) / 2 - si.FontSize / 2;                              // now go up or down depending on which line                              if (sa.Length == 1)                                  break;                              if (sa.Length % 2 == 0)	// even number                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize) + si.FontSize / 2;                              }                              else                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize);                              }                              break;                          case VerticalAlignEnum.Bottom:                              if (height <= 0)                                  break;                                startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length - i));                              break;                          case VerticalAlignEnum.Top:                          default:                              break;                      }                  }                  else                  {                      //25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                        switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                    }                    // Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)                  if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)                  {	// background color' height and width are specified                      iAddFillRect(x' y' width' height' si.BackgroundColor);                  }                    // Set the clipping path' (Itext have no clip)                  if (height > 0 && width > 0)                  {                      cb.SetRGBColorFill(si.Color.R' si.Color.G' si.Color.B);                        if (si.WritingMode == WritingModeEnum.lr_tb)                      {                          //If textline after measure with word break can fit just simple show Text                          if (width >= textwidth)                          {                              cb.BeginText();                              cb.SetFontAndSize(bf' si.FontSize);                              cb.SetTextMatrix(startX' (_pSize.yHeight - startY - si.FontSize));                              cb.ShowText(text);                              cb.EndText();                          }                          else                          {                              //else use Column text to wrap or clip (wrap: for example a text like an URL so word break is not working here' itextsharp ColumnText do the work for us)                              ColumnText ct = new ColumnText(cb);                              Phrase myPhrase = new Phrase(text' new iTextSharp.text.Font(bf' si.FontSize));                              ct.SetSimpleColumn(myPhrase' x + si.PaddingLeft' _pSize.yHeight - startY' x + width - si.PaddingRight' _pSize.yHeight - y - si.PaddingBottom - height' 10f' align);                              ct.Go();                          }                      }                      else                      {                          //Not checked                          double rads = -283.0 / 180.0;                          double radsCos = Math.Cos(rads);                          double radsSin = Math.Sin(rads);                          cb.BeginText();                          cb.SetFontAndSize(bf' si.FontSize);                          cb.SetTextMatrix((float)radsCos' (float)radsSin' (float)-radsSin' (float)radsCos' startX' _pSize.yHeight - startY);                          cb.ShowText(text);                          cb.EndText();                      }                        //add URL                      if (url != null)  						pdfdocument.Add(new Annotation(x' _pSize.yHeight - (y + height)' width + x' _pSize.yHeight - y' url));                      //add tooltip                      if (tooltip != null)  						pdfdocument.Add(new Annotation(x' _pSize.yHeight - (y + height)' width + x' _pSize.yHeight - y' tooltip));                    }                    // Handle underlining etc.                  float maxX;                  switch (si.TextDecoration)                  {                      case TextDecorationEnum.Underline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + si.FontSize + 1' maxX' startY + si.FontSize + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.LineThrough:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + (si.FontSize / 2) + 1' maxX' startY + (si.FontSize / 2) + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.Overline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + 1' maxX' startY + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.None:                      default:                          break;                  }              }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: for (int i = 0; i < sa.Length; i++)              {                  string text = sa[i];                  float textwidth = tw[i];                  // Calculate the x positino                  float startX = x + si.PaddingLeft;						// TODO: handle tb_rl                  float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl                  int align = 0;                  if (si.WritingMode == WritingModeEnum.lr_tb)                  {	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now                      switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (width > 0)                              {                                  startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                                  align = Element.ALIGN_CENTER;                              }                              break;                          case TextAlignEnum.Right:                              if (width > 0)                              {                                  startX = x + width - textwidth - si.PaddingRight;                                  align = Element.ALIGN_RIGHT;                              }                              break;                          case TextAlignEnum.Left:                          default:                              align = Element.ALIGN_LEFT;                              break;                      }                        // Calculate the y position                      switch (si.VerticalAlign)                      {                          case VerticalAlignEnum.Middle:                              if (height <= 0)                                  break;                                // calculate the middle of the region                              startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom) / 2 - si.FontSize / 2;                              // now go up or down depending on which line                              if (sa.Length == 1)                                  break;                              if (sa.Length % 2 == 0)	// even number                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize) + si.FontSize / 2;                              }                              else                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize);                              }                              break;                          case VerticalAlignEnum.Bottom:                              if (height <= 0)                                  break;                                startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length - i));                              break;                          case VerticalAlignEnum.Top:                          default:                              break;                      }                  }                  else                  {                      //25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                        switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                    }                    // Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)                  if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)                  {	// background color' height and width are specified                      iAddFillRect(x' y' width' height' si.BackgroundColor);                  }                    // Set the clipping path' (Itext have no clip)                  if (height > 0 && width > 0)                  {                      cb.SetRGBColorFill(si.Color.R' si.Color.G' si.Color.B);                        if (si.WritingMode == WritingModeEnum.lr_tb)                      {                          //If textline after measure with word break can fit just simple show Text                          if (width >= textwidth)                          {                              cb.BeginText();                              cb.SetFontAndSize(bf' si.FontSize);                              cb.SetTextMatrix(startX' (_pSize.yHeight - startY - si.FontSize));                              cb.ShowText(text);                              cb.EndText();                          }                          else                          {                              //else use Column text to wrap or clip (wrap: for example a text like an URL so word break is not working here' itextsharp ColumnText do the work for us)                              ColumnText ct = new ColumnText(cb);                              Phrase myPhrase = new Phrase(text' new iTextSharp.text.Font(bf' si.FontSize));                              ct.SetSimpleColumn(myPhrase' x + si.PaddingLeft' _pSize.yHeight - startY' x + width - si.PaddingRight' _pSize.yHeight - y - si.PaddingBottom - height' 10f' align);                              ct.Go();                          }                      }                      else                      {                          //Not checked                          double rads = -283.0 / 180.0;                          double radsCos = Math.Cos(rads);                          double radsSin = Math.Sin(rads);                          cb.BeginText();                          cb.SetFontAndSize(bf' si.FontSize);                          cb.SetTextMatrix((float)radsCos' (float)radsSin' (float)-radsSin' (float)radsCos' startX' _pSize.yHeight - startY);                          cb.ShowText(text);                          cb.EndText();                      }                        //add URL                      if (url != null)  						pdfdocument.Add(new Annotation(x' _pSize.yHeight - (y + height)' width + x' _pSize.yHeight - y' url));                      //add tooltip                      if (tooltip != null)  						pdfdocument.Add(new Annotation(x' _pSize.yHeight - (y + height)' width + x' _pSize.yHeight - y' tooltip));                    }                    // Handle underlining etc.                  float maxX;                  switch (si.TextDecoration)                  {                      case TextDecorationEnum.Underline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + si.FontSize + 1' maxX' startY + si.FontSize + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.LineThrough:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + (si.FontSize / 2) + 1' maxX' startY + (si.FontSize / 2) + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.Overline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + 1' maxX' startY + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.None:                      default:                          break;                  }              }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: for (int i = 0; i < sa.Length; i++)              {                  string text = sa[i];                  float textwidth = tw[i];                  // Calculate the x positino                  float startX = x + si.PaddingLeft;						// TODO: handle tb_rl                  float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl                  int align = 0;                  if (si.WritingMode == WritingModeEnum.lr_tb)                  {	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now                      switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (width > 0)                              {                                  startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                                  align = Element.ALIGN_CENTER;                              }                              break;                          case TextAlignEnum.Right:                              if (width > 0)                              {                                  startX = x + width - textwidth - si.PaddingRight;                                  align = Element.ALIGN_RIGHT;                              }                              break;                          case TextAlignEnum.Left:                          default:                              align = Element.ALIGN_LEFT;                              break;                      }                        // Calculate the y position                      switch (si.VerticalAlign)                      {                          case VerticalAlignEnum.Middle:                              if (height <= 0)                                  break;                                // calculate the middle of the region                              startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom) / 2 - si.FontSize / 2;                              // now go up or down depending on which line                              if (sa.Length == 1)                                  break;                              if (sa.Length % 2 == 0)	// even number                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize) + si.FontSize / 2;                              }                              else                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize);                              }                              break;                          case VerticalAlignEnum.Bottom:                              if (height <= 0)                                  break;                                startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length - i));                              break;                          case VerticalAlignEnum.Top:                          default:                              break;                      }                  }                  else                  {                      //25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                        switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                    }                    // Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)                  if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)                  {	// background color' height and width are specified                      iAddFillRect(x' y' width' height' si.BackgroundColor);                  }                    // Set the clipping path' (Itext have no clip)                  if (height > 0 && width > 0)                  {                      cb.SetRGBColorFill(si.Color.R' si.Color.G' si.Color.B);                        if (si.WritingMode == WritingModeEnum.lr_tb)                      {                          //If textline after measure with word break can fit just simple show Text                          if (width >= textwidth)                          {                              cb.BeginText();                              cb.SetFontAndSize(bf' si.FontSize);                              cb.SetTextMatrix(startX' (_pSize.yHeight - startY - si.FontSize));                              cb.ShowText(text);                              cb.EndText();                          }                          else                          {                              //else use Column text to wrap or clip (wrap: for example a text like an URL so word break is not working here' itextsharp ColumnText do the work for us)                              ColumnText ct = new ColumnText(cb);                              Phrase myPhrase = new Phrase(text' new iTextSharp.text.Font(bf' si.FontSize));                              ct.SetSimpleColumn(myPhrase' x + si.PaddingLeft' _pSize.yHeight - startY' x + width - si.PaddingRight' _pSize.yHeight - y - si.PaddingBottom - height' 10f' align);                              ct.Go();                          }                      }                      else                      {                          //Not checked                          double rads = -283.0 / 180.0;                          double radsCos = Math.Cos(rads);                          double radsSin = Math.Sin(rads);                          cb.BeginText();                          cb.SetFontAndSize(bf' si.FontSize);                          cb.SetTextMatrix((float)radsCos' (float)radsSin' (float)-radsSin' (float)radsCos' startX' _pSize.yHeight - startY);                          cb.ShowText(text);                          cb.EndText();                      }                        //add URL                      if (url != null)  						pdfdocument.Add(new Annotation(x' _pSize.yHeight - (y + height)' width + x' _pSize.yHeight - y' url));                      //add tooltip                      if (tooltip != null)  						pdfdocument.Add(new Annotation(x' _pSize.yHeight - (y + height)' width + x' _pSize.yHeight - y' tooltip));                    }                    // Handle underlining etc.                  float maxX;                  switch (si.TextDecoration)                  {                      case TextDecorationEnum.Underline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + si.FontSize + 1' maxX' startY + si.FontSize + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.LineThrough:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + (si.FontSize / 2) + 1' maxX' startY + (si.FontSize / 2) + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.Overline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + 1' maxX' startY + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.None:                      default:                          break;                  }              }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: for (int i = 0; i < sa.Length; i++)              {                  string text = sa[i];                  float textwidth = tw[i];                  // Calculate the x positino                  float startX = x + si.PaddingLeft;						// TODO: handle tb_rl                  float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl                  int align = 0;                  if (si.WritingMode == WritingModeEnum.lr_tb)                  {	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now                      switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (width > 0)                              {                                  startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                                  align = Element.ALIGN_CENTER;                              }                              break;                          case TextAlignEnum.Right:                              if (width > 0)                              {                                  startX = x + width - textwidth - si.PaddingRight;                                  align = Element.ALIGN_RIGHT;                              }                              break;                          case TextAlignEnum.Left:                          default:                              align = Element.ALIGN_LEFT;                              break;                      }                        // Calculate the y position                      switch (si.VerticalAlign)                      {                          case VerticalAlignEnum.Middle:                              if (height <= 0)                                  break;                                // calculate the middle of the region                              startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom) / 2 - si.FontSize / 2;                              // now go up or down depending on which line                              if (sa.Length == 1)                                  break;                              if (sa.Length % 2 == 0)	// even number                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize) + si.FontSize / 2;                              }                              else                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize);                              }                              break;                          case VerticalAlignEnum.Bottom:                              if (height <= 0)                                  break;                                startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length - i));                              break;                          case VerticalAlignEnum.Top:                          default:                              break;                      }                  }                  else                  {                      //25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                        switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                    }                    // Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)                  if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)                  {	// background color' height and width are specified                      iAddFillRect(x' y' width' height' si.BackgroundColor);                  }                    // Set the clipping path' (Itext have no clip)                  if (height > 0 && width > 0)                  {                      cb.SetRGBColorFill(si.Color.R' si.Color.G' si.Color.B);                        if (si.WritingMode == WritingModeEnum.lr_tb)                      {                          //If textline after measure with word break can fit just simple show Text                          if (width >= textwidth)                          {                              cb.BeginText();                              cb.SetFontAndSize(bf' si.FontSize);                              cb.SetTextMatrix(startX' (_pSize.yHeight - startY - si.FontSize));                              cb.ShowText(text);                              cb.EndText();                          }                          else                          {                              //else use Column text to wrap or clip (wrap: for example a text like an URL so word break is not working here' itextsharp ColumnText do the work for us)                              ColumnText ct = new ColumnText(cb);                              Phrase myPhrase = new Phrase(text' new iTextSharp.text.Font(bf' si.FontSize));                              ct.SetSimpleColumn(myPhrase' x + si.PaddingLeft' _pSize.yHeight - startY' x + width - si.PaddingRight' _pSize.yHeight - y - si.PaddingBottom - height' 10f' align);                              ct.Go();                          }                      }                      else                      {                          //Not checked                          double rads = -283.0 / 180.0;                          double radsCos = Math.Cos(rads);                          double radsSin = Math.Sin(rads);                          cb.BeginText();                          cb.SetFontAndSize(bf' si.FontSize);                          cb.SetTextMatrix((float)radsCos' (float)radsSin' (float)-radsSin' (float)radsCos' startX' _pSize.yHeight - startY);                          cb.ShowText(text);                          cb.EndText();                      }                        //add URL                      if (url != null)  						pdfdocument.Add(new Annotation(x' _pSize.yHeight - (y + height)' width + x' _pSize.yHeight - y' url));                      //add tooltip                      if (tooltip != null)  						pdfdocument.Add(new Annotation(x' _pSize.yHeight - (y + height)' width + x' _pSize.yHeight - y' tooltip));                    }                    // Handle underlining etc.                  float maxX;                  switch (si.TextDecoration)                  {                      case TextDecorationEnum.Underline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + si.FontSize + 1' maxX' startY + si.FontSize + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.LineThrough:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + (si.FontSize / 2) + 1' maxX' startY + (si.FontSize / 2) + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.Overline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + 1' maxX' startY + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.None:                      default:                          break;                  }              }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: for (int i = 0; i < sa.Length; i++)              {                  string text = sa[i];                  float textwidth = tw[i];                  // Calculate the x positino                  float startX = x + si.PaddingLeft;						// TODO: handle tb_rl                  float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl                  int align = 0;                  if (si.WritingMode == WritingModeEnum.lr_tb)                  {	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now                      switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (width > 0)                              {                                  startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                                  align = Element.ALIGN_CENTER;                              }                              break;                          case TextAlignEnum.Right:                              if (width > 0)                              {                                  startX = x + width - textwidth - si.PaddingRight;                                  align = Element.ALIGN_RIGHT;                              }                              break;                          case TextAlignEnum.Left:                          default:                              align = Element.ALIGN_LEFT;                              break;                      }                        // Calculate the y position                      switch (si.VerticalAlign)                      {                          case VerticalAlignEnum.Middle:                              if (height <= 0)                                  break;                                // calculate the middle of the region                              startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom) / 2 - si.FontSize / 2;                              // now go up or down depending on which line                              if (sa.Length == 1)                                  break;                              if (sa.Length % 2 == 0)	// even number                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize) + si.FontSize / 2;                              }                              else                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize);                              }                              break;                          case VerticalAlignEnum.Bottom:                              if (height <= 0)                                  break;                                startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length - i));                              break;                          case VerticalAlignEnum.Top:                          default:                              break;                      }                  }                  else                  {                      //25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                        switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                    }                    // Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)                  if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)                  {	// background color' height and width are specified                      iAddFillRect(x' y' width' height' si.BackgroundColor);                  }                    // Set the clipping path' (Itext have no clip)                  if (height > 0 && width > 0)                  {                      cb.SetRGBColorFill(si.Color.R' si.Color.G' si.Color.B);                        if (si.WritingMode == WritingModeEnum.lr_tb)                      {                          //If textline after measure with word break can fit just simple show Text                          if (width >= textwidth)                          {                              cb.BeginText();                              cb.SetFontAndSize(bf' si.FontSize);                              cb.SetTextMatrix(startX' (_pSize.yHeight - startY - si.FontSize));                              cb.ShowText(text);                              cb.EndText();                          }                          else                          {                              //else use Column text to wrap or clip (wrap: for example a text like an URL so word break is not working here' itextsharp ColumnText do the work for us)                              ColumnText ct = new ColumnText(cb);                              Phrase myPhrase = new Phrase(text' new iTextSharp.text.Font(bf' si.FontSize));                              ct.SetSimpleColumn(myPhrase' x + si.PaddingLeft' _pSize.yHeight - startY' x + width - si.PaddingRight' _pSize.yHeight - y - si.PaddingBottom - height' 10f' align);                              ct.Go();                          }                      }                      else                      {                          //Not checked                          double rads = -283.0 / 180.0;                          double radsCos = Math.Cos(rads);                          double radsSin = Math.Sin(rads);                          cb.BeginText();                          cb.SetFontAndSize(bf' si.FontSize);                          cb.SetTextMatrix((float)radsCos' (float)radsSin' (float)-radsSin' (float)radsCos' startX' _pSize.yHeight - startY);                          cb.ShowText(text);                          cb.EndText();                      }                        //add URL                      if (url != null)  						pdfdocument.Add(new Annotation(x' _pSize.yHeight - (y + height)' width + x' _pSize.yHeight - y' url));                      //add tooltip                      if (tooltip != null)  						pdfdocument.Add(new Annotation(x' _pSize.yHeight - (y + height)' width + x' _pSize.yHeight - y' tooltip));                    }                    // Handle underlining etc.                  float maxX;                  switch (si.TextDecoration)                  {                      case TextDecorationEnum.Underline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + si.FontSize + 1' maxX' startY + si.FontSize + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.LineThrough:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + (si.FontSize / 2) + 1' maxX' startY + (si.FontSize / 2) + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.Overline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + 1' maxX' startY + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.None:                      default:                          break;                  }              }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: for (int i = 0; i < sa.Length; i++)              {                  string text = sa[i];                  float textwidth = tw[i];                  // Calculate the x positino                  float startX = x + si.PaddingLeft;						// TODO: handle tb_rl                  float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl                  int align = 0;                  if (si.WritingMode == WritingModeEnum.lr_tb)                  {	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now                      switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (width > 0)                              {                                  startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                                  align = Element.ALIGN_CENTER;                              }                              break;                          case TextAlignEnum.Right:                              if (width > 0)                              {                                  startX = x + width - textwidth - si.PaddingRight;                                  align = Element.ALIGN_RIGHT;                              }                              break;                          case TextAlignEnum.Left:                          default:                              align = Element.ALIGN_LEFT;                              break;                      }                        // Calculate the y position                      switch (si.VerticalAlign)                      {                          case VerticalAlignEnum.Middle:                              if (height <= 0)                                  break;                                // calculate the middle of the region                              startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom) / 2 - si.FontSize / 2;                              // now go up or down depending on which line                              if (sa.Length == 1)                                  break;                              if (sa.Length % 2 == 0)	// even number                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize) + si.FontSize / 2;                              }                              else                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize);                              }                              break;                          case VerticalAlignEnum.Bottom:                              if (height <= 0)                                  break;                                startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length - i));                              break;                          case VerticalAlignEnum.Top:                          default:                              break;                      }                  }                  else                  {                      //25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                        switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                    }                    // Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)                  if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)                  {	// background color' height and width are specified                      iAddFillRect(x' y' width' height' si.BackgroundColor);                  }                    // Set the clipping path' (Itext have no clip)                  if (height > 0 && width > 0)                  {                      cb.SetRGBColorFill(si.Color.R' si.Color.G' si.Color.B);                        if (si.WritingMode == WritingModeEnum.lr_tb)                      {                          //If textline after measure with word break can fit just simple show Text                          if (width >= textwidth)                          {                              cb.BeginText();                              cb.SetFontAndSize(bf' si.FontSize);                              cb.SetTextMatrix(startX' (_pSize.yHeight - startY - si.FontSize));                              cb.ShowText(text);                              cb.EndText();                          }                          else                          {                              //else use Column text to wrap or clip (wrap: for example a text like an URL so word break is not working here' itextsharp ColumnText do the work for us)                              ColumnText ct = new ColumnText(cb);                              Phrase myPhrase = new Phrase(text' new iTextSharp.text.Font(bf' si.FontSize));                              ct.SetSimpleColumn(myPhrase' x + si.PaddingLeft' _pSize.yHeight - startY' x + width - si.PaddingRight' _pSize.yHeight - y - si.PaddingBottom - height' 10f' align);                              ct.Go();                          }                      }                      else                      {                          //Not checked                          double rads = -283.0 / 180.0;                          double radsCos = Math.Cos(rads);                          double radsSin = Math.Sin(rads);                          cb.BeginText();                          cb.SetFontAndSize(bf' si.FontSize);                          cb.SetTextMatrix((float)radsCos' (float)radsSin' (float)-radsSin' (float)radsCos' startX' _pSize.yHeight - startY);                          cb.ShowText(text);                          cb.EndText();                      }                        //add URL                      if (url != null)  						pdfdocument.Add(new Annotation(x' _pSize.yHeight - (y + height)' width + x' _pSize.yHeight - y' url));                      //add tooltip                      if (tooltip != null)  						pdfdocument.Add(new Annotation(x' _pSize.yHeight - (y + height)' width + x' _pSize.yHeight - y' tooltip));                    }                    // Handle underlining etc.                  float maxX;                  switch (si.TextDecoration)                  {                      case TextDecorationEnum.Underline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + si.FontSize + 1' maxX' startY + si.FontSize + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.LineThrough:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + (si.FontSize / 2) + 1' maxX' startY + (si.FontSize / 2) + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.Overline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + 1' maxX' startY + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.None:                      default:                          break;                  }              }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: for (int i = 0; i < sa.Length; i++)              {                  string text = sa[i];                  float textwidth = tw[i];                  // Calculate the x positino                  float startX = x + si.PaddingLeft;						// TODO: handle tb_rl                  float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl                  int align = 0;                  if (si.WritingMode == WritingModeEnum.lr_tb)                  {	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now                      switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (width > 0)                              {                                  startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                                  align = Element.ALIGN_CENTER;                              }                              break;                          case TextAlignEnum.Right:                              if (width > 0)                              {                                  startX = x + width - textwidth - si.PaddingRight;                                  align = Element.ALIGN_RIGHT;                              }                              break;                          case TextAlignEnum.Left:                          default:                              align = Element.ALIGN_LEFT;                              break;                      }                        // Calculate the y position                      switch (si.VerticalAlign)                      {                          case VerticalAlignEnum.Middle:                              if (height <= 0)                                  break;                                // calculate the middle of the region                              startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom) / 2 - si.FontSize / 2;                              // now go up or down depending on which line                              if (sa.Length == 1)                                  break;                              if (sa.Length % 2 == 0)	// even number                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize) + si.FontSize / 2;                              }                              else                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize);                              }                              break;                          case VerticalAlignEnum.Bottom:                              if (height <= 0)                                  break;                                startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length - i));                              break;                          case VerticalAlignEnum.Top:                          default:                              break;                      }                  }                  else                  {                      //25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                        switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                    }                    // Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)                  if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)                  {	// background color' height and width are specified                      iAddFillRect(x' y' width' height' si.BackgroundColor);                  }                    // Set the clipping path' (Itext have no clip)                  if (height > 0 && width > 0)                  {                      cb.SetRGBColorFill(si.Color.R' si.Color.G' si.Color.B);                        if (si.WritingMode == WritingModeEnum.lr_tb)                      {                          //If textline after measure with word break can fit just simple show Text                          if (width >= textwidth)                          {                              cb.BeginText();                              cb.SetFontAndSize(bf' si.FontSize);                              cb.SetTextMatrix(startX' (_pSize.yHeight - startY - si.FontSize));                              cb.ShowText(text);                              cb.EndText();                          }                          else                          {                              //else use Column text to wrap or clip (wrap: for example a text like an URL so word break is not working here' itextsharp ColumnText do the work for us)                              ColumnText ct = new ColumnText(cb);                              Phrase myPhrase = new Phrase(text' new iTextSharp.text.Font(bf' si.FontSize));                              ct.SetSimpleColumn(myPhrase' x + si.PaddingLeft' _pSize.yHeight - startY' x + width - si.PaddingRight' _pSize.yHeight - y - si.PaddingBottom - height' 10f' align);                              ct.Go();                          }                      }                      else                      {                          //Not checked                          double rads = -283.0 / 180.0;                          double radsCos = Math.Cos(rads);                          double radsSin = Math.Sin(rads);                          cb.BeginText();                          cb.SetFontAndSize(bf' si.FontSize);                          cb.SetTextMatrix((float)radsCos' (float)radsSin' (float)-radsSin' (float)radsCos' startX' _pSize.yHeight - startY);                          cb.ShowText(text);                          cb.EndText();                      }                        //add URL                      if (url != null)  						pdfdocument.Add(new Annotation(x' _pSize.yHeight - (y + height)' width + x' _pSize.yHeight - y' url));                      //add tooltip                      if (tooltip != null)  						pdfdocument.Add(new Annotation(x' _pSize.yHeight - (y + height)' width + x' _pSize.yHeight - y' tooltip));                    }                    // Handle underlining etc.                  float maxX;                  switch (si.TextDecoration)                  {                      case TextDecorationEnum.Underline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + si.FontSize + 1' maxX' startY + si.FontSize + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.LineThrough:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + (si.FontSize / 2) + 1' maxX' startY + (si.FontSize / 2) + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.Overline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + 1' maxX' startY + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.None:                      default:                          break;                  }              }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: for (int i = 0; i < sa.Length; i++)              {                  string text = sa[i];                  float textwidth = tw[i];                  // Calculate the x positino                  float startX = x + si.PaddingLeft;						// TODO: handle tb_rl                  float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl                  int align = 0;                  if (si.WritingMode == WritingModeEnum.lr_tb)                  {	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now                      switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (width > 0)                              {                                  startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                                  align = Element.ALIGN_CENTER;                              }                              break;                          case TextAlignEnum.Right:                              if (width > 0)                              {                                  startX = x + width - textwidth - si.PaddingRight;                                  align = Element.ALIGN_RIGHT;                              }                              break;                          case TextAlignEnum.Left:                          default:                              align = Element.ALIGN_LEFT;                              break;                      }                        // Calculate the y position                      switch (si.VerticalAlign)                      {                          case VerticalAlignEnum.Middle:                              if (height <= 0)                                  break;                                // calculate the middle of the region                              startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom) / 2 - si.FontSize / 2;                              // now go up or down depending on which line                              if (sa.Length == 1)                                  break;                              if (sa.Length % 2 == 0)	// even number                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize) + si.FontSize / 2;                              }                              else                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize);                              }                              break;                          case VerticalAlignEnum.Bottom:                              if (height <= 0)                                  break;                                startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length - i));                              break;                          case VerticalAlignEnum.Top:                          default:                              break;                      }                  }                  else                  {                      //25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                        switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                    }                    // Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)                  if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)                  {	// background color' height and width are specified                      iAddFillRect(x' y' width' height' si.BackgroundColor);                  }                    // Set the clipping path' (Itext have no clip)                  if (height > 0 && width > 0)                  {                      cb.SetRGBColorFill(si.Color.R' si.Color.G' si.Color.B);                        if (si.WritingMode == WritingModeEnum.lr_tb)                      {                          //If textline after measure with word break can fit just simple show Text                          if (width >= textwidth)                          {                              cb.BeginText();                              cb.SetFontAndSize(bf' si.FontSize);                              cb.SetTextMatrix(startX' (_pSize.yHeight - startY - si.FontSize));                              cb.ShowText(text);                              cb.EndText();                          }                          else                          {                              //else use Column text to wrap or clip (wrap: for example a text like an URL so word break is not working here' itextsharp ColumnText do the work for us)                              ColumnText ct = new ColumnText(cb);                              Phrase myPhrase = new Phrase(text' new iTextSharp.text.Font(bf' si.FontSize));                              ct.SetSimpleColumn(myPhrase' x + si.PaddingLeft' _pSize.yHeight - startY' x + width - si.PaddingRight' _pSize.yHeight - y - si.PaddingBottom - height' 10f' align);                              ct.Go();                          }                      }                      else                      {                          //Not checked                          double rads = -283.0 / 180.0;                          double radsCos = Math.Cos(rads);                          double radsSin = Math.Sin(rads);                          cb.BeginText();                          cb.SetFontAndSize(bf' si.FontSize);                          cb.SetTextMatrix((float)radsCos' (float)radsSin' (float)-radsSin' (float)radsCos' startX' _pSize.yHeight - startY);                          cb.ShowText(text);                          cb.EndText();                      }                        //add URL                      if (url != null)  						pdfdocument.Add(new Annotation(x' _pSize.yHeight - (y + height)' width + x' _pSize.yHeight - y' url));                      //add tooltip                      if (tooltip != null)  						pdfdocument.Add(new Annotation(x' _pSize.yHeight - (y + height)' width + x' _pSize.yHeight - y' tooltip));                    }                    // Handle underlining etc.                  float maxX;                  switch (si.TextDecoration)                  {                      case TextDecorationEnum.Underline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + si.FontSize + 1' maxX' startY + si.FontSize + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.LineThrough:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + (si.FontSize / 2) + 1' maxX' startY + (si.FontSize / 2) + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.Overline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + 1' maxX' startY + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.None:                      default:                          break;                  }              }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: for (int i = 0; i < sa.Length; i++)              {                  string text = sa[i];                  float textwidth = tw[i];                  // Calculate the x positino                  float startX = x + si.PaddingLeft;						// TODO: handle tb_rl                  float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl                  int align = 0;                  if (si.WritingMode == WritingModeEnum.lr_tb)                  {	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now                      switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (width > 0)                              {                                  startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                                  align = Element.ALIGN_CENTER;                              }                              break;                          case TextAlignEnum.Right:                              if (width > 0)                              {                                  startX = x + width - textwidth - si.PaddingRight;                                  align = Element.ALIGN_RIGHT;                              }                              break;                          case TextAlignEnum.Left:                          default:                              align = Element.ALIGN_LEFT;                              break;                      }                        // Calculate the y position                      switch (si.VerticalAlign)                      {                          case VerticalAlignEnum.Middle:                              if (height <= 0)                                  break;                                // calculate the middle of the region                              startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom) / 2 - si.FontSize / 2;                              // now go up or down depending on which line                              if (sa.Length == 1)                                  break;                              if (sa.Length % 2 == 0)	// even number                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize) + si.FontSize / 2;                              }                              else                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize);                              }                              break;                          case VerticalAlignEnum.Bottom:                              if (height <= 0)                                  break;                                startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length - i));                              break;                          case VerticalAlignEnum.Top:                          default:                              break;                      }                  }                  else                  {                      //25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                        switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                    }                    // Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)                  if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)                  {	// background color' height and width are specified                      iAddFillRect(x' y' width' height' si.BackgroundColor);                  }                    // Set the clipping path' (Itext have no clip)                  if (height > 0 && width > 0)                  {                      cb.SetRGBColorFill(si.Color.R' si.Color.G' si.Color.B);                        if (si.WritingMode == WritingModeEnum.lr_tb)                      {                          //If textline after measure with word break can fit just simple show Text                          if (width >= textwidth)                          {                              cb.BeginText();                              cb.SetFontAndSize(bf' si.FontSize);                              cb.SetTextMatrix(startX' (_pSize.yHeight - startY - si.FontSize));                              cb.ShowText(text);                              cb.EndText();                          }                          else                          {                              //else use Column text to wrap or clip (wrap: for example a text like an URL so word break is not working here' itextsharp ColumnText do the work for us)                              ColumnText ct = new ColumnText(cb);                              Phrase myPhrase = new Phrase(text' new iTextSharp.text.Font(bf' si.FontSize));                              ct.SetSimpleColumn(myPhrase' x + si.PaddingLeft' _pSize.yHeight - startY' x + width - si.PaddingRight' _pSize.yHeight - y - si.PaddingBottom - height' 10f' align);                              ct.Go();                          }                      }                      else                      {                          //Not checked                          double rads = -283.0 / 180.0;                          double radsCos = Math.Cos(rads);                          double radsSin = Math.Sin(rads);                          cb.BeginText();                          cb.SetFontAndSize(bf' si.FontSize);                          cb.SetTextMatrix((float)radsCos' (float)radsSin' (float)-radsSin' (float)radsCos' startX' _pSize.yHeight - startY);                          cb.ShowText(text);                          cb.EndText();                      }                        //add URL                      if (url != null)  						pdfdocument.Add(new Annotation(x' _pSize.yHeight - (y + height)' width + x' _pSize.yHeight - y' url));                      //add tooltip                      if (tooltip != null)  						pdfdocument.Add(new Annotation(x' _pSize.yHeight - (y + height)' width + x' _pSize.yHeight - y' tooltip));                    }                    // Handle underlining etc.                  float maxX;                  switch (si.TextDecoration)                  {                      case TextDecorationEnum.Underline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + si.FontSize + 1' maxX' startY + si.FontSize + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.LineThrough:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + (si.FontSize / 2) + 1' maxX' startY + (si.FontSize / 2) + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.Overline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + 1' maxX' startY + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.None:                      default:                          break;                  }              }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: for (int i = 0; i < sa.Length; i++)              {                  string text = sa[i];                  float textwidth = tw[i];                  // Calculate the x positino                  float startX = x + si.PaddingLeft;						// TODO: handle tb_rl                  float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl                  int align = 0;                  if (si.WritingMode == WritingModeEnum.lr_tb)                  {	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now                      switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (width > 0)                              {                                  startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                                  align = Element.ALIGN_CENTER;                              }                              break;                          case TextAlignEnum.Right:                              if (width > 0)                              {                                  startX = x + width - textwidth - si.PaddingRight;                                  align = Element.ALIGN_RIGHT;                              }                              break;                          case TextAlignEnum.Left:                          default:                              align = Element.ALIGN_LEFT;                              break;                      }                        // Calculate the y position                      switch (si.VerticalAlign)                      {                          case VerticalAlignEnum.Middle:                              if (height <= 0)                                  break;                                // calculate the middle of the region                              startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom) / 2 - si.FontSize / 2;                              // now go up or down depending on which line                              if (sa.Length == 1)                                  break;                              if (sa.Length % 2 == 0)	// even number                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize) + si.FontSize / 2;                              }                              else                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize);                              }                              break;                          case VerticalAlignEnum.Bottom:                              if (height <= 0)                                  break;                                startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length - i));                              break;                          case VerticalAlignEnum.Top:                          default:                              break;                      }                  }                  else                  {                      //25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                        switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                    }                    // Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)                  if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)                  {	// background color' height and width are specified                      iAddFillRect(x' y' width' height' si.BackgroundColor);                  }                    // Set the clipping path' (Itext have no clip)                  if (height > 0 && width > 0)                  {                      cb.SetRGBColorFill(si.Color.R' si.Color.G' si.Color.B);                        if (si.WritingMode == WritingModeEnum.lr_tb)                      {                          //If textline after measure with word break can fit just simple show Text                          if (width >= textwidth)                          {                              cb.BeginText();                              cb.SetFontAndSize(bf' si.FontSize);                              cb.SetTextMatrix(startX' (_pSize.yHeight - startY - si.FontSize));                              cb.ShowText(text);                              cb.EndText();                          }                          else                          {                              //else use Column text to wrap or clip (wrap: for example a text like an URL so word break is not working here' itextsharp ColumnText do the work for us)                              ColumnText ct = new ColumnText(cb);                              Phrase myPhrase = new Phrase(text' new iTextSharp.text.Font(bf' si.FontSize));                              ct.SetSimpleColumn(myPhrase' x + si.PaddingLeft' _pSize.yHeight - startY' x + width - si.PaddingRight' _pSize.yHeight - y - si.PaddingBottom - height' 10f' align);                              ct.Go();                          }                      }                      else                      {                          //Not checked                          double rads = -283.0 / 180.0;                          double radsCos = Math.Cos(rads);                          double radsSin = Math.Sin(rads);                          cb.BeginText();                          cb.SetFontAndSize(bf' si.FontSize);                          cb.SetTextMatrix((float)radsCos' (float)radsSin' (float)-radsSin' (float)radsCos' startX' _pSize.yHeight - startY);                          cb.ShowText(text);                          cb.EndText();                      }                        //add URL                      if (url != null)  						pdfdocument.Add(new Annotation(x' _pSize.yHeight - (y + height)' width + x' _pSize.yHeight - y' url));                      //add tooltip                      if (tooltip != null)  						pdfdocument.Add(new Annotation(x' _pSize.yHeight - (y + height)' width + x' _pSize.yHeight - y' tooltip));                    }                    // Handle underlining etc.                  float maxX;                  switch (si.TextDecoration)                  {                      case TextDecorationEnum.Underline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + si.FontSize + 1' maxX' startY + si.FontSize + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.LineThrough:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + (si.FontSize / 2) + 1' maxX' startY + (si.FontSize / 2) + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.Overline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + 1' maxX' startY + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.None:                      default:                          break;                  }              }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: for (int i = 0; i < sa.Length; i++)              {                  string text = sa[i];                  float textwidth = tw[i];                  // Calculate the x positino                  float startX = x + si.PaddingLeft;						// TODO: handle tb_rl                  float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl                  int align = 0;                  if (si.WritingMode == WritingModeEnum.lr_tb)                  {	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now                      switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (width > 0)                              {                                  startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                                  align = Element.ALIGN_CENTER;                              }                              break;                          case TextAlignEnum.Right:                              if (width > 0)                              {                                  startX = x + width - textwidth - si.PaddingRight;                                  align = Element.ALIGN_RIGHT;                              }                              break;                          case TextAlignEnum.Left:                          default:                              align = Element.ALIGN_LEFT;                              break;                      }                        // Calculate the y position                      switch (si.VerticalAlign)                      {                          case VerticalAlignEnum.Middle:                              if (height <= 0)                                  break;                                // calculate the middle of the region                              startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom) / 2 - si.FontSize / 2;                              // now go up or down depending on which line                              if (sa.Length == 1)                                  break;                              if (sa.Length % 2 == 0)	// even number                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize) + si.FontSize / 2;                              }                              else                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize);                              }                              break;                          case VerticalAlignEnum.Bottom:                              if (height <= 0)                                  break;                                startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length - i));                              break;                          case VerticalAlignEnum.Top:                          default:                              break;                      }                  }                  else                  {                      //25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                        switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                    }                    // Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)                  if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)                  {	// background color' height and width are specified                      iAddFillRect(x' y' width' height' si.BackgroundColor);                  }                    // Set the clipping path' (Itext have no clip)                  if (height > 0 && width > 0)                  {                      cb.SetRGBColorFill(si.Color.R' si.Color.G' si.Color.B);                        if (si.WritingMode == WritingModeEnum.lr_tb)                      {                          //If textline after measure with word break can fit just simple show Text                          if (width >= textwidth)                          {                              cb.BeginText();                              cb.SetFontAndSize(bf' si.FontSize);                              cb.SetTextMatrix(startX' (_pSize.yHeight - startY - si.FontSize));                              cb.ShowText(text);                              cb.EndText();                          }                          else                          {                              //else use Column text to wrap or clip (wrap: for example a text like an URL so word break is not working here' itextsharp ColumnText do the work for us)                              ColumnText ct = new ColumnText(cb);                              Phrase myPhrase = new Phrase(text' new iTextSharp.text.Font(bf' si.FontSize));                              ct.SetSimpleColumn(myPhrase' x + si.PaddingLeft' _pSize.yHeight - startY' x + width - si.PaddingRight' _pSize.yHeight - y - si.PaddingBottom - height' 10f' align);                              ct.Go();                          }                      }                      else                      {                          //Not checked                          double rads = -283.0 / 180.0;                          double radsCos = Math.Cos(rads);                          double radsSin = Math.Sin(rads);                          cb.BeginText();                          cb.SetFontAndSize(bf' si.FontSize);                          cb.SetTextMatrix((float)radsCos' (float)radsSin' (float)-radsSin' (float)radsCos' startX' _pSize.yHeight - startY);                          cb.ShowText(text);                          cb.EndText();                      }                        //add URL                      if (url != null)  						pdfdocument.Add(new Annotation(x' _pSize.yHeight - (y + height)' width + x' _pSize.yHeight - y' url));                      //add tooltip                      if (tooltip != null)  						pdfdocument.Add(new Annotation(x' _pSize.yHeight - (y + height)' width + x' _pSize.yHeight - y' tooltip));                    }                    // Handle underlining etc.                  float maxX;                  switch (si.TextDecoration)                  {                      case TextDecorationEnum.Underline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + si.FontSize + 1' maxX' startY + si.FontSize + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.LineThrough:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + (si.FontSize / 2) + 1' maxX' startY + (si.FontSize / 2) + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.Overline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + 1' maxX' startY + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.None:                      default:                          break;                  }              }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,iAddText,The following statement contains a magic number: for (int i = 0; i < sa.Length; i++)              {                  string text = sa[i];                  float textwidth = tw[i];                  // Calculate the x positino                  float startX = x + si.PaddingLeft;						// TODO: handle tb_rl                  float startY = y + si.PaddingTop + (i * si.FontSize);	// TODO: handle tb_rl                  int align = 0;                  if (si.WritingMode == WritingModeEnum.lr_tb)                  {	// TODO: not sure what alignment means with tb_lr so I'll leave it out for now                      switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (width > 0)                              {                                  startX = x + si.PaddingLeft + (width - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                                  align = Element.ALIGN_CENTER;                              }                              break;                          case TextAlignEnum.Right:                              if (width > 0)                              {                                  startX = x + width - textwidth - si.PaddingRight;                                  align = Element.ALIGN_RIGHT;                              }                              break;                          case TextAlignEnum.Left:                          default:                              align = Element.ALIGN_LEFT;                              break;                      }                        // Calculate the y position                      switch (si.VerticalAlign)                      {                          case VerticalAlignEnum.Middle:                              if (height <= 0)                                  break;                                // calculate the middle of the region                              startY = y + si.PaddingTop + (height - si.PaddingTop - si.PaddingBottom) / 2 - si.FontSize / 2;                              // now go up or down depending on which line                              if (sa.Length == 1)                                  break;                              if (sa.Length % 2 == 0)	// even number                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize) + si.FontSize / 2;                              }                              else                              {                                  startY = startY - ((sa.Length / 2 - i) * si.FontSize);                              }                              break;                          case VerticalAlignEnum.Bottom:                              if (height <= 0)                                  break;                                startY = y + height - si.PaddingBottom - (si.FontSize * (sa.Length - i));                              break;                          case VerticalAlignEnum.Top:                          default:                              break;                      }                  }                  else                  {                      //25072008 GJL - Move x in a little - it draws to close to the edge of the rectangle (25% of the font size seems to work!) and Center or right align vertical text                      startX += si.FontSize / 4;                        switch (si.TextAlign)                      {                          case TextAlignEnum.Center:                              if (height > 0)                                  startY = y + si.PaddingLeft + (height - si.PaddingLeft - si.PaddingRight) / 2 - textwidth / 2;                              break;                          case TextAlignEnum.Right:                              if (width > 0)                                  startY = y + height - textwidth - si.PaddingRight;                              break;                          case TextAlignEnum.Left:                          default:                              break;                      }                    }                    // Draw background rectangle if needed (only put out on the first line' since we do whole rectangle)                  if (!si.BackgroundColor.IsEmpty && height > 0 && width > 0 && i == 0)                  {	// background color' height and width are specified                      iAddFillRect(x' y' width' height' si.BackgroundColor);                  }                    // Set the clipping path' (Itext have no clip)                  if (height > 0 && width > 0)                  {                      cb.SetRGBColorFill(si.Color.R' si.Color.G' si.Color.B);                        if (si.WritingMode == WritingModeEnum.lr_tb)                      {                          //If textline after measure with word break can fit just simple show Text                          if (width >= textwidth)                          {                              cb.BeginText();                              cb.SetFontAndSize(bf' si.FontSize);                              cb.SetTextMatrix(startX' (_pSize.yHeight - startY - si.FontSize));                              cb.ShowText(text);                              cb.EndText();                          }                          else                          {                              //else use Column text to wrap or clip (wrap: for example a text like an URL so word break is not working here' itextsharp ColumnText do the work for us)                              ColumnText ct = new ColumnText(cb);                              Phrase myPhrase = new Phrase(text' new iTextSharp.text.Font(bf' si.FontSize));                              ct.SetSimpleColumn(myPhrase' x + si.PaddingLeft' _pSize.yHeight - startY' x + width - si.PaddingRight' _pSize.yHeight - y - si.PaddingBottom - height' 10f' align);                              ct.Go();                          }                      }                      else                      {                          //Not checked                          double rads = -283.0 / 180.0;                          double radsCos = Math.Cos(rads);                          double radsSin = Math.Sin(rads);                          cb.BeginText();                          cb.SetFontAndSize(bf' si.FontSize);                          cb.SetTextMatrix((float)radsCos' (float)radsSin' (float)-radsSin' (float)radsCos' startX' _pSize.yHeight - startY);                          cb.ShowText(text);                          cb.EndText();                      }                        //add URL                      if (url != null)  						pdfdocument.Add(new Annotation(x' _pSize.yHeight - (y + height)' width + x' _pSize.yHeight - y' url));                      //add tooltip                      if (tooltip != null)  						pdfdocument.Add(new Annotation(x' _pSize.yHeight - (y + height)' width + x' _pSize.yHeight - y' tooltip));                    }                    // Handle underlining etc.                  float maxX;                  switch (si.TextDecoration)                  {                      case TextDecorationEnum.Underline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + si.FontSize + 1' maxX' startY + si.FontSize + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.LineThrough:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + (si.FontSize / 2) + 1' maxX' startY + (si.FontSize / 2) + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.Overline:                          maxX = width > 0 ? Math.Min(x + width' startX + textwidth) : startX + textwidth;                          iAddLine(startX' startY + 1' maxX' startY + 1' 1' si.Color' BorderStyleEnum.Solid);                          break;                      case TextDecorationEnum.None:                      default:                          break;                  }              }
Magic Number,fyiReporting.RDL,RenderPdf,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderPdf.cs,MeasureStringBlank,The following statement contains a magic number: return width * 2;
Magic Number,fyiReporting.RDL,DataSets,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\DataSets.cs,DataSets,The following statement contains a magic number: if (dsn.Items.Count < 10)  				_Items = new ListDictionary();	// Hashtable is overkill for small lists  			else  				_Items = new Hashtable(dsn.Items.Count);
Magic Number,fyiReporting.RDL,Pages,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\Pages.cs,Pages,The following statement contains a magic number: _bm = new Bitmap(10' 10);
Magic Number,fyiReporting.RDL,Pages,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\Pages.cs,Pages,The following statement contains a magic number: _bm = new Bitmap(10' 10);
Magic Number,fyiReporting.RDL,PageTextHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtml.cs,BuildPrivate,The following statement contains a magic number: int fontSizeModel = 3;
Magic Number,fyiReporting.RDL,PageTextHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtml.cs,BuildPrivate,The following statement contains a magic number: foreach (string token in tokens)  			{  				if (token[0] == PageTextHtmlLexer.HTMLCMD)		// indicates an HTML command  				{  					// we need to create a PageText since the styleinfo is changing  					if (sb.Length != 0)  					{  						pt = new PageText(sb.ToString());                          pt.AllowSelect = false;                          pt.Page = this.Page;                          pt.HtmlParent = this;  						pt.HyperLink = model.HyperLink;  						pt.Tooltip = model.Tooltip;  						pt.NoClip = true;  						sb = new StringBuilder();  						pt.X = this.X + lineXPos;  						pt.Y = this.Y + yPos;  						pt.CanGrow = false;  						pt.SI = CurrentStyle(si).Clone() as StyleInfo;  						_items.Add(pt);  						lineItems.Add(pt);  						ms = this.MeasureString(pt.Text' pt.SI' g' out descent);  						maxDescent = Math.Max(maxDescent' descent);  						pt.W = ms.Width;  						pt.H = ms.Height;  						pt.Descent = descent;  						maxLineHeight = Math.Max(maxLineHeight' ms.Height);  						lineXPos = xPos;  					}  					// Now reset the styleinfo  					StyleInfo cs = CurrentStyle(si);  					string ltoken = token.Substring(1'Math.Min(token.Length-1'10)).ToLower();  					if (ltoken == "<b>" || ltoken == "<strong>")  						cs.FontWeight = FontWeightEnum.Bold;  					else if (ltoken == "</b>" || ltoken == "</strong>")  						cs.FontWeight = FontWeightEnum.Normal;  					else if (ltoken == "<i>" || ltoken == "<cite>" || ltoken == "<var>" || ltoken == "<em>")  						cs.FontStyle = FontStyleEnum.Italic;  					else if (ltoken == "</i>" || ltoken == "</cite>" || ltoken == "</var>" || ltoken == "</em>")  						cs.FontStyle = FontStyleEnum.Normal;  					else if (ltoken == "<code>" || ltoken == "<samp>")  						cs.FontFamily = "Courier New";  					else if (ltoken == "</code>" || ltoken == "</samp>")  						cs.FontFamily = this.SI.FontFamily;  					else if (ltoken == "<kbd>")  					{  						cs.FontFamily = "Courier New";  						cs.FontWeight = FontWeightEnum.Bold;  					}  					else if (ltoken == "</kdd>")  					{  						cs.FontFamily = this.SI.FontFamily;  						cs.FontWeight = FontWeightEnum.Normal;  					}  					else if (ltoken == "<big>")  					{	// big makes it bigger by 20% for each time over the baseline of 3  						fontSizeModel++;  						float inc = 1;  						for (int i=3; i < fontSizeModel; i++)  						{  							inc += .2f;  						}  						float h = this.SI.FontSize * inc;  						cs.FontSize = h;  					}  					else if (ltoken == "</big>")  					{	// undoes the effect of big  						fontSizeModel--;  						float inc = 1;  						for (int i=3; i < fontSizeModel; i++)  						{  							inc += .2f;  						}  						float h = this.SI.FontSize / inc;  						cs.FontSize = h;  					}  					else if (ltoken == "<small>")  					{	// small makes it smaller by 20% for each time under the baseline of 3  						fontSizeModel--;  						float inc = 1;  						for (int i=3; i > fontSizeModel; i--)  						{  							inc += .2f;  						}  						float h = this.SI.FontSize / inc;  						cs.FontSize = h;  					}  					else if (ltoken == "</small>")  					{	// undoes the effect of small  						fontSizeModel++;  						float inc = 1;  						for (int i=3; i > fontSizeModel; i--)  						{  							inc += .2f;  						}  						float h = this.SI.FontSize * inc;  						cs.FontSize = h;  					}  					else if (ltoken.StartsWith("<br"))  					{  						yPos += maxLineHeight;  						NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);  						xPos = lineXPos = maxDescent = 0;  						bFirstInLine = true;  						bWhiteSpace = false;  					}                      else if (ltoken.StartsWith("<hr"))                      {   // Add a line                          // Process existing line if any                          yPos += maxLineHeight;                          NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);                          maxLineHeight = xPos = lineXPos = maxDescent = 0;                          bFirstInLine = true;                          bWhiteSpace = false;                            PageLine pl = new PageLine();                          pl.AllowSelect = false;                          pl.Page = this.Page;                          const int horzLineHeight = 10;                          pl.SI = cs.Clone() as StyleInfo;                          pl.SI.BStyleLeft = BorderStyleEnum.Ridge;                          pl.Y = pl.Y2 = this.Y + yPos + horzLineHeight / 2;                          pl.X = this.X;                          pl.X2 = pl.X + this.W;                          _items.Add(pl);                          yPos += horzLineHeight;  // skip past horizontal line                      }                      else if (ltoken.StartsWith("<p"))  					{  						yPos += maxLineHeight * 2;  						NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);  						maxLineHeight = xPos = lineXPos = maxDescent = 0;  						bFirstInLine = true;  						bWhiteSpace = false;  					}  					else if (ltoken.StartsWith("<a"))  					{  						BuildAnchor(token.Substring(1)' cs' model);  					}                      else if (ltoken.StartsWith("<img"))                      {                          PageImage pimg = BuildImage(g' token.Substring(1)' cs' model);                          if (pimg != null)   // We got an image; add to process list                          {                              pimg.Y = this.Y + yPos;                              pimg.X = this.X;                              _items.Add(pimg);                              yPos += pimg.H;	        // Increment y position                              maxLineHeight = xPos = lineXPos = maxDescent = 0;                              bFirstInLine = true;                              bWhiteSpace = false;                          }                      }                      else if (ltoken == "</a>")                      {                          model.HyperLink = model.Tooltip = null;                          PopStyle();                      }                      else if (ltoken.StartsWith("<span"))                      {                          HandleStyle(token.Substring(1)' si);                      }                      else if (ltoken == "</span>")                      {   // we really should match span and font but it shouldn't matter very often?                          PopStyle();                      }                      else if (ltoken.StartsWith("<font"))                      {                          HandleFont(token.Substring(1)' si);                      }                      else if (ltoken == "</font>")                      {   // we really should match span and font but it shouldn't matter very often?                          PopStyle();                      }                      else if (ltoken.StartsWith("<ol") || ltoken.StartsWith("<ul"))                      {                          yPos += maxLineHeight;                          NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);                          maxLineHeight = xPos = lineXPos = maxDescent = 0;                          bFirstInLine = true;                          bWhiteSpace = false;                            bIsOrderedList = ltoken.StartsWith("<ol");                      }                      else if (ltoken.StartsWith("<li"))                      {                          yPos += maxLineHeight;                          NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);                          maxLineHeight = xPos = lineXPos = maxDescent = 0;                          bFirstInLine = true;                          bWhiteSpace = false;                            if (OlLiCount == null)                              OlLiCount = 0;                          if(bIsOrderedList)                              OlLiCount++;                      }                      else if (ltoken.StartsWith("</ol") || ltoken.StartsWith("</ul"))                      {                          bIsOrderedList = false;                          OlLiCount = null;                      }                                          continue;  				}  				if (token == PageTextHtmlLexer.WHITESPACE)  				{  					if (!bFirstInLine)  						bWhiteSpace = true;  					continue;  				}    				if (token != PageTextHtmlLexer.EOF)  				{  					string ntoken;                      if (token == PageTextHtmlLexer.NBSP.ToString())                          ntoken = bWhiteSpace ? "  " : " ";                      else                          ntoken = bWhiteSpace ? " " + token : token;                      ntoken = ntoken.Replace(PageTextHtmlLexer.NBSP' ' ');    					bWhiteSpace = false;			// can only use whitespace once  					ms = this.MeasureString(ntoken' CurrentStyle(si)' g' out descent);  					if (xPos + ms.Width < textWidth)  					{                          if (bFirstInLine)                          {                              if (OlLiCount == 0)                        //Adds UL bullet                                  sb.Append("   ");                              else if (OlLiCount > 0)                        //Adds OL numeric prefix                                  sb.AppendFormat("{0})   "' OlLiCount);                          }                            bFirstInLine = false;  						sb.Append(ntoken);    						maxDescent = Math.Max(maxDescent' descent);  						maxLineHeight = Math.Max(maxLineHeight' ms.Height);  						xPos += ms.Width;  						continue;  					}  				}  				else if (sb.Length == 0)	// EOF and no previous string means we're done  					continue;    				pt = new PageText(sb.ToString());                  pt.AllowSelect = false;                  pt.Page = this.Page;                  pt.HtmlParent = this;                  pt.NoClip = true;  				pt.HyperLink = model.HyperLink;  				pt.Tooltip = model.Tooltip;  				sb = new StringBuilder();  				sb.Append(token.Replace(PageTextHtmlLexer.NBSP' ' '));  				pt.SI = CurrentStyle(si).Clone() as StyleInfo;  				ms = this.MeasureString(pt.Text' pt.SI' g' out descent);  				pt.X = this.X + lineXPos;  				pt.Y = this.Y + yPos;  				pt.H = ms.Height;  				pt.W = ms.Width;   				pt.Descent = descent;  				pt.CanGrow = false;  				_items.Add(pt);  				lineItems.Add(pt);  				maxDescent = Math.Max(maxDescent' descent);  				maxLineHeight = Math.Max(maxLineHeight' ms.Height);  				yPos += maxLineHeight;	// Increment y position  				NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);  				lineXPos = maxLineHeight = maxDescent = 0;	// start line height over    				// Now set the xPos just after the current token  				ms = this.MeasureString(token' CurrentStyle(si)' g' out descent);  				xPos = ms.Width;	   			}
Magic Number,fyiReporting.RDL,PageTextHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtml.cs,BuildPrivate,The following statement contains a magic number: foreach (string token in tokens)  			{  				if (token[0] == PageTextHtmlLexer.HTMLCMD)		// indicates an HTML command  				{  					// we need to create a PageText since the styleinfo is changing  					if (sb.Length != 0)  					{  						pt = new PageText(sb.ToString());                          pt.AllowSelect = false;                          pt.Page = this.Page;                          pt.HtmlParent = this;  						pt.HyperLink = model.HyperLink;  						pt.Tooltip = model.Tooltip;  						pt.NoClip = true;  						sb = new StringBuilder();  						pt.X = this.X + lineXPos;  						pt.Y = this.Y + yPos;  						pt.CanGrow = false;  						pt.SI = CurrentStyle(si).Clone() as StyleInfo;  						_items.Add(pt);  						lineItems.Add(pt);  						ms = this.MeasureString(pt.Text' pt.SI' g' out descent);  						maxDescent = Math.Max(maxDescent' descent);  						pt.W = ms.Width;  						pt.H = ms.Height;  						pt.Descent = descent;  						maxLineHeight = Math.Max(maxLineHeight' ms.Height);  						lineXPos = xPos;  					}  					// Now reset the styleinfo  					StyleInfo cs = CurrentStyle(si);  					string ltoken = token.Substring(1'Math.Min(token.Length-1'10)).ToLower();  					if (ltoken == "<b>" || ltoken == "<strong>")  						cs.FontWeight = FontWeightEnum.Bold;  					else if (ltoken == "</b>" || ltoken == "</strong>")  						cs.FontWeight = FontWeightEnum.Normal;  					else if (ltoken == "<i>" || ltoken == "<cite>" || ltoken == "<var>" || ltoken == "<em>")  						cs.FontStyle = FontStyleEnum.Italic;  					else if (ltoken == "</i>" || ltoken == "</cite>" || ltoken == "</var>" || ltoken == "</em>")  						cs.FontStyle = FontStyleEnum.Normal;  					else if (ltoken == "<code>" || ltoken == "<samp>")  						cs.FontFamily = "Courier New";  					else if (ltoken == "</code>" || ltoken == "</samp>")  						cs.FontFamily = this.SI.FontFamily;  					else if (ltoken == "<kbd>")  					{  						cs.FontFamily = "Courier New";  						cs.FontWeight = FontWeightEnum.Bold;  					}  					else if (ltoken == "</kdd>")  					{  						cs.FontFamily = this.SI.FontFamily;  						cs.FontWeight = FontWeightEnum.Normal;  					}  					else if (ltoken == "<big>")  					{	// big makes it bigger by 20% for each time over the baseline of 3  						fontSizeModel++;  						float inc = 1;  						for (int i=3; i < fontSizeModel; i++)  						{  							inc += .2f;  						}  						float h = this.SI.FontSize * inc;  						cs.FontSize = h;  					}  					else if (ltoken == "</big>")  					{	// undoes the effect of big  						fontSizeModel--;  						float inc = 1;  						for (int i=3; i < fontSizeModel; i++)  						{  							inc += .2f;  						}  						float h = this.SI.FontSize / inc;  						cs.FontSize = h;  					}  					else if (ltoken == "<small>")  					{	// small makes it smaller by 20% for each time under the baseline of 3  						fontSizeModel--;  						float inc = 1;  						for (int i=3; i > fontSizeModel; i--)  						{  							inc += .2f;  						}  						float h = this.SI.FontSize / inc;  						cs.FontSize = h;  					}  					else if (ltoken == "</small>")  					{	// undoes the effect of small  						fontSizeModel++;  						float inc = 1;  						for (int i=3; i > fontSizeModel; i--)  						{  							inc += .2f;  						}  						float h = this.SI.FontSize * inc;  						cs.FontSize = h;  					}  					else if (ltoken.StartsWith("<br"))  					{  						yPos += maxLineHeight;  						NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);  						xPos = lineXPos = maxDescent = 0;  						bFirstInLine = true;  						bWhiteSpace = false;  					}                      else if (ltoken.StartsWith("<hr"))                      {   // Add a line                          // Process existing line if any                          yPos += maxLineHeight;                          NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);                          maxLineHeight = xPos = lineXPos = maxDescent = 0;                          bFirstInLine = true;                          bWhiteSpace = false;                            PageLine pl = new PageLine();                          pl.AllowSelect = false;                          pl.Page = this.Page;                          const int horzLineHeight = 10;                          pl.SI = cs.Clone() as StyleInfo;                          pl.SI.BStyleLeft = BorderStyleEnum.Ridge;                          pl.Y = pl.Y2 = this.Y + yPos + horzLineHeight / 2;                          pl.X = this.X;                          pl.X2 = pl.X + this.W;                          _items.Add(pl);                          yPos += horzLineHeight;  // skip past horizontal line                      }                      else if (ltoken.StartsWith("<p"))  					{  						yPos += maxLineHeight * 2;  						NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);  						maxLineHeight = xPos = lineXPos = maxDescent = 0;  						bFirstInLine = true;  						bWhiteSpace = false;  					}  					else if (ltoken.StartsWith("<a"))  					{  						BuildAnchor(token.Substring(1)' cs' model);  					}                      else if (ltoken.StartsWith("<img"))                      {                          PageImage pimg = BuildImage(g' token.Substring(1)' cs' model);                          if (pimg != null)   // We got an image; add to process list                          {                              pimg.Y = this.Y + yPos;                              pimg.X = this.X;                              _items.Add(pimg);                              yPos += pimg.H;	        // Increment y position                              maxLineHeight = xPos = lineXPos = maxDescent = 0;                              bFirstInLine = true;                              bWhiteSpace = false;                          }                      }                      else if (ltoken == "</a>")                      {                          model.HyperLink = model.Tooltip = null;                          PopStyle();                      }                      else if (ltoken.StartsWith("<span"))                      {                          HandleStyle(token.Substring(1)' si);                      }                      else if (ltoken == "</span>")                      {   // we really should match span and font but it shouldn't matter very often?                          PopStyle();                      }                      else if (ltoken.StartsWith("<font"))                      {                          HandleFont(token.Substring(1)' si);                      }                      else if (ltoken == "</font>")                      {   // we really should match span and font but it shouldn't matter very often?                          PopStyle();                      }                      else if (ltoken.StartsWith("<ol") || ltoken.StartsWith("<ul"))                      {                          yPos += maxLineHeight;                          NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);                          maxLineHeight = xPos = lineXPos = maxDescent = 0;                          bFirstInLine = true;                          bWhiteSpace = false;                            bIsOrderedList = ltoken.StartsWith("<ol");                      }                      else if (ltoken.StartsWith("<li"))                      {                          yPos += maxLineHeight;                          NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);                          maxLineHeight = xPos = lineXPos = maxDescent = 0;                          bFirstInLine = true;                          bWhiteSpace = false;                            if (OlLiCount == null)                              OlLiCount = 0;                          if(bIsOrderedList)                              OlLiCount++;                      }                      else if (ltoken.StartsWith("</ol") || ltoken.StartsWith("</ul"))                      {                          bIsOrderedList = false;                          OlLiCount = null;                      }                                          continue;  				}  				if (token == PageTextHtmlLexer.WHITESPACE)  				{  					if (!bFirstInLine)  						bWhiteSpace = true;  					continue;  				}    				if (token != PageTextHtmlLexer.EOF)  				{  					string ntoken;                      if (token == PageTextHtmlLexer.NBSP.ToString())                          ntoken = bWhiteSpace ? "  " : " ";                      else                          ntoken = bWhiteSpace ? " " + token : token;                      ntoken = ntoken.Replace(PageTextHtmlLexer.NBSP' ' ');    					bWhiteSpace = false;			// can only use whitespace once  					ms = this.MeasureString(ntoken' CurrentStyle(si)' g' out descent);  					if (xPos + ms.Width < textWidth)  					{                          if (bFirstInLine)                          {                              if (OlLiCount == 0)                        //Adds UL bullet                                  sb.Append("   ");                              else if (OlLiCount > 0)                        //Adds OL numeric prefix                                  sb.AppendFormat("{0})   "' OlLiCount);                          }                            bFirstInLine = false;  						sb.Append(ntoken);    						maxDescent = Math.Max(maxDescent' descent);  						maxLineHeight = Math.Max(maxLineHeight' ms.Height);  						xPos += ms.Width;  						continue;  					}  				}  				else if (sb.Length == 0)	// EOF and no previous string means we're done  					continue;    				pt = new PageText(sb.ToString());                  pt.AllowSelect = false;                  pt.Page = this.Page;                  pt.HtmlParent = this;                  pt.NoClip = true;  				pt.HyperLink = model.HyperLink;  				pt.Tooltip = model.Tooltip;  				sb = new StringBuilder();  				sb.Append(token.Replace(PageTextHtmlLexer.NBSP' ' '));  				pt.SI = CurrentStyle(si).Clone() as StyleInfo;  				ms = this.MeasureString(pt.Text' pt.SI' g' out descent);  				pt.X = this.X + lineXPos;  				pt.Y = this.Y + yPos;  				pt.H = ms.Height;  				pt.W = ms.Width;   				pt.Descent = descent;  				pt.CanGrow = false;  				_items.Add(pt);  				lineItems.Add(pt);  				maxDescent = Math.Max(maxDescent' descent);  				maxLineHeight = Math.Max(maxLineHeight' ms.Height);  				yPos += maxLineHeight;	// Increment y position  				NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);  				lineXPos = maxLineHeight = maxDescent = 0;	// start line height over    				// Now set the xPos just after the current token  				ms = this.MeasureString(token' CurrentStyle(si)' g' out descent);  				xPos = ms.Width;	   			}
Magic Number,fyiReporting.RDL,PageTextHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtml.cs,BuildPrivate,The following statement contains a magic number: foreach (string token in tokens)  			{  				if (token[0] == PageTextHtmlLexer.HTMLCMD)		// indicates an HTML command  				{  					// we need to create a PageText since the styleinfo is changing  					if (sb.Length != 0)  					{  						pt = new PageText(sb.ToString());                          pt.AllowSelect = false;                          pt.Page = this.Page;                          pt.HtmlParent = this;  						pt.HyperLink = model.HyperLink;  						pt.Tooltip = model.Tooltip;  						pt.NoClip = true;  						sb = new StringBuilder();  						pt.X = this.X + lineXPos;  						pt.Y = this.Y + yPos;  						pt.CanGrow = false;  						pt.SI = CurrentStyle(si).Clone() as StyleInfo;  						_items.Add(pt);  						lineItems.Add(pt);  						ms = this.MeasureString(pt.Text' pt.SI' g' out descent);  						maxDescent = Math.Max(maxDescent' descent);  						pt.W = ms.Width;  						pt.H = ms.Height;  						pt.Descent = descent;  						maxLineHeight = Math.Max(maxLineHeight' ms.Height);  						lineXPos = xPos;  					}  					// Now reset the styleinfo  					StyleInfo cs = CurrentStyle(si);  					string ltoken = token.Substring(1'Math.Min(token.Length-1'10)).ToLower();  					if (ltoken == "<b>" || ltoken == "<strong>")  						cs.FontWeight = FontWeightEnum.Bold;  					else if (ltoken == "</b>" || ltoken == "</strong>")  						cs.FontWeight = FontWeightEnum.Normal;  					else if (ltoken == "<i>" || ltoken == "<cite>" || ltoken == "<var>" || ltoken == "<em>")  						cs.FontStyle = FontStyleEnum.Italic;  					else if (ltoken == "</i>" || ltoken == "</cite>" || ltoken == "</var>" || ltoken == "</em>")  						cs.FontStyle = FontStyleEnum.Normal;  					else if (ltoken == "<code>" || ltoken == "<samp>")  						cs.FontFamily = "Courier New";  					else if (ltoken == "</code>" || ltoken == "</samp>")  						cs.FontFamily = this.SI.FontFamily;  					else if (ltoken == "<kbd>")  					{  						cs.FontFamily = "Courier New";  						cs.FontWeight = FontWeightEnum.Bold;  					}  					else if (ltoken == "</kdd>")  					{  						cs.FontFamily = this.SI.FontFamily;  						cs.FontWeight = FontWeightEnum.Normal;  					}  					else if (ltoken == "<big>")  					{	// big makes it bigger by 20% for each time over the baseline of 3  						fontSizeModel++;  						float inc = 1;  						for (int i=3; i < fontSizeModel; i++)  						{  							inc += .2f;  						}  						float h = this.SI.FontSize * inc;  						cs.FontSize = h;  					}  					else if (ltoken == "</big>")  					{	// undoes the effect of big  						fontSizeModel--;  						float inc = 1;  						for (int i=3; i < fontSizeModel; i++)  						{  							inc += .2f;  						}  						float h = this.SI.FontSize / inc;  						cs.FontSize = h;  					}  					else if (ltoken == "<small>")  					{	// small makes it smaller by 20% for each time under the baseline of 3  						fontSizeModel--;  						float inc = 1;  						for (int i=3; i > fontSizeModel; i--)  						{  							inc += .2f;  						}  						float h = this.SI.FontSize / inc;  						cs.FontSize = h;  					}  					else if (ltoken == "</small>")  					{	// undoes the effect of small  						fontSizeModel++;  						float inc = 1;  						for (int i=3; i > fontSizeModel; i--)  						{  							inc += .2f;  						}  						float h = this.SI.FontSize * inc;  						cs.FontSize = h;  					}  					else if (ltoken.StartsWith("<br"))  					{  						yPos += maxLineHeight;  						NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);  						xPos = lineXPos = maxDescent = 0;  						bFirstInLine = true;  						bWhiteSpace = false;  					}                      else if (ltoken.StartsWith("<hr"))                      {   // Add a line                          // Process existing line if any                          yPos += maxLineHeight;                          NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);                          maxLineHeight = xPos = lineXPos = maxDescent = 0;                          bFirstInLine = true;                          bWhiteSpace = false;                            PageLine pl = new PageLine();                          pl.AllowSelect = false;                          pl.Page = this.Page;                          const int horzLineHeight = 10;                          pl.SI = cs.Clone() as StyleInfo;                          pl.SI.BStyleLeft = BorderStyleEnum.Ridge;                          pl.Y = pl.Y2 = this.Y + yPos + horzLineHeight / 2;                          pl.X = this.X;                          pl.X2 = pl.X + this.W;                          _items.Add(pl);                          yPos += horzLineHeight;  // skip past horizontal line                      }                      else if (ltoken.StartsWith("<p"))  					{  						yPos += maxLineHeight * 2;  						NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);  						maxLineHeight = xPos = lineXPos = maxDescent = 0;  						bFirstInLine = true;  						bWhiteSpace = false;  					}  					else if (ltoken.StartsWith("<a"))  					{  						BuildAnchor(token.Substring(1)' cs' model);  					}                      else if (ltoken.StartsWith("<img"))                      {                          PageImage pimg = BuildImage(g' token.Substring(1)' cs' model);                          if (pimg != null)   // We got an image; add to process list                          {                              pimg.Y = this.Y + yPos;                              pimg.X = this.X;                              _items.Add(pimg);                              yPos += pimg.H;	        // Increment y position                              maxLineHeight = xPos = lineXPos = maxDescent = 0;                              bFirstInLine = true;                              bWhiteSpace = false;                          }                      }                      else if (ltoken == "</a>")                      {                          model.HyperLink = model.Tooltip = null;                          PopStyle();                      }                      else if (ltoken.StartsWith("<span"))                      {                          HandleStyle(token.Substring(1)' si);                      }                      else if (ltoken == "</span>")                      {   // we really should match span and font but it shouldn't matter very often?                          PopStyle();                      }                      else if (ltoken.StartsWith("<font"))                      {                          HandleFont(token.Substring(1)' si);                      }                      else if (ltoken == "</font>")                      {   // we really should match span and font but it shouldn't matter very often?                          PopStyle();                      }                      else if (ltoken.StartsWith("<ol") || ltoken.StartsWith("<ul"))                      {                          yPos += maxLineHeight;                          NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);                          maxLineHeight = xPos = lineXPos = maxDescent = 0;                          bFirstInLine = true;                          bWhiteSpace = false;                            bIsOrderedList = ltoken.StartsWith("<ol");                      }                      else if (ltoken.StartsWith("<li"))                      {                          yPos += maxLineHeight;                          NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);                          maxLineHeight = xPos = lineXPos = maxDescent = 0;                          bFirstInLine = true;                          bWhiteSpace = false;                            if (OlLiCount == null)                              OlLiCount = 0;                          if(bIsOrderedList)                              OlLiCount++;                      }                      else if (ltoken.StartsWith("</ol") || ltoken.StartsWith("</ul"))                      {                          bIsOrderedList = false;                          OlLiCount = null;                      }                                          continue;  				}  				if (token == PageTextHtmlLexer.WHITESPACE)  				{  					if (!bFirstInLine)  						bWhiteSpace = true;  					continue;  				}    				if (token != PageTextHtmlLexer.EOF)  				{  					string ntoken;                      if (token == PageTextHtmlLexer.NBSP.ToString())                          ntoken = bWhiteSpace ? "  " : " ";                      else                          ntoken = bWhiteSpace ? " " + token : token;                      ntoken = ntoken.Replace(PageTextHtmlLexer.NBSP' ' ');    					bWhiteSpace = false;			// can only use whitespace once  					ms = this.MeasureString(ntoken' CurrentStyle(si)' g' out descent);  					if (xPos + ms.Width < textWidth)  					{                          if (bFirstInLine)                          {                              if (OlLiCount == 0)                        //Adds UL bullet                                  sb.Append("   ");                              else if (OlLiCount > 0)                        //Adds OL numeric prefix                                  sb.AppendFormat("{0})   "' OlLiCount);                          }                            bFirstInLine = false;  						sb.Append(ntoken);    						maxDescent = Math.Max(maxDescent' descent);  						maxLineHeight = Math.Max(maxLineHeight' ms.Height);  						xPos += ms.Width;  						continue;  					}  				}  				else if (sb.Length == 0)	// EOF and no previous string means we're done  					continue;    				pt = new PageText(sb.ToString());                  pt.AllowSelect = false;                  pt.Page = this.Page;                  pt.HtmlParent = this;                  pt.NoClip = true;  				pt.HyperLink = model.HyperLink;  				pt.Tooltip = model.Tooltip;  				sb = new StringBuilder();  				sb.Append(token.Replace(PageTextHtmlLexer.NBSP' ' '));  				pt.SI = CurrentStyle(si).Clone() as StyleInfo;  				ms = this.MeasureString(pt.Text' pt.SI' g' out descent);  				pt.X = this.X + lineXPos;  				pt.Y = this.Y + yPos;  				pt.H = ms.Height;  				pt.W = ms.Width;   				pt.Descent = descent;  				pt.CanGrow = false;  				_items.Add(pt);  				lineItems.Add(pt);  				maxDescent = Math.Max(maxDescent' descent);  				maxLineHeight = Math.Max(maxLineHeight' ms.Height);  				yPos += maxLineHeight;	// Increment y position  				NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);  				lineXPos = maxLineHeight = maxDescent = 0;	// start line height over    				// Now set the xPos just after the current token  				ms = this.MeasureString(token' CurrentStyle(si)' g' out descent);  				xPos = ms.Width;	   			}
Magic Number,fyiReporting.RDL,PageTextHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtml.cs,BuildPrivate,The following statement contains a magic number: foreach (string token in tokens)  			{  				if (token[0] == PageTextHtmlLexer.HTMLCMD)		// indicates an HTML command  				{  					// we need to create a PageText since the styleinfo is changing  					if (sb.Length != 0)  					{  						pt = new PageText(sb.ToString());                          pt.AllowSelect = false;                          pt.Page = this.Page;                          pt.HtmlParent = this;  						pt.HyperLink = model.HyperLink;  						pt.Tooltip = model.Tooltip;  						pt.NoClip = true;  						sb = new StringBuilder();  						pt.X = this.X + lineXPos;  						pt.Y = this.Y + yPos;  						pt.CanGrow = false;  						pt.SI = CurrentStyle(si).Clone() as StyleInfo;  						_items.Add(pt);  						lineItems.Add(pt);  						ms = this.MeasureString(pt.Text' pt.SI' g' out descent);  						maxDescent = Math.Max(maxDescent' descent);  						pt.W = ms.Width;  						pt.H = ms.Height;  						pt.Descent = descent;  						maxLineHeight = Math.Max(maxLineHeight' ms.Height);  						lineXPos = xPos;  					}  					// Now reset the styleinfo  					StyleInfo cs = CurrentStyle(si);  					string ltoken = token.Substring(1'Math.Min(token.Length-1'10)).ToLower();  					if (ltoken == "<b>" || ltoken == "<strong>")  						cs.FontWeight = FontWeightEnum.Bold;  					else if (ltoken == "</b>" || ltoken == "</strong>")  						cs.FontWeight = FontWeightEnum.Normal;  					else if (ltoken == "<i>" || ltoken == "<cite>" || ltoken == "<var>" || ltoken == "<em>")  						cs.FontStyle = FontStyleEnum.Italic;  					else if (ltoken == "</i>" || ltoken == "</cite>" || ltoken == "</var>" || ltoken == "</em>")  						cs.FontStyle = FontStyleEnum.Normal;  					else if (ltoken == "<code>" || ltoken == "<samp>")  						cs.FontFamily = "Courier New";  					else if (ltoken == "</code>" || ltoken == "</samp>")  						cs.FontFamily = this.SI.FontFamily;  					else if (ltoken == "<kbd>")  					{  						cs.FontFamily = "Courier New";  						cs.FontWeight = FontWeightEnum.Bold;  					}  					else if (ltoken == "</kdd>")  					{  						cs.FontFamily = this.SI.FontFamily;  						cs.FontWeight = FontWeightEnum.Normal;  					}  					else if (ltoken == "<big>")  					{	// big makes it bigger by 20% for each time over the baseline of 3  						fontSizeModel++;  						float inc = 1;  						for (int i=3; i < fontSizeModel; i++)  						{  							inc += .2f;  						}  						float h = this.SI.FontSize * inc;  						cs.FontSize = h;  					}  					else if (ltoken == "</big>")  					{	// undoes the effect of big  						fontSizeModel--;  						float inc = 1;  						for (int i=3; i < fontSizeModel; i++)  						{  							inc += .2f;  						}  						float h = this.SI.FontSize / inc;  						cs.FontSize = h;  					}  					else if (ltoken == "<small>")  					{	// small makes it smaller by 20% for each time under the baseline of 3  						fontSizeModel--;  						float inc = 1;  						for (int i=3; i > fontSizeModel; i--)  						{  							inc += .2f;  						}  						float h = this.SI.FontSize / inc;  						cs.FontSize = h;  					}  					else if (ltoken == "</small>")  					{	// undoes the effect of small  						fontSizeModel++;  						float inc = 1;  						for (int i=3; i > fontSizeModel; i--)  						{  							inc += .2f;  						}  						float h = this.SI.FontSize * inc;  						cs.FontSize = h;  					}  					else if (ltoken.StartsWith("<br"))  					{  						yPos += maxLineHeight;  						NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);  						xPos = lineXPos = maxDescent = 0;  						bFirstInLine = true;  						bWhiteSpace = false;  					}                      else if (ltoken.StartsWith("<hr"))                      {   // Add a line                          // Process existing line if any                          yPos += maxLineHeight;                          NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);                          maxLineHeight = xPos = lineXPos = maxDescent = 0;                          bFirstInLine = true;                          bWhiteSpace = false;                            PageLine pl = new PageLine();                          pl.AllowSelect = false;                          pl.Page = this.Page;                          const int horzLineHeight = 10;                          pl.SI = cs.Clone() as StyleInfo;                          pl.SI.BStyleLeft = BorderStyleEnum.Ridge;                          pl.Y = pl.Y2 = this.Y + yPos + horzLineHeight / 2;                          pl.X = this.X;                          pl.X2 = pl.X + this.W;                          _items.Add(pl);                          yPos += horzLineHeight;  // skip past horizontal line                      }                      else if (ltoken.StartsWith("<p"))  					{  						yPos += maxLineHeight * 2;  						NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);  						maxLineHeight = xPos = lineXPos = maxDescent = 0;  						bFirstInLine = true;  						bWhiteSpace = false;  					}  					else if (ltoken.StartsWith("<a"))  					{  						BuildAnchor(token.Substring(1)' cs' model);  					}                      else if (ltoken.StartsWith("<img"))                      {                          PageImage pimg = BuildImage(g' token.Substring(1)' cs' model);                          if (pimg != null)   // We got an image; add to process list                          {                              pimg.Y = this.Y + yPos;                              pimg.X = this.X;                              _items.Add(pimg);                              yPos += pimg.H;	        // Increment y position                              maxLineHeight = xPos = lineXPos = maxDescent = 0;                              bFirstInLine = true;                              bWhiteSpace = false;                          }                      }                      else if (ltoken == "</a>")                      {                          model.HyperLink = model.Tooltip = null;                          PopStyle();                      }                      else if (ltoken.StartsWith("<span"))                      {                          HandleStyle(token.Substring(1)' si);                      }                      else if (ltoken == "</span>")                      {   // we really should match span and font but it shouldn't matter very often?                          PopStyle();                      }                      else if (ltoken.StartsWith("<font"))                      {                          HandleFont(token.Substring(1)' si);                      }                      else if (ltoken == "</font>")                      {   // we really should match span and font but it shouldn't matter very often?                          PopStyle();                      }                      else if (ltoken.StartsWith("<ol") || ltoken.StartsWith("<ul"))                      {                          yPos += maxLineHeight;                          NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);                          maxLineHeight = xPos = lineXPos = maxDescent = 0;                          bFirstInLine = true;                          bWhiteSpace = false;                            bIsOrderedList = ltoken.StartsWith("<ol");                      }                      else if (ltoken.StartsWith("<li"))                      {                          yPos += maxLineHeight;                          NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);                          maxLineHeight = xPos = lineXPos = maxDescent = 0;                          bFirstInLine = true;                          bWhiteSpace = false;                            if (OlLiCount == null)                              OlLiCount = 0;                          if(bIsOrderedList)                              OlLiCount++;                      }                      else if (ltoken.StartsWith("</ol") || ltoken.StartsWith("</ul"))                      {                          bIsOrderedList = false;                          OlLiCount = null;                      }                                          continue;  				}  				if (token == PageTextHtmlLexer.WHITESPACE)  				{  					if (!bFirstInLine)  						bWhiteSpace = true;  					continue;  				}    				if (token != PageTextHtmlLexer.EOF)  				{  					string ntoken;                      if (token == PageTextHtmlLexer.NBSP.ToString())                          ntoken = bWhiteSpace ? "  " : " ";                      else                          ntoken = bWhiteSpace ? " " + token : token;                      ntoken = ntoken.Replace(PageTextHtmlLexer.NBSP' ' ');    					bWhiteSpace = false;			// can only use whitespace once  					ms = this.MeasureString(ntoken' CurrentStyle(si)' g' out descent);  					if (xPos + ms.Width < textWidth)  					{                          if (bFirstInLine)                          {                              if (OlLiCount == 0)                        //Adds UL bullet                                  sb.Append("   ");                              else if (OlLiCount > 0)                        //Adds OL numeric prefix                                  sb.AppendFormat("{0})   "' OlLiCount);                          }                            bFirstInLine = false;  						sb.Append(ntoken);    						maxDescent = Math.Max(maxDescent' descent);  						maxLineHeight = Math.Max(maxLineHeight' ms.Height);  						xPos += ms.Width;  						continue;  					}  				}  				else if (sb.Length == 0)	// EOF and no previous string means we're done  					continue;    				pt = new PageText(sb.ToString());                  pt.AllowSelect = false;                  pt.Page = this.Page;                  pt.HtmlParent = this;                  pt.NoClip = true;  				pt.HyperLink = model.HyperLink;  				pt.Tooltip = model.Tooltip;  				sb = new StringBuilder();  				sb.Append(token.Replace(PageTextHtmlLexer.NBSP' ' '));  				pt.SI = CurrentStyle(si).Clone() as StyleInfo;  				ms = this.MeasureString(pt.Text' pt.SI' g' out descent);  				pt.X = this.X + lineXPos;  				pt.Y = this.Y + yPos;  				pt.H = ms.Height;  				pt.W = ms.Width;   				pt.Descent = descent;  				pt.CanGrow = false;  				_items.Add(pt);  				lineItems.Add(pt);  				maxDescent = Math.Max(maxDescent' descent);  				maxLineHeight = Math.Max(maxLineHeight' ms.Height);  				yPos += maxLineHeight;	// Increment y position  				NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);  				lineXPos = maxLineHeight = maxDescent = 0;	// start line height over    				// Now set the xPos just after the current token  				ms = this.MeasureString(token' CurrentStyle(si)' g' out descent);  				xPos = ms.Width;	   			}
Magic Number,fyiReporting.RDL,PageTextHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtml.cs,BuildPrivate,The following statement contains a magic number: foreach (string token in tokens)  			{  				if (token[0] == PageTextHtmlLexer.HTMLCMD)		// indicates an HTML command  				{  					// we need to create a PageText since the styleinfo is changing  					if (sb.Length != 0)  					{  						pt = new PageText(sb.ToString());                          pt.AllowSelect = false;                          pt.Page = this.Page;                          pt.HtmlParent = this;  						pt.HyperLink = model.HyperLink;  						pt.Tooltip = model.Tooltip;  						pt.NoClip = true;  						sb = new StringBuilder();  						pt.X = this.X + lineXPos;  						pt.Y = this.Y + yPos;  						pt.CanGrow = false;  						pt.SI = CurrentStyle(si).Clone() as StyleInfo;  						_items.Add(pt);  						lineItems.Add(pt);  						ms = this.MeasureString(pt.Text' pt.SI' g' out descent);  						maxDescent = Math.Max(maxDescent' descent);  						pt.W = ms.Width;  						pt.H = ms.Height;  						pt.Descent = descent;  						maxLineHeight = Math.Max(maxLineHeight' ms.Height);  						lineXPos = xPos;  					}  					// Now reset the styleinfo  					StyleInfo cs = CurrentStyle(si);  					string ltoken = token.Substring(1'Math.Min(token.Length-1'10)).ToLower();  					if (ltoken == "<b>" || ltoken == "<strong>")  						cs.FontWeight = FontWeightEnum.Bold;  					else if (ltoken == "</b>" || ltoken == "</strong>")  						cs.FontWeight = FontWeightEnum.Normal;  					else if (ltoken == "<i>" || ltoken == "<cite>" || ltoken == "<var>" || ltoken == "<em>")  						cs.FontStyle = FontStyleEnum.Italic;  					else if (ltoken == "</i>" || ltoken == "</cite>" || ltoken == "</var>" || ltoken == "</em>")  						cs.FontStyle = FontStyleEnum.Normal;  					else if (ltoken == "<code>" || ltoken == "<samp>")  						cs.FontFamily = "Courier New";  					else if (ltoken == "</code>" || ltoken == "</samp>")  						cs.FontFamily = this.SI.FontFamily;  					else if (ltoken == "<kbd>")  					{  						cs.FontFamily = "Courier New";  						cs.FontWeight = FontWeightEnum.Bold;  					}  					else if (ltoken == "</kdd>")  					{  						cs.FontFamily = this.SI.FontFamily;  						cs.FontWeight = FontWeightEnum.Normal;  					}  					else if (ltoken == "<big>")  					{	// big makes it bigger by 20% for each time over the baseline of 3  						fontSizeModel++;  						float inc = 1;  						for (int i=3; i < fontSizeModel; i++)  						{  							inc += .2f;  						}  						float h = this.SI.FontSize * inc;  						cs.FontSize = h;  					}  					else if (ltoken == "</big>")  					{	// undoes the effect of big  						fontSizeModel--;  						float inc = 1;  						for (int i=3; i < fontSizeModel; i++)  						{  							inc += .2f;  						}  						float h = this.SI.FontSize / inc;  						cs.FontSize = h;  					}  					else if (ltoken == "<small>")  					{	// small makes it smaller by 20% for each time under the baseline of 3  						fontSizeModel--;  						float inc = 1;  						for (int i=3; i > fontSizeModel; i--)  						{  							inc += .2f;  						}  						float h = this.SI.FontSize / inc;  						cs.FontSize = h;  					}  					else if (ltoken == "</small>")  					{	// undoes the effect of small  						fontSizeModel++;  						float inc = 1;  						for (int i=3; i > fontSizeModel; i--)  						{  							inc += .2f;  						}  						float h = this.SI.FontSize * inc;  						cs.FontSize = h;  					}  					else if (ltoken.StartsWith("<br"))  					{  						yPos += maxLineHeight;  						NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);  						xPos = lineXPos = maxDescent = 0;  						bFirstInLine = true;  						bWhiteSpace = false;  					}                      else if (ltoken.StartsWith("<hr"))                      {   // Add a line                          // Process existing line if any                          yPos += maxLineHeight;                          NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);                          maxLineHeight = xPos = lineXPos = maxDescent = 0;                          bFirstInLine = true;                          bWhiteSpace = false;                            PageLine pl = new PageLine();                          pl.AllowSelect = false;                          pl.Page = this.Page;                          const int horzLineHeight = 10;                          pl.SI = cs.Clone() as StyleInfo;                          pl.SI.BStyleLeft = BorderStyleEnum.Ridge;                          pl.Y = pl.Y2 = this.Y + yPos + horzLineHeight / 2;                          pl.X = this.X;                          pl.X2 = pl.X + this.W;                          _items.Add(pl);                          yPos += horzLineHeight;  // skip past horizontal line                      }                      else if (ltoken.StartsWith("<p"))  					{  						yPos += maxLineHeight * 2;  						NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);  						maxLineHeight = xPos = lineXPos = maxDescent = 0;  						bFirstInLine = true;  						bWhiteSpace = false;  					}  					else if (ltoken.StartsWith("<a"))  					{  						BuildAnchor(token.Substring(1)' cs' model);  					}                      else if (ltoken.StartsWith("<img"))                      {                          PageImage pimg = BuildImage(g' token.Substring(1)' cs' model);                          if (pimg != null)   // We got an image; add to process list                          {                              pimg.Y = this.Y + yPos;                              pimg.X = this.X;                              _items.Add(pimg);                              yPos += pimg.H;	        // Increment y position                              maxLineHeight = xPos = lineXPos = maxDescent = 0;                              bFirstInLine = true;                              bWhiteSpace = false;                          }                      }                      else if (ltoken == "</a>")                      {                          model.HyperLink = model.Tooltip = null;                          PopStyle();                      }                      else if (ltoken.StartsWith("<span"))                      {                          HandleStyle(token.Substring(1)' si);                      }                      else if (ltoken == "</span>")                      {   // we really should match span and font but it shouldn't matter very often?                          PopStyle();                      }                      else if (ltoken.StartsWith("<font"))                      {                          HandleFont(token.Substring(1)' si);                      }                      else if (ltoken == "</font>")                      {   // we really should match span and font but it shouldn't matter very often?                          PopStyle();                      }                      else if (ltoken.StartsWith("<ol") || ltoken.StartsWith("<ul"))                      {                          yPos += maxLineHeight;                          NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);                          maxLineHeight = xPos = lineXPos = maxDescent = 0;                          bFirstInLine = true;                          bWhiteSpace = false;                            bIsOrderedList = ltoken.StartsWith("<ol");                      }                      else if (ltoken.StartsWith("<li"))                      {                          yPos += maxLineHeight;                          NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);                          maxLineHeight = xPos = lineXPos = maxDescent = 0;                          bFirstInLine = true;                          bWhiteSpace = false;                            if (OlLiCount == null)                              OlLiCount = 0;                          if(bIsOrderedList)                              OlLiCount++;                      }                      else if (ltoken.StartsWith("</ol") || ltoken.StartsWith("</ul"))                      {                          bIsOrderedList = false;                          OlLiCount = null;                      }                                          continue;  				}  				if (token == PageTextHtmlLexer.WHITESPACE)  				{  					if (!bFirstInLine)  						bWhiteSpace = true;  					continue;  				}    				if (token != PageTextHtmlLexer.EOF)  				{  					string ntoken;                      if (token == PageTextHtmlLexer.NBSP.ToString())                          ntoken = bWhiteSpace ? "  " : " ";                      else                          ntoken = bWhiteSpace ? " " + token : token;                      ntoken = ntoken.Replace(PageTextHtmlLexer.NBSP' ' ');    					bWhiteSpace = false;			// can only use whitespace once  					ms = this.MeasureString(ntoken' CurrentStyle(si)' g' out descent);  					if (xPos + ms.Width < textWidth)  					{                          if (bFirstInLine)                          {                              if (OlLiCount == 0)                        //Adds UL bullet                                  sb.Append("   ");                              else if (OlLiCount > 0)                        //Adds OL numeric prefix                                  sb.AppendFormat("{0})   "' OlLiCount);                          }                            bFirstInLine = false;  						sb.Append(ntoken);    						maxDescent = Math.Max(maxDescent' descent);  						maxLineHeight = Math.Max(maxLineHeight' ms.Height);  						xPos += ms.Width;  						continue;  					}  				}  				else if (sb.Length == 0)	// EOF and no previous string means we're done  					continue;    				pt = new PageText(sb.ToString());                  pt.AllowSelect = false;                  pt.Page = this.Page;                  pt.HtmlParent = this;                  pt.NoClip = true;  				pt.HyperLink = model.HyperLink;  				pt.Tooltip = model.Tooltip;  				sb = new StringBuilder();  				sb.Append(token.Replace(PageTextHtmlLexer.NBSP' ' '));  				pt.SI = CurrentStyle(si).Clone() as StyleInfo;  				ms = this.MeasureString(pt.Text' pt.SI' g' out descent);  				pt.X = this.X + lineXPos;  				pt.Y = this.Y + yPos;  				pt.H = ms.Height;  				pt.W = ms.Width;   				pt.Descent = descent;  				pt.CanGrow = false;  				_items.Add(pt);  				lineItems.Add(pt);  				maxDescent = Math.Max(maxDescent' descent);  				maxLineHeight = Math.Max(maxLineHeight' ms.Height);  				yPos += maxLineHeight;	// Increment y position  				NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);  				lineXPos = maxLineHeight = maxDescent = 0;	// start line height over    				// Now set the xPos just after the current token  				ms = this.MeasureString(token' CurrentStyle(si)' g' out descent);  				xPos = ms.Width;	   			}
Magic Number,fyiReporting.RDL,PageTextHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtml.cs,BuildPrivate,The following statement contains a magic number: foreach (string token in tokens)  			{  				if (token[0] == PageTextHtmlLexer.HTMLCMD)		// indicates an HTML command  				{  					// we need to create a PageText since the styleinfo is changing  					if (sb.Length != 0)  					{  						pt = new PageText(sb.ToString());                          pt.AllowSelect = false;                          pt.Page = this.Page;                          pt.HtmlParent = this;  						pt.HyperLink = model.HyperLink;  						pt.Tooltip = model.Tooltip;  						pt.NoClip = true;  						sb = new StringBuilder();  						pt.X = this.X + lineXPos;  						pt.Y = this.Y + yPos;  						pt.CanGrow = false;  						pt.SI = CurrentStyle(si).Clone() as StyleInfo;  						_items.Add(pt);  						lineItems.Add(pt);  						ms = this.MeasureString(pt.Text' pt.SI' g' out descent);  						maxDescent = Math.Max(maxDescent' descent);  						pt.W = ms.Width;  						pt.H = ms.Height;  						pt.Descent = descent;  						maxLineHeight = Math.Max(maxLineHeight' ms.Height);  						lineXPos = xPos;  					}  					// Now reset the styleinfo  					StyleInfo cs = CurrentStyle(si);  					string ltoken = token.Substring(1'Math.Min(token.Length-1'10)).ToLower();  					if (ltoken == "<b>" || ltoken == "<strong>")  						cs.FontWeight = FontWeightEnum.Bold;  					else if (ltoken == "</b>" || ltoken == "</strong>")  						cs.FontWeight = FontWeightEnum.Normal;  					else if (ltoken == "<i>" || ltoken == "<cite>" || ltoken == "<var>" || ltoken == "<em>")  						cs.FontStyle = FontStyleEnum.Italic;  					else if (ltoken == "</i>" || ltoken == "</cite>" || ltoken == "</var>" || ltoken == "</em>")  						cs.FontStyle = FontStyleEnum.Normal;  					else if (ltoken == "<code>" || ltoken == "<samp>")  						cs.FontFamily = "Courier New";  					else if (ltoken == "</code>" || ltoken == "</samp>")  						cs.FontFamily = this.SI.FontFamily;  					else if (ltoken == "<kbd>")  					{  						cs.FontFamily = "Courier New";  						cs.FontWeight = FontWeightEnum.Bold;  					}  					else if (ltoken == "</kdd>")  					{  						cs.FontFamily = this.SI.FontFamily;  						cs.FontWeight = FontWeightEnum.Normal;  					}  					else if (ltoken == "<big>")  					{	// big makes it bigger by 20% for each time over the baseline of 3  						fontSizeModel++;  						float inc = 1;  						for (int i=3; i < fontSizeModel; i++)  						{  							inc += .2f;  						}  						float h = this.SI.FontSize * inc;  						cs.FontSize = h;  					}  					else if (ltoken == "</big>")  					{	// undoes the effect of big  						fontSizeModel--;  						float inc = 1;  						for (int i=3; i < fontSizeModel; i++)  						{  							inc += .2f;  						}  						float h = this.SI.FontSize / inc;  						cs.FontSize = h;  					}  					else if (ltoken == "<small>")  					{	// small makes it smaller by 20% for each time under the baseline of 3  						fontSizeModel--;  						float inc = 1;  						for (int i=3; i > fontSizeModel; i--)  						{  							inc += .2f;  						}  						float h = this.SI.FontSize / inc;  						cs.FontSize = h;  					}  					else if (ltoken == "</small>")  					{	// undoes the effect of small  						fontSizeModel++;  						float inc = 1;  						for (int i=3; i > fontSizeModel; i--)  						{  							inc += .2f;  						}  						float h = this.SI.FontSize * inc;  						cs.FontSize = h;  					}  					else if (ltoken.StartsWith("<br"))  					{  						yPos += maxLineHeight;  						NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);  						xPos = lineXPos = maxDescent = 0;  						bFirstInLine = true;  						bWhiteSpace = false;  					}                      else if (ltoken.StartsWith("<hr"))                      {   // Add a line                          // Process existing line if any                          yPos += maxLineHeight;                          NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);                          maxLineHeight = xPos = lineXPos = maxDescent = 0;                          bFirstInLine = true;                          bWhiteSpace = false;                            PageLine pl = new PageLine();                          pl.AllowSelect = false;                          pl.Page = this.Page;                          const int horzLineHeight = 10;                          pl.SI = cs.Clone() as StyleInfo;                          pl.SI.BStyleLeft = BorderStyleEnum.Ridge;                          pl.Y = pl.Y2 = this.Y + yPos + horzLineHeight / 2;                          pl.X = this.X;                          pl.X2 = pl.X + this.W;                          _items.Add(pl);                          yPos += horzLineHeight;  // skip past horizontal line                      }                      else if (ltoken.StartsWith("<p"))  					{  						yPos += maxLineHeight * 2;  						NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);  						maxLineHeight = xPos = lineXPos = maxDescent = 0;  						bFirstInLine = true;  						bWhiteSpace = false;  					}  					else if (ltoken.StartsWith("<a"))  					{  						BuildAnchor(token.Substring(1)' cs' model);  					}                      else if (ltoken.StartsWith("<img"))                      {                          PageImage pimg = BuildImage(g' token.Substring(1)' cs' model);                          if (pimg != null)   // We got an image; add to process list                          {                              pimg.Y = this.Y + yPos;                              pimg.X = this.X;                              _items.Add(pimg);                              yPos += pimg.H;	        // Increment y position                              maxLineHeight = xPos = lineXPos = maxDescent = 0;                              bFirstInLine = true;                              bWhiteSpace = false;                          }                      }                      else if (ltoken == "</a>")                      {                          model.HyperLink = model.Tooltip = null;                          PopStyle();                      }                      else if (ltoken.StartsWith("<span"))                      {                          HandleStyle(token.Substring(1)' si);                      }                      else if (ltoken == "</span>")                      {   // we really should match span and font but it shouldn't matter very often?                          PopStyle();                      }                      else if (ltoken.StartsWith("<font"))                      {                          HandleFont(token.Substring(1)' si);                      }                      else if (ltoken == "</font>")                      {   // we really should match span and font but it shouldn't matter very often?                          PopStyle();                      }                      else if (ltoken.StartsWith("<ol") || ltoken.StartsWith("<ul"))                      {                          yPos += maxLineHeight;                          NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);                          maxLineHeight = xPos = lineXPos = maxDescent = 0;                          bFirstInLine = true;                          bWhiteSpace = false;                            bIsOrderedList = ltoken.StartsWith("<ol");                      }                      else if (ltoken.StartsWith("<li"))                      {                          yPos += maxLineHeight;                          NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);                          maxLineHeight = xPos = lineXPos = maxDescent = 0;                          bFirstInLine = true;                          bWhiteSpace = false;                            if (OlLiCount == null)                              OlLiCount = 0;                          if(bIsOrderedList)                              OlLiCount++;                      }                      else if (ltoken.StartsWith("</ol") || ltoken.StartsWith("</ul"))                      {                          bIsOrderedList = false;                          OlLiCount = null;                      }                                          continue;  				}  				if (token == PageTextHtmlLexer.WHITESPACE)  				{  					if (!bFirstInLine)  						bWhiteSpace = true;  					continue;  				}    				if (token != PageTextHtmlLexer.EOF)  				{  					string ntoken;                      if (token == PageTextHtmlLexer.NBSP.ToString())                          ntoken = bWhiteSpace ? "  " : " ";                      else                          ntoken = bWhiteSpace ? " " + token : token;                      ntoken = ntoken.Replace(PageTextHtmlLexer.NBSP' ' ');    					bWhiteSpace = false;			// can only use whitespace once  					ms = this.MeasureString(ntoken' CurrentStyle(si)' g' out descent);  					if (xPos + ms.Width < textWidth)  					{                          if (bFirstInLine)                          {                              if (OlLiCount == 0)                        //Adds UL bullet                                  sb.Append("   ");                              else if (OlLiCount > 0)                        //Adds OL numeric prefix                                  sb.AppendFormat("{0})   "' OlLiCount);                          }                            bFirstInLine = false;  						sb.Append(ntoken);    						maxDescent = Math.Max(maxDescent' descent);  						maxLineHeight = Math.Max(maxLineHeight' ms.Height);  						xPos += ms.Width;  						continue;  					}  				}  				else if (sb.Length == 0)	// EOF and no previous string means we're done  					continue;    				pt = new PageText(sb.ToString());                  pt.AllowSelect = false;                  pt.Page = this.Page;                  pt.HtmlParent = this;                  pt.NoClip = true;  				pt.HyperLink = model.HyperLink;  				pt.Tooltip = model.Tooltip;  				sb = new StringBuilder();  				sb.Append(token.Replace(PageTextHtmlLexer.NBSP' ' '));  				pt.SI = CurrentStyle(si).Clone() as StyleInfo;  				ms = this.MeasureString(pt.Text' pt.SI' g' out descent);  				pt.X = this.X + lineXPos;  				pt.Y = this.Y + yPos;  				pt.H = ms.Height;  				pt.W = ms.Width;   				pt.Descent = descent;  				pt.CanGrow = false;  				_items.Add(pt);  				lineItems.Add(pt);  				maxDescent = Math.Max(maxDescent' descent);  				maxLineHeight = Math.Max(maxLineHeight' ms.Height);  				yPos += maxLineHeight;	// Increment y position  				NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);  				lineXPos = maxLineHeight = maxDescent = 0;	// start line height over    				// Now set the xPos just after the current token  				ms = this.MeasureString(token' CurrentStyle(si)' g' out descent);  				xPos = ms.Width;	   			}
Magic Number,fyiReporting.RDL,PageTextHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtml.cs,BuildPrivate,The following statement contains a magic number: foreach (string token in tokens)  			{  				if (token[0] == PageTextHtmlLexer.HTMLCMD)		// indicates an HTML command  				{  					// we need to create a PageText since the styleinfo is changing  					if (sb.Length != 0)  					{  						pt = new PageText(sb.ToString());                          pt.AllowSelect = false;                          pt.Page = this.Page;                          pt.HtmlParent = this;  						pt.HyperLink = model.HyperLink;  						pt.Tooltip = model.Tooltip;  						pt.NoClip = true;  						sb = new StringBuilder();  						pt.X = this.X + lineXPos;  						pt.Y = this.Y + yPos;  						pt.CanGrow = false;  						pt.SI = CurrentStyle(si).Clone() as StyleInfo;  						_items.Add(pt);  						lineItems.Add(pt);  						ms = this.MeasureString(pt.Text' pt.SI' g' out descent);  						maxDescent = Math.Max(maxDescent' descent);  						pt.W = ms.Width;  						pt.H = ms.Height;  						pt.Descent = descent;  						maxLineHeight = Math.Max(maxLineHeight' ms.Height);  						lineXPos = xPos;  					}  					// Now reset the styleinfo  					StyleInfo cs = CurrentStyle(si);  					string ltoken = token.Substring(1'Math.Min(token.Length-1'10)).ToLower();  					if (ltoken == "<b>" || ltoken == "<strong>")  						cs.FontWeight = FontWeightEnum.Bold;  					else if (ltoken == "</b>" || ltoken == "</strong>")  						cs.FontWeight = FontWeightEnum.Normal;  					else if (ltoken == "<i>" || ltoken == "<cite>" || ltoken == "<var>" || ltoken == "<em>")  						cs.FontStyle = FontStyleEnum.Italic;  					else if (ltoken == "</i>" || ltoken == "</cite>" || ltoken == "</var>" || ltoken == "</em>")  						cs.FontStyle = FontStyleEnum.Normal;  					else if (ltoken == "<code>" || ltoken == "<samp>")  						cs.FontFamily = "Courier New";  					else if (ltoken == "</code>" || ltoken == "</samp>")  						cs.FontFamily = this.SI.FontFamily;  					else if (ltoken == "<kbd>")  					{  						cs.FontFamily = "Courier New";  						cs.FontWeight = FontWeightEnum.Bold;  					}  					else if (ltoken == "</kdd>")  					{  						cs.FontFamily = this.SI.FontFamily;  						cs.FontWeight = FontWeightEnum.Normal;  					}  					else if (ltoken == "<big>")  					{	// big makes it bigger by 20% for each time over the baseline of 3  						fontSizeModel++;  						float inc = 1;  						for (int i=3; i < fontSizeModel; i++)  						{  							inc += .2f;  						}  						float h = this.SI.FontSize * inc;  						cs.FontSize = h;  					}  					else if (ltoken == "</big>")  					{	// undoes the effect of big  						fontSizeModel--;  						float inc = 1;  						for (int i=3; i < fontSizeModel; i++)  						{  							inc += .2f;  						}  						float h = this.SI.FontSize / inc;  						cs.FontSize = h;  					}  					else if (ltoken == "<small>")  					{	// small makes it smaller by 20% for each time under the baseline of 3  						fontSizeModel--;  						float inc = 1;  						for (int i=3; i > fontSizeModel; i--)  						{  							inc += .2f;  						}  						float h = this.SI.FontSize / inc;  						cs.FontSize = h;  					}  					else if (ltoken == "</small>")  					{	// undoes the effect of small  						fontSizeModel++;  						float inc = 1;  						for (int i=3; i > fontSizeModel; i--)  						{  							inc += .2f;  						}  						float h = this.SI.FontSize * inc;  						cs.FontSize = h;  					}  					else if (ltoken.StartsWith("<br"))  					{  						yPos += maxLineHeight;  						NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);  						xPos = lineXPos = maxDescent = 0;  						bFirstInLine = true;  						bWhiteSpace = false;  					}                      else if (ltoken.StartsWith("<hr"))                      {   // Add a line                          // Process existing line if any                          yPos += maxLineHeight;                          NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);                          maxLineHeight = xPos = lineXPos = maxDescent = 0;                          bFirstInLine = true;                          bWhiteSpace = false;                            PageLine pl = new PageLine();                          pl.AllowSelect = false;                          pl.Page = this.Page;                          const int horzLineHeight = 10;                          pl.SI = cs.Clone() as StyleInfo;                          pl.SI.BStyleLeft = BorderStyleEnum.Ridge;                          pl.Y = pl.Y2 = this.Y + yPos + horzLineHeight / 2;                          pl.X = this.X;                          pl.X2 = pl.X + this.W;                          _items.Add(pl);                          yPos += horzLineHeight;  // skip past horizontal line                      }                      else if (ltoken.StartsWith("<p"))  					{  						yPos += maxLineHeight * 2;  						NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);  						maxLineHeight = xPos = lineXPos = maxDescent = 0;  						bFirstInLine = true;  						bWhiteSpace = false;  					}  					else if (ltoken.StartsWith("<a"))  					{  						BuildAnchor(token.Substring(1)' cs' model);  					}                      else if (ltoken.StartsWith("<img"))                      {                          PageImage pimg = BuildImage(g' token.Substring(1)' cs' model);                          if (pimg != null)   // We got an image; add to process list                          {                              pimg.Y = this.Y + yPos;                              pimg.X = this.X;                              _items.Add(pimg);                              yPos += pimg.H;	        // Increment y position                              maxLineHeight = xPos = lineXPos = maxDescent = 0;                              bFirstInLine = true;                              bWhiteSpace = false;                          }                      }                      else if (ltoken == "</a>")                      {                          model.HyperLink = model.Tooltip = null;                          PopStyle();                      }                      else if (ltoken.StartsWith("<span"))                      {                          HandleStyle(token.Substring(1)' si);                      }                      else if (ltoken == "</span>")                      {   // we really should match span and font but it shouldn't matter very often?                          PopStyle();                      }                      else if (ltoken.StartsWith("<font"))                      {                          HandleFont(token.Substring(1)' si);                      }                      else if (ltoken == "</font>")                      {   // we really should match span and font but it shouldn't matter very often?                          PopStyle();                      }                      else if (ltoken.StartsWith("<ol") || ltoken.StartsWith("<ul"))                      {                          yPos += maxLineHeight;                          NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);                          maxLineHeight = xPos = lineXPos = maxDescent = 0;                          bFirstInLine = true;                          bWhiteSpace = false;                            bIsOrderedList = ltoken.StartsWith("<ol");                      }                      else if (ltoken.StartsWith("<li"))                      {                          yPos += maxLineHeight;                          NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);                          maxLineHeight = xPos = lineXPos = maxDescent = 0;                          bFirstInLine = true;                          bWhiteSpace = false;                            if (OlLiCount == null)                              OlLiCount = 0;                          if(bIsOrderedList)                              OlLiCount++;                      }                      else if (ltoken.StartsWith("</ol") || ltoken.StartsWith("</ul"))                      {                          bIsOrderedList = false;                          OlLiCount = null;                      }                                          continue;  				}  				if (token == PageTextHtmlLexer.WHITESPACE)  				{  					if (!bFirstInLine)  						bWhiteSpace = true;  					continue;  				}    				if (token != PageTextHtmlLexer.EOF)  				{  					string ntoken;                      if (token == PageTextHtmlLexer.NBSP.ToString())                          ntoken = bWhiteSpace ? "  " : " ";                      else                          ntoken = bWhiteSpace ? " " + token : token;                      ntoken = ntoken.Replace(PageTextHtmlLexer.NBSP' ' ');    					bWhiteSpace = false;			// can only use whitespace once  					ms = this.MeasureString(ntoken' CurrentStyle(si)' g' out descent);  					if (xPos + ms.Width < textWidth)  					{                          if (bFirstInLine)                          {                              if (OlLiCount == 0)                        //Adds UL bullet                                  sb.Append("   ");                              else if (OlLiCount > 0)                        //Adds OL numeric prefix                                  sb.AppendFormat("{0})   "' OlLiCount);                          }                            bFirstInLine = false;  						sb.Append(ntoken);    						maxDescent = Math.Max(maxDescent' descent);  						maxLineHeight = Math.Max(maxLineHeight' ms.Height);  						xPos += ms.Width;  						continue;  					}  				}  				else if (sb.Length == 0)	// EOF and no previous string means we're done  					continue;    				pt = new PageText(sb.ToString());                  pt.AllowSelect = false;                  pt.Page = this.Page;                  pt.HtmlParent = this;                  pt.NoClip = true;  				pt.HyperLink = model.HyperLink;  				pt.Tooltip = model.Tooltip;  				sb = new StringBuilder();  				sb.Append(token.Replace(PageTextHtmlLexer.NBSP' ' '));  				pt.SI = CurrentStyle(si).Clone() as StyleInfo;  				ms = this.MeasureString(pt.Text' pt.SI' g' out descent);  				pt.X = this.X + lineXPos;  				pt.Y = this.Y + yPos;  				pt.H = ms.Height;  				pt.W = ms.Width;   				pt.Descent = descent;  				pt.CanGrow = false;  				_items.Add(pt);  				lineItems.Add(pt);  				maxDescent = Math.Max(maxDescent' descent);  				maxLineHeight = Math.Max(maxLineHeight' ms.Height);  				yPos += maxLineHeight;	// Increment y position  				NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);  				lineXPos = maxLineHeight = maxDescent = 0;	// start line height over    				// Now set the xPos just after the current token  				ms = this.MeasureString(token' CurrentStyle(si)' g' out descent);  				xPos = ms.Width;	   			}
Magic Number,fyiReporting.RDL,PageTextHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtml.cs,BuildPrivate,The following statement contains a magic number: foreach (string token in tokens)  			{  				if (token[0] == PageTextHtmlLexer.HTMLCMD)		// indicates an HTML command  				{  					// we need to create a PageText since the styleinfo is changing  					if (sb.Length != 0)  					{  						pt = new PageText(sb.ToString());                          pt.AllowSelect = false;                          pt.Page = this.Page;                          pt.HtmlParent = this;  						pt.HyperLink = model.HyperLink;  						pt.Tooltip = model.Tooltip;  						pt.NoClip = true;  						sb = new StringBuilder();  						pt.X = this.X + lineXPos;  						pt.Y = this.Y + yPos;  						pt.CanGrow = false;  						pt.SI = CurrentStyle(si).Clone() as StyleInfo;  						_items.Add(pt);  						lineItems.Add(pt);  						ms = this.MeasureString(pt.Text' pt.SI' g' out descent);  						maxDescent = Math.Max(maxDescent' descent);  						pt.W = ms.Width;  						pt.H = ms.Height;  						pt.Descent = descent;  						maxLineHeight = Math.Max(maxLineHeight' ms.Height);  						lineXPos = xPos;  					}  					// Now reset the styleinfo  					StyleInfo cs = CurrentStyle(si);  					string ltoken = token.Substring(1'Math.Min(token.Length-1'10)).ToLower();  					if (ltoken == "<b>" || ltoken == "<strong>")  						cs.FontWeight = FontWeightEnum.Bold;  					else if (ltoken == "</b>" || ltoken == "</strong>")  						cs.FontWeight = FontWeightEnum.Normal;  					else if (ltoken == "<i>" || ltoken == "<cite>" || ltoken == "<var>" || ltoken == "<em>")  						cs.FontStyle = FontStyleEnum.Italic;  					else if (ltoken == "</i>" || ltoken == "</cite>" || ltoken == "</var>" || ltoken == "</em>")  						cs.FontStyle = FontStyleEnum.Normal;  					else if (ltoken == "<code>" || ltoken == "<samp>")  						cs.FontFamily = "Courier New";  					else if (ltoken == "</code>" || ltoken == "</samp>")  						cs.FontFamily = this.SI.FontFamily;  					else if (ltoken == "<kbd>")  					{  						cs.FontFamily = "Courier New";  						cs.FontWeight = FontWeightEnum.Bold;  					}  					else if (ltoken == "</kdd>")  					{  						cs.FontFamily = this.SI.FontFamily;  						cs.FontWeight = FontWeightEnum.Normal;  					}  					else if (ltoken == "<big>")  					{	// big makes it bigger by 20% for each time over the baseline of 3  						fontSizeModel++;  						float inc = 1;  						for (int i=3; i < fontSizeModel; i++)  						{  							inc += .2f;  						}  						float h = this.SI.FontSize * inc;  						cs.FontSize = h;  					}  					else if (ltoken == "</big>")  					{	// undoes the effect of big  						fontSizeModel--;  						float inc = 1;  						for (int i=3; i < fontSizeModel; i++)  						{  							inc += .2f;  						}  						float h = this.SI.FontSize / inc;  						cs.FontSize = h;  					}  					else if (ltoken == "<small>")  					{	// small makes it smaller by 20% for each time under the baseline of 3  						fontSizeModel--;  						float inc = 1;  						for (int i=3; i > fontSizeModel; i--)  						{  							inc += .2f;  						}  						float h = this.SI.FontSize / inc;  						cs.FontSize = h;  					}  					else if (ltoken == "</small>")  					{	// undoes the effect of small  						fontSizeModel++;  						float inc = 1;  						for (int i=3; i > fontSizeModel; i--)  						{  							inc += .2f;  						}  						float h = this.SI.FontSize * inc;  						cs.FontSize = h;  					}  					else if (ltoken.StartsWith("<br"))  					{  						yPos += maxLineHeight;  						NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);  						xPos = lineXPos = maxDescent = 0;  						bFirstInLine = true;  						bWhiteSpace = false;  					}                      else if (ltoken.StartsWith("<hr"))                      {   // Add a line                          // Process existing line if any                          yPos += maxLineHeight;                          NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);                          maxLineHeight = xPos = lineXPos = maxDescent = 0;                          bFirstInLine = true;                          bWhiteSpace = false;                            PageLine pl = new PageLine();                          pl.AllowSelect = false;                          pl.Page = this.Page;                          const int horzLineHeight = 10;                          pl.SI = cs.Clone() as StyleInfo;                          pl.SI.BStyleLeft = BorderStyleEnum.Ridge;                          pl.Y = pl.Y2 = this.Y + yPos + horzLineHeight / 2;                          pl.X = this.X;                          pl.X2 = pl.X + this.W;                          _items.Add(pl);                          yPos += horzLineHeight;  // skip past horizontal line                      }                      else if (ltoken.StartsWith("<p"))  					{  						yPos += maxLineHeight * 2;  						NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);  						maxLineHeight = xPos = lineXPos = maxDescent = 0;  						bFirstInLine = true;  						bWhiteSpace = false;  					}  					else if (ltoken.StartsWith("<a"))  					{  						BuildAnchor(token.Substring(1)' cs' model);  					}                      else if (ltoken.StartsWith("<img"))                      {                          PageImage pimg = BuildImage(g' token.Substring(1)' cs' model);                          if (pimg != null)   // We got an image; add to process list                          {                              pimg.Y = this.Y + yPos;                              pimg.X = this.X;                              _items.Add(pimg);                              yPos += pimg.H;	        // Increment y position                              maxLineHeight = xPos = lineXPos = maxDescent = 0;                              bFirstInLine = true;                              bWhiteSpace = false;                          }                      }                      else if (ltoken == "</a>")                      {                          model.HyperLink = model.Tooltip = null;                          PopStyle();                      }                      else if (ltoken.StartsWith("<span"))                      {                          HandleStyle(token.Substring(1)' si);                      }                      else if (ltoken == "</span>")                      {   // we really should match span and font but it shouldn't matter very often?                          PopStyle();                      }                      else if (ltoken.StartsWith("<font"))                      {                          HandleFont(token.Substring(1)' si);                      }                      else if (ltoken == "</font>")                      {   // we really should match span and font but it shouldn't matter very often?                          PopStyle();                      }                      else if (ltoken.StartsWith("<ol") || ltoken.StartsWith("<ul"))                      {                          yPos += maxLineHeight;                          NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);                          maxLineHeight = xPos = lineXPos = maxDescent = 0;                          bFirstInLine = true;                          bWhiteSpace = false;                            bIsOrderedList = ltoken.StartsWith("<ol");                      }                      else if (ltoken.StartsWith("<li"))                      {                          yPos += maxLineHeight;                          NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);                          maxLineHeight = xPos = lineXPos = maxDescent = 0;                          bFirstInLine = true;                          bWhiteSpace = false;                            if (OlLiCount == null)                              OlLiCount = 0;                          if(bIsOrderedList)                              OlLiCount++;                      }                      else if (ltoken.StartsWith("</ol") || ltoken.StartsWith("</ul"))                      {                          bIsOrderedList = false;                          OlLiCount = null;                      }                                          continue;  				}  				if (token == PageTextHtmlLexer.WHITESPACE)  				{  					if (!bFirstInLine)  						bWhiteSpace = true;  					continue;  				}    				if (token != PageTextHtmlLexer.EOF)  				{  					string ntoken;                      if (token == PageTextHtmlLexer.NBSP.ToString())                          ntoken = bWhiteSpace ? "  " : " ";                      else                          ntoken = bWhiteSpace ? " " + token : token;                      ntoken = ntoken.Replace(PageTextHtmlLexer.NBSP' ' ');    					bWhiteSpace = false;			// can only use whitespace once  					ms = this.MeasureString(ntoken' CurrentStyle(si)' g' out descent);  					if (xPos + ms.Width < textWidth)  					{                          if (bFirstInLine)                          {                              if (OlLiCount == 0)                        //Adds UL bullet                                  sb.Append("   ");                              else if (OlLiCount > 0)                        //Adds OL numeric prefix                                  sb.AppendFormat("{0})   "' OlLiCount);                          }                            bFirstInLine = false;  						sb.Append(ntoken);    						maxDescent = Math.Max(maxDescent' descent);  						maxLineHeight = Math.Max(maxLineHeight' ms.Height);  						xPos += ms.Width;  						continue;  					}  				}  				else if (sb.Length == 0)	// EOF and no previous string means we're done  					continue;    				pt = new PageText(sb.ToString());                  pt.AllowSelect = false;                  pt.Page = this.Page;                  pt.HtmlParent = this;                  pt.NoClip = true;  				pt.HyperLink = model.HyperLink;  				pt.Tooltip = model.Tooltip;  				sb = new StringBuilder();  				sb.Append(token.Replace(PageTextHtmlLexer.NBSP' ' '));  				pt.SI = CurrentStyle(si).Clone() as StyleInfo;  				ms = this.MeasureString(pt.Text' pt.SI' g' out descent);  				pt.X = this.X + lineXPos;  				pt.Y = this.Y + yPos;  				pt.H = ms.Height;  				pt.W = ms.Width;   				pt.Descent = descent;  				pt.CanGrow = false;  				_items.Add(pt);  				lineItems.Add(pt);  				maxDescent = Math.Max(maxDescent' descent);  				maxLineHeight = Math.Max(maxLineHeight' ms.Height);  				yPos += maxLineHeight;	// Increment y position  				NormalizeLineHeight(lineItems' maxLineHeight' maxDescent);  				lineXPos = maxLineHeight = maxDescent = 0;	// start line height over    				// Now set the xPos just after the current token  				ms = this.MeasureString(token' CurrentStyle(si)' g' out descent);  				xPos = ms.Width;	   			}
Magic Number,fyiReporting.RDL,PageTextHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtml.cs,BuildImage,The following statement contains a magic number: PageTextHtmlCmdLexer hc = new PageTextHtmlCmdLexer(token.Substring(4));
Magic Number,fyiReporting.RDL,PageTextHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtml.cs,HandleFont,The following statement contains a magic number: PageTextHtmlCmdLexer hc = new PageTextHtmlCmdLexer(token.Substring(5));
Magic Number,fyiReporting.RDL,PageTextHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtml.cs,HandleStyleString,The following statement contains a magic number: foreach (string item in styleList)  			{  				string[] val = item.Split(new char[] {':'});  				if (val.Length != 2)  					continue;			// must be illegal syntax  				string tval = val[1].Trim();  				switch (val[0].ToLower().Trim())  				{  					case "background":  					case "background-color":  						si.BackgroundColor = XmlUtil.ColorFromHtml(tval' si.Color);  						break;  					case "color":  						si.Color = XmlUtil.ColorFromHtml(tval' si.Color);  						break;  					case "font-family":  						si.FontFamily = tval;  						break;  					case "font-size":  						HandleStyleFontSize(si' tval);  						break;  					case "font-style":  						if (tval == "italic")  							si.FontStyle = FontStyleEnum.Italic;  						break;  					case "font-weight":  						HandleStyleFontWeight(si' tval);  						break;  				}  			}
Magic Number,fyiReporting.RDL,PageTextHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtml.cs,HandleStyleFontSize,The following statement contains a magic number: try  			{  				int i = size.IndexOf("pt");    				if (i > 0)  				{  					size = size.Remove(i' 2);  					float n = (float) Convert.ToDouble(size);  					if (size[0] == '+')  						si.FontSize += n;  					else  						si.FontSize = n;  					return;  				}  				i = size.IndexOf("%");  				if (i > 0)  				{  					size = size.Remove(i' 1);  					float n = (float) Convert.ToDouble(size);  					si.FontSize = n*si.FontSize;  					return;  				}  				switch (size)  				{  					case "xx-small":  						si.FontSize = 6;  						break;  					case "x-small":  						si.FontSize = 8;  						break;  					case "small":  						si.FontSize = 10;  						break;  					case "medium":  						si.FontSize = 12;  						break;  					case "large":  						si.FontSize = 14;  						break;  					case "x-large":  						si.FontSize = 16;  						break;  					case "xx-large":  						si.FontSize = 18;  						break;                      case "1":                          si.FontSize = 8;                          break;                      case "2":                          si.FontSize = 10;                          break;                      case "3":                          si.FontSize = 12;                          break;                      case "4":                          si.FontSize = 14;                          break;                      case "5":                          si.FontSize = 18;                          break;                      case "6":                          si.FontSize = 24;                          break;                      case "7":                          si.FontSize = 36;                          break;                  }  			}  			catch {}
Magic Number,fyiReporting.RDL,PageTextHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtml.cs,HandleStyleFontSize,The following statement contains a magic number: try  			{  				int i = size.IndexOf("pt");    				if (i > 0)  				{  					size = size.Remove(i' 2);  					float n = (float) Convert.ToDouble(size);  					if (size[0] == '+')  						si.FontSize += n;  					else  						si.FontSize = n;  					return;  				}  				i = size.IndexOf("%");  				if (i > 0)  				{  					size = size.Remove(i' 1);  					float n = (float) Convert.ToDouble(size);  					si.FontSize = n*si.FontSize;  					return;  				}  				switch (size)  				{  					case "xx-small":  						si.FontSize = 6;  						break;  					case "x-small":  						si.FontSize = 8;  						break;  					case "small":  						si.FontSize = 10;  						break;  					case "medium":  						si.FontSize = 12;  						break;  					case "large":  						si.FontSize = 14;  						break;  					case "x-large":  						si.FontSize = 16;  						break;  					case "xx-large":  						si.FontSize = 18;  						break;                      case "1":                          si.FontSize = 8;                          break;                      case "2":                          si.FontSize = 10;                          break;                      case "3":                          si.FontSize = 12;                          break;                      case "4":                          si.FontSize = 14;                          break;                      case "5":                          si.FontSize = 18;                          break;                      case "6":                          si.FontSize = 24;                          break;                      case "7":                          si.FontSize = 36;                          break;                  }  			}  			catch {}
Magic Number,fyiReporting.RDL,PageTextHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtml.cs,HandleStyleFontSize,The following statement contains a magic number: try  			{  				int i = size.IndexOf("pt");    				if (i > 0)  				{  					size = size.Remove(i' 2);  					float n = (float) Convert.ToDouble(size);  					if (size[0] == '+')  						si.FontSize += n;  					else  						si.FontSize = n;  					return;  				}  				i = size.IndexOf("%");  				if (i > 0)  				{  					size = size.Remove(i' 1);  					float n = (float) Convert.ToDouble(size);  					si.FontSize = n*si.FontSize;  					return;  				}  				switch (size)  				{  					case "xx-small":  						si.FontSize = 6;  						break;  					case "x-small":  						si.FontSize = 8;  						break;  					case "small":  						si.FontSize = 10;  						break;  					case "medium":  						si.FontSize = 12;  						break;  					case "large":  						si.FontSize = 14;  						break;  					case "x-large":  						si.FontSize = 16;  						break;  					case "xx-large":  						si.FontSize = 18;  						break;                      case "1":                          si.FontSize = 8;                          break;                      case "2":                          si.FontSize = 10;                          break;                      case "3":                          si.FontSize = 12;                          break;                      case "4":                          si.FontSize = 14;                          break;                      case "5":                          si.FontSize = 18;                          break;                      case "6":                          si.FontSize = 24;                          break;                      case "7":                          si.FontSize = 36;                          break;                  }  			}  			catch {}
Magic Number,fyiReporting.RDL,PageTextHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtml.cs,HandleStyleFontSize,The following statement contains a magic number: try  			{  				int i = size.IndexOf("pt");    				if (i > 0)  				{  					size = size.Remove(i' 2);  					float n = (float) Convert.ToDouble(size);  					if (size[0] == '+')  						si.FontSize += n;  					else  						si.FontSize = n;  					return;  				}  				i = size.IndexOf("%");  				if (i > 0)  				{  					size = size.Remove(i' 1);  					float n = (float) Convert.ToDouble(size);  					si.FontSize = n*si.FontSize;  					return;  				}  				switch (size)  				{  					case "xx-small":  						si.FontSize = 6;  						break;  					case "x-small":  						si.FontSize = 8;  						break;  					case "small":  						si.FontSize = 10;  						break;  					case "medium":  						si.FontSize = 12;  						break;  					case "large":  						si.FontSize = 14;  						break;  					case "x-large":  						si.FontSize = 16;  						break;  					case "xx-large":  						si.FontSize = 18;  						break;                      case "1":                          si.FontSize = 8;                          break;                      case "2":                          si.FontSize = 10;                          break;                      case "3":                          si.FontSize = 12;                          break;                      case "4":                          si.FontSize = 14;                          break;                      case "5":                          si.FontSize = 18;                          break;                      case "6":                          si.FontSize = 24;                          break;                      case "7":                          si.FontSize = 36;                          break;                  }  			}  			catch {}
Magic Number,fyiReporting.RDL,PageTextHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtml.cs,HandleStyleFontSize,The following statement contains a magic number: try  			{  				int i = size.IndexOf("pt");    				if (i > 0)  				{  					size = size.Remove(i' 2);  					float n = (float) Convert.ToDouble(size);  					if (size[0] == '+')  						si.FontSize += n;  					else  						si.FontSize = n;  					return;  				}  				i = size.IndexOf("%");  				if (i > 0)  				{  					size = size.Remove(i' 1);  					float n = (float) Convert.ToDouble(size);  					si.FontSize = n*si.FontSize;  					return;  				}  				switch (size)  				{  					case "xx-small":  						si.FontSize = 6;  						break;  					case "x-small":  						si.FontSize = 8;  						break;  					case "small":  						si.FontSize = 10;  						break;  					case "medium":  						si.FontSize = 12;  						break;  					case "large":  						si.FontSize = 14;  						break;  					case "x-large":  						si.FontSize = 16;  						break;  					case "xx-large":  						si.FontSize = 18;  						break;                      case "1":                          si.FontSize = 8;                          break;                      case "2":                          si.FontSize = 10;                          break;                      case "3":                          si.FontSize = 12;                          break;                      case "4":                          si.FontSize = 14;                          break;                      case "5":                          si.FontSize = 18;                          break;                      case "6":                          si.FontSize = 24;                          break;                      case "7":                          si.FontSize = 36;                          break;                  }  			}  			catch {}
Magic Number,fyiReporting.RDL,PageTextHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtml.cs,HandleStyleFontSize,The following statement contains a magic number: try  			{  				int i = size.IndexOf("pt");    				if (i > 0)  				{  					size = size.Remove(i' 2);  					float n = (float) Convert.ToDouble(size);  					if (size[0] == '+')  						si.FontSize += n;  					else  						si.FontSize = n;  					return;  				}  				i = size.IndexOf("%");  				if (i > 0)  				{  					size = size.Remove(i' 1);  					float n = (float) Convert.ToDouble(size);  					si.FontSize = n*si.FontSize;  					return;  				}  				switch (size)  				{  					case "xx-small":  						si.FontSize = 6;  						break;  					case "x-small":  						si.FontSize = 8;  						break;  					case "small":  						si.FontSize = 10;  						break;  					case "medium":  						si.FontSize = 12;  						break;  					case "large":  						si.FontSize = 14;  						break;  					case "x-large":  						si.FontSize = 16;  						break;  					case "xx-large":  						si.FontSize = 18;  						break;                      case "1":                          si.FontSize = 8;                          break;                      case "2":                          si.FontSize = 10;                          break;                      case "3":                          si.FontSize = 12;                          break;                      case "4":                          si.FontSize = 14;                          break;                      case "5":                          si.FontSize = 18;                          break;                      case "6":                          si.FontSize = 24;                          break;                      case "7":                          si.FontSize = 36;                          break;                  }  			}  			catch {}
Magic Number,fyiReporting.RDL,PageTextHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtml.cs,HandleStyleFontSize,The following statement contains a magic number: try  			{  				int i = size.IndexOf("pt");    				if (i > 0)  				{  					size = size.Remove(i' 2);  					float n = (float) Convert.ToDouble(size);  					if (size[0] == '+')  						si.FontSize += n;  					else  						si.FontSize = n;  					return;  				}  				i = size.IndexOf("%");  				if (i > 0)  				{  					size = size.Remove(i' 1);  					float n = (float) Convert.ToDouble(size);  					si.FontSize = n*si.FontSize;  					return;  				}  				switch (size)  				{  					case "xx-small":  						si.FontSize = 6;  						break;  					case "x-small":  						si.FontSize = 8;  						break;  					case "small":  						si.FontSize = 10;  						break;  					case "medium":  						si.FontSize = 12;  						break;  					case "large":  						si.FontSize = 14;  						break;  					case "x-large":  						si.FontSize = 16;  						break;  					case "xx-large":  						si.FontSize = 18;  						break;                      case "1":                          si.FontSize = 8;                          break;                      case "2":                          si.FontSize = 10;                          break;                      case "3":                          si.FontSize = 12;                          break;                      case "4":                          si.FontSize = 14;                          break;                      case "5":                          si.FontSize = 18;                          break;                      case "6":                          si.FontSize = 24;                          break;                      case "7":                          si.FontSize = 36;                          break;                  }  			}  			catch {}
Magic Number,fyiReporting.RDL,PageTextHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtml.cs,HandleStyleFontSize,The following statement contains a magic number: try  			{  				int i = size.IndexOf("pt");    				if (i > 0)  				{  					size = size.Remove(i' 2);  					float n = (float) Convert.ToDouble(size);  					if (size[0] == '+')  						si.FontSize += n;  					else  						si.FontSize = n;  					return;  				}  				i = size.IndexOf("%");  				if (i > 0)  				{  					size = size.Remove(i' 1);  					float n = (float) Convert.ToDouble(size);  					si.FontSize = n*si.FontSize;  					return;  				}  				switch (size)  				{  					case "xx-small":  						si.FontSize = 6;  						break;  					case "x-small":  						si.FontSize = 8;  						break;  					case "small":  						si.FontSize = 10;  						break;  					case "medium":  						si.FontSize = 12;  						break;  					case "large":  						si.FontSize = 14;  						break;  					case "x-large":  						si.FontSize = 16;  						break;  					case "xx-large":  						si.FontSize = 18;  						break;                      case "1":                          si.FontSize = 8;                          break;                      case "2":                          si.FontSize = 10;                          break;                      case "3":                          si.FontSize = 12;                          break;                      case "4":                          si.FontSize = 14;                          break;                      case "5":                          si.FontSize = 18;                          break;                      case "6":                          si.FontSize = 24;                          break;                      case "7":                          si.FontSize = 36;                          break;                  }  			}  			catch {}
Magic Number,fyiReporting.RDL,PageTextHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtml.cs,HandleStyleFontSize,The following statement contains a magic number: try  			{  				int i = size.IndexOf("pt");    				if (i > 0)  				{  					size = size.Remove(i' 2);  					float n = (float) Convert.ToDouble(size);  					if (size[0] == '+')  						si.FontSize += n;  					else  						si.FontSize = n;  					return;  				}  				i = size.IndexOf("%");  				if (i > 0)  				{  					size = size.Remove(i' 1);  					float n = (float) Convert.ToDouble(size);  					si.FontSize = n*si.FontSize;  					return;  				}  				switch (size)  				{  					case "xx-small":  						si.FontSize = 6;  						break;  					case "x-small":  						si.FontSize = 8;  						break;  					case "small":  						si.FontSize = 10;  						break;  					case "medium":  						si.FontSize = 12;  						break;  					case "large":  						si.FontSize = 14;  						break;  					case "x-large":  						si.FontSize = 16;  						break;  					case "xx-large":  						si.FontSize = 18;  						break;                      case "1":                          si.FontSize = 8;                          break;                      case "2":                          si.FontSize = 10;                          break;                      case "3":                          si.FontSize = 12;                          break;                      case "4":                          si.FontSize = 14;                          break;                      case "5":                          si.FontSize = 18;                          break;                      case "6":                          si.FontSize = 24;                          break;                      case "7":                          si.FontSize = 36;                          break;                  }  			}  			catch {}
Magic Number,fyiReporting.RDL,PageTextHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtml.cs,HandleStyleFontSize,The following statement contains a magic number: try  			{  				int i = size.IndexOf("pt");    				if (i > 0)  				{  					size = size.Remove(i' 2);  					float n = (float) Convert.ToDouble(size);  					if (size[0] == '+')  						si.FontSize += n;  					else  						si.FontSize = n;  					return;  				}  				i = size.IndexOf("%");  				if (i > 0)  				{  					size = size.Remove(i' 1);  					float n = (float) Convert.ToDouble(size);  					si.FontSize = n*si.FontSize;  					return;  				}  				switch (size)  				{  					case "xx-small":  						si.FontSize = 6;  						break;  					case "x-small":  						si.FontSize = 8;  						break;  					case "small":  						si.FontSize = 10;  						break;  					case "medium":  						si.FontSize = 12;  						break;  					case "large":  						si.FontSize = 14;  						break;  					case "x-large":  						si.FontSize = 16;  						break;  					case "xx-large":  						si.FontSize = 18;  						break;                      case "1":                          si.FontSize = 8;                          break;                      case "2":                          si.FontSize = 10;                          break;                      case "3":                          si.FontSize = 12;                          break;                      case "4":                          si.FontSize = 14;                          break;                      case "5":                          si.FontSize = 18;                          break;                      case "6":                          si.FontSize = 24;                          break;                      case "7":                          si.FontSize = 36;                          break;                  }  			}  			catch {}
Magic Number,fyiReporting.RDL,PageTextHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtml.cs,HandleStyleFontSize,The following statement contains a magic number: try  			{  				int i = size.IndexOf("pt");    				if (i > 0)  				{  					size = size.Remove(i' 2);  					float n = (float) Convert.ToDouble(size);  					if (size[0] == '+')  						si.FontSize += n;  					else  						si.FontSize = n;  					return;  				}  				i = size.IndexOf("%");  				if (i > 0)  				{  					size = size.Remove(i' 1);  					float n = (float) Convert.ToDouble(size);  					si.FontSize = n*si.FontSize;  					return;  				}  				switch (size)  				{  					case "xx-small":  						si.FontSize = 6;  						break;  					case "x-small":  						si.FontSize = 8;  						break;  					case "small":  						si.FontSize = 10;  						break;  					case "medium":  						si.FontSize = 12;  						break;  					case "large":  						si.FontSize = 14;  						break;  					case "x-large":  						si.FontSize = 16;  						break;  					case "xx-large":  						si.FontSize = 18;  						break;                      case "1":                          si.FontSize = 8;                          break;                      case "2":                          si.FontSize = 10;                          break;                      case "3":                          si.FontSize = 12;                          break;                      case "4":                          si.FontSize = 14;                          break;                      case "5":                          si.FontSize = 18;                          break;                      case "6":                          si.FontSize = 24;                          break;                      case "7":                          si.FontSize = 36;                          break;                  }  			}  			catch {}
Magic Number,fyiReporting.RDL,PageTextHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtml.cs,HandleStyleFontSize,The following statement contains a magic number: try  			{  				int i = size.IndexOf("pt");    				if (i > 0)  				{  					size = size.Remove(i' 2);  					float n = (float) Convert.ToDouble(size);  					if (size[0] == '+')  						si.FontSize += n;  					else  						si.FontSize = n;  					return;  				}  				i = size.IndexOf("%");  				if (i > 0)  				{  					size = size.Remove(i' 1);  					float n = (float) Convert.ToDouble(size);  					si.FontSize = n*si.FontSize;  					return;  				}  				switch (size)  				{  					case "xx-small":  						si.FontSize = 6;  						break;  					case "x-small":  						si.FontSize = 8;  						break;  					case "small":  						si.FontSize = 10;  						break;  					case "medium":  						si.FontSize = 12;  						break;  					case "large":  						si.FontSize = 14;  						break;  					case "x-large":  						si.FontSize = 16;  						break;  					case "xx-large":  						si.FontSize = 18;  						break;                      case "1":                          si.FontSize = 8;                          break;                      case "2":                          si.FontSize = 10;                          break;                      case "3":                          si.FontSize = 12;                          break;                      case "4":                          si.FontSize = 14;                          break;                      case "5":                          si.FontSize = 18;                          break;                      case "6":                          si.FontSize = 24;                          break;                      case "7":                          si.FontSize = 36;                          break;                  }  			}  			catch {}
Magic Number,fyiReporting.RDL,PageTextHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtml.cs,HandleStyleFontSize,The following statement contains a magic number: try  			{  				int i = size.IndexOf("pt");    				if (i > 0)  				{  					size = size.Remove(i' 2);  					float n = (float) Convert.ToDouble(size);  					if (size[0] == '+')  						si.FontSize += n;  					else  						si.FontSize = n;  					return;  				}  				i = size.IndexOf("%");  				if (i > 0)  				{  					size = size.Remove(i' 1);  					float n = (float) Convert.ToDouble(size);  					si.FontSize = n*si.FontSize;  					return;  				}  				switch (size)  				{  					case "xx-small":  						si.FontSize = 6;  						break;  					case "x-small":  						si.FontSize = 8;  						break;  					case "small":  						si.FontSize = 10;  						break;  					case "medium":  						si.FontSize = 12;  						break;  					case "large":  						si.FontSize = 14;  						break;  					case "x-large":  						si.FontSize = 16;  						break;  					case "xx-large":  						si.FontSize = 18;  						break;                      case "1":                          si.FontSize = 8;                          break;                      case "2":                          si.FontSize = 10;                          break;                      case "3":                          si.FontSize = 12;                          break;                      case "4":                          si.FontSize = 14;                          break;                      case "5":                          si.FontSize = 18;                          break;                      case "6":                          si.FontSize = 24;                          break;                      case "7":                          si.FontSize = 36;                          break;                  }  			}  			catch {}
Magic Number,fyiReporting.RDL,PageTextHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtml.cs,HandleStyleFontSize,The following statement contains a magic number: try  			{  				int i = size.IndexOf("pt");    				if (i > 0)  				{  					size = size.Remove(i' 2);  					float n = (float) Convert.ToDouble(size);  					if (size[0] == '+')  						si.FontSize += n;  					else  						si.FontSize = n;  					return;  				}  				i = size.IndexOf("%");  				if (i > 0)  				{  					size = size.Remove(i' 1);  					float n = (float) Convert.ToDouble(size);  					si.FontSize = n*si.FontSize;  					return;  				}  				switch (size)  				{  					case "xx-small":  						si.FontSize = 6;  						break;  					case "x-small":  						si.FontSize = 8;  						break;  					case "small":  						si.FontSize = 10;  						break;  					case "medium":  						si.FontSize = 12;  						break;  					case "large":  						si.FontSize = 14;  						break;  					case "x-large":  						si.FontSize = 16;  						break;  					case "xx-large":  						si.FontSize = 18;  						break;                      case "1":                          si.FontSize = 8;                          break;                      case "2":                          si.FontSize = 10;                          break;                      case "3":                          si.FontSize = 12;                          break;                      case "4":                          si.FontSize = 14;                          break;                      case "5":                          si.FontSize = 18;                          break;                      case "6":                          si.FontSize = 24;                          break;                      case "7":                          si.FontSize = 36;                          break;                  }  			}  			catch {}
Magic Number,fyiReporting.RDL,PageTextHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtml.cs,HandleStyleFontSize,The following statement contains a magic number: try  			{  				int i = size.IndexOf("pt");    				if (i > 0)  				{  					size = size.Remove(i' 2);  					float n = (float) Convert.ToDouble(size);  					if (size[0] == '+')  						si.FontSize += n;  					else  						si.FontSize = n;  					return;  				}  				i = size.IndexOf("%");  				if (i > 0)  				{  					size = size.Remove(i' 1);  					float n = (float) Convert.ToDouble(size);  					si.FontSize = n*si.FontSize;  					return;  				}  				switch (size)  				{  					case "xx-small":  						si.FontSize = 6;  						break;  					case "x-small":  						si.FontSize = 8;  						break;  					case "small":  						si.FontSize = 10;  						break;  					case "medium":  						si.FontSize = 12;  						break;  					case "large":  						si.FontSize = 14;  						break;  					case "x-large":  						si.FontSize = 16;  						break;  					case "xx-large":  						si.FontSize = 18;  						break;                      case "1":                          si.FontSize = 8;                          break;                      case "2":                          si.FontSize = 10;                          break;                      case "3":                          si.FontSize = 12;                          break;                      case "4":                          si.FontSize = 14;                          break;                      case "5":                          si.FontSize = 18;                          break;                      case "6":                          si.FontSize = 24;                          break;                      case "7":                          si.FontSize = 36;                          break;                  }  			}  			catch {}
Magic Number,fyiReporting.RDL,PageTextHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtml.cs,ParseHtmlCmd,The following statement contains a magic number: if (keys == null || keys.Length < 2)                  return ht;
Magic Number,fyiReporting.RDL,PageTextHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtml.cs,ParseHtmlCmd,The following statement contains a magic number: try              {                  for (int i = 0; i < keys.Length - 1; i += 2)                  {                      // remove " from the value if any                      string v = keys[i + 1];                      if (v.Length > 0 && (v[0] == '"' || v[0] == '\''))                          v = v.Substring(1);                      if (v.Length > 0 && (v[v.Length - 1] == '"' || v[v.Length - 1] == '\''))                          v = v.Substring(0' v.Length - 1);                      // normalize key to lower case                      string key = keys[i].ToLower().Trim();                      ht.Add(key' v);                  }              }              catch { }
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: int MAXSPECIAL = 8;
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: if (s[0] == '#')			// number character  			{  				try  				{  					string num = s.Substring(1);	// this can cause an exception  					int nv = Convert.ToInt32(num);	//    and this can too  					if (nv > 255)  						return ' ';		// not a valid number; return blank  					return Convert.ToChar(nv);  				}  				catch  				{  					return ' ';			// not a valid number; return blank  				}  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,PageTextHtmlLexer,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtmlLexer.cs,ReadSpecial,The following statement contains a magic number: switch (s)              {   // see http://www.w3.org/TR/html4/sgml/entities.html  				case "quot": return '"';  				case "amp": return '&';  				case "lt": return '<';  				case "gt": return '>';  				case "nbsp": return NBSP;  				case "iexcl": return Convert.ToChar(161);  				case "cent": return Convert.ToChar(162);  				case "pound": return Convert.ToChar(163);  				case "curren": return Convert.ToChar(164);  				case "yen": return Convert.ToChar(165);  				case "brvbar": return Convert.ToChar(166);  				case "sect": return Convert.ToChar(167);  				case "uml": return Convert.ToChar(168);  				case "copy": return Convert.ToChar(169);  				case "ordf": return Convert.ToChar(170);  				case "laquo": return Convert.ToChar(171);  				case "not": return Convert.ToChar(172);  				case "shy": return Convert.ToChar(173);  				case "reg": return Convert.ToChar(174);  				case "macr": return Convert.ToChar(175);  				case "deg": return Convert.ToChar(176);  				case "plusmn": return Convert.ToChar(177);  				case "sup2": return Convert.ToChar(178);  				case "sup3": return Convert.ToChar(179);  				case "acute": return Convert.ToChar(180);  				case "micro": return Convert.ToChar(181);  				case "para": return Convert.ToChar(182);  				case "middot": return Convert.ToChar(183);  				case "cedil": return Convert.ToChar(184);  				case "sup1": return Convert.ToChar(185);  				case "ordm": return Convert.ToChar(186);  				case "raquo": return Convert.ToChar(187);  				case "frac14": return Convert.ToChar(188);  				case "frac12": return Convert.ToChar(189);  				case "frac34": return Convert.ToChar(190);  				case "iquest": return Convert.ToChar(191);  				case "Agrave": return Convert.ToChar(192);  				case "Aacute": return Convert.ToChar(193);  				case "Acirc": return Convert.ToChar(194);  				case "Atilde": return Convert.ToChar(195);  				case "Auml": return Convert.ToChar(196);  				case "Aring": return Convert.ToChar(197);  				case "AElig": return Convert.ToChar(198);  				case "Ccedil": return Convert.ToChar(199);  				case "Egrave": return Convert.ToChar(200);  				case "Eacute": return Convert.ToChar(201);  				case "Ecirc": return Convert.ToChar(202);  				case "Euml": return Convert.ToChar(203);  				case "lgrave": return Convert.ToChar(204);  				case "lacute": return Convert.ToChar(205);  				case "lcirc": return Convert.ToChar(206);  				case "luml": return Convert.ToChar(207);  				case "EHT": return Convert.ToChar(208);  				case "Ntilde": return Convert.ToChar(209);  				case "Ograve": return Convert.ToChar(210);  				case "Oacute": return Convert.ToChar(211);  				case "Ocirc": return Convert.ToChar(212);  				case "Otilde": return Convert.ToChar(213);  				case "Ouml": return Convert.ToChar(214);  				case "times": return Convert.ToChar(215);  				case "Oslash": return Convert.ToChar(216);  				case "Ugrave": return Convert.ToChar(217);  				case "Uacute": return Convert.ToChar(218);  				case "Ucirc": return Convert.ToChar(219);  				case "Uuml": return Convert.ToChar(220);  				case "Yacute": return Convert.ToChar(221);  				case "THORN": return Convert.ToChar(222);  				case "szlig": return Convert.ToChar(223);  				case "agrave": return Convert.ToChar(224);  				case "aacute": return Convert.ToChar(225);  				case "acirc": return Convert.ToChar(226);  				case "atilde": return Convert.ToChar(227);  				case "auml": return Convert.ToChar(228);  				case "aring": return Convert.ToChar(229);  				case "aelig": return Convert.ToChar(230);  				case "ccedil": return Convert.ToChar(231);  				case "egrave": return Convert.ToChar(232);  				case "eacute": return Convert.ToChar(233);  				case "ecirc": return Convert.ToChar(234);  				case "euml": return Convert.ToChar(235);  				case "igrave": return Convert.ToChar(236);  				case "iacute": return Convert.ToChar(237);  				case "icirc": return Convert.ToChar(238);  				case "iuml": return Convert.ToChar(239);  				case "eth": return Convert.ToChar(240);  				case "ntilde": return Convert.ToChar(241);  				case "ograve": return Convert.ToChar(242);  				case "oacute": return Convert.ToChar(243);  				case "ocirc": return Convert.ToChar(244);  				case "otilde": return Convert.ToChar(245);  				case "ouml": return Convert.ToChar(246);  				case "divide": return Convert.ToChar(247);  				case "oslash": return Convert.ToChar(248);  				case "ugrave": return Convert.ToChar(249);  				case "uacute": return Convert.ToChar(250);  				case "ucirc": return Convert.ToChar(251);  				case "uuml": return Convert.ToChar(252);  				case "yacute": return Convert.ToChar(253);  				case "thorn": return Convert.ToChar(254);  				case "yuml": return Convert.ToChar(255);                  //  Arrows                   case "larr": return Convert.ToChar(8592);                  case "uarr": return Convert.ToChar(8593);                  case "rarr": return Convert.ToChar(8594);                  case "darr": return Convert.ToChar(8595);                  case "harr": return Convert.ToChar(8596);                  case "crarr": return Convert.ToChar(8629);                  case "lArr": return Convert.ToChar(8657);                  case "rArr": return Convert.ToChar(8658);                  case "dArr": return Convert.ToChar(8659);                  case "hArr": return Convert.ToChar(8660);                  // Miscellaneous Symbols -->                  case "spades": return Convert.ToChar(9824);                  case "clubs": return Convert.ToChar(9827);                  case "hearts": return Convert.ToChar(9829);                  case "diams": return Convert.ToChar(9830);                  default: return ' ';			// not a valid special character  			}
Magic Number,fyiReporting.RDL,CompressionConfig,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\RdlEngineConfig.cs,CompressionConfig,The following statement contains a magic number: if (cm == null || cn == null || fn == null)                  _UseCompression = 2;
Magic Number,fyiReporting.RDL,CompressionConfig,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\RdlEngineConfig.cs,CallStreamFinish,The following statement contains a magic number: if (_UseCompression == 2)              {                  strm.Close();                  return;              }
Magic Number,fyiReporting.RDL,CompressionConfig,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\RdlEngineConfig.cs,GetArray,The following statement contains a magic number: byte[] wa = new byte[cmpData.Length + 2 + 4];
Magic Number,fyiReporting.RDL,CompressionConfig,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\RdlEngineConfig.cs,GetArray,The following statement contains a magic number: byte[] wa = new byte[cmpData.Length + 2 + 4];
Magic Number,fyiReporting.RDL,CompressionConfig,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\RdlEngineConfig.cs,GetArray,The following statement contains a magic number: cmpData.CopyTo(wa' 2);
Magic Number,fyiReporting.RDL,CompressionConfig,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\RdlEngineConfig.cs,GetArray,The following statement contains a magic number: wa[2 + cmpData.Length + 0] = (byte)(c >> 24);
Magic Number,fyiReporting.RDL,CompressionConfig,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\RdlEngineConfig.cs,GetArray,The following statement contains a magic number: wa[2 + cmpData.Length + 0] = (byte)(c >> 24);
Magic Number,fyiReporting.RDL,CompressionConfig,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\RdlEngineConfig.cs,GetArray,The following statement contains a magic number: wa[2 + cmpData.Length + 1] = (byte)(c >> 16);
Magic Number,fyiReporting.RDL,CompressionConfig,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\RdlEngineConfig.cs,GetArray,The following statement contains a magic number: wa[2 + cmpData.Length + 1] = (byte)(c >> 16);
Magic Number,fyiReporting.RDL,CompressionConfig,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\RdlEngineConfig.cs,GetArray,The following statement contains a magic number: wa[2 + cmpData.Length + 2] = (byte)(c >> 8);
Magic Number,fyiReporting.RDL,CompressionConfig,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\RdlEngineConfig.cs,GetArray,The following statement contains a magic number: wa[2 + cmpData.Length + 2] = (byte)(c >> 8);
Magic Number,fyiReporting.RDL,CompressionConfig,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\RdlEngineConfig.cs,GetArray,The following statement contains a magic number: wa[2 + cmpData.Length + 2] = (byte)(c >> 8);
Magic Number,fyiReporting.RDL,CompressionConfig,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\RdlEngineConfig.cs,GetArray,The following statement contains a magic number: wa[2 + cmpData.Length + 3] = (byte)(c);
Magic Number,fyiReporting.RDL,CompressionConfig,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\RdlEngineConfig.cs,GetArray,The following statement contains a magic number: wa[2 + cmpData.Length + 3] = (byte)(c);
Magic Number,fyiReporting.RDL,CompressionConfig,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\RdlEngineConfig.cs,adler,The following statement contains a magic number: const int MOD_ADLER = 65521;
Magic Number,fyiReporting.RDL,CompressionConfig,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\RdlEngineConfig.cs,adler,The following statement contains a magic number: while (len > 0)              {                  int tlen = len > 5552 ? 5552 : len;                  len -= tlen;                  do                  {                      a += cmpData[i++];                      b += a;                  } while (--tlen > 0);                    a %= MOD_ADLER;                  b %= MOD_ADLER;              }
Magic Number,fyiReporting.RDL,CompressionConfig,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\RdlEngineConfig.cs,adler,The following statement contains a magic number: while (len > 0)              {                  int tlen = len > 5552 ? 5552 : len;                  len -= tlen;                  do                  {                      a += cmpData[i++];                      b += a;                  } while (--tlen > 0);                    a %= MOD_ADLER;                  b %= MOD_ADLER;              }
Magic Number,fyiReporting.RDL,CompressionConfig,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\RdlEngineConfig.cs,adler,The following statement contains a magic number: return (b << 16) | a;
Magic Number,fyiReporting.RDL,CompressionConfig,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\RdlEngineConfig.cs,GetStream,The following statement contains a magic number: if (_UseCompression == 2)              {   // use the built-in compression .NET 2 provides                   //System.IO.Compression.GZipStream cs =                   //    new System.IO.Compression.GZipStream(str' System.IO.Compression.CompressionMode.Compress);                   System.IO.Compression.DeflateStream cs =                      new System.IO.Compression.DeflateStream(str' System.IO.Compression.CompressionMode.Compress);                  return cs;              }
Magic Number,fyiReporting.RDL,Report,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\Report.cs,RunRenderMht,The following statement contains a magic number: try  			{  				string tempHtmlReportFileName = Path.ChangeExtension(Path.GetTempFileName()' "htm");  				temp = new OneFileStreamGen(tempHtmlReportFileName' true);  				RunRender(temp' OutputPresentationType.HTML);  				temp.CloseMainStream();    				// Create the mht file (into a temporary file position)  				MhtBuilder mhtConverter = new MhtBuilder();  				string fileName = Path.ChangeExtension(Path.GetTempFileName()' "mht");  				mhtConverter.SavePageArchive(fileName' "file://" + tempHtmlReportFileName);    				// clean up the temporary files  				foreach (string tempFileName in temp.FileList)  				{  					try  					{  						File.Delete(tempFileName);  					}  					catch{}  				}    				// Copy the mht file to the requested stream  				Stream os = sg.GetStream();  				fs = File.OpenRead(fileName);  				byte[] ba = new byte[4096];  				int rb=0;  				while ((rb = fs.Read(ba' 0' ba.Length)) > 0)  				{  					os.Write(ba' 0' rb);  				}  				  			}  			catch (Exception ex)  			{  				rl.LogError(8' "Error converting HTML to MHTML " + ex.Message +   									Environment.NewLine + ex.StackTrace);  			}  			finally  			{  				if (temp != null)  					temp.CloseMainStream();  				if (fs != null)  					fs.Close();                  _Cache = new RCache();              }
Magic Number,fyiReporting.RDL,Report,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\Report.cs,RunRenderMht,The following statement contains a magic number: try  			{  				string tempHtmlReportFileName = Path.ChangeExtension(Path.GetTempFileName()' "htm");  				temp = new OneFileStreamGen(tempHtmlReportFileName' true);  				RunRender(temp' OutputPresentationType.HTML);  				temp.CloseMainStream();    				// Create the mht file (into a temporary file position)  				MhtBuilder mhtConverter = new MhtBuilder();  				string fileName = Path.ChangeExtension(Path.GetTempFileName()' "mht");  				mhtConverter.SavePageArchive(fileName' "file://" + tempHtmlReportFileName);    				// clean up the temporary files  				foreach (string tempFileName in temp.FileList)  				{  					try  					{  						File.Delete(tempFileName);  					}  					catch{}  				}    				// Copy the mht file to the requested stream  				Stream os = sg.GetStream();  				fs = File.OpenRead(fileName);  				byte[] ba = new byte[4096];  				int rb=0;  				while ((rb = fs.Read(ba' 0' ba.Length)) > 0)  				{  					os.Write(ba' 0' rb);  				}  				  			}  			catch (Exception ex)  			{  				rl.LogError(8' "Error converting HTML to MHTML " + ex.Message +   									Environment.NewLine + ex.StackTrace);  			}  			finally  			{  				if (temp != null)  					temp.CloseMainStream();  				if (fs != null)  					fs.Close();                  _Cache = new RCache();              }
Magic Number,fyiReporting.RDL,Report,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\Report.cs,RunRenderXmlTransform,The following statement contains a magic number: try  			{  				string file;  				if (_Report.DataTransform[0] != Path.DirectorySeparatorChar)  					file = this.Folder + Path.DirectorySeparatorChar + _Report.DataTransform;  				else  					file = this.Folder + _Report.DataTransform;  				XmlUtil.XslTrans(file' msg.GetText()' sg.GetStream());  			}	  			catch (Exception ex)  			{  				rl.LogError(8' "Error processing DataTransform " + ex.Message + "\r\n" + ex.StackTrace);  			}  			finally   			{  				msg.Dispose();  			}
Magic Number,fyiReporting.RDL,Report,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\Report.cs,BuildPages,The following statement contains a magic number: try  			{  				Page p = new Page(1);				// kick it off with a new page  				pgs.AddPage(p);    				// Create all the pages  				_Report.Body.RunPage(pgs);    				if (pgs.LastPage.IsEmpty() && pgs.PageCount > 1) // get rid of extraneous pages which  					pgs.RemoveLastPage();			//   can be caused by region page break at end    				// Now create the headers and footers for all the pages (as needed)  				if (_Report.PageHeader != null)  					_Report.PageHeader.RunPage(pgs);  				if (_Report.PageFooter != null)  					_Report.PageFooter.RunPage(pgs);  				// clear out any runtime clutter  				foreach (Page pg in pgs)  					pg.ResetPageExpressions();                    pgs.SortPageItems();             // Handle ZIndex ordering of pages  			}  			catch (Exception e)  			{  				rl.LogError(8' "Exception running report\r\n" + e.Message + "\r\n" + e.StackTrace);  			}  			finally  			{  				pgs.CleanUp();		// always want to make sure we clean this up since                   _Cache = new RCache();  			}
Magic Number,fyiReporting.RDL,StyleInfo,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\StyleInfo.cs,StyleInfo,The following statement contains a magic number: FontSize = 10;
Magic Number,fyiReporting.RDL,StyleInfo,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\StyleInfo.cs,GetFormatCode,The following statement contains a magic number: switch (val)              {                  case "General":                      return 0;                  case "0":                      return 1;                  case "0.00":                      return 2;                  case "#'##0":                      return 3;                  case "#'##0.00":                      return 4;                  case "0%":                      return 9;                  case "0.00%":                      return 10;                  case "0.00E+00":                      return 11;                  case "# ?/?":                      return 12;                  case " # ??/??":                      return 13;                  case "mm-dd-yy":                      return 14;                  case "d-mmm-yy":                      return 15;                  case "d-mmm":                      return 16;                  case "mmm-yy":                      return 17;                  case "h:mm AM/PM":                      return 18;                  case "h:mm:ss AM/PM":                      return 19;                  case "h:mm":                      return 20;                  case "h:mm:ss":                      return 21;                  case "m/d/yy h:mm":                      return 22;                  case "#'##0 ;(#'##0)":                      return 37;                  case "#'##0 ;[Red](#'##0)":                      return 38;                  case "#'##0.00;(#'##0.00)":                      return 39;                  case "#'##0.00;[Red](#'##0.00)":                      return 40;                  case "mm:ss":                      return 45;                  case "[h]:mm:ss":                      return 46;                  case "mmss.0":                      return 47;                  case "##0.0E+0":                      return 48;                  case "@":                      return 49;                  default:                      return 999;                }
Magic Number,fyiReporting.RDL,StyleInfo,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\StyleInfo.cs,GetFormatCode,The following statement contains a magic number: switch (val)              {                  case "General":                      return 0;                  case "0":                      return 1;                  case "0.00":                      return 2;                  case "#'##0":                      return 3;                  case "#'##0.00":                      return 4;                  case "0%":                      return 9;                  case "0.00%":                      return 10;                  case "0.00E+00":                      return 11;                  case "# ?/?":                      return 12;                  case " # ??/??":                      return 13;                  case "mm-dd-yy":                      return 14;                  case "d-mmm-yy":                      return 15;                  case "d-mmm":                      return 16;                  case "mmm-yy":                      return 17;                  case "h:mm AM/PM":                      return 18;                  case "h:mm:ss AM/PM":                      return 19;                  case "h:mm":                      return 20;                  case "h:mm:ss":                      return 21;                  case "m/d/yy h:mm":                      return 22;                  case "#'##0 ;(#'##0)":                      return 37;                  case "#'##0 ;[Red](#'##0)":                      return 38;                  case "#'##0.00;(#'##0.00)":                      return 39;                  case "#'##0.00;[Red](#'##0.00)":                      return 40;                  case "mm:ss":                      return 45;                  case "[h]:mm:ss":                      return 46;                  case "mmss.0":                      return 47;                  case "##0.0E+0":                      return 48;                  case "@":                      return 49;                  default:                      return 999;                }
Magic Number,fyiReporting.RDL,StyleInfo,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\StyleInfo.cs,GetFormatCode,The following statement contains a magic number: switch (val)              {                  case "General":                      return 0;                  case "0":                      return 1;                  case "0.00":                      return 2;                  case "#'##0":                      return 3;                  case "#'##0.00":                      return 4;                  case "0%":                      return 9;                  case "0.00%":                      return 10;                  case "0.00E+00":                      return 11;                  case "# ?/?":                      return 12;                  case " # ??/??":                      return 13;                  case "mm-dd-yy":                      return 14;                  case "d-mmm-yy":                      return 15;                  case "d-mmm":                      return 16;                  case "mmm-yy":                      return 17;                  case "h:mm AM/PM":                      return 18;                  case "h:mm:ss AM/PM":                      return 19;                  case "h:mm":                      return 20;                  case "h:mm:ss":                      return 21;                  case "m/d/yy h:mm":                      return 22;                  case "#'##0 ;(#'##0)":                      return 37;                  case "#'##0 ;[Red](#'##0)":                      return 38;                  case "#'##0.00;(#'##0.00)":                      return 39;                  case "#'##0.00;[Red](#'##0.00)":                      return 40;                  case "mm:ss":                      return 45;                  case "[h]:mm:ss":                      return 46;                  case "mmss.0":                      return 47;                  case "##0.0E+0":                      return 48;                  case "@":                      return 49;                  default:                      return 999;                }
Magic Number,fyiReporting.RDL,StyleInfo,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\StyleInfo.cs,GetFormatCode,The following statement contains a magic number: switch (val)              {                  case "General":                      return 0;                  case "0":                      return 1;                  case "0.00":                      return 2;                  case "#'##0":                      return 3;                  case "#'##0.00":                      return 4;                  case "0%":                      return 9;                  case "0.00%":                      return 10;                  case "0.00E+00":                      return 11;                  case "# ?/?":                      return 12;                  case " # ??/??":                      return 13;                  case "mm-dd-yy":                      return 14;                  case "d-mmm-yy":                      return 15;                  case "d-mmm":                      return 16;                  case "mmm-yy":                      return 17;                  case "h:mm AM/PM":                      return 18;                  case "h:mm:ss AM/PM":                      return 19;                  case "h:mm":                      return 20;                  case "h:mm:ss":                      return 21;                  case "m/d/yy h:mm":                      return 22;                  case "#'##0 ;(#'##0)":                      return 37;                  case "#'##0 ;[Red](#'##0)":                      return 38;                  case "#'##0.00;(#'##0.00)":                      return 39;                  case "#'##0.00;[Red](#'##0.00)":                      return 40;                  case "mm:ss":                      return 45;                  case "[h]:mm:ss":                      return 46;                  case "mmss.0":                      return 47;                  case "##0.0E+0":                      return 48;                  case "@":                      return 49;                  default:                      return 999;                }
Magic Number,fyiReporting.RDL,StyleInfo,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\StyleInfo.cs,GetFormatCode,The following statement contains a magic number: switch (val)              {                  case "General":                      return 0;                  case "0":                      return 1;                  case "0.00":                      return 2;                  case "#'##0":                      return 3;                  case "#'##0.00":                      return 4;                  case "0%":                      return 9;                  case "0.00%":                      return 10;                  case "0.00E+00":                      return 11;                  case "# ?/?":                      return 12;                  case " # ??/??":                      return 13;                  case "mm-dd-yy":                      return 14;                  case "d-mmm-yy":                      return 15;                  case "d-mmm":                      return 16;                  case "mmm-yy":                      return 17;                  case "h:mm AM/PM":                      return 18;                  case "h:mm:ss AM/PM":                      return 19;                  case "h:mm":                      return 20;                  case "h:mm:ss":                      return 21;                  case "m/d/yy h:mm":                      return 22;                  case "#'##0 ;(#'##0)":                      return 37;                  case "#'##0 ;[Red](#'##0)":                      return 38;                  case "#'##0.00;(#'##0.00)":                      return 39;                  case "#'##0.00;[Red](#'##0.00)":                      return 40;                  case "mm:ss":                      return 45;                  case "[h]:mm:ss":                      return 46;                  case "mmss.0":                      return 47;                  case "##0.0E+0":                      return 48;                  case "@":                      return 49;                  default:                      return 999;                }
Magic Number,fyiReporting.RDL,StyleInfo,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\StyleInfo.cs,GetFormatCode,The following statement contains a magic number: switch (val)              {                  case "General":                      return 0;                  case "0":                      return 1;                  case "0.00":                      return 2;                  case "#'##0":                      return 3;                  case "#'##0.00":                      return 4;                  case "0%":                      return 9;                  case "0.00%":                      return 10;                  case "0.00E+00":                      return 11;                  case "# ?/?":                      return 12;                  case " # ??/??":                      return 13;                  case "mm-dd-yy":                      return 14;                  case "d-mmm-yy":                      return 15;                  case "d-mmm":                      return 16;                  case "mmm-yy":                      return 17;                  case "h:mm AM/PM":                      return 18;                  case "h:mm:ss AM/PM":                      return 19;                  case "h:mm":                      return 20;                  case "h:mm:ss":                      return 21;                  case "m/d/yy h:mm":                      return 22;                  case "#'##0 ;(#'##0)":                      return 37;                  case "#'##0 ;[Red](#'##0)":                      return 38;                  case "#'##0.00;(#'##0.00)":                      return 39;                  case "#'##0.00;[Red](#'##0.00)":                      return 40;                  case "mm:ss":                      return 45;                  case "[h]:mm:ss":                      return 46;                  case "mmss.0":                      return 47;                  case "##0.0E+0":                      return 48;                  case "@":                      return 49;                  default:                      return 999;                }
Magic Number,fyiReporting.RDL,StyleInfo,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\StyleInfo.cs,GetFormatCode,The following statement contains a magic number: switch (val)              {                  case "General":                      return 0;                  case "0":                      return 1;                  case "0.00":                      return 2;                  case "#'##0":                      return 3;                  case "#'##0.00":                      return 4;                  case "0%":                      return 9;                  case "0.00%":                      return 10;                  case "0.00E+00":                      return 11;                  case "# ?/?":                      return 12;                  case " # ??/??":                      return 13;                  case "mm-dd-yy":                      return 14;                  case "d-mmm-yy":                      return 15;                  case "d-mmm":                      return 16;                  case "mmm-yy":                      return 17;                  case "h:mm AM/PM":                      return 18;                  case "h:mm:ss AM/PM":                      return 19;                  case "h:mm":                      return 20;                  case "h:mm:ss":                      return 21;                  case "m/d/yy h:mm":                      return 22;                  case "#'##0 ;(#'##0)":                      return 37;                  case "#'##0 ;[Red](#'##0)":                      return 38;                  case "#'##0.00;(#'##0.00)":                      return 39;                  case "#'##0.00;[Red](#'##0.00)":                      return 40;                  case "mm:ss":                      return 45;                  case "[h]:mm:ss":                      return 46;                  case "mmss.0":                      return 47;                  case "##0.0E+0":                      return 48;                  case "@":                      return 49;                  default:                      return 999;                }
Magic Number,fyiReporting.RDL,StyleInfo,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\StyleInfo.cs,GetFormatCode,The following statement contains a magic number: switch (val)              {                  case "General":                      return 0;                  case "0":                      return 1;                  case "0.00":                      return 2;                  case "#'##0":                      return 3;                  case "#'##0.00":                      return 4;                  case "0%":                      return 9;                  case "0.00%":                      return 10;                  case "0.00E+00":                      return 11;                  case "# ?/?":                      return 12;                  case " # ??/??":                      return 13;                  case "mm-dd-yy":                      return 14;                  case "d-mmm-yy":                      return 15;                  case "d-mmm":                      return 16;                  case "mmm-yy":                      return 17;                  case "h:mm AM/PM":                      return 18;                  case "h:mm:ss AM/PM":                      return 19;                  case "h:mm":                      return 20;                  case "h:mm:ss":                      return 21;                  case "m/d/yy h:mm":                      return 22;                  case "#'##0 ;(#'##0)":                      return 37;                  case "#'##0 ;[Red](#'##0)":                      return 38;                  case "#'##0.00;(#'##0.00)":                      return 39;                  case "#'##0.00;[Red](#'##0.00)":                      return 40;                  case "mm:ss":                      return 45;                  case "[h]:mm:ss":                      return 46;                  case "mmss.0":                      return 47;                  case "##0.0E+0":                      return 48;                  case "@":                      return 49;                  default:                      return 999;                }
Magic Number,fyiReporting.RDL,StyleInfo,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\StyleInfo.cs,GetFormatCode,The following statement contains a magic number: switch (val)              {                  case "General":                      return 0;                  case "0":                      return 1;                  case "0.00":                      return 2;                  case "#'##0":                      return 3;                  case "#'##0.00":                      return 4;                  case "0%":                      return 9;                  case "0.00%":                      return 10;                  case "0.00E+00":                      return 11;                  case "# ?/?":                      return 12;                  case " # ??/??":                      return 13;                  case "mm-dd-yy":                      return 14;                  case "d-mmm-yy":                      return 15;                  case "d-mmm":                      return 16;                  case "mmm-yy":                      return 17;                  case "h:mm AM/PM":                      return 18;                  case "h:mm:ss AM/PM":                      return 19;                  case "h:mm":                      return 20;                  case "h:mm:ss":                      return 21;                  case "m/d/yy h:mm":                      return 22;                  case "#'##0 ;(#'##0)":                      return 37;                  case "#'##0 ;[Red](#'##0)":                      return 38;                  case "#'##0.00;(#'##0.00)":                      return 39;                  case "#'##0.00;[Red](#'##0.00)":                      return 40;                  case "mm:ss":                      return 45;                  case "[h]:mm:ss":                      return 46;                  case "mmss.0":                      return 47;                  case "##0.0E+0":                      return 48;                  case "@":                      return 49;                  default:                      return 999;                }
Magic Number,fyiReporting.RDL,StyleInfo,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\StyleInfo.cs,GetFormatCode,The following statement contains a magic number: switch (val)              {                  case "General":                      return 0;                  case "0":                      return 1;                  case "0.00":                      return 2;                  case "#'##0":                      return 3;                  case "#'##0.00":                      return 4;                  case "0%":                      return 9;                  case "0.00%":                      return 10;                  case "0.00E+00":                      return 11;                  case "# ?/?":                      return 12;                  case " # ??/??":                      return 13;                  case "mm-dd-yy":                      return 14;                  case "d-mmm-yy":                      return 15;                  case "d-mmm":                      return 16;                  case "mmm-yy":                      return 17;                  case "h:mm AM/PM":                      return 18;                  case "h:mm:ss AM/PM":                      return 19;                  case "h:mm":                      return 20;                  case "h:mm:ss":                      return 21;                  case "m/d/yy h:mm":                      return 22;                  case "#'##0 ;(#'##0)":                      return 37;                  case "#'##0 ;[Red](#'##0)":                      return 38;                  case "#'##0.00;(#'##0.00)":                      return 39;                  case "#'##0.00;[Red](#'##0.00)":                      return 40;                  case "mm:ss":                      return 45;                  case "[h]:mm:ss":                      return 46;                  case "mmss.0":                      return 47;                  case "##0.0E+0":                      return 48;                  case "@":                      return 49;                  default:                      return 999;                }
Magic Number,fyiReporting.RDL,StyleInfo,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\StyleInfo.cs,GetFormatCode,The following statement contains a magic number: switch (val)              {                  case "General":                      return 0;                  case "0":                      return 1;                  case "0.00":                      return 2;                  case "#'##0":                      return 3;                  case "#'##0.00":                      return 4;                  case "0%":                      return 9;                  case "0.00%":                      return 10;                  case "0.00E+00":                      return 11;                  case "# ?/?":                      return 12;                  case " # ??/??":                      return 13;                  case "mm-dd-yy":                      return 14;                  case "d-mmm-yy":                      return 15;                  case "d-mmm":                      return 16;                  case "mmm-yy":                      return 17;                  case "h:mm AM/PM":                      return 18;                  case "h:mm:ss AM/PM":                      return 19;                  case "h:mm":                      return 20;                  case "h:mm:ss":                      return 21;                  case "m/d/yy h:mm":                      return 22;                  case "#'##0 ;(#'##0)":                      return 37;                  case "#'##0 ;[Red](#'##0)":                      return 38;                  case "#'##0.00;(#'##0.00)":                      return 39;                  case "#'##0.00;[Red](#'##0.00)":                      return 40;                  case "mm:ss":                      return 45;                  case "[h]:mm:ss":                      return 46;                  case "mmss.0":                      return 47;                  case "##0.0E+0":                      return 48;                  case "@":                      return 49;                  default:                      return 999;                }
Magic Number,fyiReporting.RDL,StyleInfo,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\StyleInfo.cs,GetFormatCode,The following statement contains a magic number: switch (val)              {                  case "General":                      return 0;                  case "0":                      return 1;                  case "0.00":                      return 2;                  case "#'##0":                      return 3;                  case "#'##0.00":                      return 4;                  case "0%":                      return 9;                  case "0.00%":                      return 10;                  case "0.00E+00":                      return 11;                  case "# ?/?":                      return 12;                  case " # ??/??":                      return 13;                  case "mm-dd-yy":                      return 14;                  case "d-mmm-yy":                      return 15;                  case "d-mmm":                      return 16;                  case "mmm-yy":                      return 17;                  case "h:mm AM/PM":                      return 18;                  case "h:mm:ss AM/PM":                      return 19;                  case "h:mm":                      return 20;                  case "h:mm:ss":                      return 21;                  case "m/d/yy h:mm":                      return 22;                  case "#'##0 ;(#'##0)":                      return 37;                  case "#'##0 ;[Red](#'##0)":                      return 38;                  case "#'##0.00;(#'##0.00)":                      return 39;                  case "#'##0.00;[Red](#'##0.00)":                      return 40;                  case "mm:ss":                      return 45;                  case "[h]:mm:ss":                      return 46;                  case "mmss.0":                      return 47;                  case "##0.0E+0":                      return 48;                  case "@":                      return 49;                  default:                      return 999;                }
Magic Number,fyiReporting.RDL,StyleInfo,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\StyleInfo.cs,GetFormatCode,The following statement contains a magic number: switch (val)              {                  case "General":                      return 0;                  case "0":                      return 1;                  case "0.00":                      return 2;                  case "#'##0":                      return 3;                  case "#'##0.00":                      return 4;                  case "0%":                      return 9;                  case "0.00%":                      return 10;                  case "0.00E+00":                      return 11;                  case "# ?/?":                      return 12;                  case " # ??/??":                      return 13;                  case "mm-dd-yy":                      return 14;                  case "d-mmm-yy":                      return 15;                  case "d-mmm":                      return 16;                  case "mmm-yy":                      return 17;                  case "h:mm AM/PM":                      return 18;                  case "h:mm:ss AM/PM":                      return 19;                  case "h:mm":                      return 20;                  case "h:mm:ss":                      return 21;                  case "m/d/yy h:mm":                      return 22;                  case "#'##0 ;(#'##0)":                      return 37;                  case "#'##0 ;[Red](#'##0)":                      return 38;                  case "#'##0.00;(#'##0.00)":                      return 39;                  case "#'##0.00;[Red](#'##0.00)":                      return 40;                  case "mm:ss":                      return 45;                  case "[h]:mm:ss":                      return 46;                  case "mmss.0":                      return 47;                  case "##0.0E+0":                      return 48;                  case "@":                      return 49;                  default:                      return 999;                }
Magic Number,fyiReporting.RDL,StyleInfo,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\StyleInfo.cs,GetFormatCode,The following statement contains a magic number: switch (val)              {                  case "General":                      return 0;                  case "0":                      return 1;                  case "0.00":                      return 2;                  case "#'##0":                      return 3;                  case "#'##0.00":                      return 4;                  case "0%":                      return 9;                  case "0.00%":                      return 10;                  case "0.00E+00":                      return 11;                  case "# ?/?":                      return 12;                  case " # ??/??":                      return 13;                  case "mm-dd-yy":                      return 14;                  case "d-mmm-yy":                      return 15;                  case "d-mmm":                      return 16;                  case "mmm-yy":                      return 17;                  case "h:mm AM/PM":                      return 18;                  case "h:mm:ss AM/PM":                      return 19;                  case "h:mm":                      return 20;                  case "h:mm:ss":                      return 21;                  case "m/d/yy h:mm":                      return 22;                  case "#'##0 ;(#'##0)":                      return 37;                  case "#'##0 ;[Red](#'##0)":                      return 38;                  case "#'##0.00;(#'##0.00)":                      return 39;                  case "#'##0.00;[Red](#'##0.00)":                      return 40;                  case "mm:ss":                      return 45;                  case "[h]:mm:ss":                      return 46;                  case "mmss.0":                      return 47;                  case "##0.0E+0":                      return 48;                  case "@":                      return 49;                  default:                      return 999;                }
Magic Number,fyiReporting.RDL,StyleInfo,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\StyleInfo.cs,GetFormatCode,The following statement contains a magic number: switch (val)              {                  case "General":                      return 0;                  case "0":                      return 1;                  case "0.00":                      return 2;                  case "#'##0":                      return 3;                  case "#'##0.00":                      return 4;                  case "0%":                      return 9;                  case "0.00%":                      return 10;                  case "0.00E+00":                      return 11;                  case "# ?/?":                      return 12;                  case " # ??/??":                      return 13;                  case "mm-dd-yy":                      return 14;                  case "d-mmm-yy":                      return 15;                  case "d-mmm":                      return 16;                  case "mmm-yy":                      return 17;                  case "h:mm AM/PM":                      return 18;                  case "h:mm:ss AM/PM":                      return 19;                  case "h:mm":                      return 20;                  case "h:mm:ss":                      return 21;                  case "m/d/yy h:mm":                      return 22;                  case "#'##0 ;(#'##0)":                      return 37;                  case "#'##0 ;[Red](#'##0)":                      return 38;                  case "#'##0.00;(#'##0.00)":                      return 39;                  case "#'##0.00;[Red](#'##0.00)":                      return 40;                  case "mm:ss":                      return 45;                  case "[h]:mm:ss":                      return 46;                  case "mmss.0":                      return 47;                  case "##0.0E+0":                      return 48;                  case "@":                      return 49;                  default:                      return 999;                }
Magic Number,fyiReporting.RDL,StyleInfo,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\StyleInfo.cs,GetFormatCode,The following statement contains a magic number: switch (val)              {                  case "General":                      return 0;                  case "0":                      return 1;                  case "0.00":                      return 2;                  case "#'##0":                      return 3;                  case "#'##0.00":                      return 4;                  case "0%":                      return 9;                  case "0.00%":                      return 10;                  case "0.00E+00":                      return 11;                  case "# ?/?":                      return 12;                  case " # ??/??":                      return 13;                  case "mm-dd-yy":                      return 14;                  case "d-mmm-yy":                      return 15;                  case "d-mmm":                      return 16;                  case "mmm-yy":                      return 17;                  case "h:mm AM/PM":                      return 18;                  case "h:mm:ss AM/PM":                      return 19;                  case "h:mm":                      return 20;                  case "h:mm:ss":                      return 21;                  case "m/d/yy h:mm":                      return 22;                  case "#'##0 ;(#'##0)":                      return 37;                  case "#'##0 ;[Red](#'##0)":                      return 38;                  case "#'##0.00;(#'##0.00)":                      return 39;                  case "#'##0.00;[Red](#'##0.00)":                      return 40;                  case "mm:ss":                      return 45;                  case "[h]:mm:ss":                      return 46;                  case "mmss.0":                      return 47;                  case "##0.0E+0":                      return 48;                  case "@":                      return 49;                  default:                      return 999;                }
Magic Number,fyiReporting.RDL,StyleInfo,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\StyleInfo.cs,GetFormatCode,The following statement contains a magic number: switch (val)              {                  case "General":                      return 0;                  case "0":                      return 1;                  case "0.00":                      return 2;                  case "#'##0":                      return 3;                  case "#'##0.00":                      return 4;                  case "0%":                      return 9;                  case "0.00%":                      return 10;                  case "0.00E+00":                      return 11;                  case "# ?/?":                      return 12;                  case " # ??/??":                      return 13;                  case "mm-dd-yy":                      return 14;                  case "d-mmm-yy":                      return 15;                  case "d-mmm":                      return 16;                  case "mmm-yy":                      return 17;                  case "h:mm AM/PM":                      return 18;                  case "h:mm:ss AM/PM":                      return 19;                  case "h:mm":                      return 20;                  case "h:mm:ss":                      return 21;                  case "m/d/yy h:mm":                      return 22;                  case "#'##0 ;(#'##0)":                      return 37;                  case "#'##0 ;[Red](#'##0)":                      return 38;                  case "#'##0.00;(#'##0.00)":                      return 39;                  case "#'##0.00;[Red](#'##0.00)":                      return 40;                  case "mm:ss":                      return 45;                  case "[h]:mm:ss":                      return 46;                  case "mmss.0":                      return 47;                  case "##0.0E+0":                      return 48;                  case "@":                      return 49;                  default:                      return 999;                }
Magic Number,fyiReporting.RDL,StyleInfo,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\StyleInfo.cs,GetFormatCode,The following statement contains a magic number: switch (val)              {                  case "General":                      return 0;                  case "0":                      return 1;                  case "0.00":                      return 2;                  case "#'##0":                      return 3;                  case "#'##0.00":                      return 4;                  case "0%":                      return 9;                  case "0.00%":                      return 10;                  case "0.00E+00":                      return 11;                  case "# ?/?":                      return 12;                  case " # ??/??":                      return 13;                  case "mm-dd-yy":                      return 14;                  case "d-mmm-yy":                      return 15;                  case "d-mmm":                      return 16;                  case "mmm-yy":                      return 17;                  case "h:mm AM/PM":                      return 18;                  case "h:mm:ss AM/PM":                      return 19;                  case "h:mm":                      return 20;                  case "h:mm:ss":                      return 21;                  case "m/d/yy h:mm":                      return 22;                  case "#'##0 ;(#'##0)":                      return 37;                  case "#'##0 ;[Red](#'##0)":                      return 38;                  case "#'##0.00;(#'##0.00)":                      return 39;                  case "#'##0.00;[Red](#'##0.00)":                      return 40;                  case "mm:ss":                      return 45;                  case "[h]:mm:ss":                      return 46;                  case "mmss.0":                      return 47;                  case "##0.0E+0":                      return 48;                  case "@":                      return 49;                  default:                      return 999;                }
Magic Number,fyiReporting.RDL,StyleInfo,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\StyleInfo.cs,GetFormatCode,The following statement contains a magic number: switch (val)              {                  case "General":                      return 0;                  case "0":                      return 1;                  case "0.00":                      return 2;                  case "#'##0":                      return 3;                  case "#'##0.00":                      return 4;                  case "0%":                      return 9;                  case "0.00%":                      return 10;                  case "0.00E+00":                      return 11;                  case "# ?/?":                      return 12;                  case " # ??/??":                      return 13;                  case "mm-dd-yy":                      return 14;                  case "d-mmm-yy":                      return 15;                  case "d-mmm":                      return 16;                  case "mmm-yy":                      return 17;                  case "h:mm AM/PM":                      return 18;                  case "h:mm:ss AM/PM":                      return 19;                  case "h:mm":                      return 20;                  case "h:mm:ss":                      return 21;                  case "m/d/yy h:mm":                      return 22;                  case "#'##0 ;(#'##0)":                      return 37;                  case "#'##0 ;[Red](#'##0)":                      return 38;                  case "#'##0.00;(#'##0.00)":                      return 39;                  case "#'##0.00;[Red](#'##0.00)":                      return 40;                  case "mm:ss":                      return 45;                  case "[h]:mm:ss":                      return 46;                  case "mmss.0":                      return 47;                  case "##0.0E+0":                      return 48;                  case "@":                      return 49;                  default:                      return 999;                }
Magic Number,fyiReporting.RDL,StyleInfo,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\StyleInfo.cs,GetFormatCode,The following statement contains a magic number: switch (val)              {                  case "General":                      return 0;                  case "0":                      return 1;                  case "0.00":                      return 2;                  case "#'##0":                      return 3;                  case "#'##0.00":                      return 4;                  case "0%":                      return 9;                  case "0.00%":                      return 10;                  case "0.00E+00":                      return 11;                  case "# ?/?":                      return 12;                  case " # ??/??":                      return 13;                  case "mm-dd-yy":                      return 14;                  case "d-mmm-yy":                      return 15;                  case "d-mmm":                      return 16;                  case "mmm-yy":                      return 17;                  case "h:mm AM/PM":                      return 18;                  case "h:mm:ss AM/PM":                      return 19;                  case "h:mm":                      return 20;                  case "h:mm:ss":                      return 21;                  case "m/d/yy h:mm":                      return 22;                  case "#'##0 ;(#'##0)":                      return 37;                  case "#'##0 ;[Red](#'##0)":                      return 38;                  case "#'##0.00;(#'##0.00)":                      return 39;                  case "#'##0.00;[Red](#'##0.00)":                      return 40;                  case "mm:ss":                      return 45;                  case "[h]:mm:ss":                      return 46;                  case "mmss.0":                      return 47;                  case "##0.0E+0":                      return 48;                  case "@":                      return 49;                  default:                      return 999;                }
Magic Number,fyiReporting.RDL,StyleInfo,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\StyleInfo.cs,GetFormatCode,The following statement contains a magic number: switch (val)              {                  case "General":                      return 0;                  case "0":                      return 1;                  case "0.00":                      return 2;                  case "#'##0":                      return 3;                  case "#'##0.00":                      return 4;                  case "0%":                      return 9;                  case "0.00%":                      return 10;                  case "0.00E+00":                      return 11;                  case "# ?/?":                      return 12;                  case " # ??/??":                      return 13;                  case "mm-dd-yy":                      return 14;                  case "d-mmm-yy":                      return 15;                  case "d-mmm":                      return 16;                  case "mmm-yy":                      return 17;                  case "h:mm AM/PM":                      return 18;                  case "h:mm:ss AM/PM":                      return 19;                  case "h:mm":                      return 20;                  case "h:mm:ss":                      return 21;                  case "m/d/yy h:mm":                      return 22;                  case "#'##0 ;(#'##0)":                      return 37;                  case "#'##0 ;[Red](#'##0)":                      return 38;                  case "#'##0.00;(#'##0.00)":                      return 39;                  case "#'##0.00;[Red](#'##0.00)":                      return 40;                  case "mm:ss":                      return 45;                  case "[h]:mm:ss":                      return 46;                  case "mmss.0":                      return 47;                  case "##0.0E+0":                      return 48;                  case "@":                      return 49;                  default:                      return 999;                }
Magic Number,fyiReporting.RDL,StyleInfo,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\StyleInfo.cs,GetFormatCode,The following statement contains a magic number: switch (val)              {                  case "General":                      return 0;                  case "0":                      return 1;                  case "0.00":                      return 2;                  case "#'##0":                      return 3;                  case "#'##0.00":                      return 4;                  case "0%":                      return 9;                  case "0.00%":                      return 10;                  case "0.00E+00":                      return 11;                  case "# ?/?":                      return 12;                  case " # ??/??":                      return 13;                  case "mm-dd-yy":                      return 14;                  case "d-mmm-yy":                      return 15;                  case "d-mmm":                      return 16;                  case "mmm-yy":                      return 17;                  case "h:mm AM/PM":                      return 18;                  case "h:mm:ss AM/PM":                      return 19;                  case "h:mm":                      return 20;                  case "h:mm:ss":                      return 21;                  case "m/d/yy h:mm":                      return 22;                  case "#'##0 ;(#'##0)":                      return 37;                  case "#'##0 ;[Red](#'##0)":                      return 38;                  case "#'##0.00;(#'##0.00)":                      return 39;                  case "#'##0.00;[Red](#'##0.00)":                      return 40;                  case "mm:ss":                      return 45;                  case "[h]:mm:ss":                      return 46;                  case "mmss.0":                      return 47;                  case "##0.0E+0":                      return 48;                  case "@":                      return 49;                  default:                      return 999;                }
Magic Number,fyiReporting.RDL,StyleInfo,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\StyleInfo.cs,GetFormatCode,The following statement contains a magic number: switch (val)              {                  case "General":                      return 0;                  case "0":                      return 1;                  case "0.00":                      return 2;                  case "#'##0":                      return 3;                  case "#'##0.00":                      return 4;                  case "0%":                      return 9;                  case "0.00%":                      return 10;                  case "0.00E+00":                      return 11;                  case "# ?/?":                      return 12;                  case " # ??/??":                      return 13;                  case "mm-dd-yy":                      return 14;                  case "d-mmm-yy":                      return 15;                  case "d-mmm":                      return 16;                  case "mmm-yy":                      return 17;                  case "h:mm AM/PM":                      return 18;                  case "h:mm:ss AM/PM":                      return 19;                  case "h:mm":                      return 20;                  case "h:mm:ss":                      return 21;                  case "m/d/yy h:mm":                      return 22;                  case "#'##0 ;(#'##0)":                      return 37;                  case "#'##0 ;[Red](#'##0)":                      return 38;                  case "#'##0.00;(#'##0.00)":                      return 39;                  case "#'##0.00;[Red](#'##0.00)":                      return 40;                  case "mm:ss":                      return 45;                  case "[h]:mm:ss":                      return 46;                  case "mmss.0":                      return 47;                  case "##0.0E+0":                      return 48;                  case "@":                      return 49;                  default:                      return 999;                }
Magic Number,fyiReporting.RDL,StyleInfo,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\StyleInfo.cs,GetFormatCode,The following statement contains a magic number: switch (val)              {                  case "General":                      return 0;                  case "0":                      return 1;                  case "0.00":                      return 2;                  case "#'##0":                      return 3;                  case "#'##0.00":                      return 4;                  case "0%":                      return 9;                  case "0.00%":                      return 10;                  case "0.00E+00":                      return 11;                  case "# ?/?":                      return 12;                  case " # ??/??":                      return 13;                  case "mm-dd-yy":                      return 14;                  case "d-mmm-yy":                      return 15;                  case "d-mmm":                      return 16;                  case "mmm-yy":                      return 17;                  case "h:mm AM/PM":                      return 18;                  case "h:mm:ss AM/PM":                      return 19;                  case "h:mm":                      return 20;                  case "h:mm:ss":                      return 21;                  case "m/d/yy h:mm":                      return 22;                  case "#'##0 ;(#'##0)":                      return 37;                  case "#'##0 ;[Red](#'##0)":                      return 38;                  case "#'##0.00;(#'##0.00)":                      return 39;                  case "#'##0.00;[Red](#'##0.00)":                      return 40;                  case "mm:ss":                      return 45;                  case "[h]:mm:ss":                      return 46;                  case "mmss.0":                      return 47;                  case "##0.0E+0":                      return 48;                  case "@":                      return 49;                  default:                      return 999;                }
Magic Number,fyiReporting.RDL,StyleInfo,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\StyleInfo.cs,GetFormatCode,The following statement contains a magic number: switch (val)              {                  case "General":                      return 0;                  case "0":                      return 1;                  case "0.00":                      return 2;                  case "#'##0":                      return 3;                  case "#'##0.00":                      return 4;                  case "0%":                      return 9;                  case "0.00%":                      return 10;                  case "0.00E+00":                      return 11;                  case "# ?/?":                      return 12;                  case " # ??/??":                      return 13;                  case "mm-dd-yy":                      return 14;                  case "d-mmm-yy":                      return 15;                  case "d-mmm":                      return 16;                  case "mmm-yy":                      return 17;                  case "h:mm AM/PM":                      return 18;                  case "h:mm:ss AM/PM":                      return 19;                  case "h:mm":                      return 20;                  case "h:mm:ss":                      return 21;                  case "m/d/yy h:mm":                      return 22;                  case "#'##0 ;(#'##0)":                      return 37;                  case "#'##0 ;[Red](#'##0)":                      return 38;                  case "#'##0.00;(#'##0.00)":                      return 39;                  case "#'##0.00;[Red](#'##0.00)":                      return 40;                  case "mm:ss":                      return 45;                  case "[h]:mm:ss":                      return 46;                  case "mmss.0":                      return 47;                  case "##0.0E+0":                      return 48;                  case "@":                      return 49;                  default:                      return 999;                }
Magic Number,fyiReporting.RDL,StyleInfo,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\StyleInfo.cs,GetFormatCode,The following statement contains a magic number: switch (val)              {                  case "General":                      return 0;                  case "0":                      return 1;                  case "0.00":                      return 2;                  case "#'##0":                      return 3;                  case "#'##0.00":                      return 4;                  case "0%":                      return 9;                  case "0.00%":                      return 10;                  case "0.00E+00":                      return 11;                  case "# ?/?":                      return 12;                  case " # ??/??":                      return 13;                  case "mm-dd-yy":                      return 14;                  case "d-mmm-yy":                      return 15;                  case "d-mmm":                      return 16;                  case "mmm-yy":                      return 17;                  case "h:mm AM/PM":                      return 18;                  case "h:mm:ss AM/PM":                      return 19;                  case "h:mm":                      return 20;                  case "h:mm:ss":                      return 21;                  case "m/d/yy h:mm":                      return 22;                  case "#'##0 ;(#'##0)":                      return 37;                  case "#'##0 ;[Red](#'##0)":                      return 38;                  case "#'##0.00;(#'##0.00)":                      return 39;                  case "#'##0.00;[Red](#'##0.00)":                      return 40;                  case "mm:ss":                      return 45;                  case "[h]:mm:ss":                      return 46;                  case "mmss.0":                      return 47;                  case "##0.0E+0":                      return 48;                  case "@":                      return 49;                  default:                      return 999;                }
Magic Number,fyiReporting.RDL,StyleInfo,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\StyleInfo.cs,GetFormatCode,The following statement contains a magic number: switch (val)              {                  case "General":                      return 0;                  case "0":                      return 1;                  case "0.00":                      return 2;                  case "#'##0":                      return 3;                  case "#'##0.00":                      return 4;                  case "0%":                      return 9;                  case "0.00%":                      return 10;                  case "0.00E+00":                      return 11;                  case "# ?/?":                      return 12;                  case " # ??/??":                      return 13;                  case "mm-dd-yy":                      return 14;                  case "d-mmm-yy":                      return 15;                  case "d-mmm":                      return 16;                  case "mmm-yy":                      return 17;                  case "h:mm AM/PM":                      return 18;                  case "h:mm:ss AM/PM":                      return 19;                  case "h:mm":                      return 20;                  case "h:mm:ss":                      return 21;                  case "m/d/yy h:mm":                      return 22;                  case "#'##0 ;(#'##0)":                      return 37;                  case "#'##0 ;[Red](#'##0)":                      return 38;                  case "#'##0.00;(#'##0.00)":                      return 39;                  case "#'##0.00;[Red](#'##0.00)":                      return 40;                  case "mm:ss":                      return 45;                  case "[h]:mm:ss":                      return 46;                  case "mmss.0":                      return 47;                  case "##0.0E+0":                      return 48;                  case "@":                      return 49;                  default:                      return 999;                }
Magic Number,fyiReporting.RDL.Utility,Measurement,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Utility\Measurement.cs,TwipsFromPoints,The following statement contains a magic number: return (int)Math.Round(points * 20' 0);
Missing Default,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegend,The following switch statement is missing a default case: switch (LineSize)                          {                              case "Small": intLineSize = 1;                                  break;                              case "Regular": intLineSize = 2;                                  break;                              case "Large": intLineSize = 3;                                  break;                              case "Extra Large": intLineSize = 4;                                  break;                              case "Super Size": intLineSize = 5;                                  break;                          }
Missing Default,fyiReporting.RDL,ChartBase,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBase.cs,DrawLegendMarker,The following switch statement is missing a default case: switch (marker)  			{                  case ChartMarkerEnum.Bubble:                  case ChartMarkerEnum.Circle:  					g.FillEllipse(b' x' y' mSize' mSize);  					break;  				case ChartMarkerEnum.Square:  					g.FillRectangle(b' x' y' mSize' mSize);  					break;  				case ChartMarkerEnum.Plus:  					// 20022008 AJM GJL - Changed to line - plus is hard to see                      p = new Pen(p.Brush' 2);  					g.DrawLine(p' new Point(x + (mSize + 1)/2' y)' new Point(x + (mSize + 1)/2' y + mSize));  					//g.DrawLine(p' new Point(x + (mSize + 1)/2' y + (mSize+1)/2)' new Point(x + mSize' y + (mSize+1)/2));  					break;  				case ChartMarkerEnum.Diamond:  					points = new PointF[5];  					points[0] = points[4] = new Point(x + (mSize + 1)/2' y);	// starting and ending point  					points[1] = new PointF(x' y + (mSize+1)/2);  					points[2] = new PointF(x + (mSize+1)/2' y+mSize);  					points[3] = new PointF(x + mSize' y + (mSize+1)/2);  					g.FillPolygon(b' points);  					break;  				case ChartMarkerEnum.Triangle:  					points = new PointF[4];  					points[0] = points[3] = new PointF(x + (mSize + 1)/2' y);	// starting and ending point  					points[1] = new PointF(x' y + mSize);  					points[2] = new PointF(x + mSize' y + mSize);  					g.FillPolygon(b' points);                      break;  				case ChartMarkerEnum.X:                      p = new Pen(p.Brush' 2);// 20022008 AJM GJL  					g.DrawLine(p' new Point(x' y)' new Point(x + mSize' y + mSize));  					g.DrawLine(p' new Point(x' y + mSize)' new Point(x + mSize' y));// 20022008 AJM GJL  					break;  			}
Missing Default,fyiReporting.RDL,ChartBubble,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartBubble.cs,DrawPlot,The following switch statement is missing a default case: switch (LineSize)                              {                                  case "Small": intLineSize = 1;                                      break;                                  case "Regular": intLineSize = 2;                                      break;                                  case "Large": intLineSize = 3;                                      break;                                  case "Extra Large": intLineSize = 4;                                      break;                                  case "Super Size": intLineSize = 5;                                      break;                              }
Missing Default,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawPlotAreaPlain,The following switch statement is missing a default case: switch (LineSize)                                              {                                                  case "Small": intLineSize = 1;                                                      break;                                                  case "Regular": intLineSize = 2;                                                      break;                                                  case "Large": intLineSize = 3;                                                      break;                                                  case "Extra Large": intLineSize = 4;                                                      break;                                                  case "Super Size": intLineSize = 5;                                                      break;                                              }
Missing Default,fyiReporting.RDL,ChartColumn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartColumn.cs,DrawLegendLineMarker,The following switch statement is missing a default case: switch (marker)              {                  case ChartMarkerEnum.Bubble:                  case ChartMarkerEnum.Circle:                      g.FillEllipse(b' x' y' mSize' mSize);                      break;                  case ChartMarkerEnum.Square:                      g.FillRectangle(b' x' y' mSize' mSize);                      break;                  case ChartMarkerEnum.Plus:                                                           p2 = new Pen(b' 2.0f);                      g.DrawLine(p2' new Point(x + (mSize + 1) / 2' y)' new Point(x + (mSize + 1) / 2' y + mSize));                      //g.DrawLine(p2' new Point(x + (mSize + 1) / 2' y + (mSize + 1) / 2)' new Point(x + mSize' y + (mSize + 1) / 2));                      break;                  case ChartMarkerEnum.Diamond:                      points = new PointF[5];                      points[0] = points[4] = new PointF(x + (mSize + 1) / 2' y);	// starting and ending point                      points[1] = new PointF(x' y + (mSize + 1) / 2);                      points[2] = new PointF(x + (mSize + 1) / 2' y + mSize);                      points[3] = new PointF(x + mSize' y + (mSize + 1) / 2);                      g.FillPolygon(b' points);                      break;                  case ChartMarkerEnum.Triangle:                      points = new PointF[4];                      points[0] = points[3] = new PointF(x + (mSize + 1) / 2' y);	// starting and ending point                      points[1] = new PointF(x' y + mSize);                      points[2] = new PointF(x + mSize' y + mSize);                      g.FillPolygon(b' points);                      break;                  case ChartMarkerEnum.X:                      p2 = new Pen(b' 2.0f);                      g.DrawLine(p2' new Point(x' y)' new Point(x + mSize' y + mSize));                      g.DrawLine(p2' new Point(x' y + mSize)' new Point(x + mSize' y));                      break;              }
Missing Default,fyiReporting.RDL,ChartLine,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartLine.cs,DrawPlotAreaLine,The following switch statement is missing a default case: switch (LineSize)                  {                      case "Small": intLineSize = 1;                          break;                      case "Regular": intLineSize = 2;                          break;                      case "Large": intLineSize = 3;                          break;                      case "Extra Large": intLineSize = 4;                          break;                      case "Super Size": intLineSize = 5;                          break;                  }
Missing Default,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,ReadXmlLines,The following switch statement is missing a default case: switch (xr.Name)                  {                      case "Points":                          pts = ReadXmlPoints(xr);                          break;                  }
Missing Default,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,ReadXmlPolygon,The following switch statement is missing a default case: switch (xr.Name)                  {                      case "Points":                          pts = ReadXmlPoints(xr);                          break;                      case "Keys":                          keys = ReadXmlKeys(xr);                          break;                      case "FillColor":                          fill = ReadXmlColor(xr);                          break;                  }
Missing Default,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,ReadXmlText,The following switch statement is missing a default case: switch (xr.Name)                  {                      case "Location":                          PointF[] pfa = ReadXmlPoints(xr);                          location = pfa[0];                          break;                      case "Value":                          val = xr.ReadString();                          break;                      case "FontFamily":                          family = xr.ReadString();                          break;                      case "FontSize":                          temp = xr.ReadString();                          try                          {                              fontsize = float.Parse(temp' NumberFormatInfo.InvariantInfo);                          }                          catch                          {                              fontsize = 8;                          }                          break;                      case "FontWeight":                          temp = xr.ReadString();                          bBold = temp.ToLower() == "bold";                          break;                      case "FontStyle":                          temp = xr.ReadString();                          bItalic = temp.ToLower() == "italic";                          break;                      case "TextDecoration":                          temp = xr.ReadString();                          switch (temp.ToLower())                          {                              case "underline":                                  bUnderline = true;                                  break;                              case "linethrough":                                  bUnderline = true;                                  break;                          }                          break;                  }
Missing Default,fyiReporting.RDL,MapData,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ChartMapData.cs,ReadXmlText,The following switch statement is missing a default case: switch (temp.ToLower())                          {                              case "underline":                                  bUnderline = true;                                  break;                              case "linethrough":                                  bUnderline = true;                                  break;                          }
Missing Default,fyiReporting.RDL,DataSetDefn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataSetDefn.cs,DataSetDefn,The following switch statement is missing a default case: switch (xAttr.Name)  				{  					case "Name":  						_Name = new Name(xAttr.Value);  						break;  				}
Missing Default,fyiReporting.RDL,DataSourceDefn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DataSourceDefn.cs,DataSourceDefn,The following switch statement is missing a default case: switch (xAttr.Name)  				{  					case "Name":  						_Name = new Name(xAttr.Value);  						break;  				}
Missing Default,fyiReporting.RDL,DrillthroughParameter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\DrillthroughParameter.cs,DrillthroughParameter,The following switch statement is missing a default case: switch (xAttr.Name)  				{  					case "Name":  						_Name = new Name(xAttr.Value);  						break;  				}
Missing Default,fyiReporting.RDL,EmbeddedImage,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EmbeddedImage.cs,EmbeddedImage,The following switch statement is missing a default case: switch (xAttr.Name)  				{  					case "Name":  						_Name = new Name(xAttr.Value);  						break;  				}
Missing Default,fyiReporting.RDL,FillEllipse,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFDrawingRecords\FillEllipse.cs,DoInstructions,The following switch statement is missing a default case: switch (b.GetType().Name)              {                  case "SolidBrush":                      System.Drawing.SolidBrush theBrush = (System.Drawing.SolidBrush)b;                      Color col = theBrush.Color;                        PageEllipse pl = new PageEllipse();                      pl.X = X + Xp * SCALEFACTOR;                      pl.Y = Y + Yp * SCALEFACTOR;                      pl.W = Wid * SCALEFACTOR;                      pl.H = Hgt * SCALEFACTOR;                        StyleInfo SI = new StyleInfo();                                         SI.BackgroundColor = col;                      pl.SI = SI;                      items.Add(pl);                              //Lines.AppendFormat("\r\n"); //CrLf                      //Lines.AppendFormat("q\t"); //Push graphics state onto stack                      //Lines.AppendFormat("{0} w\t"' 1 * ScaleX); //set width of path                       //Lines.AppendFormat("{0} {1} {2} RG\t"' Math.Round(theBrush.Color.R / 255.0' 3)' Math.Round(theBrush.Color.G / 255.0' 3)' Math.Round(theBrush.Color.B / 255.0' 3)); //Set RGB colours                      //Lines.AppendFormat("{0} {1} {2} rg\t"' Math.Round(theBrush.Color.R / 255.0' 3)' Math.Round(theBrush.Color.G / 255.0' 3)' Math.Round(theBrush.Color.B / 255.0' 3)); //Set RGB colours                      ////Need some bezier curves to  draw an ellipse.. we can't draw a circle' but we can get close.                      //Double k = 0.5522847498;                      //Double RadiusX = (Wid / 2.0) * ScaleX;                      //Double RadiusY = (Hgt / 2.0) * ScaleY;                      //Double Y4 = Y + Height - Yp * ScaleY;                      //Double X1 = Xp * ScaleX + X;                      //Double Y1 = Y4 - RadiusY;                      //Double X4 = X1 + RadiusX;                      //Lines.AppendFormat("{0} {1} m\t"' X1' Y1);//FirstPoint..                      //Double kRy = k * RadiusY;                      //Double kRx = k * RadiusX;                      ////Control Point 1 will be on the same X as point 1 and be -kRy Y                      //Double X2 = X1;                      //Double Y2 = Y1 + kRy;                      //Double X3 = X4 - kRx;                      //Double Y3 = Y4;                      //Lines.AppendFormat("{0} {1} {2} {3} {4} {5}  c\t"' X2' Y2' X3' Y3' X4' Y4); //Upper Left Quadrant                      //X1 += 2 * RadiusX;                      //X2 = X1;                      //X3 += 2 * kRx;                      //Lines.AppendFormat("{0} {1} {2} {3} {4} {5}  c\t"' X3' Y3' X2' Y2' X1' Y1); //Upper Right Quadrant                      //Y2 -= 2 * kRy;                      //Y3 -= 2 * RadiusY;                      //Y4 = Y3;                      //Lines.AppendFormat("{0} {1} {2} {3} {4} {5}  c\t"' X2' Y2' X3' Y3' X4' Y4); //Lower Right Quadrant                      //X1 -= 2 * RadiusX;                      //X2 = X1;                      //X3 -= 2 * kRx;                      //Lines.AppendFormat("{0} {1} {2} {3} {4} {5}  c\t"' X3' Y3' X2' Y2' X1' Y1); //Lower Right Quadrant                      //Lines.AppendFormat("f\t");//fill path                      //Lines.AppendFormat("Q\t");//Pop graphics state from stack                       break;              }
Missing Default,fyiReporting.RDL,EMFBrush,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFObjects\EMFBrush.cs,ProcessBrush,The following switch statement is missing a default case: switch (BrushType)                  {                      case (UInt32)EMFBrushType.SolidColor:                                                 return new EmfSolidBrush(_br);                                               case (UInt32)EMFBrushType.HatchFill:                          return new EmfHatchFillBrush(_br);                                                                    case (UInt32)EMFBrushType.TextureFill:                          throw new NotSupportedException("TextureFill brush Not Supported Yet!");                                                case (UInt32)EMFBrushType.PathGradient:                          throw new NotSupportedException("PathGradient brush Not Supported Yet!");                                               case (UInt32)EMFBrushType.LinearGradient:                          return new EmfLinearGradientBrush(_br);                                           }
Missing Default,fyiReporting.RDL,EMFRecordObject,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\EMFConverter\EMFRecords\EMFRecordObject.cs,getObject,The following switch statement is missing a default case: switch ((UInt16)ObjectTyp)                  {                      case (UInt16)EmfObjectType.invalid:                           break;                      case (UInt16)EmfObjectType.brush:                          EMFBrush Obrush = EMFBrush.getEMFBrush(RecordData);                          Obrush.ObjectID = Objectid;                          return Obrush;                      case (UInt16)EmfObjectType.pen:                          EMFPen OPen = EMFPen.getEMFPen(RecordData);                          OPen.ObjectID = Objectid;                          return OPen;                      case (UInt16)EmfObjectType.path:                          break;                      case (UInt16)EmfObjectType.region:                          break;                      case (UInt16)EmfObjectType.image:                          break;                      case (UInt16)EmfObjectType.font:                          EMFFont OFont = EMFFont.getEMFFont(RecordData);                          OFont.ObjectID = Objectid;                          return OFont;                                           case (UInt16)EmfObjectType.stringformat:                          EMFStringFormat Ostringformat = EMFStringFormat.getEMFStringFormat(RecordData);                          Ostringformat.ObjectID = Objectid;                          return Ostringformat;                                             case (UInt16)EmfObjectType.ImageAttributes:                          break;                      case (UInt16)EmfObjectType.CustomLineType:                          break;                  }
Missing Default,fyiReporting.RDL,Field,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Field.cs,Field,The following switch statement is missing a default case: switch (xAttr.Name)  				{  					case "Name":  						_Name = new Name(xAttr.Value);  						break;  				}
Missing Default,fyiReporting.RDL,Grouping,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Grouping.cs,Grouping,The following switch statement is missing a default case: switch (xAttr.Name)  				{  					case "Name":  						_Name = new Name(xAttr.Value);  						break;  				}
Missing Default,fyiReporting.RDL,Query,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\Query.cs,ParameterValue,The following switch statement is missing a default case: switch (qp.Value.Expr.GetTypeCode())                      {                          case TypeCode.Char:                          case TypeCode.DateTime:                          case TypeCode.String:                              // need to double up on "'" and then surround by '                              svalue = svalue.Replace("'"' "''");                              svalue = "'" + svalue + "'";                              break;                      }
Missing Default,fyiReporting.RDL,QueryParameter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\QueryParameter.cs,QueryParameter,The following switch statement is missing a default case: switch (xAttr.Name)  				{  					case "Name":  						_Name = new Name(xAttr.Value);  						break;  				}
Missing Default,fyiReporting.RDL,ReportDefn,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportDefn.cs,ReportDefn,The following switch statement is missing a default case: switch (xAttr.Name)  				{  					case "Name":  						_Name = new Name(xAttr.Value);  						break;  				}
Missing Default,fyiReporting.RDL,ReportItem,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportItem.cs,ReportItem,The following switch statement is missing a default case: switch (xAttr.Name)  				{  					case "Name":  						_Name = new Name(xAttr.Value);  						break;  				}
Missing Default,fyiReporting.RDL,ReportParameter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\ReportParameter.cs,ReportParameter,The following switch statement is missing a default case: switch (xAttr.Name)  				{  					case "Name":  						_Name = new Name(xAttr.Value);  						break;  				}
Missing Default,fyiReporting.RDL,SubreportParameter,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Definition\SubreportParameter.cs,SubreportParameter,The following switch statement is missing a default case: switch (xAttr.Name)  				{  					case "Name":  						_Name = new Name(xAttr.Value);  						break;  				}
Missing Default,fyiReporting.RDL,PdfPatternEntry,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfPattern.cs,PdfPatternEntry,The following switch statement is missing a default case: switch (patternType)              {              	case "BackwardDiagonal":              		patternDict = BackwardDiagonal();              		break;              	case "DarkDownwardDiagonal":              		patternDict = DarkDownwardDiagonal();              		break;              	case "DarkHorizontal":              		patternDict = DarkHorizontal();              		break;              	case "Vertical":              		patternDict = Vertical();              		break;              	case "OutlinedDiamond":              		patternDict = OutlinedDiamond();              		break;              	case "LargeConfetti":              		patternDict = LargeConfetti();              		break;              	case "SmallConfetti":              		patternDict = SmallConfetti();              		break;              	case "HorizontalBrick":              		patternDict = HorizontalBrick();              		break;              	case "DiagonalBrick":              		patternDict = DiagonalBrick();              		break;              	case "SolidDiamond":              		patternDict = SolidDiamond();              		break;              	case "Cross":              		patternDict = Cross();              		break;              	case "CheckerBoard":              		patternDict = CheckerBoard();              		break;            			              }
Missing Default,fyiReporting.RDL,RenderTif,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderTif.cs,DrawString,The following switch statement is missing a default case: switch (si.TextDecoration)                  {                      case TextDecorationEnum.Underline:                          fs |= System.Drawing.FontStyle.Underline;                          break;                      case TextDecorationEnum.LineThrough:                          fs |= System.Drawing.FontStyle.Strikeout;                          break;                      case TextDecorationEnum.Overline:                      case TextDecorationEnum.None:                          break;                  }
Missing Default,fyiReporting.RDL,Parser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Parser.cs,MatchExprAndOr,The following switch statement is missing a default case: switch(t)  				{  					case TokenTypes.AND:  						result = new FunctionAnd(lhs' rhs);  						break;  					case TokenTypes.OR:  						result = new FunctionOr(lhs' rhs);  						break;  				}
Missing Default,fyiReporting.RDL,Parser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Parser.cs,MatchExprRelop,The following switch statement is missing a default case: switch(t)  				{  					case TokenTypes.EQUAL:  						result = new FunctionRelopEQ(lhs' rhs);  						break;  					case TokenTypes.NOTEQUAL:  						result = new FunctionRelopNE(lhs' rhs);  						break;  					case TokenTypes.GREATERTHAN:  						result = new FunctionRelopGT(lhs' rhs);  						break;  					case TokenTypes.GREATERTHANOREQUAL:  						result = new FunctionRelopGTE(lhs' rhs);  						break;  					case TokenTypes.LESSTHAN:  						result = new FunctionRelopLT(lhs' rhs);  						break;  					case TokenTypes.LESSTHANOREQUAL:  						result = new FunctionRelopLTE(lhs' rhs);  						break;  				}
Missing Default,fyiReporting.RDL,Parser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Parser.cs,MatchExprAddSub,The following switch statement is missing a default case: switch(t)  				{  					case TokenTypes.PLUSSTRING:  						result = new FunctionPlusString(lhs' rhs);  						break;  					case TokenTypes.PLUS:                          if (bDecimal)                              result = new FunctionPlusDecimal(lhs' rhs);                          else if (bString)                              result = new FunctionPlusString(lhs' rhs);                          else if (bInt32)                              result = new FunctionPlusInt32(lhs' rhs);                          else                              result = new FunctionPlus(lhs' rhs);  						break;  					case TokenTypes.MINUS:  						if (bDecimal)  							result = new FunctionMinusDecimal(lhs' rhs);  						else if (bString)  							throw new ParserException(Strings.Parser_ErrorP_MinusNeedNumbers + GetLocationInfo(curToken));                          else if (bInt32)                              result = new FunctionMinusInt32(lhs' rhs);                          else  							result = new FunctionMinus(lhs' rhs);  						break;  				}
Missing Default,fyiReporting.RDL,Parser,C:\repos\majorsilence_My-FyiReporting\RdlEngine\ExprParser\Parser.cs,MatchExprMultDiv,The following switch statement is missing a default case: switch (t)  				{  					case TokenTypes.FORWARDSLASH:  						if (bDecimal)  							result = new FunctionDivDecimal(lhs' rhs);	  						else  							result = new FunctionDiv(lhs' rhs);	  						break;  					case TokenTypes.STAR:  						if (bDecimal)  							result = new FunctionMultDecimal(lhs' rhs);  						else  							result = new FunctionMult(lhs' rhs);  						break;  					case TokenTypes.MODULUS:  						result = new FunctionModulus(lhs' rhs);  						break;  				}
Missing Default,fyiReporting.RDL,Ascii85Encode,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\PdfUtility.cs,ToString,The following switch statement is missing a default case: switch (count++)   				{  					case 0:	tuple |= ((uint)b << 24); break;  					case 1: tuple |= ((uint)b << 16); break;  					case 2:	tuple |= ((uint)b <<  8); break;  					case 3:  						tuple |= b;  						if (tuple == 0)   						{  							sw.Write('z');  							if (pos++ >= width)   							{  								pos = 0;  								sw.Write('\n');  							}  						}   						else  						{  							encode(tuple' count);  						}  						tuple = 0;  						count = 0;  						break;  				}
Missing Default,fyiReporting.RDL,RenderHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Render\RenderHtml.cs,Image,The following switch statement is missing a default case: switch (i.Sizing)              {                  case ImageSizingEnum.AutoSize:                      break;          // this is right                  case ImageSizingEnum.Clip:                      break;          // not sure how to clip it                      case ImageSizingEnum.Fit:                      if (h > 0)                          sw.Write(" height=\"{0}\""' h.ToString());                      if (w > 0)                          sw.Write(" width=\"{0}\""' w.ToString());                      break;                  case ImageSizingEnum.FitProportional:                      break;          // would have to create an image to handle this              }
Missing Default,fyiReporting.RDL,PageTextHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtml.cs,HandleStyleString,The following switch statement is missing a default case: switch (val[0].ToLower().Trim())  				{  					case "background":  					case "background-color":  						si.BackgroundColor = XmlUtil.ColorFromHtml(tval' si.Color);  						break;  					case "color":  						si.Color = XmlUtil.ColorFromHtml(tval' si.Color);  						break;  					case "font-family":  						si.FontFamily = tval;  						break;  					case "font-size":  						HandleStyleFontSize(si' tval);  						break;  					case "font-style":  						if (tval == "italic")  							si.FontStyle = FontStyleEnum.Italic;  						break;  					case "font-weight":  						HandleStyleFontWeight(si' tval);  						break;  				}
Missing Default,fyiReporting.RDL,PageTextHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtml.cs,HandleStyleFontSize,The following switch statement is missing a default case: switch (size)  				{  					case "xx-small":  						si.FontSize = 6;  						break;  					case "x-small":  						si.FontSize = 8;  						break;  					case "small":  						si.FontSize = 10;  						break;  					case "medium":  						si.FontSize = 12;  						break;  					case "large":  						si.FontSize = 14;  						break;  					case "x-large":  						si.FontSize = 16;  						break;  					case "xx-large":  						si.FontSize = 18;  						break;                      case "1":                          si.FontSize = 8;                          break;                      case "2":                          si.FontSize = 10;                          break;                      case "3":                          si.FontSize = 12;                          break;                      case "4":                          si.FontSize = 14;                          break;                      case "5":                          si.FontSize = 18;                          break;                      case "6":                          si.FontSize = 24;                          break;                      case "7":                          si.FontSize = 36;                          break;                  }
Missing Default,fyiReporting.RDL,PageTextHtml,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\PageTextHtml.cs,HandleStyleFontWeight,The following switch statement is missing a default case: switch (w)  				{  					case "bold":  						si.FontWeight = FontWeightEnum.Bold;  						break;  					case "bolder":  						if (si.FontWeight > FontWeightEnum.Bolder)  						{  							if (si.FontWeight < FontWeightEnum.W900)  								si.FontWeight++;  						}  						else if (si.FontWeight == FontWeightEnum.Normal)  							si.FontWeight = FontWeightEnum.W700;  						else if (si.FontWeight == FontWeightEnum.Bold)  							si.FontWeight = FontWeightEnum.W900;  						else if (si.FontWeight != FontWeightEnum.Bolder)  							si.FontWeight = FontWeightEnum.Normal;  						break;  					case "lighter":  						if (si.FontWeight > FontWeightEnum.Bolder)  						{  							if (si.FontWeight > FontWeightEnum.W100)  								si.FontWeight--;  						}  						else if (si.FontWeight == FontWeightEnum.Normal)  							si.FontWeight = FontWeightEnum.W300;  						else if (si.FontWeight == FontWeightEnum.Bold)  							si.FontWeight = FontWeightEnum.W400;  						else if (si.FontWeight != FontWeightEnum.Lighter)  							si.FontWeight = FontWeightEnum.Normal;  						break;  					case "normal":  						si.FontWeight = FontWeightEnum.Normal;  						break;  					case "100":  						si.FontWeight = FontWeightEnum.W100;  						break;  					case "200":  						si.FontWeight = FontWeightEnum.W200;  						break;  					case "300":  						si.FontWeight = FontWeightEnum.W300;  						break;  					case "400":  						si.FontWeight = FontWeightEnum.W400;  						break;  					case "500":  						si.FontWeight = FontWeightEnum.W500;  						break;  					case "600":  						si.FontWeight = FontWeightEnum.W600;  						break;  					case "700":  						si.FontWeight = FontWeightEnum.W700;  						break;  					case "800":  						si.FontWeight = FontWeightEnum.W800;  						break;  					case "900":  						si.FontWeight = FontWeightEnum.W900;  						break;  				}
Missing Default,fyiReporting.RDL,RdlEngineConfig,C:\repos\majorsilence_My-FyiReporting\RdlEngine\Runtime\RdlEngineConfig.cs,GetCompression,The following switch statement is missing a default case: switch (xNodeLoop.Name)                  {                      case "CodeModule":                          if (xNodeLoop.InnerText.Length > 0)                              cm = xNodeLoop.InnerText;                          break;                      case "ClassName":                          if (xNodeLoop.InnerText.Length > 0)                              cn = xNodeLoop.InnerText;                          break;                      case "Finish":                          if (xNodeLoop.InnerText.Length > 0)                              fn = xNodeLoop.InnerText;                          break;                      case "Enable":                          if (xNodeLoop.InnerText.ToLower() == "false")                              bEnable = false;                          break;                  }
