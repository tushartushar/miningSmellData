Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.LiveLabs.PE,MetadataTables,C:\repos\Reactive-Extensions_IL2JS\PE\MetadataTables.cs,Read,The method has 304 lines of code.
Long Method,Microsoft.LiveLabs.PE,MetadataTables,C:\repos\Reactive-Extensions_IL2JS\PE\MetadataTables.cs,Write,The method has 302 lines of code.
Long Method,Microsoft.LiveLabs.PE,Instruction,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Skip,The method has 255 lines of code.
Long Method,Microsoft.LiveLabs.PE,Instruction,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Read,The method has 278 lines of code.
Long Method,Microsoft.LiveLabs.PE,Instruction,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Size,The method has 265 lines of code.
Long Method,Microsoft.LiveLabs.PE,Instruction,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Write,The method has 284 lines of code.
Long Method,Microsoft.LiveLabs.PE,TokenRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The method has 126 lines of code.
Complex Method,Microsoft.LiveLabs.PE,MetadataTables,C:\repos\Reactive-Extensions_IL2JS\PE\MetadataTables.cs,Read,Cyclomatic complexity of the method is 238
Complex Method,Microsoft.LiveLabs.PE,MetadataTables,C:\repos\Reactive-Extensions_IL2JS\PE\MetadataTables.cs,Write,Cyclomatic complexity of the method is 238
Complex Method,Microsoft.LiveLabs.PE,Instruction,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Skip,Cyclomatic complexity of the method is 247
Complex Method,Microsoft.LiveLabs.PE,Instruction,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Read,Cyclomatic complexity of the method is 258
Complex Method,Microsoft.LiveLabs.PE,Instruction,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Size,Cyclomatic complexity of the method is 253
Complex Method,Microsoft.LiveLabs.PE,Instruction,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Write,Cyclomatic complexity of the method is 257
Complex Method,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Read,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Write,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,Cyclomatic complexity of the method is 61
Complex Method,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,Cyclomatic complexity of the method is 31
Complex Method,Microsoft.LiveLabs.PE,TypeDefOrRefRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.LiveLabs.PE,TypeDefOrRefRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.LiveLabs.PE,HasConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.LiveLabs.PE,HasConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,Cyclomatic complexity of the method is 60
Complex Method,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,Cyclomatic complexity of the method is 60
Complex Method,Microsoft.LiveLabs.PE,HasFieldMarshalRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.PE,HasFieldMarshalRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.PE,HasDeclSecurityRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.LiveLabs.PE,HasDeclSecurityRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.LiveLabs.PE,MemberRefParentRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,Cyclomatic complexity of the method is 18
Complex Method,Microsoft.LiveLabs.PE,MemberRefParentRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,Cyclomatic complexity of the method is 18
Complex Method,Microsoft.LiveLabs.PE,HasSemanticsRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.PE,HasSemanticsRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.PE,MethodDefOrRefRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.PE,MethodDefOrRefRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.PE,MemberForwardedRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.PE,MemberForwardedRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.PE,ImplementationRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.LiveLabs.PE,ImplementationRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.LiveLabs.PE,CustomAttributeTypeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.LiveLabs.PE,CustomAttributeTypeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.PE,ResolutionScopeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.LiveLabs.PE,ResolutionScopeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.LiveLabs.PE,TypeOrMethodDefRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.PE,TypeOrMethodDefRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.PE,TokenRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,Cyclomatic complexity of the method is 117
Complex Method,Microsoft.LiveLabs.PE,TypeDefOrRefVarLenRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.LiveLabs.PE,TypeSig,C:\repos\Reactive-Extensions_IL2JS\PE\Signature.cs,Read,Cyclomatic complexity of the method is 70
Complex Method,Microsoft.LiveLabs.PE,PrimitiveTypeSig,C:\repos\Reactive-Extensions_IL2JS\PE\Signature.cs,FromTag,Cyclomatic complexity of the method is 21
Complex Method,Microsoft.LiveLabs.PE,PrimitiveTypeSig,C:\repos\Reactive-Extensions_IL2JS\PE\Signature.cs,ToTag,Cyclomatic complexity of the method is 21
Complex Method,Microsoft.LiveLabs.PE,PrimitiveTypeSig,C:\repos\Reactive-Extensions_IL2JS\PE\Signature.cs,ByteSize,Cyclomatic complexity of the method is 23
Complex Method,Microsoft.LiveLabs.PE,MemberSig,C:\repos\Reactive-Extensions_IL2JS\PE\Signature.cs,Read,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.LiveLabs.PE,CustomAttributePropertyType,C:\repos\Reactive-Extensions_IL2JS\PE\Signature.cs,Read,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.LiveLabs.PE,CustomAttributePropertyType,C:\repos\Reactive-Extensions_IL2JS\PE\Signature.cs,FromRuntimeType,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.LiveLabs.PE,PrimitiveCustomAttributePropertyType,C:\repos\Reactive-Extensions_IL2JS\PE\Signature.cs,ReadValue,Cyclomatic complexity of the method is 23
Complex Method,Microsoft.LiveLabs.PE,PrimitiveCustomAttributePropertyType,C:\repos\Reactive-Extensions_IL2JS\PE\Signature.cs,NewArray,Cyclomatic complexity of the method is 22
Complex Method,Microsoft.LiveLabs.PE,PrimitiveCustomAttributePropertyType,C:\repos\Reactive-Extensions_IL2JS\PE\Signature.cs,WriteValue,Cyclomatic complexity of the method is 51
Complex Method,Microsoft.LiveLabs.PE,CustomAttributeSignature,C:\repos\Reactive-Extensions_IL2JS\PE\Signature.cs,Read,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.LiveLabs.PE,PEFileHeader,C:\repos\Reactive-Extensions_IL2JS\PE\Structures.cs,Read,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.LiveLabs.PE,PEHeaderNTSpecificFields,C:\repos\Reactive-Extensions_IL2JS\PE\Structures.cs,Read,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.LiveLabs.PE,PEHeaderDataDirectories,C:\repos\Reactive-Extensions_IL2JS\PE\Structures.cs,Read,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.LiveLabs.PE,SectionHeader,C:\repos\Reactive-Extensions_IL2JS\PE\Structures.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.PE,SectionHeader,C:\repos\Reactive-Extensions_IL2JS\PE\Structures.cs,Write,Cyclomatic complexity of the method is 11
Long Parameter List,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,WriteMethodDataSection,The method has 5 parameters.
Long Statement,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt32,The length of the statement  "		return (uint)data [currOffset++] | ((uint)data [currOffset++] << 8) | ((uint)data [currOffset++] << 16) | ((uint)data [currOffset++] << 24); " is 140.
Long Statement,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt32,The length of the statement  "		return (uint)d [currOffset++] | ((uint)d [currOffset++] << 8) | ((uint)d [currOffset++] << 16) | ((uint)d [currOffset++] << 24); " is 128.
Long Statement,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The length of the statement  "		return (ulong)data [currOffset++] | ((ulong)data [currOffset++] << 8) | ((ulong)data [currOffset++] << 16) | ((ulong)data [currOffset++] << 24) | ((ulong)data [currOffset++] << 32) | ((ulong)data [currOffset++] << 40) | ((ulong)data [currOffset++] << 48) | ((ulong)data [currOffset++] << 56); " is 292.
Long Statement,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The length of the statement  "		return (ulong)d [currOffset++] | ((ulong)d [currOffset++] << 8) | ((ulong)d [currOffset++] << 16) | ((ulong)d [currOffset++] << 24) | ((ulong)d [currOffset++] << 32) | ((ulong)d [currOffset++] << 40) | ((ulong)d [currOffset++] << 48) | ((ulong)d [currOffset++] << 56); " is 268.
Long Statement,Microsoft.LiveLabs.PE,MetadataTables,C:\repos\Reactive-Extensions_IL2JS\PE\MetadataTables.cs,DetermineIndexCodingSizes,The length of the statement  "	HasCustomAttributeIsBig = IsBig (5' MethodDefTable' FieldTable' TypeRefTable' TypeDefTable' ParamTable' InterfaceImplTable' MemberRefTable' ModuleTable' DeclSecurityTable' PropertyTable' EventTable' StandAloneSigTable' ModuleRefTable' TypeSpecTable' AssemblyTable' AssemblyRefTable' FileTable' ExportedTypeTable' ManifestResourceTable); " is 336.
Long Statement,Microsoft.LiveLabs.PE,WriterContext,C:\repos\Reactive-Extensions_IL2JS\PE\WriterContext.cs,InitializedDataSize,The length of the statement  "	return sections [sectionToIndex [(int)Section.Reloc]].SizeOfRawData + sections [sectionToIndex [(int)Section.Rsrc]].SizeOfRawData; " is 130.
Long Statement,Microsoft.LiveLabs.PE,WriterContext,C:\repos\Reactive-Extensions_IL2JS\PE\WriterContext.cs,BaseOfData,The length of the statement  "	return Math.Min (sections [sectionToIndex [(int)Section.Reloc]].VirtualAddress' sections [sectionToIndex [(int)Section.Rsrc]].VirtualAddress); " is 142.
Complex Conditional,Microsoft.LiveLabs.PE,BlobWriter,C:\repos\Reactive-Extensions_IL2JS\PE\BlobWriter.cs,WriteUTF16SizedStringWithEncodingHint,The conditional expression  "c >= 0x01 && c <= 0x08 || c >= 0x0e && c <= 0x1f || c == 0x27 || c == 0x2d || c == 0x7f || c > 0xff"  is complex.
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt16,The following statement contains a magic number: if (currOffset + 2 <= dataLimit)  	return (ushort)((uint)data [currOffset++] | ((uint)data [currOffset++] << 8));  else if (currOffset >= dataLimit && currOffset + 2 <= readLimit) {  	currOffset += 2;  	return 0;  }  else {  	var d = ReadBytes (2);  	return (ushort)((uint)d [0] | ((uint)d [1] << 8));  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt16,The following statement contains a magic number: if (currOffset + 2 <= dataLimit)  	return (ushort)((uint)data [currOffset++] | ((uint)data [currOffset++] << 8));  else if (currOffset >= dataLimit && currOffset + 2 <= readLimit) {  	currOffset += 2;  	return 0;  }  else {  	var d = ReadBytes (2);  	return (ushort)((uint)d [0] | ((uint)d [1] << 8));  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt16,The following statement contains a magic number: if (currOffset + 2 <= dataLimit)  	return (ushort)((uint)data [currOffset++] | ((uint)data [currOffset++] << 8));  else if (currOffset >= dataLimit && currOffset + 2 <= readLimit) {  	currOffset += 2;  	return 0;  }  else {  	var d = ReadBytes (2);  	return (ushort)((uint)d [0] | ((uint)d [1] << 8));  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt16,The following statement contains a magic number: if (currOffset + 2 <= dataLimit)  	return (ushort)((uint)data [currOffset++] | ((uint)data [currOffset++] << 8));  else if (currOffset >= dataLimit && currOffset + 2 <= readLimit) {  	currOffset += 2;  	return 0;  }  else {  	var d = ReadBytes (2);  	return (ushort)((uint)d [0] | ((uint)d [1] << 8));  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt16,The following statement contains a magic number: if (currOffset + 2 <= dataLimit)  	return (ushort)((uint)data [currOffset++] | ((uint)data [currOffset++] << 8));  else if (currOffset >= dataLimit && currOffset + 2 <= readLimit) {  	currOffset += 2;  	return 0;  }  else {  	var d = ReadBytes (2);  	return (ushort)((uint)d [0] | ((uint)d [1] << 8));  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt16,The following statement contains a magic number: if (currOffset + 2 <= dataLimit)  	return (ushort)((uint)data [currOffset++] | ((uint)data [currOffset++] << 8));  else if (currOffset >= dataLimit && currOffset + 2 <= readLimit) {  	currOffset += 2;  	return 0;  }  else {  	var d = ReadBytes (2);  	return (ushort)((uint)d [0] | ((uint)d [1] << 8));  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt16,The following statement contains a magic number: return (ushort)((uint)data [currOffset++] | ((uint)data [currOffset++] << 8));  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt16,The following statement contains a magic number: if (currOffset >= dataLimit && currOffset + 2 <= readLimit) {  	currOffset += 2;  	return 0;  }  else {  	var d = ReadBytes (2);  	return (ushort)((uint)d [0] | ((uint)d [1] << 8));  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt16,The following statement contains a magic number: if (currOffset >= dataLimit && currOffset + 2 <= readLimit) {  	currOffset += 2;  	return 0;  }  else {  	var d = ReadBytes (2);  	return (ushort)((uint)d [0] | ((uint)d [1] << 8));  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt16,The following statement contains a magic number: if (currOffset >= dataLimit && currOffset + 2 <= readLimit) {  	currOffset += 2;  	return 0;  }  else {  	var d = ReadBytes (2);  	return (ushort)((uint)d [0] | ((uint)d [1] << 8));  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt16,The following statement contains a magic number: if (currOffset >= dataLimit && currOffset + 2 <= readLimit) {  	currOffset += 2;  	return 0;  }  else {  	var d = ReadBytes (2);  	return (ushort)((uint)d [0] | ((uint)d [1] << 8));  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt16,The following statement contains a magic number: currOffset += 2;  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt16,The following statement contains a magic number: return (ushort)((uint)d [0] | ((uint)d [1] << 8));  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt24,The following statement contains a magic number: if (currOffset + 3 <= dataLimit)  	return (uint)data [currOffset++] | ((uint)(data [currOffset++]) << 8) | ((uint)(data [currOffset++]) << 16);  else if (currOffset >= dataLimit && currOffset + 3 <= readLimit) {  	currOffset += 3;  	return 0;  }  else {  	var d = ReadBytes (3);  	return (uint)d [0] | ((uint)(d [1]) << 8) | ((uint)(d [2]) << 16);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt24,The following statement contains a magic number: if (currOffset + 3 <= dataLimit)  	return (uint)data [currOffset++] | ((uint)(data [currOffset++]) << 8) | ((uint)(data [currOffset++]) << 16);  else if (currOffset >= dataLimit && currOffset + 3 <= readLimit) {  	currOffset += 3;  	return 0;  }  else {  	var d = ReadBytes (3);  	return (uint)d [0] | ((uint)(d [1]) << 8) | ((uint)(d [2]) << 16);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt24,The following statement contains a magic number: if (currOffset + 3 <= dataLimit)  	return (uint)data [currOffset++] | ((uint)(data [currOffset++]) << 8) | ((uint)(data [currOffset++]) << 16);  else if (currOffset >= dataLimit && currOffset + 3 <= readLimit) {  	currOffset += 3;  	return 0;  }  else {  	var d = ReadBytes (3);  	return (uint)d [0] | ((uint)(d [1]) << 8) | ((uint)(d [2]) << 16);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt24,The following statement contains a magic number: if (currOffset + 3 <= dataLimit)  	return (uint)data [currOffset++] | ((uint)(data [currOffset++]) << 8) | ((uint)(data [currOffset++]) << 16);  else if (currOffset >= dataLimit && currOffset + 3 <= readLimit) {  	currOffset += 3;  	return 0;  }  else {  	var d = ReadBytes (3);  	return (uint)d [0] | ((uint)(d [1]) << 8) | ((uint)(d [2]) << 16);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt24,The following statement contains a magic number: if (currOffset + 3 <= dataLimit)  	return (uint)data [currOffset++] | ((uint)(data [currOffset++]) << 8) | ((uint)(data [currOffset++]) << 16);  else if (currOffset >= dataLimit && currOffset + 3 <= readLimit) {  	currOffset += 3;  	return 0;  }  else {  	var d = ReadBytes (3);  	return (uint)d [0] | ((uint)(d [1]) << 8) | ((uint)(d [2]) << 16);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt24,The following statement contains a magic number: if (currOffset + 3 <= dataLimit)  	return (uint)data [currOffset++] | ((uint)(data [currOffset++]) << 8) | ((uint)(data [currOffset++]) << 16);  else if (currOffset >= dataLimit && currOffset + 3 <= readLimit) {  	currOffset += 3;  	return 0;  }  else {  	var d = ReadBytes (3);  	return (uint)d [0] | ((uint)(d [1]) << 8) | ((uint)(d [2]) << 16);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt24,The following statement contains a magic number: if (currOffset + 3 <= dataLimit)  	return (uint)data [currOffset++] | ((uint)(data [currOffset++]) << 8) | ((uint)(data [currOffset++]) << 16);  else if (currOffset >= dataLimit && currOffset + 3 <= readLimit) {  	currOffset += 3;  	return 0;  }  else {  	var d = ReadBytes (3);  	return (uint)d [0] | ((uint)(d [1]) << 8) | ((uint)(d [2]) << 16);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt24,The following statement contains a magic number: if (currOffset + 3 <= dataLimit)  	return (uint)data [currOffset++] | ((uint)(data [currOffset++]) << 8) | ((uint)(data [currOffset++]) << 16);  else if (currOffset >= dataLimit && currOffset + 3 <= readLimit) {  	currOffset += 3;  	return 0;  }  else {  	var d = ReadBytes (3);  	return (uint)d [0] | ((uint)(d [1]) << 8) | ((uint)(d [2]) << 16);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt24,The following statement contains a magic number: if (currOffset + 3 <= dataLimit)  	return (uint)data [currOffset++] | ((uint)(data [currOffset++]) << 8) | ((uint)(data [currOffset++]) << 16);  else if (currOffset >= dataLimit && currOffset + 3 <= readLimit) {  	currOffset += 3;  	return 0;  }  else {  	var d = ReadBytes (3);  	return (uint)d [0] | ((uint)(d [1]) << 8) | ((uint)(d [2]) << 16);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt24,The following statement contains a magic number: return (uint)data [currOffset++] | ((uint)(data [currOffset++]) << 8) | ((uint)(data [currOffset++]) << 16);  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt24,The following statement contains a magic number: return (uint)data [currOffset++] | ((uint)(data [currOffset++]) << 8) | ((uint)(data [currOffset++]) << 16);  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt24,The following statement contains a magic number: if (currOffset >= dataLimit && currOffset + 3 <= readLimit) {  	currOffset += 3;  	return 0;  }  else {  	var d = ReadBytes (3);  	return (uint)d [0] | ((uint)(d [1]) << 8) | ((uint)(d [2]) << 16);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt24,The following statement contains a magic number: if (currOffset >= dataLimit && currOffset + 3 <= readLimit) {  	currOffset += 3;  	return 0;  }  else {  	var d = ReadBytes (3);  	return (uint)d [0] | ((uint)(d [1]) << 8) | ((uint)(d [2]) << 16);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt24,The following statement contains a magic number: if (currOffset >= dataLimit && currOffset + 3 <= readLimit) {  	currOffset += 3;  	return 0;  }  else {  	var d = ReadBytes (3);  	return (uint)d [0] | ((uint)(d [1]) << 8) | ((uint)(d [2]) << 16);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt24,The following statement contains a magic number: if (currOffset >= dataLimit && currOffset + 3 <= readLimit) {  	currOffset += 3;  	return 0;  }  else {  	var d = ReadBytes (3);  	return (uint)d [0] | ((uint)(d [1]) << 8) | ((uint)(d [2]) << 16);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt24,The following statement contains a magic number: if (currOffset >= dataLimit && currOffset + 3 <= readLimit) {  	currOffset += 3;  	return 0;  }  else {  	var d = ReadBytes (3);  	return (uint)d [0] | ((uint)(d [1]) << 8) | ((uint)(d [2]) << 16);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt24,The following statement contains a magic number: if (currOffset >= dataLimit && currOffset + 3 <= readLimit) {  	currOffset += 3;  	return 0;  }  else {  	var d = ReadBytes (3);  	return (uint)d [0] | ((uint)(d [1]) << 8) | ((uint)(d [2]) << 16);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt24,The following statement contains a magic number: currOffset += 3;  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt24,The following statement contains a magic number: return (uint)d [0] | ((uint)(d [1]) << 8) | ((uint)(d [2]) << 16);  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt24,The following statement contains a magic number: return (uint)d [0] | ((uint)(d [1]) << 8) | ((uint)(d [2]) << 16);  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt24,The following statement contains a magic number: return (uint)d [0] | ((uint)(d [1]) << 8) | ((uint)(d [2]) << 16);  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt32,The following statement contains a magic number: if (currOffset + 4 <= dataLimit)  	return (uint)data [currOffset++] | ((uint)data [currOffset++] << 8) | ((uint)data [currOffset++] << 16) | ((uint)data [currOffset++] << 24);  else if (currOffset >= dataLimit && currOffset + 4 <= readLimit) {  	currOffset += 4;  	return 0;  }  else {  	var d = ReadBytes (4);  	return (uint)d [currOffset++] | ((uint)d [currOffset++] << 8) | ((uint)d [currOffset++] << 16) | ((uint)d [currOffset++] << 24);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt32,The following statement contains a magic number: if (currOffset + 4 <= dataLimit)  	return (uint)data [currOffset++] | ((uint)data [currOffset++] << 8) | ((uint)data [currOffset++] << 16) | ((uint)data [currOffset++] << 24);  else if (currOffset >= dataLimit && currOffset + 4 <= readLimit) {  	currOffset += 4;  	return 0;  }  else {  	var d = ReadBytes (4);  	return (uint)d [currOffset++] | ((uint)d [currOffset++] << 8) | ((uint)d [currOffset++] << 16) | ((uint)d [currOffset++] << 24);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt32,The following statement contains a magic number: if (currOffset + 4 <= dataLimit)  	return (uint)data [currOffset++] | ((uint)data [currOffset++] << 8) | ((uint)data [currOffset++] << 16) | ((uint)data [currOffset++] << 24);  else if (currOffset >= dataLimit && currOffset + 4 <= readLimit) {  	currOffset += 4;  	return 0;  }  else {  	var d = ReadBytes (4);  	return (uint)d [currOffset++] | ((uint)d [currOffset++] << 8) | ((uint)d [currOffset++] << 16) | ((uint)d [currOffset++] << 24);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt32,The following statement contains a magic number: if (currOffset + 4 <= dataLimit)  	return (uint)data [currOffset++] | ((uint)data [currOffset++] << 8) | ((uint)data [currOffset++] << 16) | ((uint)data [currOffset++] << 24);  else if (currOffset >= dataLimit && currOffset + 4 <= readLimit) {  	currOffset += 4;  	return 0;  }  else {  	var d = ReadBytes (4);  	return (uint)d [currOffset++] | ((uint)d [currOffset++] << 8) | ((uint)d [currOffset++] << 16) | ((uint)d [currOffset++] << 24);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt32,The following statement contains a magic number: if (currOffset + 4 <= dataLimit)  	return (uint)data [currOffset++] | ((uint)data [currOffset++] << 8) | ((uint)data [currOffset++] << 16) | ((uint)data [currOffset++] << 24);  else if (currOffset >= dataLimit && currOffset + 4 <= readLimit) {  	currOffset += 4;  	return 0;  }  else {  	var d = ReadBytes (4);  	return (uint)d [currOffset++] | ((uint)d [currOffset++] << 8) | ((uint)d [currOffset++] << 16) | ((uint)d [currOffset++] << 24);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt32,The following statement contains a magic number: if (currOffset + 4 <= dataLimit)  	return (uint)data [currOffset++] | ((uint)data [currOffset++] << 8) | ((uint)data [currOffset++] << 16) | ((uint)data [currOffset++] << 24);  else if (currOffset >= dataLimit && currOffset + 4 <= readLimit) {  	currOffset += 4;  	return 0;  }  else {  	var d = ReadBytes (4);  	return (uint)d [currOffset++] | ((uint)d [currOffset++] << 8) | ((uint)d [currOffset++] << 16) | ((uint)d [currOffset++] << 24);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt32,The following statement contains a magic number: if (currOffset + 4 <= dataLimit)  	return (uint)data [currOffset++] | ((uint)data [currOffset++] << 8) | ((uint)data [currOffset++] << 16) | ((uint)data [currOffset++] << 24);  else if (currOffset >= dataLimit && currOffset + 4 <= readLimit) {  	currOffset += 4;  	return 0;  }  else {  	var d = ReadBytes (4);  	return (uint)d [currOffset++] | ((uint)d [currOffset++] << 8) | ((uint)d [currOffset++] << 16) | ((uint)d [currOffset++] << 24);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt32,The following statement contains a magic number: if (currOffset + 4 <= dataLimit)  	return (uint)data [currOffset++] | ((uint)data [currOffset++] << 8) | ((uint)data [currOffset++] << 16) | ((uint)data [currOffset++] << 24);  else if (currOffset >= dataLimit && currOffset + 4 <= readLimit) {  	currOffset += 4;  	return 0;  }  else {  	var d = ReadBytes (4);  	return (uint)d [currOffset++] | ((uint)d [currOffset++] << 8) | ((uint)d [currOffset++] << 16) | ((uint)d [currOffset++] << 24);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt32,The following statement contains a magic number: if (currOffset + 4 <= dataLimit)  	return (uint)data [currOffset++] | ((uint)data [currOffset++] << 8) | ((uint)data [currOffset++] << 16) | ((uint)data [currOffset++] << 24);  else if (currOffset >= dataLimit && currOffset + 4 <= readLimit) {  	currOffset += 4;  	return 0;  }  else {  	var d = ReadBytes (4);  	return (uint)d [currOffset++] | ((uint)d [currOffset++] << 8) | ((uint)d [currOffset++] << 16) | ((uint)d [currOffset++] << 24);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt32,The following statement contains a magic number: if (currOffset + 4 <= dataLimit)  	return (uint)data [currOffset++] | ((uint)data [currOffset++] << 8) | ((uint)data [currOffset++] << 16) | ((uint)data [currOffset++] << 24);  else if (currOffset >= dataLimit && currOffset + 4 <= readLimit) {  	currOffset += 4;  	return 0;  }  else {  	var d = ReadBytes (4);  	return (uint)d [currOffset++] | ((uint)d [currOffset++] << 8) | ((uint)d [currOffset++] << 16) | ((uint)d [currOffset++] << 24);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt32,The following statement contains a magic number: return (uint)data [currOffset++] | ((uint)data [currOffset++] << 8) | ((uint)data [currOffset++] << 16) | ((uint)data [currOffset++] << 24);  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt32,The following statement contains a magic number: return (uint)data [currOffset++] | ((uint)data [currOffset++] << 8) | ((uint)data [currOffset++] << 16) | ((uint)data [currOffset++] << 24);  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt32,The following statement contains a magic number: return (uint)data [currOffset++] | ((uint)data [currOffset++] << 8) | ((uint)data [currOffset++] << 16) | ((uint)data [currOffset++] << 24);  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt32,The following statement contains a magic number: if (currOffset >= dataLimit && currOffset + 4 <= readLimit) {  	currOffset += 4;  	return 0;  }  else {  	var d = ReadBytes (4);  	return (uint)d [currOffset++] | ((uint)d [currOffset++] << 8) | ((uint)d [currOffset++] << 16) | ((uint)d [currOffset++] << 24);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt32,The following statement contains a magic number: if (currOffset >= dataLimit && currOffset + 4 <= readLimit) {  	currOffset += 4;  	return 0;  }  else {  	var d = ReadBytes (4);  	return (uint)d [currOffset++] | ((uint)d [currOffset++] << 8) | ((uint)d [currOffset++] << 16) | ((uint)d [currOffset++] << 24);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt32,The following statement contains a magic number: if (currOffset >= dataLimit && currOffset + 4 <= readLimit) {  	currOffset += 4;  	return 0;  }  else {  	var d = ReadBytes (4);  	return (uint)d [currOffset++] | ((uint)d [currOffset++] << 8) | ((uint)d [currOffset++] << 16) | ((uint)d [currOffset++] << 24);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt32,The following statement contains a magic number: if (currOffset >= dataLimit && currOffset + 4 <= readLimit) {  	currOffset += 4;  	return 0;  }  else {  	var d = ReadBytes (4);  	return (uint)d [currOffset++] | ((uint)d [currOffset++] << 8) | ((uint)d [currOffset++] << 16) | ((uint)d [currOffset++] << 24);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt32,The following statement contains a magic number: if (currOffset >= dataLimit && currOffset + 4 <= readLimit) {  	currOffset += 4;  	return 0;  }  else {  	var d = ReadBytes (4);  	return (uint)d [currOffset++] | ((uint)d [currOffset++] << 8) | ((uint)d [currOffset++] << 16) | ((uint)d [currOffset++] << 24);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt32,The following statement contains a magic number: if (currOffset >= dataLimit && currOffset + 4 <= readLimit) {  	currOffset += 4;  	return 0;  }  else {  	var d = ReadBytes (4);  	return (uint)d [currOffset++] | ((uint)d [currOffset++] << 8) | ((uint)d [currOffset++] << 16) | ((uint)d [currOffset++] << 24);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt32,The following statement contains a magic number: currOffset += 4;  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt32,The following statement contains a magic number: return (uint)d [currOffset++] | ((uint)d [currOffset++] << 8) | ((uint)d [currOffset++] << 16) | ((uint)d [currOffset++] << 24);  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt32,The following statement contains a magic number: return (uint)d [currOffset++] | ((uint)d [currOffset++] << 8) | ((uint)d [currOffset++] << 16) | ((uint)d [currOffset++] << 24);  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt32,The following statement contains a magic number: return (uint)d [currOffset++] | ((uint)d [currOffset++] << 8) | ((uint)d [currOffset++] << 16) | ((uint)d [currOffset++] << 24);  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: if (currOffset + 8 <= dataLimit)  	return (ulong)data [currOffset++] | ((ulong)data [currOffset++] << 8) | ((ulong)data [currOffset++] << 16) | ((ulong)data [currOffset++] << 24) | ((ulong)data [currOffset++] << 32) | ((ulong)data [currOffset++] << 40) | ((ulong)data [currOffset++] << 48) | ((ulong)data [currOffset++] << 56);  else if (currOffset >= dataLimit && currOffset + 8 <= readLimit) {  	currOffset += 8;  	return 0;  }  else {  	var d = ReadBytes (8);  	return (ulong)d [currOffset++] | ((ulong)d [currOffset++] << 8) | ((ulong)d [currOffset++] << 16) | ((ulong)d [currOffset++] << 24) | ((ulong)d [currOffset++] << 32) | ((ulong)d [currOffset++] << 40) | ((ulong)d [currOffset++] << 48) | ((ulong)d [currOffset++] << 56);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: if (currOffset + 8 <= dataLimit)  	return (ulong)data [currOffset++] | ((ulong)data [currOffset++] << 8) | ((ulong)data [currOffset++] << 16) | ((ulong)data [currOffset++] << 24) | ((ulong)data [currOffset++] << 32) | ((ulong)data [currOffset++] << 40) | ((ulong)data [currOffset++] << 48) | ((ulong)data [currOffset++] << 56);  else if (currOffset >= dataLimit && currOffset + 8 <= readLimit) {  	currOffset += 8;  	return 0;  }  else {  	var d = ReadBytes (8);  	return (ulong)d [currOffset++] | ((ulong)d [currOffset++] << 8) | ((ulong)d [currOffset++] << 16) | ((ulong)d [currOffset++] << 24) | ((ulong)d [currOffset++] << 32) | ((ulong)d [currOffset++] << 40) | ((ulong)d [currOffset++] << 48) | ((ulong)d [currOffset++] << 56);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: if (currOffset + 8 <= dataLimit)  	return (ulong)data [currOffset++] | ((ulong)data [currOffset++] << 8) | ((ulong)data [currOffset++] << 16) | ((ulong)data [currOffset++] << 24) | ((ulong)data [currOffset++] << 32) | ((ulong)data [currOffset++] << 40) | ((ulong)data [currOffset++] << 48) | ((ulong)data [currOffset++] << 56);  else if (currOffset >= dataLimit && currOffset + 8 <= readLimit) {  	currOffset += 8;  	return 0;  }  else {  	var d = ReadBytes (8);  	return (ulong)d [currOffset++] | ((ulong)d [currOffset++] << 8) | ((ulong)d [currOffset++] << 16) | ((ulong)d [currOffset++] << 24) | ((ulong)d [currOffset++] << 32) | ((ulong)d [currOffset++] << 40) | ((ulong)d [currOffset++] << 48) | ((ulong)d [currOffset++] << 56);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: if (currOffset + 8 <= dataLimit)  	return (ulong)data [currOffset++] | ((ulong)data [currOffset++] << 8) | ((ulong)data [currOffset++] << 16) | ((ulong)data [currOffset++] << 24) | ((ulong)data [currOffset++] << 32) | ((ulong)data [currOffset++] << 40) | ((ulong)data [currOffset++] << 48) | ((ulong)data [currOffset++] << 56);  else if (currOffset >= dataLimit && currOffset + 8 <= readLimit) {  	currOffset += 8;  	return 0;  }  else {  	var d = ReadBytes (8);  	return (ulong)d [currOffset++] | ((ulong)d [currOffset++] << 8) | ((ulong)d [currOffset++] << 16) | ((ulong)d [currOffset++] << 24) | ((ulong)d [currOffset++] << 32) | ((ulong)d [currOffset++] << 40) | ((ulong)d [currOffset++] << 48) | ((ulong)d [currOffset++] << 56);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: if (currOffset + 8 <= dataLimit)  	return (ulong)data [currOffset++] | ((ulong)data [currOffset++] << 8) | ((ulong)data [currOffset++] << 16) | ((ulong)data [currOffset++] << 24) | ((ulong)data [currOffset++] << 32) | ((ulong)data [currOffset++] << 40) | ((ulong)data [currOffset++] << 48) | ((ulong)data [currOffset++] << 56);  else if (currOffset >= dataLimit && currOffset + 8 <= readLimit) {  	currOffset += 8;  	return 0;  }  else {  	var d = ReadBytes (8);  	return (ulong)d [currOffset++] | ((ulong)d [currOffset++] << 8) | ((ulong)d [currOffset++] << 16) | ((ulong)d [currOffset++] << 24) | ((ulong)d [currOffset++] << 32) | ((ulong)d [currOffset++] << 40) | ((ulong)d [currOffset++] << 48) | ((ulong)d [currOffset++] << 56);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: if (currOffset + 8 <= dataLimit)  	return (ulong)data [currOffset++] | ((ulong)data [currOffset++] << 8) | ((ulong)data [currOffset++] << 16) | ((ulong)data [currOffset++] << 24) | ((ulong)data [currOffset++] << 32) | ((ulong)data [currOffset++] << 40) | ((ulong)data [currOffset++] << 48) | ((ulong)data [currOffset++] << 56);  else if (currOffset >= dataLimit && currOffset + 8 <= readLimit) {  	currOffset += 8;  	return 0;  }  else {  	var d = ReadBytes (8);  	return (ulong)d [currOffset++] | ((ulong)d [currOffset++] << 8) | ((ulong)d [currOffset++] << 16) | ((ulong)d [currOffset++] << 24) | ((ulong)d [currOffset++] << 32) | ((ulong)d [currOffset++] << 40) | ((ulong)d [currOffset++] << 48) | ((ulong)d [currOffset++] << 56);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: if (currOffset + 8 <= dataLimit)  	return (ulong)data [currOffset++] | ((ulong)data [currOffset++] << 8) | ((ulong)data [currOffset++] << 16) | ((ulong)data [currOffset++] << 24) | ((ulong)data [currOffset++] << 32) | ((ulong)data [currOffset++] << 40) | ((ulong)data [currOffset++] << 48) | ((ulong)data [currOffset++] << 56);  else if (currOffset >= dataLimit && currOffset + 8 <= readLimit) {  	currOffset += 8;  	return 0;  }  else {  	var d = ReadBytes (8);  	return (ulong)d [currOffset++] | ((ulong)d [currOffset++] << 8) | ((ulong)d [currOffset++] << 16) | ((ulong)d [currOffset++] << 24) | ((ulong)d [currOffset++] << 32) | ((ulong)d [currOffset++] << 40) | ((ulong)d [currOffset++] << 48) | ((ulong)d [currOffset++] << 56);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: if (currOffset + 8 <= dataLimit)  	return (ulong)data [currOffset++] | ((ulong)data [currOffset++] << 8) | ((ulong)data [currOffset++] << 16) | ((ulong)data [currOffset++] << 24) | ((ulong)data [currOffset++] << 32) | ((ulong)data [currOffset++] << 40) | ((ulong)data [currOffset++] << 48) | ((ulong)data [currOffset++] << 56);  else if (currOffset >= dataLimit && currOffset + 8 <= readLimit) {  	currOffset += 8;  	return 0;  }  else {  	var d = ReadBytes (8);  	return (ulong)d [currOffset++] | ((ulong)d [currOffset++] << 8) | ((ulong)d [currOffset++] << 16) | ((ulong)d [currOffset++] << 24) | ((ulong)d [currOffset++] << 32) | ((ulong)d [currOffset++] << 40) | ((ulong)d [currOffset++] << 48) | ((ulong)d [currOffset++] << 56);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: if (currOffset + 8 <= dataLimit)  	return (ulong)data [currOffset++] | ((ulong)data [currOffset++] << 8) | ((ulong)data [currOffset++] << 16) | ((ulong)data [currOffset++] << 24) | ((ulong)data [currOffset++] << 32) | ((ulong)data [currOffset++] << 40) | ((ulong)data [currOffset++] << 48) | ((ulong)data [currOffset++] << 56);  else if (currOffset >= dataLimit && currOffset + 8 <= readLimit) {  	currOffset += 8;  	return 0;  }  else {  	var d = ReadBytes (8);  	return (ulong)d [currOffset++] | ((ulong)d [currOffset++] << 8) | ((ulong)d [currOffset++] << 16) | ((ulong)d [currOffset++] << 24) | ((ulong)d [currOffset++] << 32) | ((ulong)d [currOffset++] << 40) | ((ulong)d [currOffset++] << 48) | ((ulong)d [currOffset++] << 56);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: if (currOffset + 8 <= dataLimit)  	return (ulong)data [currOffset++] | ((ulong)data [currOffset++] << 8) | ((ulong)data [currOffset++] << 16) | ((ulong)data [currOffset++] << 24) | ((ulong)data [currOffset++] << 32) | ((ulong)data [currOffset++] << 40) | ((ulong)data [currOffset++] << 48) | ((ulong)data [currOffset++] << 56);  else if (currOffset >= dataLimit && currOffset + 8 <= readLimit) {  	currOffset += 8;  	return 0;  }  else {  	var d = ReadBytes (8);  	return (ulong)d [currOffset++] | ((ulong)d [currOffset++] << 8) | ((ulong)d [currOffset++] << 16) | ((ulong)d [currOffset++] << 24) | ((ulong)d [currOffset++] << 32) | ((ulong)d [currOffset++] << 40) | ((ulong)d [currOffset++] << 48) | ((ulong)d [currOffset++] << 56);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: if (currOffset + 8 <= dataLimit)  	return (ulong)data [currOffset++] | ((ulong)data [currOffset++] << 8) | ((ulong)data [currOffset++] << 16) | ((ulong)data [currOffset++] << 24) | ((ulong)data [currOffset++] << 32) | ((ulong)data [currOffset++] << 40) | ((ulong)data [currOffset++] << 48) | ((ulong)data [currOffset++] << 56);  else if (currOffset >= dataLimit && currOffset + 8 <= readLimit) {  	currOffset += 8;  	return 0;  }  else {  	var d = ReadBytes (8);  	return (ulong)d [currOffset++] | ((ulong)d [currOffset++] << 8) | ((ulong)d [currOffset++] << 16) | ((ulong)d [currOffset++] << 24) | ((ulong)d [currOffset++] << 32) | ((ulong)d [currOffset++] << 40) | ((ulong)d [currOffset++] << 48) | ((ulong)d [currOffset++] << 56);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: if (currOffset + 8 <= dataLimit)  	return (ulong)data [currOffset++] | ((ulong)data [currOffset++] << 8) | ((ulong)data [currOffset++] << 16) | ((ulong)data [currOffset++] << 24) | ((ulong)data [currOffset++] << 32) | ((ulong)data [currOffset++] << 40) | ((ulong)data [currOffset++] << 48) | ((ulong)data [currOffset++] << 56);  else if (currOffset >= dataLimit && currOffset + 8 <= readLimit) {  	currOffset += 8;  	return 0;  }  else {  	var d = ReadBytes (8);  	return (ulong)d [currOffset++] | ((ulong)d [currOffset++] << 8) | ((ulong)d [currOffset++] << 16) | ((ulong)d [currOffset++] << 24) | ((ulong)d [currOffset++] << 32) | ((ulong)d [currOffset++] << 40) | ((ulong)d [currOffset++] << 48) | ((ulong)d [currOffset++] << 56);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: if (currOffset + 8 <= dataLimit)  	return (ulong)data [currOffset++] | ((ulong)data [currOffset++] << 8) | ((ulong)data [currOffset++] << 16) | ((ulong)data [currOffset++] << 24) | ((ulong)data [currOffset++] << 32) | ((ulong)data [currOffset++] << 40) | ((ulong)data [currOffset++] << 48) | ((ulong)data [currOffset++] << 56);  else if (currOffset >= dataLimit && currOffset + 8 <= readLimit) {  	currOffset += 8;  	return 0;  }  else {  	var d = ReadBytes (8);  	return (ulong)d [currOffset++] | ((ulong)d [currOffset++] << 8) | ((ulong)d [currOffset++] << 16) | ((ulong)d [currOffset++] << 24) | ((ulong)d [currOffset++] << 32) | ((ulong)d [currOffset++] << 40) | ((ulong)d [currOffset++] << 48) | ((ulong)d [currOffset++] << 56);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: if (currOffset + 8 <= dataLimit)  	return (ulong)data [currOffset++] | ((ulong)data [currOffset++] << 8) | ((ulong)data [currOffset++] << 16) | ((ulong)data [currOffset++] << 24) | ((ulong)data [currOffset++] << 32) | ((ulong)data [currOffset++] << 40) | ((ulong)data [currOffset++] << 48) | ((ulong)data [currOffset++] << 56);  else if (currOffset >= dataLimit && currOffset + 8 <= readLimit) {  	currOffset += 8;  	return 0;  }  else {  	var d = ReadBytes (8);  	return (ulong)d [currOffset++] | ((ulong)d [currOffset++] << 8) | ((ulong)d [currOffset++] << 16) | ((ulong)d [currOffset++] << 24) | ((ulong)d [currOffset++] << 32) | ((ulong)d [currOffset++] << 40) | ((ulong)d [currOffset++] << 48) | ((ulong)d [currOffset++] << 56);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: if (currOffset + 8 <= dataLimit)  	return (ulong)data [currOffset++] | ((ulong)data [currOffset++] << 8) | ((ulong)data [currOffset++] << 16) | ((ulong)data [currOffset++] << 24) | ((ulong)data [currOffset++] << 32) | ((ulong)data [currOffset++] << 40) | ((ulong)data [currOffset++] << 48) | ((ulong)data [currOffset++] << 56);  else if (currOffset >= dataLimit && currOffset + 8 <= readLimit) {  	currOffset += 8;  	return 0;  }  else {  	var d = ReadBytes (8);  	return (ulong)d [currOffset++] | ((ulong)d [currOffset++] << 8) | ((ulong)d [currOffset++] << 16) | ((ulong)d [currOffset++] << 24) | ((ulong)d [currOffset++] << 32) | ((ulong)d [currOffset++] << 40) | ((ulong)d [currOffset++] << 48) | ((ulong)d [currOffset++] << 56);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: if (currOffset + 8 <= dataLimit)  	return (ulong)data [currOffset++] | ((ulong)data [currOffset++] << 8) | ((ulong)data [currOffset++] << 16) | ((ulong)data [currOffset++] << 24) | ((ulong)data [currOffset++] << 32) | ((ulong)data [currOffset++] << 40) | ((ulong)data [currOffset++] << 48) | ((ulong)data [currOffset++] << 56);  else if (currOffset >= dataLimit && currOffset + 8 <= readLimit) {  	currOffset += 8;  	return 0;  }  else {  	var d = ReadBytes (8);  	return (ulong)d [currOffset++] | ((ulong)d [currOffset++] << 8) | ((ulong)d [currOffset++] << 16) | ((ulong)d [currOffset++] << 24) | ((ulong)d [currOffset++] << 32) | ((ulong)d [currOffset++] << 40) | ((ulong)d [currOffset++] << 48) | ((ulong)d [currOffset++] << 56);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: if (currOffset + 8 <= dataLimit)  	return (ulong)data [currOffset++] | ((ulong)data [currOffset++] << 8) | ((ulong)data [currOffset++] << 16) | ((ulong)data [currOffset++] << 24) | ((ulong)data [currOffset++] << 32) | ((ulong)data [currOffset++] << 40) | ((ulong)data [currOffset++] << 48) | ((ulong)data [currOffset++] << 56);  else if (currOffset >= dataLimit && currOffset + 8 <= readLimit) {  	currOffset += 8;  	return 0;  }  else {  	var d = ReadBytes (8);  	return (ulong)d [currOffset++] | ((ulong)d [currOffset++] << 8) | ((ulong)d [currOffset++] << 16) | ((ulong)d [currOffset++] << 24) | ((ulong)d [currOffset++] << 32) | ((ulong)d [currOffset++] << 40) | ((ulong)d [currOffset++] << 48) | ((ulong)d [currOffset++] << 56);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: if (currOffset + 8 <= dataLimit)  	return (ulong)data [currOffset++] | ((ulong)data [currOffset++] << 8) | ((ulong)data [currOffset++] << 16) | ((ulong)data [currOffset++] << 24) | ((ulong)data [currOffset++] << 32) | ((ulong)data [currOffset++] << 40) | ((ulong)data [currOffset++] << 48) | ((ulong)data [currOffset++] << 56);  else if (currOffset >= dataLimit && currOffset + 8 <= readLimit) {  	currOffset += 8;  	return 0;  }  else {  	var d = ReadBytes (8);  	return (ulong)d [currOffset++] | ((ulong)d [currOffset++] << 8) | ((ulong)d [currOffset++] << 16) | ((ulong)d [currOffset++] << 24) | ((ulong)d [currOffset++] << 32) | ((ulong)d [currOffset++] << 40) | ((ulong)d [currOffset++] << 48) | ((ulong)d [currOffset++] << 56);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: return (ulong)data [currOffset++] | ((ulong)data [currOffset++] << 8) | ((ulong)data [currOffset++] << 16) | ((ulong)data [currOffset++] << 24) | ((ulong)data [currOffset++] << 32) | ((ulong)data [currOffset++] << 40) | ((ulong)data [currOffset++] << 48) | ((ulong)data [currOffset++] << 56);  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: return (ulong)data [currOffset++] | ((ulong)data [currOffset++] << 8) | ((ulong)data [currOffset++] << 16) | ((ulong)data [currOffset++] << 24) | ((ulong)data [currOffset++] << 32) | ((ulong)data [currOffset++] << 40) | ((ulong)data [currOffset++] << 48) | ((ulong)data [currOffset++] << 56);  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: return (ulong)data [currOffset++] | ((ulong)data [currOffset++] << 8) | ((ulong)data [currOffset++] << 16) | ((ulong)data [currOffset++] << 24) | ((ulong)data [currOffset++] << 32) | ((ulong)data [currOffset++] << 40) | ((ulong)data [currOffset++] << 48) | ((ulong)data [currOffset++] << 56);  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: return (ulong)data [currOffset++] | ((ulong)data [currOffset++] << 8) | ((ulong)data [currOffset++] << 16) | ((ulong)data [currOffset++] << 24) | ((ulong)data [currOffset++] << 32) | ((ulong)data [currOffset++] << 40) | ((ulong)data [currOffset++] << 48) | ((ulong)data [currOffset++] << 56);  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: return (ulong)data [currOffset++] | ((ulong)data [currOffset++] << 8) | ((ulong)data [currOffset++] << 16) | ((ulong)data [currOffset++] << 24) | ((ulong)data [currOffset++] << 32) | ((ulong)data [currOffset++] << 40) | ((ulong)data [currOffset++] << 48) | ((ulong)data [currOffset++] << 56);  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: return (ulong)data [currOffset++] | ((ulong)data [currOffset++] << 8) | ((ulong)data [currOffset++] << 16) | ((ulong)data [currOffset++] << 24) | ((ulong)data [currOffset++] << 32) | ((ulong)data [currOffset++] << 40) | ((ulong)data [currOffset++] << 48) | ((ulong)data [currOffset++] << 56);  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: return (ulong)data [currOffset++] | ((ulong)data [currOffset++] << 8) | ((ulong)data [currOffset++] << 16) | ((ulong)data [currOffset++] << 24) | ((ulong)data [currOffset++] << 32) | ((ulong)data [currOffset++] << 40) | ((ulong)data [currOffset++] << 48) | ((ulong)data [currOffset++] << 56);  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: if (currOffset >= dataLimit && currOffset + 8 <= readLimit) {  	currOffset += 8;  	return 0;  }  else {  	var d = ReadBytes (8);  	return (ulong)d [currOffset++] | ((ulong)d [currOffset++] << 8) | ((ulong)d [currOffset++] << 16) | ((ulong)d [currOffset++] << 24) | ((ulong)d [currOffset++] << 32) | ((ulong)d [currOffset++] << 40) | ((ulong)d [currOffset++] << 48) | ((ulong)d [currOffset++] << 56);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: if (currOffset >= dataLimit && currOffset + 8 <= readLimit) {  	currOffset += 8;  	return 0;  }  else {  	var d = ReadBytes (8);  	return (ulong)d [currOffset++] | ((ulong)d [currOffset++] << 8) | ((ulong)d [currOffset++] << 16) | ((ulong)d [currOffset++] << 24) | ((ulong)d [currOffset++] << 32) | ((ulong)d [currOffset++] << 40) | ((ulong)d [currOffset++] << 48) | ((ulong)d [currOffset++] << 56);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: if (currOffset >= dataLimit && currOffset + 8 <= readLimit) {  	currOffset += 8;  	return 0;  }  else {  	var d = ReadBytes (8);  	return (ulong)d [currOffset++] | ((ulong)d [currOffset++] << 8) | ((ulong)d [currOffset++] << 16) | ((ulong)d [currOffset++] << 24) | ((ulong)d [currOffset++] << 32) | ((ulong)d [currOffset++] << 40) | ((ulong)d [currOffset++] << 48) | ((ulong)d [currOffset++] << 56);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: if (currOffset >= dataLimit && currOffset + 8 <= readLimit) {  	currOffset += 8;  	return 0;  }  else {  	var d = ReadBytes (8);  	return (ulong)d [currOffset++] | ((ulong)d [currOffset++] << 8) | ((ulong)d [currOffset++] << 16) | ((ulong)d [currOffset++] << 24) | ((ulong)d [currOffset++] << 32) | ((ulong)d [currOffset++] << 40) | ((ulong)d [currOffset++] << 48) | ((ulong)d [currOffset++] << 56);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: if (currOffset >= dataLimit && currOffset + 8 <= readLimit) {  	currOffset += 8;  	return 0;  }  else {  	var d = ReadBytes (8);  	return (ulong)d [currOffset++] | ((ulong)d [currOffset++] << 8) | ((ulong)d [currOffset++] << 16) | ((ulong)d [currOffset++] << 24) | ((ulong)d [currOffset++] << 32) | ((ulong)d [currOffset++] << 40) | ((ulong)d [currOffset++] << 48) | ((ulong)d [currOffset++] << 56);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: if (currOffset >= dataLimit && currOffset + 8 <= readLimit) {  	currOffset += 8;  	return 0;  }  else {  	var d = ReadBytes (8);  	return (ulong)d [currOffset++] | ((ulong)d [currOffset++] << 8) | ((ulong)d [currOffset++] << 16) | ((ulong)d [currOffset++] << 24) | ((ulong)d [currOffset++] << 32) | ((ulong)d [currOffset++] << 40) | ((ulong)d [currOffset++] << 48) | ((ulong)d [currOffset++] << 56);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: if (currOffset >= dataLimit && currOffset + 8 <= readLimit) {  	currOffset += 8;  	return 0;  }  else {  	var d = ReadBytes (8);  	return (ulong)d [currOffset++] | ((ulong)d [currOffset++] << 8) | ((ulong)d [currOffset++] << 16) | ((ulong)d [currOffset++] << 24) | ((ulong)d [currOffset++] << 32) | ((ulong)d [currOffset++] << 40) | ((ulong)d [currOffset++] << 48) | ((ulong)d [currOffset++] << 56);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: if (currOffset >= dataLimit && currOffset + 8 <= readLimit) {  	currOffset += 8;  	return 0;  }  else {  	var d = ReadBytes (8);  	return (ulong)d [currOffset++] | ((ulong)d [currOffset++] << 8) | ((ulong)d [currOffset++] << 16) | ((ulong)d [currOffset++] << 24) | ((ulong)d [currOffset++] << 32) | ((ulong)d [currOffset++] << 40) | ((ulong)d [currOffset++] << 48) | ((ulong)d [currOffset++] << 56);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: if (currOffset >= dataLimit && currOffset + 8 <= readLimit) {  	currOffset += 8;  	return 0;  }  else {  	var d = ReadBytes (8);  	return (ulong)d [currOffset++] | ((ulong)d [currOffset++] << 8) | ((ulong)d [currOffset++] << 16) | ((ulong)d [currOffset++] << 24) | ((ulong)d [currOffset++] << 32) | ((ulong)d [currOffset++] << 40) | ((ulong)d [currOffset++] << 48) | ((ulong)d [currOffset++] << 56);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: if (currOffset >= dataLimit && currOffset + 8 <= readLimit) {  	currOffset += 8;  	return 0;  }  else {  	var d = ReadBytes (8);  	return (ulong)d [currOffset++] | ((ulong)d [currOffset++] << 8) | ((ulong)d [currOffset++] << 16) | ((ulong)d [currOffset++] << 24) | ((ulong)d [currOffset++] << 32) | ((ulong)d [currOffset++] << 40) | ((ulong)d [currOffset++] << 48) | ((ulong)d [currOffset++] << 56);  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: currOffset += 8;  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: return (ulong)d [currOffset++] | ((ulong)d [currOffset++] << 8) | ((ulong)d [currOffset++] << 16) | ((ulong)d [currOffset++] << 24) | ((ulong)d [currOffset++] << 32) | ((ulong)d [currOffset++] << 40) | ((ulong)d [currOffset++] << 48) | ((ulong)d [currOffset++] << 56);  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: return (ulong)d [currOffset++] | ((ulong)d [currOffset++] << 8) | ((ulong)d [currOffset++] << 16) | ((ulong)d [currOffset++] << 24) | ((ulong)d [currOffset++] << 32) | ((ulong)d [currOffset++] << 40) | ((ulong)d [currOffset++] << 48) | ((ulong)d [currOffset++] << 56);  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: return (ulong)d [currOffset++] | ((ulong)d [currOffset++] << 8) | ((ulong)d [currOffset++] << 16) | ((ulong)d [currOffset++] << 24) | ((ulong)d [currOffset++] << 32) | ((ulong)d [currOffset++] << 40) | ((ulong)d [currOffset++] << 48) | ((ulong)d [currOffset++] << 56);  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: return (ulong)d [currOffset++] | ((ulong)d [currOffset++] << 8) | ((ulong)d [currOffset++] << 16) | ((ulong)d [currOffset++] << 24) | ((ulong)d [currOffset++] << 32) | ((ulong)d [currOffset++] << 40) | ((ulong)d [currOffset++] << 48) | ((ulong)d [currOffset++] << 56);  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: return (ulong)d [currOffset++] | ((ulong)d [currOffset++] << 8) | ((ulong)d [currOffset++] << 16) | ((ulong)d [currOffset++] << 24) | ((ulong)d [currOffset++] << 32) | ((ulong)d [currOffset++] << 40) | ((ulong)d [currOffset++] << 48) | ((ulong)d [currOffset++] << 56);  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: return (ulong)d [currOffset++] | ((ulong)d [currOffset++] << 8) | ((ulong)d [currOffset++] << 16) | ((ulong)d [currOffset++] << 24) | ((ulong)d [currOffset++] << 32) | ((ulong)d [currOffset++] << 40) | ((ulong)d [currOffset++] << 48) | ((ulong)d [currOffset++] << 56);  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUInt64,The following statement contains a magic number: return (ulong)d [currOffset++] | ((ulong)d [currOffset++] << 8) | ((ulong)d [currOffset++] << 16) | ((ulong)d [currOffset++] << 24) | ((ulong)d [currOffset++] << 32) | ((ulong)d [currOffset++] << 40) | ((ulong)d [currOffset++] << 48) | ((ulong)d [currOffset++] << 56);  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadSingle,The following statement contains a magic number: if (currOffset + 4 <= dataLimit) {  	var value = BitConverter.ToSingle (data' (int)currOffset);  	currOffset += 4;  	return value;  }  else if (currOffset >= dataLimit && currOffset + 4 <= readLimit) {  	currOffset += 4;  	return 0.0f;  }  else {  	var d = ReadBytes (4);  	var value = BitConverter.ToSingle (d' 0);  	currOffset += 4;  	return value;  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadSingle,The following statement contains a magic number: if (currOffset + 4 <= dataLimit) {  	var value = BitConverter.ToSingle (data' (int)currOffset);  	currOffset += 4;  	return value;  }  else if (currOffset >= dataLimit && currOffset + 4 <= readLimit) {  	currOffset += 4;  	return 0.0f;  }  else {  	var d = ReadBytes (4);  	var value = BitConverter.ToSingle (d' 0);  	currOffset += 4;  	return value;  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadSingle,The following statement contains a magic number: if (currOffset + 4 <= dataLimit) {  	var value = BitConverter.ToSingle (data' (int)currOffset);  	currOffset += 4;  	return value;  }  else if (currOffset >= dataLimit && currOffset + 4 <= readLimit) {  	currOffset += 4;  	return 0.0f;  }  else {  	var d = ReadBytes (4);  	var value = BitConverter.ToSingle (d' 0);  	currOffset += 4;  	return value;  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadSingle,The following statement contains a magic number: if (currOffset + 4 <= dataLimit) {  	var value = BitConverter.ToSingle (data' (int)currOffset);  	currOffset += 4;  	return value;  }  else if (currOffset >= dataLimit && currOffset + 4 <= readLimit) {  	currOffset += 4;  	return 0.0f;  }  else {  	var d = ReadBytes (4);  	var value = BitConverter.ToSingle (d' 0);  	currOffset += 4;  	return value;  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadSingle,The following statement contains a magic number: if (currOffset + 4 <= dataLimit) {  	var value = BitConverter.ToSingle (data' (int)currOffset);  	currOffset += 4;  	return value;  }  else if (currOffset >= dataLimit && currOffset + 4 <= readLimit) {  	currOffset += 4;  	return 0.0f;  }  else {  	var d = ReadBytes (4);  	var value = BitConverter.ToSingle (d' 0);  	currOffset += 4;  	return value;  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadSingle,The following statement contains a magic number: if (currOffset + 4 <= dataLimit) {  	var value = BitConverter.ToSingle (data' (int)currOffset);  	currOffset += 4;  	return value;  }  else if (currOffset >= dataLimit && currOffset + 4 <= readLimit) {  	currOffset += 4;  	return 0.0f;  }  else {  	var d = ReadBytes (4);  	var value = BitConverter.ToSingle (d' 0);  	currOffset += 4;  	return value;  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadSingle,The following statement contains a magic number: currOffset += 4;  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadSingle,The following statement contains a magic number: if (currOffset >= dataLimit && currOffset + 4 <= readLimit) {  	currOffset += 4;  	return 0.0f;  }  else {  	var d = ReadBytes (4);  	var value = BitConverter.ToSingle (d' 0);  	currOffset += 4;  	return value;  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadSingle,The following statement contains a magic number: if (currOffset >= dataLimit && currOffset + 4 <= readLimit) {  	currOffset += 4;  	return 0.0f;  }  else {  	var d = ReadBytes (4);  	var value = BitConverter.ToSingle (d' 0);  	currOffset += 4;  	return value;  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadSingle,The following statement contains a magic number: if (currOffset >= dataLimit && currOffset + 4 <= readLimit) {  	currOffset += 4;  	return 0.0f;  }  else {  	var d = ReadBytes (4);  	var value = BitConverter.ToSingle (d' 0);  	currOffset += 4;  	return value;  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadSingle,The following statement contains a magic number: if (currOffset >= dataLimit && currOffset + 4 <= readLimit) {  	currOffset += 4;  	return 0.0f;  }  else {  	var d = ReadBytes (4);  	var value = BitConverter.ToSingle (d' 0);  	currOffset += 4;  	return value;  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadSingle,The following statement contains a magic number: currOffset += 4;  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadSingle,The following statement contains a magic number: currOffset += 4;  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadDouble,The following statement contains a magic number: if (currOffset + 8 <= dataLimit) {  	var value = BitConverter.ToDouble (data' (int)currOffset);  	currOffset += 8;  	return value;  }  else if (currOffset >= dataLimit && currOffset + 8 <= readLimit) {  	currOffset += 8;  	return 0.0;  }  else {  	var d = ReadBytes (8);  	var value = BitConverter.ToDouble (d' 0);  	currOffset += 8;  	return value;  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadDouble,The following statement contains a magic number: if (currOffset + 8 <= dataLimit) {  	var value = BitConverter.ToDouble (data' (int)currOffset);  	currOffset += 8;  	return value;  }  else if (currOffset >= dataLimit && currOffset + 8 <= readLimit) {  	currOffset += 8;  	return 0.0;  }  else {  	var d = ReadBytes (8);  	var value = BitConverter.ToDouble (d' 0);  	currOffset += 8;  	return value;  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadDouble,The following statement contains a magic number: if (currOffset + 8 <= dataLimit) {  	var value = BitConverter.ToDouble (data' (int)currOffset);  	currOffset += 8;  	return value;  }  else if (currOffset >= dataLimit && currOffset + 8 <= readLimit) {  	currOffset += 8;  	return 0.0;  }  else {  	var d = ReadBytes (8);  	var value = BitConverter.ToDouble (d' 0);  	currOffset += 8;  	return value;  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadDouble,The following statement contains a magic number: if (currOffset + 8 <= dataLimit) {  	var value = BitConverter.ToDouble (data' (int)currOffset);  	currOffset += 8;  	return value;  }  else if (currOffset >= dataLimit && currOffset + 8 <= readLimit) {  	currOffset += 8;  	return 0.0;  }  else {  	var d = ReadBytes (8);  	var value = BitConverter.ToDouble (d' 0);  	currOffset += 8;  	return value;  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadDouble,The following statement contains a magic number: if (currOffset + 8 <= dataLimit) {  	var value = BitConverter.ToDouble (data' (int)currOffset);  	currOffset += 8;  	return value;  }  else if (currOffset >= dataLimit && currOffset + 8 <= readLimit) {  	currOffset += 8;  	return 0.0;  }  else {  	var d = ReadBytes (8);  	var value = BitConverter.ToDouble (d' 0);  	currOffset += 8;  	return value;  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadDouble,The following statement contains a magic number: if (currOffset + 8 <= dataLimit) {  	var value = BitConverter.ToDouble (data' (int)currOffset);  	currOffset += 8;  	return value;  }  else if (currOffset >= dataLimit && currOffset + 8 <= readLimit) {  	currOffset += 8;  	return 0.0;  }  else {  	var d = ReadBytes (8);  	var value = BitConverter.ToDouble (d' 0);  	currOffset += 8;  	return value;  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadDouble,The following statement contains a magic number: currOffset += 8;  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadDouble,The following statement contains a magic number: if (currOffset >= dataLimit && currOffset + 8 <= readLimit) {  	currOffset += 8;  	return 0.0;  }  else {  	var d = ReadBytes (8);  	var value = BitConverter.ToDouble (d' 0);  	currOffset += 8;  	return value;  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadDouble,The following statement contains a magic number: if (currOffset >= dataLimit && currOffset + 8 <= readLimit) {  	currOffset += 8;  	return 0.0;  }  else {  	var d = ReadBytes (8);  	var value = BitConverter.ToDouble (d' 0);  	currOffset += 8;  	return value;  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadDouble,The following statement contains a magic number: if (currOffset >= dataLimit && currOffset + 8 <= readLimit) {  	currOffset += 8;  	return 0.0;  }  else {  	var d = ReadBytes (8);  	var value = BitConverter.ToDouble (d' 0);  	currOffset += 8;  	return value;  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadDouble,The following statement contains a magic number: if (currOffset >= dataLimit && currOffset + 8 <= readLimit) {  	currOffset += 8;  	return 0.0;  }  else {  	var d = ReadBytes (8);  	var value = BitConverter.ToDouble (d' 0);  	currOffset += 8;  	return value;  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadDouble,The following statement contains a magic number: currOffset += 8;  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadDouble,The following statement contains a magic number: currOffset += 8;  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00)  	return headerByte;  else if ((headerByte & 0xc0) == 0x80)  	return ((uint)(headerByte & 0x3f) << 8) | ReadByte ();  else if ((headerByte & 0xe0) == 0xc0)  	return ((uint)(headerByte & 0x1f) << 24) | ((uint)ReadByte () << 16) | ((uint)ReadByte () << 8) | ReadByte ();  else if (headerByte == 0xFF)  	return 0xffffffff;  else  	throw new PEException ("invalid bytes for 7-bit encoding");  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00)  	return headerByte;  else if ((headerByte & 0xc0) == 0x80)  	return ((uint)(headerByte & 0x3f) << 8) | ReadByte ();  else if ((headerByte & 0xe0) == 0xc0)  	return ((uint)(headerByte & 0x1f) << 24) | ((uint)ReadByte () << 16) | ((uint)ReadByte () << 8) | ReadByte ();  else if (headerByte == 0xFF)  	return 0xffffffff;  else  	throw new PEException ("invalid bytes for 7-bit encoding");  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00)  	return headerByte;  else if ((headerByte & 0xc0) == 0x80)  	return ((uint)(headerByte & 0x3f) << 8) | ReadByte ();  else if ((headerByte & 0xe0) == 0xc0)  	return ((uint)(headerByte & 0x1f) << 24) | ((uint)ReadByte () << 16) | ((uint)ReadByte () << 8) | ReadByte ();  else if (headerByte == 0xFF)  	return 0xffffffff;  else  	throw new PEException ("invalid bytes for 7-bit encoding");  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00)  	return headerByte;  else if ((headerByte & 0xc0) == 0x80)  	return ((uint)(headerByte & 0x3f) << 8) | ReadByte ();  else if ((headerByte & 0xe0) == 0xc0)  	return ((uint)(headerByte & 0x1f) << 24) | ((uint)ReadByte () << 16) | ((uint)ReadByte () << 8) | ReadByte ();  else if (headerByte == 0xFF)  	return 0xffffffff;  else  	throw new PEException ("invalid bytes for 7-bit encoding");  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0xc0) == 0x80)  	return ((uint)(headerByte & 0x3f) << 8) | ReadByte ();  else if ((headerByte & 0xe0) == 0xc0)  	return ((uint)(headerByte & 0x1f) << 24) | ((uint)ReadByte () << 16) | ((uint)ReadByte () << 8) | ReadByte ();  else if (headerByte == 0xFF)  	return 0xffffffff;  else  	throw new PEException ("invalid bytes for 7-bit encoding");  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0xc0) == 0x80)  	return ((uint)(headerByte & 0x3f) << 8) | ReadByte ();  else if ((headerByte & 0xe0) == 0xc0)  	return ((uint)(headerByte & 0x1f) << 24) | ((uint)ReadByte () << 16) | ((uint)ReadByte () << 8) | ReadByte ();  else if (headerByte == 0xFF)  	return 0xffffffff;  else  	throw new PEException ("invalid bytes for 7-bit encoding");  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0xc0) == 0x80)  	return ((uint)(headerByte & 0x3f) << 8) | ReadByte ();  else if ((headerByte & 0xe0) == 0xc0)  	return ((uint)(headerByte & 0x1f) << 24) | ((uint)ReadByte () << 16) | ((uint)ReadByte () << 8) | ReadByte ();  else if (headerByte == 0xFF)  	return 0xffffffff;  else  	throw new PEException ("invalid bytes for 7-bit encoding");  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0xc0) == 0x80)  	return ((uint)(headerByte & 0x3f) << 8) | ReadByte ();  else if ((headerByte & 0xe0) == 0xc0)  	return ((uint)(headerByte & 0x1f) << 24) | ((uint)ReadByte () << 16) | ((uint)ReadByte () << 8) | ReadByte ();  else if (headerByte == 0xFF)  	return 0xffffffff;  else  	throw new PEException ("invalid bytes for 7-bit encoding");  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadCompressedUInt32,The following statement contains a magic number: return ((uint)(headerByte & 0x3f) << 8) | ReadByte ();  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0xe0) == 0xc0)  	return ((uint)(headerByte & 0x1f) << 24) | ((uint)ReadByte () << 16) | ((uint)ReadByte () << 8) | ReadByte ();  else if (headerByte == 0xFF)  	return 0xffffffff;  else  	throw new PEException ("invalid bytes for 7-bit encoding");  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0xe0) == 0xc0)  	return ((uint)(headerByte & 0x1f) << 24) | ((uint)ReadByte () << 16) | ((uint)ReadByte () << 8) | ReadByte ();  else if (headerByte == 0xFF)  	return 0xffffffff;  else  	throw new PEException ("invalid bytes for 7-bit encoding");  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0xe0) == 0xc0)  	return ((uint)(headerByte & 0x1f) << 24) | ((uint)ReadByte () << 16) | ((uint)ReadByte () << 8) | ReadByte ();  else if (headerByte == 0xFF)  	return 0xffffffff;  else  	throw new PEException ("invalid bytes for 7-bit encoding");  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadCompressedUInt32,The following statement contains a magic number: return ((uint)(headerByte & 0x1f) << 24) | ((uint)ReadByte () << 16) | ((uint)ReadByte () << 8) | ReadByte ();  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadCompressedUInt32,The following statement contains a magic number: return ((uint)(headerByte & 0x1f) << 24) | ((uint)ReadByte () << 16) | ((uint)ReadByte () << 8) | ReadByte ();  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadCompressedUInt32,The following statement contains a magic number: return ((uint)(headerByte & 0x1f) << 24) | ((uint)ReadByte () << 16) | ((uint)ReadByte () << 8) | ReadByte ();  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUTF16SizedString,The following statement contains a magic number: if (len == 0xffffffffu)  	return null;  else if (len == 0)  	return "";  else {  	if (len % 2 != 0)  		throw new PEException ("invalid UTF16 string length");  	var blob = ReadBytes (len);  	return new String (Encoding.Unicode.GetChars (blob));  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUTF16SizedString,The following statement contains a magic number: if (len == 0)  	return "";  else {  	if (len % 2 != 0)  		throw new PEException ("invalid UTF16 string length");  	var blob = ReadBytes (len);  	return new String (Encoding.Unicode.GetChars (blob));  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUTF16SizedString,The following statement contains a magic number: if (len % 2 != 0)  	throw new PEException ("invalid UTF16 string length");  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUTF16SizedStringWithEncodingHint,The following statement contains a magic number: if (len == 0xffffffffu)  	return null;  else if (len == 0)  	return "";  else {  	if (len % 2 == 0)  		throw new PEException ("invalid UTF16 string with encoding hint length");  	var blob = ReadBytes (len - 1u);  	var isUTF16 = ReadByte () > 0;  	// ignored  	return new String (Encoding.Unicode.GetChars (blob));  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUTF16SizedStringWithEncodingHint,The following statement contains a magic number: if (len == 0)  	return "";  else {  	if (len % 2 == 0)  		throw new PEException ("invalid UTF16 string with encoding hint length");  	var blob = ReadBytes (len - 1u);  	var isUTF16 = ReadByte () > 0;  	// ignored  	return new String (Encoding.Unicode.GetChars (blob));  }  
Magic Number,Microsoft.LiveLabs.PE,BlobReader,C:\repos\Reactive-Extensions_IL2JS\PE\BlobReader.cs,ReadUTF16SizedStringWithEncodingHint,The following statement contains a magic number: if (len % 2 == 0)  	throw new PEException ("invalid UTF16 string with encoding hint length");  
Magic Number,Microsoft.LiveLabs.PE,BlobWriter,C:\repos\Reactive-Extensions_IL2JS\PE\BlobWriter.cs,Prepare,The following statement contains a magic number: if (newOffset > (uint)data.Length) {  	var newLength = (uint)data.Length * 2;  	if (limited && newLength > writeLimit)  		newLength = writeLimit;  	var newData = new byte[newLength];  	Array.Copy (data' newData' (int)dataLimit);  	data = newData;  }  
Magic Number,Microsoft.LiveLabs.PE,BlobWriter,C:\repos\Reactive-Extensions_IL2JS\PE\BlobWriter.cs,WriteUInt16,The following statement contains a magic number: Prepare (2);  
Magic Number,Microsoft.LiveLabs.PE,BlobWriter,C:\repos\Reactive-Extensions_IL2JS\PE\BlobWriter.cs,WriteUInt16,The following statement contains a magic number: data [currOffset++] = (byte)(value >> 8);  
Magic Number,Microsoft.LiveLabs.PE,BlobWriter,C:\repos\Reactive-Extensions_IL2JS\PE\BlobWriter.cs,WriteUInt24,The following statement contains a magic number: Prepare (3);  
Magic Number,Microsoft.LiveLabs.PE,BlobWriter,C:\repos\Reactive-Extensions_IL2JS\PE\BlobWriter.cs,WriteUInt24,The following statement contains a magic number: data [currOffset++] = (byte)((value >> 8) & 0xff);  
Magic Number,Microsoft.LiveLabs.PE,BlobWriter,C:\repos\Reactive-Extensions_IL2JS\PE\BlobWriter.cs,WriteUInt24,The following statement contains a magic number: data [currOffset++] = (byte)(value >> 16);  
Magic Number,Microsoft.LiveLabs.PE,BlobWriter,C:\repos\Reactive-Extensions_IL2JS\PE\BlobWriter.cs,WriteUInt32,The following statement contains a magic number: Prepare (4);  
Magic Number,Microsoft.LiveLabs.PE,BlobWriter,C:\repos\Reactive-Extensions_IL2JS\PE\BlobWriter.cs,WriteUInt32,The following statement contains a magic number: data [currOffset++] = (byte)((value >> 8) & 0xff);  
Magic Number,Microsoft.LiveLabs.PE,BlobWriter,C:\repos\Reactive-Extensions_IL2JS\PE\BlobWriter.cs,WriteUInt32,The following statement contains a magic number: data [currOffset++] = (byte)((value >> 16) & 0xff);  
Magic Number,Microsoft.LiveLabs.PE,BlobWriter,C:\repos\Reactive-Extensions_IL2JS\PE\BlobWriter.cs,WriteUInt32,The following statement contains a magic number: data [currOffset++] = (byte)(value >> 24);  
Magic Number,Microsoft.LiveLabs.PE,BlobWriter,C:\repos\Reactive-Extensions_IL2JS\PE\BlobWriter.cs,WriteUInt64,The following statement contains a magic number: Prepare (8);  
Magic Number,Microsoft.LiveLabs.PE,BlobWriter,C:\repos\Reactive-Extensions_IL2JS\PE\BlobWriter.cs,WriteUInt64,The following statement contains a magic number: data [currOffset++] = (byte)((value >> 8) & 0xff);  
Magic Number,Microsoft.LiveLabs.PE,BlobWriter,C:\repos\Reactive-Extensions_IL2JS\PE\BlobWriter.cs,WriteUInt64,The following statement contains a magic number: data [currOffset++] = (byte)((value >> 16) & 0xff);  
Magic Number,Microsoft.LiveLabs.PE,BlobWriter,C:\repos\Reactive-Extensions_IL2JS\PE\BlobWriter.cs,WriteUInt64,The following statement contains a magic number: data [currOffset++] = (byte)((value >> 24) & 0xff);  
Magic Number,Microsoft.LiveLabs.PE,BlobWriter,C:\repos\Reactive-Extensions_IL2JS\PE\BlobWriter.cs,WriteUInt64,The following statement contains a magic number: data [currOffset++] = (byte)((value >> 32) & 0xff);  
Magic Number,Microsoft.LiveLabs.PE,BlobWriter,C:\repos\Reactive-Extensions_IL2JS\PE\BlobWriter.cs,WriteUInt64,The following statement contains a magic number: data [currOffset++] = (byte)((value >> 40) & 0xff);  
Magic Number,Microsoft.LiveLabs.PE,BlobWriter,C:\repos\Reactive-Extensions_IL2JS\PE\BlobWriter.cs,WriteUInt64,The following statement contains a magic number: data [currOffset++] = (byte)((value >> 48) & 0xff);  
Magic Number,Microsoft.LiveLabs.PE,BlobWriter,C:\repos\Reactive-Extensions_IL2JS\PE\BlobWriter.cs,WriteUInt64,The following statement contains a magic number: data [currOffset++] = (byte)(value >> 56);  
Magic Number,Microsoft.LiveLabs.PE,BlobWriter,C:\repos\Reactive-Extensions_IL2JS\PE\BlobWriter.cs,WriteCompressedUInt32,The following statement contains a magic number: if (value <= 0x7f)  	WriteByte ((byte)value);  else if (value <= 0x3fff) {  	WriteByte ((byte)((value >> 8) | 0x80));  	WriteByte ((byte)(value & 0xff));  }  else if (value <= 0x1fffffff) {  	WriteByte ((byte)((value >> 24) | 0xc0));  	WriteByte ((byte)((value >> 16) & 0xff));  	WriteByte ((byte)((value >> 8) & 0xff));  	WriteByte ((byte)(value & 0xff));  }  else if (value == 0xffffffff)  	WriteByte (0xff);  else  	throw new PEException ("invalid value for 7-bit encoding");  
Magic Number,Microsoft.LiveLabs.PE,BlobWriter,C:\repos\Reactive-Extensions_IL2JS\PE\BlobWriter.cs,WriteCompressedUInt32,The following statement contains a magic number: if (value <= 0x7f)  	WriteByte ((byte)value);  else if (value <= 0x3fff) {  	WriteByte ((byte)((value >> 8) | 0x80));  	WriteByte ((byte)(value & 0xff));  }  else if (value <= 0x1fffffff) {  	WriteByte ((byte)((value >> 24) | 0xc0));  	WriteByte ((byte)((value >> 16) & 0xff));  	WriteByte ((byte)((value >> 8) & 0xff));  	WriteByte ((byte)(value & 0xff));  }  else if (value == 0xffffffff)  	WriteByte (0xff);  else  	throw new PEException ("invalid value for 7-bit encoding");  
Magic Number,Microsoft.LiveLabs.PE,BlobWriter,C:\repos\Reactive-Extensions_IL2JS\PE\BlobWriter.cs,WriteCompressedUInt32,The following statement contains a magic number: if (value <= 0x7f)  	WriteByte ((byte)value);  else if (value <= 0x3fff) {  	WriteByte ((byte)((value >> 8) | 0x80));  	WriteByte ((byte)(value & 0xff));  }  else if (value <= 0x1fffffff) {  	WriteByte ((byte)((value >> 24) | 0xc0));  	WriteByte ((byte)((value >> 16) & 0xff));  	WriteByte ((byte)((value >> 8) & 0xff));  	WriteByte ((byte)(value & 0xff));  }  else if (value == 0xffffffff)  	WriteByte (0xff);  else  	throw new PEException ("invalid value for 7-bit encoding");  
Magic Number,Microsoft.LiveLabs.PE,BlobWriter,C:\repos\Reactive-Extensions_IL2JS\PE\BlobWriter.cs,WriteCompressedUInt32,The following statement contains a magic number: if (value <= 0x7f)  	WriteByte ((byte)value);  else if (value <= 0x3fff) {  	WriteByte ((byte)((value >> 8) | 0x80));  	WriteByte ((byte)(value & 0xff));  }  else if (value <= 0x1fffffff) {  	WriteByte ((byte)((value >> 24) | 0xc0));  	WriteByte ((byte)((value >> 16) & 0xff));  	WriteByte ((byte)((value >> 8) & 0xff));  	WriteByte ((byte)(value & 0xff));  }  else if (value == 0xffffffff)  	WriteByte (0xff);  else  	throw new PEException ("invalid value for 7-bit encoding");  
Magic Number,Microsoft.LiveLabs.PE,BlobWriter,C:\repos\Reactive-Extensions_IL2JS\PE\BlobWriter.cs,WriteCompressedUInt32,The following statement contains a magic number: if (value <= 0x3fff) {  	WriteByte ((byte)((value >> 8) | 0x80));  	WriteByte ((byte)(value & 0xff));  }  else if (value <= 0x1fffffff) {  	WriteByte ((byte)((value >> 24) | 0xc0));  	WriteByte ((byte)((value >> 16) & 0xff));  	WriteByte ((byte)((value >> 8) & 0xff));  	WriteByte ((byte)(value & 0xff));  }  else if (value == 0xffffffff)  	WriteByte (0xff);  else  	throw new PEException ("invalid value for 7-bit encoding");  
Magic Number,Microsoft.LiveLabs.PE,BlobWriter,C:\repos\Reactive-Extensions_IL2JS\PE\BlobWriter.cs,WriteCompressedUInt32,The following statement contains a magic number: if (value <= 0x3fff) {  	WriteByte ((byte)((value >> 8) | 0x80));  	WriteByte ((byte)(value & 0xff));  }  else if (value <= 0x1fffffff) {  	WriteByte ((byte)((value >> 24) | 0xc0));  	WriteByte ((byte)((value >> 16) & 0xff));  	WriteByte ((byte)((value >> 8) & 0xff));  	WriteByte ((byte)(value & 0xff));  }  else if (value == 0xffffffff)  	WriteByte (0xff);  else  	throw new PEException ("invalid value for 7-bit encoding");  
Magic Number,Microsoft.LiveLabs.PE,BlobWriter,C:\repos\Reactive-Extensions_IL2JS\PE\BlobWriter.cs,WriteCompressedUInt32,The following statement contains a magic number: if (value <= 0x3fff) {  	WriteByte ((byte)((value >> 8) | 0x80));  	WriteByte ((byte)(value & 0xff));  }  else if (value <= 0x1fffffff) {  	WriteByte ((byte)((value >> 24) | 0xc0));  	WriteByte ((byte)((value >> 16) & 0xff));  	WriteByte ((byte)((value >> 8) & 0xff));  	WriteByte ((byte)(value & 0xff));  }  else if (value == 0xffffffff)  	WriteByte (0xff);  else  	throw new PEException ("invalid value for 7-bit encoding");  
Magic Number,Microsoft.LiveLabs.PE,BlobWriter,C:\repos\Reactive-Extensions_IL2JS\PE\BlobWriter.cs,WriteCompressedUInt32,The following statement contains a magic number: if (value <= 0x3fff) {  	WriteByte ((byte)((value >> 8) | 0x80));  	WriteByte ((byte)(value & 0xff));  }  else if (value <= 0x1fffffff) {  	WriteByte ((byte)((value >> 24) | 0xc0));  	WriteByte ((byte)((value >> 16) & 0xff));  	WriteByte ((byte)((value >> 8) & 0xff));  	WriteByte ((byte)(value & 0xff));  }  else if (value == 0xffffffff)  	WriteByte (0xff);  else  	throw new PEException ("invalid value for 7-bit encoding");  
Magic Number,Microsoft.LiveLabs.PE,BlobWriter,C:\repos\Reactive-Extensions_IL2JS\PE\BlobWriter.cs,WriteCompressedUInt32,The following statement contains a magic number: WriteByte ((byte)((value >> 8) | 0x80));  
Magic Number,Microsoft.LiveLabs.PE,BlobWriter,C:\repos\Reactive-Extensions_IL2JS\PE\BlobWriter.cs,WriteCompressedUInt32,The following statement contains a magic number: if (value <= 0x1fffffff) {  	WriteByte ((byte)((value >> 24) | 0xc0));  	WriteByte ((byte)((value >> 16) & 0xff));  	WriteByte ((byte)((value >> 8) & 0xff));  	WriteByte ((byte)(value & 0xff));  }  else if (value == 0xffffffff)  	WriteByte (0xff);  else  	throw new PEException ("invalid value for 7-bit encoding");  
Magic Number,Microsoft.LiveLabs.PE,BlobWriter,C:\repos\Reactive-Extensions_IL2JS\PE\BlobWriter.cs,WriteCompressedUInt32,The following statement contains a magic number: if (value <= 0x1fffffff) {  	WriteByte ((byte)((value >> 24) | 0xc0));  	WriteByte ((byte)((value >> 16) & 0xff));  	WriteByte ((byte)((value >> 8) & 0xff));  	WriteByte ((byte)(value & 0xff));  }  else if (value == 0xffffffff)  	WriteByte (0xff);  else  	throw new PEException ("invalid value for 7-bit encoding");  
Magic Number,Microsoft.LiveLabs.PE,BlobWriter,C:\repos\Reactive-Extensions_IL2JS\PE\BlobWriter.cs,WriteCompressedUInt32,The following statement contains a magic number: if (value <= 0x1fffffff) {  	WriteByte ((byte)((value >> 24) | 0xc0));  	WriteByte ((byte)((value >> 16) & 0xff));  	WriteByte ((byte)((value >> 8) & 0xff));  	WriteByte ((byte)(value & 0xff));  }  else if (value == 0xffffffff)  	WriteByte (0xff);  else  	throw new PEException ("invalid value for 7-bit encoding");  
Magic Number,Microsoft.LiveLabs.PE,BlobWriter,C:\repos\Reactive-Extensions_IL2JS\PE\BlobWriter.cs,WriteCompressedUInt32,The following statement contains a magic number: WriteByte ((byte)((value >> 24) | 0xc0));  
Magic Number,Microsoft.LiveLabs.PE,BlobWriter,C:\repos\Reactive-Extensions_IL2JS\PE\BlobWriter.cs,WriteCompressedUInt32,The following statement contains a magic number: WriteByte ((byte)((value >> 16) & 0xff));  
Magic Number,Microsoft.LiveLabs.PE,BlobWriter,C:\repos\Reactive-Extensions_IL2JS\PE\BlobWriter.cs,WriteCompressedUInt32,The following statement contains a magic number: WriteByte ((byte)((value >> 8) & 0xff));  
Magic Number,Microsoft.LiveLabs.PE,MetadataTables,C:\repos\Reactive-Extensions_IL2JS\PE\MetadataTables.cs,Read,The following statement contains a magic number: for (var i = 0; i < 64; i++) {  	var numRows = 0;  	if (valid [i])  		numRows = (int)reader.ReadUInt32 ();  	switch ((TableTag)i) {  	case TableTag.Module:  		ModuleTable = new ModuleTable (numRows);  		break;  	case TableTag.Assembly:  		AssemblyTable = new AssemblyTable (numRows);  		break;  	case TableTag.AssemblyOS:  		AssemblyOSTable = new AssemblyOSTable (numRows);  		break;  	case TableTag.AssemblyProcessor:  		AssemblyProcessorTable = new AssemblyProcessorTable (numRows);  		break;  	case TableTag.AssemblyRef:  		AssemblyRefTable = new AssemblyRefTable (numRows);  		break;  	case TableTag.AssemblyRefOS:  		AssemblyRefOSTable = new AssemblyRefOSTable (numRows);  		break;  	case TableTag.AssemblyRefProcessor:  		AssemblyRefProcessorTable = new AssemblyRefProcessorTable (numRows);  		break;  	case TableTag.ClassLayout:  		ClassLayoutTable = new ClassLayoutTable (numRows);  		break;  	case TableTag.Constant:  		ConstantTable = new ConstantTable (numRows);  		break;  	case TableTag.CustomAttribute:  		CustomAttributeTable = new CustomAttributeTable (numRows);  		break;  	case TableTag.DeclSecurity:  		DeclSecurityTable = new DeclSecurityTable (numRows);  		break;  	case TableTag.EventMap:  		EventMapTable = new EventMapTable (numRows);  		break;  	case TableTag.Event:  		EventTable = new EventTable (numRows);  		break;  	case TableTag.ExportedType:  		ExportedTypeTable = new ExportedTypeTable (numRows);  		break;  	case TableTag.Field:  		FieldTable = new FieldTable (numRows);  		break;  	case TableTag.FieldLayout:  		FieldLayoutTable = new FieldLayoutTable (numRows);  		break;  	case TableTag.FieldMarshal:  		FieldMarshalTable = new FieldMarshalTable (numRows);  		break;  	case TableTag.FieldRVA:  		FieldRVATable = new FieldRVATable (numRows);  		break;  	case TableTag.File:  		FileTable = new FileTable (numRows);  		break;  	case TableTag.GenericParam:  		GenericParamTable = new GenericParamTable (numRows);  		break;  	case TableTag.GenericParamConstraint:  		GenericParamConstraintTable = new GenericParamConstraintTable (numRows);  		break;  	case TableTag.ImplMap:  		ImplMapTable = new ImplMapTable (numRows);  		break;  	case TableTag.InterfaceImpl:  		InterfaceImplTable = new InterfaceImplTable (numRows);  		break;  	case TableTag.ManifestResource:  		ManifestResourceTable = new ManifestResourceTable (numRows);  		break;  	case TableTag.MemberRef:  		MemberRefTable = new MemberRefTable (numRows);  		break;  	case TableTag.MethodDef:  		MethodDefTable = new MethodDefTable (numRows);  		break;  	case TableTag.MethodImpl:  		MethodImplTable = new MethodImplTable (numRows);  		break;  	case TableTag.MethodSemantics:  		MethodSemanticsTable = new MethodSemanticsTable (numRows);  		break;  	case TableTag.MethodSpec:  		MethodSpecTable = new MethodSpecTable (numRows);  		break;  	case TableTag.ModuleRef:  		ModuleRefTable = new ModuleRefTable (numRows);  		break;  	case TableTag.NestedClass:  		NestedClassTable = new NestedClassTable (numRows);  		break;  	case TableTag.Param:  		ParamTable = new ParamTable (numRows);  		break;  	case TableTag.Property:  		PropertyTable = new PropertyTable (numRows);  		break;  	case TableTag.PropertyMap:  		PropertyMapTable = new PropertyMapTable (numRows);  		break;  	case TableTag.StandAloneSig:  		StandAloneSigTable = new StandAloneSigTable (numRows);  		break;  	case TableTag.TypeDef:  		TypeDefTable = new TypeDefTable (numRows);  		break;  	case TableTag.TypeRef:  		TypeRefTable = new TypeRefTable (numRows);  		break;  	case TableTag.TypeSpec:  		TypeSpecTable = new TypeSpecTable (numRows);  		break;  	default:  		// Ignore  		break;  	}  }  
Magic Number,Microsoft.LiveLabs.PE,MetadataTables,C:\repos\Reactive-Extensions_IL2JS\PE\MetadataTables.cs,Read,The following statement contains a magic number: for (var i = 0; i < 64; i++) {  	if (valid [i]) {  		switch ((TableTag)i) {  		case TableTag.Module:  			ModuleTable.Read (ctxt' reader);  			break;  		case TableTag.Assembly:  			AssemblyTable.Read (ctxt' reader);  			break;  		case TableTag.AssemblyOS:  			AssemblyOSTable.Read (ctxt' reader);  			break;  		case TableTag.AssemblyProcessor:  			AssemblyProcessorTable.Read (ctxt' reader);  			break;  		case TableTag.AssemblyRef:  			AssemblyRefTable.Read (ctxt' reader);  			break;  		case TableTag.AssemblyRefOS:  			AssemblyRefOSTable.Read (ctxt' reader);  			break;  		case TableTag.AssemblyRefProcessor:  			AssemblyRefProcessorTable.Read (ctxt' reader);  			break;  		case TableTag.ClassLayout:  			ClassLayoutTable.Read (ctxt' reader);  			break;  		case TableTag.Constant:  			ConstantTable.Read (ctxt' reader);  			break;  		case TableTag.CustomAttribute:  			CustomAttributeTable.Read (ctxt' reader);  			break;  		case TableTag.DeclSecurity:  			DeclSecurityTable.Read (ctxt' reader);  			break;  		case TableTag.EventMap:  			EventMapTable.Read (ctxt' reader);  			break;  		case TableTag.Event:  			EventTable.Read (ctxt' reader);  			break;  		case TableTag.ExportedType:  			ExportedTypeTable.Read (ctxt' reader);  			break;  		case TableTag.Field:  			FieldTable.Read (ctxt' reader);  			break;  		case TableTag.FieldLayout:  			FieldLayoutTable.Read (ctxt' reader);  			break;  		case TableTag.FieldMarshal:  			FieldMarshalTable.Read (ctxt' reader);  			break;  		case TableTag.FieldRVA:  			FieldRVATable.Read (ctxt' reader);  			break;  		case TableTag.File:  			FileTable.Read (ctxt' reader);  			break;  		case TableTag.GenericParam:  			GenericParamTable.Read (ctxt' reader);  			break;  		case TableTag.GenericParamConstraint:  			GenericParamConstraintTable.Read (ctxt' reader);  			break;  		case TableTag.ImplMap:  			ImplMapTable.Read (ctxt' reader);  			break;  		case TableTag.InterfaceImpl:  			InterfaceImplTable.Read (ctxt' reader);  			break;  		case TableTag.ManifestResource:  			ManifestResourceTable.Read (ctxt' reader);  			break;  		case TableTag.MemberRef:  			MemberRefTable.Read (ctxt' reader);  			break;  		case TableTag.MethodDef:  			MethodDefTable.Read (ctxt' reader);  			break;  		case TableTag.MethodImpl:  			MethodImplTable.Read (ctxt' reader);  			break;  		case TableTag.MethodSemantics:  			MethodSemanticsTable.Read (ctxt' reader);  			break;  		case TableTag.MethodSpec:  			MethodSpecTable.Read (ctxt' reader);  			break;  		case TableTag.ModuleRef:  			ModuleRefTable.Read (ctxt' reader);  			break;  		case TableTag.NestedClass:  			NestedClassTable.Read (ctxt' reader);  			break;  		case TableTag.Param:  			ParamTable.Read (ctxt' reader);  			break;  		case TableTag.Property:  			PropertyTable.Read (ctxt' reader);  			break;  		case TableTag.PropertyMap:  			PropertyMapTable.Read (ctxt' reader);  			break;  		case TableTag.StandAloneSig:  			StandAloneSigTable.Read (ctxt' reader);  			break;  		case TableTag.TypeDef:  			TypeDefTable.Read (ctxt' reader);  			break;  		case TableTag.TypeRef:  			TypeRefTable.Read (ctxt' reader);  			break;  		case TableTag.TypeSpec:  			TypeSpecTable.Read (ctxt' reader);  			break;  		default:  			throw new PEException ("unexpected table tag in MetadataTable body");  		}  	}  }  
Magic Number,Microsoft.LiveLabs.PE,MetadataTables,C:\repos\Reactive-Extensions_IL2JS\PE\MetadataTables.cs,DetermineIndexCodingSizes,The following statement contains a magic number: TypeDefOrRefIsBig = IsBig (2' TypeDefTable' TypeRefTable' TypeSpecTable);  
Magic Number,Microsoft.LiveLabs.PE,MetadataTables,C:\repos\Reactive-Extensions_IL2JS\PE\MetadataTables.cs,DetermineIndexCodingSizes,The following statement contains a magic number: HasConstantIsBig = IsBig (2' FieldTable' ParamTable' PropertyTable);  
Magic Number,Microsoft.LiveLabs.PE,MetadataTables,C:\repos\Reactive-Extensions_IL2JS\PE\MetadataTables.cs,DetermineIndexCodingSizes,The following statement contains a magic number: HasCustomAttributeIsBig = IsBig (5' MethodDefTable' FieldTable' TypeRefTable' TypeDefTable' ParamTable' InterfaceImplTable' MemberRefTable' ModuleTable' DeclSecurityTable' PropertyTable' EventTable' StandAloneSigTable' ModuleRefTable' TypeSpecTable' AssemblyTable' AssemblyRefTable' FileTable' ExportedTypeTable' ManifestResourceTable);  
Magic Number,Microsoft.LiveLabs.PE,MetadataTables,C:\repos\Reactive-Extensions_IL2JS\PE\MetadataTables.cs,DetermineIndexCodingSizes,The following statement contains a magic number: HasDeclSecurityIsBig = IsBig (2' TypeDefTable' MethodDefTable' AssemblyTable);  
Magic Number,Microsoft.LiveLabs.PE,MetadataTables,C:\repos\Reactive-Extensions_IL2JS\PE\MetadataTables.cs,DetermineIndexCodingSizes,The following statement contains a magic number: MemberRefParentIsBig = IsBig (3' TypeDefTable' TypeRefTable' ModuleRefTable' MethodDefTable' TypeSpecTable);  
Magic Number,Microsoft.LiveLabs.PE,MetadataTables,C:\repos\Reactive-Extensions_IL2JS\PE\MetadataTables.cs,DetermineIndexCodingSizes,The following statement contains a magic number: ImplementationIsBig = IsBig (2' FileTable' AssemblyRefTable' ExportedTypeTable);  
Magic Number,Microsoft.LiveLabs.PE,MetadataTables,C:\repos\Reactive-Extensions_IL2JS\PE\MetadataTables.cs,DetermineIndexCodingSizes,The following statement contains a magic number: CustomAttributeTypeIsBig = IsBig (3' MethodDefTable' MemberRefTable);  
Magic Number,Microsoft.LiveLabs.PE,MetadataTables,C:\repos\Reactive-Extensions_IL2JS\PE\MetadataTables.cs,DetermineIndexCodingSizes,The following statement contains a magic number: ResolutionScopeIsBig = IsBig (2' ModuleTable' ModuleRefTable' AssemblyRefTable' TypeRefTable);  
Magic Number,Microsoft.LiveLabs.PE,MetadataTables,C:\repos\Reactive-Extensions_IL2JS\PE\MetadataTables.cs,Write,The following statement contains a magic number: for (var i = 0; i < 64; i++) {  	if (valid [i]) {  		var numRows = default(int);  		switch ((TableTag)i) {  		case TableTag.Module:  			numRows = ModuleTable.NumRows;  			break;  		case TableTag.Assembly:  			numRows = AssemblyTable.NumRows;  			break;  		case TableTag.AssemblyOS:  			numRows = AssemblyOSTable.NumRows;  			break;  		case TableTag.AssemblyProcessor:  			numRows = AssemblyProcessorTable.NumRows;  			break;  		case TableTag.AssemblyRef:  			numRows = AssemblyRefTable.NumRows;  			break;  		case TableTag.AssemblyRefOS:  			numRows = AssemblyRefOSTable.NumRows;  			break;  		case TableTag.AssemblyRefProcessor:  			numRows = AssemblyRefProcessorTable.NumRows;  			break;  		case TableTag.ClassLayout:  			numRows = ClassLayoutTable.NumRows;  			break;  		case TableTag.Constant:  			numRows = ConstantTable.NumRows;  			break;  		case TableTag.CustomAttribute:  			numRows = CustomAttributeTable.NumRows;  			break;  		case TableTag.DeclSecurity:  			numRows = DeclSecurityTable.NumRows;  			break;  		case TableTag.EventMap:  			numRows = EventMapTable.NumRows;  			break;  		case TableTag.Event:  			numRows = EventTable.NumRows;  			break;  		case TableTag.ExportedType:  			numRows = ExportedTypeTable.NumRows;  			break;  		case TableTag.Field:  			numRows = FieldTable.NumRows;  			break;  		case TableTag.FieldLayout:  			numRows = FieldLayoutTable.NumRows;  			break;  		case TableTag.FieldMarshal:  			numRows = FieldMarshalTable.NumRows;  			break;  		case TableTag.FieldRVA:  			numRows = FieldRVATable.NumRows;  			break;  		case TableTag.File:  			numRows = FileTable.NumRows;  			break;  		case TableTag.GenericParam:  			numRows = GenericParamTable.NumRows;  			break;  		case TableTag.GenericParamConstraint:  			numRows = GenericParamConstraintTable.NumRows;  			break;  		case TableTag.ImplMap:  			numRows = ImplMapTable.NumRows;  			break;  		case TableTag.InterfaceImpl:  			numRows = InterfaceImplTable.NumRows;  			break;  		case TableTag.ManifestResource:  			numRows = ManifestResourceTable.NumRows;  			break;  		case TableTag.MemberRef:  			numRows = MemberRefTable.NumRows;  			break;  		case TableTag.MethodDef:  			numRows = MethodDefTable.NumRows;  			break;  		case TableTag.MethodImpl:  			numRows = MethodImplTable.NumRows;  			break;  		case TableTag.MethodSemantics:  			numRows = MethodSemanticsTable.NumRows;  			break;  		case TableTag.MethodSpec:  			numRows = MethodSpecTable.NumRows;  			break;  		case TableTag.ModuleRef:  			numRows = ModuleRefTable.NumRows;  			break;  		case TableTag.NestedClass:  			numRows = NestedClassTable.NumRows;  			break;  		case TableTag.Param:  			numRows = ParamTable.NumRows;  			break;  		case TableTag.Property:  			numRows = PropertyTable.NumRows;  			break;  		case TableTag.PropertyMap:  			numRows = PropertyMapTable.NumRows;  			break;  		case TableTag.StandAloneSig:  			numRows = StandAloneSigTable.NumRows;  			break;  		case TableTag.TypeDef:  			numRows = TypeDefTable.NumRows;  			break;  		case TableTag.TypeRef:  			numRows = TypeRefTable.NumRows;  			break;  		case TableTag.TypeSpec:  			numRows = TypeSpecTable.NumRows;  			break;  		default:  			throw new PEException ("invalid TableTag");  		}  		writer.WriteUInt32 ((uint)numRows);  	}  }  
Magic Number,Microsoft.LiveLabs.PE,MetadataTables,C:\repos\Reactive-Extensions_IL2JS\PE\MetadataTables.cs,Write,The following statement contains a magic number: for (var i = 0; i < 64; i++) {  	if (valid [i]) {  		switch ((TableTag)i) {  		case TableTag.Module:  			ModuleTable.Write (ctxt' writer);  			break;  		case TableTag.Assembly:  			AssemblyTable.Write (ctxt' writer);  			break;  		case TableTag.AssemblyOS:  			AssemblyOSTable.Write (ctxt' writer);  			break;  		case TableTag.AssemblyProcessor:  			AssemblyProcessorTable.Write (ctxt' writer);  			break;  		case TableTag.AssemblyRef:  			AssemblyRefTable.Write (ctxt' writer);  			break;  		case TableTag.AssemblyRefOS:  			AssemblyRefOSTable.Write (ctxt' writer);  			break;  		case TableTag.AssemblyRefProcessor:  			AssemblyRefProcessorTable.Write (ctxt' writer);  			break;  		case TableTag.ClassLayout:  			ClassLayoutTable.Write (ctxt' writer);  			break;  		case TableTag.Constant:  			ConstantTable.Write (ctxt' writer);  			break;  		case TableTag.CustomAttribute:  			CustomAttributeTable.Write (ctxt' writer);  			break;  		case TableTag.DeclSecurity:  			DeclSecurityTable.Write (ctxt' writer);  			break;  		case TableTag.EventMap:  			EventMapTable.Write (ctxt' writer);  			break;  		case TableTag.Event:  			EventTable.Write (ctxt' writer);  			break;  		case TableTag.ExportedType:  			ExportedTypeTable.Write (ctxt' writer);  			break;  		case TableTag.Field:  			FieldTable.Write (ctxt' writer);  			break;  		case TableTag.FieldLayout:  			FieldLayoutTable.Write (ctxt' writer);  			break;  		case TableTag.FieldMarshal:  			FieldMarshalTable.Write (ctxt' writer);  			break;  		case TableTag.FieldRVA:  			FieldRVATable.Write (ctxt' writer);  			break;  		case TableTag.File:  			FileTable.Write (ctxt' writer);  			break;  		case TableTag.GenericParam:  			GenericParamTable.Write (ctxt' writer);  			break;  		case TableTag.GenericParamConstraint:  			GenericParamConstraintTable.Write (ctxt' writer);  			break;  		case TableTag.ImplMap:  			ImplMapTable.Write (ctxt' writer);  			break;  		case TableTag.InterfaceImpl:  			InterfaceImplTable.Write (ctxt' writer);  			break;  		case TableTag.ManifestResource:  			ManifestResourceTable.Write (ctxt' writer);  			break;  		case TableTag.MemberRef:  			MemberRefTable.Write (ctxt' writer);  			break;  		case TableTag.MethodDef:  			MethodDefTable.Write (ctxt' writer);  			break;  		case TableTag.MethodImpl:  			MethodImplTable.Write (ctxt' writer);  			break;  		case TableTag.MethodSemantics:  			MethodSemanticsTable.Write (ctxt' writer);  			break;  		case TableTag.MethodSpec:  			MethodSpecTable.Write (ctxt' writer);  			break;  		case TableTag.ModuleRef:  			ModuleRefTable.Write (ctxt' writer);  			break;  		case TableTag.NestedClass:  			NestedClassTable.Write (ctxt' writer);  			break;  		case TableTag.Param:  			ParamTable.Write (ctxt' writer);  			break;  		case TableTag.Property:  			PropertyTable.Write (ctxt' writer);  			break;  		case TableTag.PropertyMap:  			PropertyMapTable.Write (ctxt' writer);  			break;  		case TableTag.StandAloneSig:  			StandAloneSigTable.Write (ctxt' writer);  			break;  		case TableTag.TypeDef:  			TypeDefTable.Write (ctxt' writer);  			break;  		case TableTag.TypeRef:  			TypeRefTable.Write (ctxt' writer);  			break;  		case TableTag.TypeSpec:  			TypeSpecTable.Write (ctxt' writer);  			break;  		default:  			throw new PEException ("invalid TableTag");  		}  	}  }  
Magic Number,Microsoft.LiveLabs.PE,Instruction,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Skip,The following statement contains a magic number: if (opCode == OpCode.Prefix1)  	opCode = (OpCode)((ushort)opCode << 8 | reader.ReadByte ());  
Magic Number,Microsoft.LiveLabs.PE,Instruction,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Skip,The following statement contains a magic number: opCode = (OpCode)((ushort)opCode << 8 | reader.ReadByte ());  
Magic Number,Microsoft.LiveLabs.PE,Instruction,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Read,The following statement contains a magic number: if (OpCode == OpCode.Prefix1)  	OpCode = (OpCode)((ushort)OpCode << 8 | reader.ReadByte ());  
Magic Number,Microsoft.LiveLabs.PE,Instruction,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Read,The following statement contains a magic number: OpCode = (OpCode)((ushort)OpCode << 8 | reader.ReadByte ());  
Magic Number,Microsoft.LiveLabs.PE,Instruction,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Size,The following statement contains a magic number: switch (OpCode) {  case OpCode.Nop:  case OpCode.Break:  case OpCode.Ldarg_0:  case OpCode.Ldarg_1:  case OpCode.Ldarg_2:  case OpCode.Ldarg_3:  case OpCode.Ldloc_0:  case OpCode.Ldloc_1:  case OpCode.Ldloc_2:  case OpCode.Ldloc_3:  case OpCode.Stloc_0:  case OpCode.Stloc_1:  case OpCode.Stloc_2:  case OpCode.Stloc_3:  case OpCode.Ldnull:  case OpCode.Ldc_i4_m1:  case OpCode.Ldc_i4_0:  case OpCode.Ldc_i4_1:  case OpCode.Ldc_i4_2:  case OpCode.Ldc_i4_3:  case OpCode.Ldc_i4_4:  case OpCode.Ldc_i4_5:  case OpCode.Ldc_i4_6:  case OpCode.Ldc_i4_7:  case OpCode.Ldc_i4_8:  case OpCode.Dup:  case OpCode.Pop:  case OpCode.Ret:  case OpCode.Ldind_i1:  case OpCode.Ldind_u1:  case OpCode.Ldind_i2:  case OpCode.Ldind_u2:  case OpCode.Ldind_i4:  case OpCode.Ldind_u4:  case OpCode.Ldind_i8:  case OpCode.Ldind_i:  case OpCode.Ldind_r4:  case OpCode.Ldind_r8:  case OpCode.Ldind_ref:  case OpCode.Stind_ref:  case OpCode.Stind_i1:  case OpCode.Stind_i2:  case OpCode.Stind_i4:  case OpCode.Stind_i8:  case OpCode.Stind_r4:  case OpCode.Stind_r8:  case OpCode.Add:  case OpCode.Sub:  case OpCode.Mul:  case OpCode.Div:  case OpCode.Div_un:  case OpCode.Rem:  case OpCode.Rem_un:  case OpCode.And:  case OpCode.Or:  case OpCode.Xor:  case OpCode.Shl:  case OpCode.Shr:  case OpCode.Shr_un:  case OpCode.Neg:  case OpCode.Not:  case OpCode.Conv_i1:  case OpCode.Conv_i2:  case OpCode.Conv_i4:  case OpCode.Conv_i8:  case OpCode.Conv_r4:  case OpCode.Conv_r8:  case OpCode.Conv_u4:  case OpCode.Conv_u8:  case OpCode.Conv_r_un:  case OpCode.Throw:  case OpCode.Conv_ovf_i1_un:  case OpCode.Conv_ovf_i2_un:  case OpCode.Conv_ovf_i4_un:  case OpCode.Conv_ovf_i8_un:  case OpCode.Conv_ovf_u1_un:  case OpCode.Conv_ovf_u2_un:  case OpCode.Conv_ovf_u4_un:  case OpCode.Conv_ovf_u8_un:  case OpCode.Conv_ovf_i_un:  case OpCode.Conv_ovf_u_un:  case OpCode.Ldlen:  case OpCode.Ldelem_i1:  case OpCode.Ldelem_u1:  case OpCode.Ldelem_i2:  case OpCode.Ldelem_u2:  case OpCode.Ldelem_i4:  case OpCode.Ldelem_u4:  case OpCode.Ldelem_i8:  case OpCode.Ldelem_i:  case OpCode.Ldelem_r4:  case OpCode.Ldelem_r8:  case OpCode.Ldelem_ref:  case OpCode.Stelem_i:  case OpCode.Stelem_i1:  case OpCode.Stelem_i2:  case OpCode.Stelem_i4:  case OpCode.Stelem_i8:  case OpCode.Stelem_r4:  case OpCode.Stelem_r8:  case OpCode.Stelem_ref:  case OpCode.Conv_ovf_i1:  case OpCode.Conv_ovf_u1:  case OpCode.Conv_ovf_i2:  case OpCode.Conv_ovf_u2:  case OpCode.Conv_ovf_i4:  case OpCode.Conv_ovf_u4:  case OpCode.Conv_ovf_i8:  case OpCode.Conv_ovf_u8:  case OpCode.Ckfinite:  case OpCode.Conv_u2:  case OpCode.Conv_u1:  case OpCode.Conv_i:  case OpCode.Conv_ovf_i:  case OpCode.Conv_ovf_u:  case OpCode.Add_ovf:  case OpCode.Add_ovf_un:  case OpCode.Mul_ovf:  case OpCode.Mul_ovf_un:  case OpCode.Sub_ovf:  case OpCode.Sub_ovf_un:  case OpCode.Endfinally:  case OpCode.Stind_i:  case OpCode.Conv_u:  case OpCode.Prefix7:  case OpCode.Prefix6:  case OpCode.Prefix5:  case OpCode.Prefix4:  case OpCode.Prefix3:  case OpCode.Prefix2:  case OpCode.Prefix1:  case OpCode.Prefixref:  case OpCode.Arglist:  case OpCode.Ceq:  case OpCode.Cgt:  case OpCode.Cgt_un:  case OpCode.Clt:  case OpCode.Clt_un:  case OpCode.Localloc:  case OpCode.Endfilter:  case OpCode.Volatile:  case OpCode.Tailcall:  case OpCode.Cpblk:  case OpCode.Initblk:  case OpCode.Rethrow:  case OpCode.Refanytype:  case OpCode.Readonly:  	break;  case OpCode.Br:  case OpCode.Brfalse:  case OpCode.Brtrue:  case OpCode.Beq:  case OpCode.Bge:  case OpCode.Bgt:  case OpCode.Ble:  case OpCode.Blt:  case OpCode.Bne_un:  case OpCode.Bge_un:  case OpCode.Bgt_un:  case OpCode.Ble_un:  case OpCode.Blt_un:  case OpCode.Leave:  	n += 4;  	break;  case OpCode.Br_s:  case OpCode.Brfalse_s:  case OpCode.Brtrue_s:  case OpCode.Beq_s:  case OpCode.Bge_s:  case OpCode.Bgt_s:  case OpCode.Ble_s:  case OpCode.Blt_s:  case OpCode.Bne_un_s:  case OpCode.Bge_un_s:  case OpCode.Bgt_un_s:  case OpCode.Ble_un_s:  case OpCode.Blt_un_s:  case OpCode.Leave_s:  	n++;  	break;  case OpCode.Ldc_i4_s:  	n++;  	break;  case OpCode.Ldarg_s:  case OpCode.Ldarga_s:  case OpCode.Starg_s:  case OpCode.Ldloc_s:  case OpCode.Ldloca_s:  case OpCode.Stloc_s:  case OpCode.Unaligned:  	n++;  	break;  case OpCode.Ldc_i4:  	n += 4;  	break;  case OpCode.Ldarg:  case OpCode.Ldarga:  case OpCode.Starg:  case OpCode.Ldloc:  case OpCode.Ldloca:  case OpCode.Stloc:  	n += 4;  	break;  case OpCode.Ldc_i8:  	n += 8;  	break;  case OpCode.Ldc_r4:  	n += 4;  	break;  case OpCode.Ldc_r8:  	n += 8;  	break;  case OpCode.Ldstr:  	n += 4;  	break;  case OpCode.Switch: {  	var targets = (Seq<int>)Value;  	n += (1 + targets.Count) * 4;  	break;  }  case OpCode.Calli:  case OpCode.Jmp:  case OpCode.Call:  case OpCode.Callvirt:  case OpCode.Newobj:  case OpCode.Ldftn:  case OpCode.Ldvirtftn:  case OpCode.Ldfld:  case OpCode.Ldflda:  case OpCode.Stfld:  case OpCode.Ldsfld:  case OpCode.Ldsflda:  case OpCode.Stsfld:  case OpCode.Ldtoken:  case OpCode.Cpobj:  case OpCode.Ldobj:  case OpCode.Castclass:  case OpCode.Isinst:  case OpCode.Unbox:  case OpCode.Stobj:  case OpCode.Box:  case OpCode.Newarr:  case OpCode.Ldelema:  case OpCode.Ldelem:  case OpCode.Stelem:  case OpCode.Unbox_any:  case OpCode.Refanyval:  case OpCode.Mkrefany:  case OpCode.Initobj:  case OpCode.Constrained:  case OpCode.Sizeof:  	n += 4;  	break;  default:  	throw new PEException ("unrecognised opcode");  }  
Magic Number,Microsoft.LiveLabs.PE,Instruction,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Size,The following statement contains a magic number: switch (OpCode) {  case OpCode.Nop:  case OpCode.Break:  case OpCode.Ldarg_0:  case OpCode.Ldarg_1:  case OpCode.Ldarg_2:  case OpCode.Ldarg_3:  case OpCode.Ldloc_0:  case OpCode.Ldloc_1:  case OpCode.Ldloc_2:  case OpCode.Ldloc_3:  case OpCode.Stloc_0:  case OpCode.Stloc_1:  case OpCode.Stloc_2:  case OpCode.Stloc_3:  case OpCode.Ldnull:  case OpCode.Ldc_i4_m1:  case OpCode.Ldc_i4_0:  case OpCode.Ldc_i4_1:  case OpCode.Ldc_i4_2:  case OpCode.Ldc_i4_3:  case OpCode.Ldc_i4_4:  case OpCode.Ldc_i4_5:  case OpCode.Ldc_i4_6:  case OpCode.Ldc_i4_7:  case OpCode.Ldc_i4_8:  case OpCode.Dup:  case OpCode.Pop:  case OpCode.Ret:  case OpCode.Ldind_i1:  case OpCode.Ldind_u1:  case OpCode.Ldind_i2:  case OpCode.Ldind_u2:  case OpCode.Ldind_i4:  case OpCode.Ldind_u4:  case OpCode.Ldind_i8:  case OpCode.Ldind_i:  case OpCode.Ldind_r4:  case OpCode.Ldind_r8:  case OpCode.Ldind_ref:  case OpCode.Stind_ref:  case OpCode.Stind_i1:  case OpCode.Stind_i2:  case OpCode.Stind_i4:  case OpCode.Stind_i8:  case OpCode.Stind_r4:  case OpCode.Stind_r8:  case OpCode.Add:  case OpCode.Sub:  case OpCode.Mul:  case OpCode.Div:  case OpCode.Div_un:  case OpCode.Rem:  case OpCode.Rem_un:  case OpCode.And:  case OpCode.Or:  case OpCode.Xor:  case OpCode.Shl:  case OpCode.Shr:  case OpCode.Shr_un:  case OpCode.Neg:  case OpCode.Not:  case OpCode.Conv_i1:  case OpCode.Conv_i2:  case OpCode.Conv_i4:  case OpCode.Conv_i8:  case OpCode.Conv_r4:  case OpCode.Conv_r8:  case OpCode.Conv_u4:  case OpCode.Conv_u8:  case OpCode.Conv_r_un:  case OpCode.Throw:  case OpCode.Conv_ovf_i1_un:  case OpCode.Conv_ovf_i2_un:  case OpCode.Conv_ovf_i4_un:  case OpCode.Conv_ovf_i8_un:  case OpCode.Conv_ovf_u1_un:  case OpCode.Conv_ovf_u2_un:  case OpCode.Conv_ovf_u4_un:  case OpCode.Conv_ovf_u8_un:  case OpCode.Conv_ovf_i_un:  case OpCode.Conv_ovf_u_un:  case OpCode.Ldlen:  case OpCode.Ldelem_i1:  case OpCode.Ldelem_u1:  case OpCode.Ldelem_i2:  case OpCode.Ldelem_u2:  case OpCode.Ldelem_i4:  case OpCode.Ldelem_u4:  case OpCode.Ldelem_i8:  case OpCode.Ldelem_i:  case OpCode.Ldelem_r4:  case OpCode.Ldelem_r8:  case OpCode.Ldelem_ref:  case OpCode.Stelem_i:  case OpCode.Stelem_i1:  case OpCode.Stelem_i2:  case OpCode.Stelem_i4:  case OpCode.Stelem_i8:  case OpCode.Stelem_r4:  case OpCode.Stelem_r8:  case OpCode.Stelem_ref:  case OpCode.Conv_ovf_i1:  case OpCode.Conv_ovf_u1:  case OpCode.Conv_ovf_i2:  case OpCode.Conv_ovf_u2:  case OpCode.Conv_ovf_i4:  case OpCode.Conv_ovf_u4:  case OpCode.Conv_ovf_i8:  case OpCode.Conv_ovf_u8:  case OpCode.Ckfinite:  case OpCode.Conv_u2:  case OpCode.Conv_u1:  case OpCode.Conv_i:  case OpCode.Conv_ovf_i:  case OpCode.Conv_ovf_u:  case OpCode.Add_ovf:  case OpCode.Add_ovf_un:  case OpCode.Mul_ovf:  case OpCode.Mul_ovf_un:  case OpCode.Sub_ovf:  case OpCode.Sub_ovf_un:  case OpCode.Endfinally:  case OpCode.Stind_i:  case OpCode.Conv_u:  case OpCode.Prefix7:  case OpCode.Prefix6:  case OpCode.Prefix5:  case OpCode.Prefix4:  case OpCode.Prefix3:  case OpCode.Prefix2:  case OpCode.Prefix1:  case OpCode.Prefixref:  case OpCode.Arglist:  case OpCode.Ceq:  case OpCode.Cgt:  case OpCode.Cgt_un:  case OpCode.Clt:  case OpCode.Clt_un:  case OpCode.Localloc:  case OpCode.Endfilter:  case OpCode.Volatile:  case OpCode.Tailcall:  case OpCode.Cpblk:  case OpCode.Initblk:  case OpCode.Rethrow:  case OpCode.Refanytype:  case OpCode.Readonly:  	break;  case OpCode.Br:  case OpCode.Brfalse:  case OpCode.Brtrue:  case OpCode.Beq:  case OpCode.Bge:  case OpCode.Bgt:  case OpCode.Ble:  case OpCode.Blt:  case OpCode.Bne_un:  case OpCode.Bge_un:  case OpCode.Bgt_un:  case OpCode.Ble_un:  case OpCode.Blt_un:  case OpCode.Leave:  	n += 4;  	break;  case OpCode.Br_s:  case OpCode.Brfalse_s:  case OpCode.Brtrue_s:  case OpCode.Beq_s:  case OpCode.Bge_s:  case OpCode.Bgt_s:  case OpCode.Ble_s:  case OpCode.Blt_s:  case OpCode.Bne_un_s:  case OpCode.Bge_un_s:  case OpCode.Bgt_un_s:  case OpCode.Ble_un_s:  case OpCode.Blt_un_s:  case OpCode.Leave_s:  	n++;  	break;  case OpCode.Ldc_i4_s:  	n++;  	break;  case OpCode.Ldarg_s:  case OpCode.Ldarga_s:  case OpCode.Starg_s:  case OpCode.Ldloc_s:  case OpCode.Ldloca_s:  case OpCode.Stloc_s:  case OpCode.Unaligned:  	n++;  	break;  case OpCode.Ldc_i4:  	n += 4;  	break;  case OpCode.Ldarg:  case OpCode.Ldarga:  case OpCode.Starg:  case OpCode.Ldloc:  case OpCode.Ldloca:  case OpCode.Stloc:  	n += 4;  	break;  case OpCode.Ldc_i8:  	n += 8;  	break;  case OpCode.Ldc_r4:  	n += 4;  	break;  case OpCode.Ldc_r8:  	n += 8;  	break;  case OpCode.Ldstr:  	n += 4;  	break;  case OpCode.Switch: {  	var targets = (Seq<int>)Value;  	n += (1 + targets.Count) * 4;  	break;  }  case OpCode.Calli:  case OpCode.Jmp:  case OpCode.Call:  case OpCode.Callvirt:  case OpCode.Newobj:  case OpCode.Ldftn:  case OpCode.Ldvirtftn:  case OpCode.Ldfld:  case OpCode.Ldflda:  case OpCode.Stfld:  case OpCode.Ldsfld:  case OpCode.Ldsflda:  case OpCode.Stsfld:  case OpCode.Ldtoken:  case OpCode.Cpobj:  case OpCode.Ldobj:  case OpCode.Castclass:  case OpCode.Isinst:  case OpCode.Unbox:  case OpCode.Stobj:  case OpCode.Box:  case OpCode.Newarr:  case OpCode.Ldelema:  case OpCode.Ldelem:  case OpCode.Stelem:  case OpCode.Unbox_any:  case OpCode.Refanyval:  case OpCode.Mkrefany:  case OpCode.Initobj:  case OpCode.Constrained:  case OpCode.Sizeof:  	n += 4;  	break;  default:  	throw new PEException ("unrecognised opcode");  }  
Magic Number,Microsoft.LiveLabs.PE,Instruction,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Size,The following statement contains a magic number: switch (OpCode) {  case OpCode.Nop:  case OpCode.Break:  case OpCode.Ldarg_0:  case OpCode.Ldarg_1:  case OpCode.Ldarg_2:  case OpCode.Ldarg_3:  case OpCode.Ldloc_0:  case OpCode.Ldloc_1:  case OpCode.Ldloc_2:  case OpCode.Ldloc_3:  case OpCode.Stloc_0:  case OpCode.Stloc_1:  case OpCode.Stloc_2:  case OpCode.Stloc_3:  case OpCode.Ldnull:  case OpCode.Ldc_i4_m1:  case OpCode.Ldc_i4_0:  case OpCode.Ldc_i4_1:  case OpCode.Ldc_i4_2:  case OpCode.Ldc_i4_3:  case OpCode.Ldc_i4_4:  case OpCode.Ldc_i4_5:  case OpCode.Ldc_i4_6:  case OpCode.Ldc_i4_7:  case OpCode.Ldc_i4_8:  case OpCode.Dup:  case OpCode.Pop:  case OpCode.Ret:  case OpCode.Ldind_i1:  case OpCode.Ldind_u1:  case OpCode.Ldind_i2:  case OpCode.Ldind_u2:  case OpCode.Ldind_i4:  case OpCode.Ldind_u4:  case OpCode.Ldind_i8:  case OpCode.Ldind_i:  case OpCode.Ldind_r4:  case OpCode.Ldind_r8:  case OpCode.Ldind_ref:  case OpCode.Stind_ref:  case OpCode.Stind_i1:  case OpCode.Stind_i2:  case OpCode.Stind_i4:  case OpCode.Stind_i8:  case OpCode.Stind_r4:  case OpCode.Stind_r8:  case OpCode.Add:  case OpCode.Sub:  case OpCode.Mul:  case OpCode.Div:  case OpCode.Div_un:  case OpCode.Rem:  case OpCode.Rem_un:  case OpCode.And:  case OpCode.Or:  case OpCode.Xor:  case OpCode.Shl:  case OpCode.Shr:  case OpCode.Shr_un:  case OpCode.Neg:  case OpCode.Not:  case OpCode.Conv_i1:  case OpCode.Conv_i2:  case OpCode.Conv_i4:  case OpCode.Conv_i8:  case OpCode.Conv_r4:  case OpCode.Conv_r8:  case OpCode.Conv_u4:  case OpCode.Conv_u8:  case OpCode.Conv_r_un:  case OpCode.Throw:  case OpCode.Conv_ovf_i1_un:  case OpCode.Conv_ovf_i2_un:  case OpCode.Conv_ovf_i4_un:  case OpCode.Conv_ovf_i8_un:  case OpCode.Conv_ovf_u1_un:  case OpCode.Conv_ovf_u2_un:  case OpCode.Conv_ovf_u4_un:  case OpCode.Conv_ovf_u8_un:  case OpCode.Conv_ovf_i_un:  case OpCode.Conv_ovf_u_un:  case OpCode.Ldlen:  case OpCode.Ldelem_i1:  case OpCode.Ldelem_u1:  case OpCode.Ldelem_i2:  case OpCode.Ldelem_u2:  case OpCode.Ldelem_i4:  case OpCode.Ldelem_u4:  case OpCode.Ldelem_i8:  case OpCode.Ldelem_i:  case OpCode.Ldelem_r4:  case OpCode.Ldelem_r8:  case OpCode.Ldelem_ref:  case OpCode.Stelem_i:  case OpCode.Stelem_i1:  case OpCode.Stelem_i2:  case OpCode.Stelem_i4:  case OpCode.Stelem_i8:  case OpCode.Stelem_r4:  case OpCode.Stelem_r8:  case OpCode.Stelem_ref:  case OpCode.Conv_ovf_i1:  case OpCode.Conv_ovf_u1:  case OpCode.Conv_ovf_i2:  case OpCode.Conv_ovf_u2:  case OpCode.Conv_ovf_i4:  case OpCode.Conv_ovf_u4:  case OpCode.Conv_ovf_i8:  case OpCode.Conv_ovf_u8:  case OpCode.Ckfinite:  case OpCode.Conv_u2:  case OpCode.Conv_u1:  case OpCode.Conv_i:  case OpCode.Conv_ovf_i:  case OpCode.Conv_ovf_u:  case OpCode.Add_ovf:  case OpCode.Add_ovf_un:  case OpCode.Mul_ovf:  case OpCode.Mul_ovf_un:  case OpCode.Sub_ovf:  case OpCode.Sub_ovf_un:  case OpCode.Endfinally:  case OpCode.Stind_i:  case OpCode.Conv_u:  case OpCode.Prefix7:  case OpCode.Prefix6:  case OpCode.Prefix5:  case OpCode.Prefix4:  case OpCode.Prefix3:  case OpCode.Prefix2:  case OpCode.Prefix1:  case OpCode.Prefixref:  case OpCode.Arglist:  case OpCode.Ceq:  case OpCode.Cgt:  case OpCode.Cgt_un:  case OpCode.Clt:  case OpCode.Clt_un:  case OpCode.Localloc:  case OpCode.Endfilter:  case OpCode.Volatile:  case OpCode.Tailcall:  case OpCode.Cpblk:  case OpCode.Initblk:  case OpCode.Rethrow:  case OpCode.Refanytype:  case OpCode.Readonly:  	break;  case OpCode.Br:  case OpCode.Brfalse:  case OpCode.Brtrue:  case OpCode.Beq:  case OpCode.Bge:  case OpCode.Bgt:  case OpCode.Ble:  case OpCode.Blt:  case OpCode.Bne_un:  case OpCode.Bge_un:  case OpCode.Bgt_un:  case OpCode.Ble_un:  case OpCode.Blt_un:  case OpCode.Leave:  	n += 4;  	break;  case OpCode.Br_s:  case OpCode.Brfalse_s:  case OpCode.Brtrue_s:  case OpCode.Beq_s:  case OpCode.Bge_s:  case OpCode.Bgt_s:  case OpCode.Ble_s:  case OpCode.Blt_s:  case OpCode.Bne_un_s:  case OpCode.Bge_un_s:  case OpCode.Bgt_un_s:  case OpCode.Ble_un_s:  case OpCode.Blt_un_s:  case OpCode.Leave_s:  	n++;  	break;  case OpCode.Ldc_i4_s:  	n++;  	break;  case OpCode.Ldarg_s:  case OpCode.Ldarga_s:  case OpCode.Starg_s:  case OpCode.Ldloc_s:  case OpCode.Ldloca_s:  case OpCode.Stloc_s:  case OpCode.Unaligned:  	n++;  	break;  case OpCode.Ldc_i4:  	n += 4;  	break;  case OpCode.Ldarg:  case OpCode.Ldarga:  case OpCode.Starg:  case OpCode.Ldloc:  case OpCode.Ldloca:  case OpCode.Stloc:  	n += 4;  	break;  case OpCode.Ldc_i8:  	n += 8;  	break;  case OpCode.Ldc_r4:  	n += 4;  	break;  case OpCode.Ldc_r8:  	n += 8;  	break;  case OpCode.Ldstr:  	n += 4;  	break;  case OpCode.Switch: {  	var targets = (Seq<int>)Value;  	n += (1 + targets.Count) * 4;  	break;  }  case OpCode.Calli:  case OpCode.Jmp:  case OpCode.Call:  case OpCode.Callvirt:  case OpCode.Newobj:  case OpCode.Ldftn:  case OpCode.Ldvirtftn:  case OpCode.Ldfld:  case OpCode.Ldflda:  case OpCode.Stfld:  case OpCode.Ldsfld:  case OpCode.Ldsflda:  case OpCode.Stsfld:  case OpCode.Ldtoken:  case OpCode.Cpobj:  case OpCode.Ldobj:  case OpCode.Castclass:  case OpCode.Isinst:  case OpCode.Unbox:  case OpCode.Stobj:  case OpCode.Box:  case OpCode.Newarr:  case OpCode.Ldelema:  case OpCode.Ldelem:  case OpCode.Stelem:  case OpCode.Unbox_any:  case OpCode.Refanyval:  case OpCode.Mkrefany:  case OpCode.Initobj:  case OpCode.Constrained:  case OpCode.Sizeof:  	n += 4;  	break;  default:  	throw new PEException ("unrecognised opcode");  }  
Magic Number,Microsoft.LiveLabs.PE,Instruction,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Size,The following statement contains a magic number: switch (OpCode) {  case OpCode.Nop:  case OpCode.Break:  case OpCode.Ldarg_0:  case OpCode.Ldarg_1:  case OpCode.Ldarg_2:  case OpCode.Ldarg_3:  case OpCode.Ldloc_0:  case OpCode.Ldloc_1:  case OpCode.Ldloc_2:  case OpCode.Ldloc_3:  case OpCode.Stloc_0:  case OpCode.Stloc_1:  case OpCode.Stloc_2:  case OpCode.Stloc_3:  case OpCode.Ldnull:  case OpCode.Ldc_i4_m1:  case OpCode.Ldc_i4_0:  case OpCode.Ldc_i4_1:  case OpCode.Ldc_i4_2:  case OpCode.Ldc_i4_3:  case OpCode.Ldc_i4_4:  case OpCode.Ldc_i4_5:  case OpCode.Ldc_i4_6:  case OpCode.Ldc_i4_7:  case OpCode.Ldc_i4_8:  case OpCode.Dup:  case OpCode.Pop:  case OpCode.Ret:  case OpCode.Ldind_i1:  case OpCode.Ldind_u1:  case OpCode.Ldind_i2:  case OpCode.Ldind_u2:  case OpCode.Ldind_i4:  case OpCode.Ldind_u4:  case OpCode.Ldind_i8:  case OpCode.Ldind_i:  case OpCode.Ldind_r4:  case OpCode.Ldind_r8:  case OpCode.Ldind_ref:  case OpCode.Stind_ref:  case OpCode.Stind_i1:  case OpCode.Stind_i2:  case OpCode.Stind_i4:  case OpCode.Stind_i8:  case OpCode.Stind_r4:  case OpCode.Stind_r8:  case OpCode.Add:  case OpCode.Sub:  case OpCode.Mul:  case OpCode.Div:  case OpCode.Div_un:  case OpCode.Rem:  case OpCode.Rem_un:  case OpCode.And:  case OpCode.Or:  case OpCode.Xor:  case OpCode.Shl:  case OpCode.Shr:  case OpCode.Shr_un:  case OpCode.Neg:  case OpCode.Not:  case OpCode.Conv_i1:  case OpCode.Conv_i2:  case OpCode.Conv_i4:  case OpCode.Conv_i8:  case OpCode.Conv_r4:  case OpCode.Conv_r8:  case OpCode.Conv_u4:  case OpCode.Conv_u8:  case OpCode.Conv_r_un:  case OpCode.Throw:  case OpCode.Conv_ovf_i1_un:  case OpCode.Conv_ovf_i2_un:  case OpCode.Conv_ovf_i4_un:  case OpCode.Conv_ovf_i8_un:  case OpCode.Conv_ovf_u1_un:  case OpCode.Conv_ovf_u2_un:  case OpCode.Conv_ovf_u4_un:  case OpCode.Conv_ovf_u8_un:  case OpCode.Conv_ovf_i_un:  case OpCode.Conv_ovf_u_un:  case OpCode.Ldlen:  case OpCode.Ldelem_i1:  case OpCode.Ldelem_u1:  case OpCode.Ldelem_i2:  case OpCode.Ldelem_u2:  case OpCode.Ldelem_i4:  case OpCode.Ldelem_u4:  case OpCode.Ldelem_i8:  case OpCode.Ldelem_i:  case OpCode.Ldelem_r4:  case OpCode.Ldelem_r8:  case OpCode.Ldelem_ref:  case OpCode.Stelem_i:  case OpCode.Stelem_i1:  case OpCode.Stelem_i2:  case OpCode.Stelem_i4:  case OpCode.Stelem_i8:  case OpCode.Stelem_r4:  case OpCode.Stelem_r8:  case OpCode.Stelem_ref:  case OpCode.Conv_ovf_i1:  case OpCode.Conv_ovf_u1:  case OpCode.Conv_ovf_i2:  case OpCode.Conv_ovf_u2:  case OpCode.Conv_ovf_i4:  case OpCode.Conv_ovf_u4:  case OpCode.Conv_ovf_i8:  case OpCode.Conv_ovf_u8:  case OpCode.Ckfinite:  case OpCode.Conv_u2:  case OpCode.Conv_u1:  case OpCode.Conv_i:  case OpCode.Conv_ovf_i:  case OpCode.Conv_ovf_u:  case OpCode.Add_ovf:  case OpCode.Add_ovf_un:  case OpCode.Mul_ovf:  case OpCode.Mul_ovf_un:  case OpCode.Sub_ovf:  case OpCode.Sub_ovf_un:  case OpCode.Endfinally:  case OpCode.Stind_i:  case OpCode.Conv_u:  case OpCode.Prefix7:  case OpCode.Prefix6:  case OpCode.Prefix5:  case OpCode.Prefix4:  case OpCode.Prefix3:  case OpCode.Prefix2:  case OpCode.Prefix1:  case OpCode.Prefixref:  case OpCode.Arglist:  case OpCode.Ceq:  case OpCode.Cgt:  case OpCode.Cgt_un:  case OpCode.Clt:  case OpCode.Clt_un:  case OpCode.Localloc:  case OpCode.Endfilter:  case OpCode.Volatile:  case OpCode.Tailcall:  case OpCode.Cpblk:  case OpCode.Initblk:  case OpCode.Rethrow:  case OpCode.Refanytype:  case OpCode.Readonly:  	break;  case OpCode.Br:  case OpCode.Brfalse:  case OpCode.Brtrue:  case OpCode.Beq:  case OpCode.Bge:  case OpCode.Bgt:  case OpCode.Ble:  case OpCode.Blt:  case OpCode.Bne_un:  case OpCode.Bge_un:  case OpCode.Bgt_un:  case OpCode.Ble_un:  case OpCode.Blt_un:  case OpCode.Leave:  	n += 4;  	break;  case OpCode.Br_s:  case OpCode.Brfalse_s:  case OpCode.Brtrue_s:  case OpCode.Beq_s:  case OpCode.Bge_s:  case OpCode.Bgt_s:  case OpCode.Ble_s:  case OpCode.Blt_s:  case OpCode.Bne_un_s:  case OpCode.Bge_un_s:  case OpCode.Bgt_un_s:  case OpCode.Ble_un_s:  case OpCode.Blt_un_s:  case OpCode.Leave_s:  	n++;  	break;  case OpCode.Ldc_i4_s:  	n++;  	break;  case OpCode.Ldarg_s:  case OpCode.Ldarga_s:  case OpCode.Starg_s:  case OpCode.Ldloc_s:  case OpCode.Ldloca_s:  case OpCode.Stloc_s:  case OpCode.Unaligned:  	n++;  	break;  case OpCode.Ldc_i4:  	n += 4;  	break;  case OpCode.Ldarg:  case OpCode.Ldarga:  case OpCode.Starg:  case OpCode.Ldloc:  case OpCode.Ldloca:  case OpCode.Stloc:  	n += 4;  	break;  case OpCode.Ldc_i8:  	n += 8;  	break;  case OpCode.Ldc_r4:  	n += 4;  	break;  case OpCode.Ldc_r8:  	n += 8;  	break;  case OpCode.Ldstr:  	n += 4;  	break;  case OpCode.Switch: {  	var targets = (Seq<int>)Value;  	n += (1 + targets.Count) * 4;  	break;  }  case OpCode.Calli:  case OpCode.Jmp:  case OpCode.Call:  case OpCode.Callvirt:  case OpCode.Newobj:  case OpCode.Ldftn:  case OpCode.Ldvirtftn:  case OpCode.Ldfld:  case OpCode.Ldflda:  case OpCode.Stfld:  case OpCode.Ldsfld:  case OpCode.Ldsflda:  case OpCode.Stsfld:  case OpCode.Ldtoken:  case OpCode.Cpobj:  case OpCode.Ldobj:  case OpCode.Castclass:  case OpCode.Isinst:  case OpCode.Unbox:  case OpCode.Stobj:  case OpCode.Box:  case OpCode.Newarr:  case OpCode.Ldelema:  case OpCode.Ldelem:  case OpCode.Stelem:  case OpCode.Unbox_any:  case OpCode.Refanyval:  case OpCode.Mkrefany:  case OpCode.Initobj:  case OpCode.Constrained:  case OpCode.Sizeof:  	n += 4;  	break;  default:  	throw new PEException ("unrecognised opcode");  }  
Magic Number,Microsoft.LiveLabs.PE,Instruction,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Size,The following statement contains a magic number: switch (OpCode) {  case OpCode.Nop:  case OpCode.Break:  case OpCode.Ldarg_0:  case OpCode.Ldarg_1:  case OpCode.Ldarg_2:  case OpCode.Ldarg_3:  case OpCode.Ldloc_0:  case OpCode.Ldloc_1:  case OpCode.Ldloc_2:  case OpCode.Ldloc_3:  case OpCode.Stloc_0:  case OpCode.Stloc_1:  case OpCode.Stloc_2:  case OpCode.Stloc_3:  case OpCode.Ldnull:  case OpCode.Ldc_i4_m1:  case OpCode.Ldc_i4_0:  case OpCode.Ldc_i4_1:  case OpCode.Ldc_i4_2:  case OpCode.Ldc_i4_3:  case OpCode.Ldc_i4_4:  case OpCode.Ldc_i4_5:  case OpCode.Ldc_i4_6:  case OpCode.Ldc_i4_7:  case OpCode.Ldc_i4_8:  case OpCode.Dup:  case OpCode.Pop:  case OpCode.Ret:  case OpCode.Ldind_i1:  case OpCode.Ldind_u1:  case OpCode.Ldind_i2:  case OpCode.Ldind_u2:  case OpCode.Ldind_i4:  case OpCode.Ldind_u4:  case OpCode.Ldind_i8:  case OpCode.Ldind_i:  case OpCode.Ldind_r4:  case OpCode.Ldind_r8:  case OpCode.Ldind_ref:  case OpCode.Stind_ref:  case OpCode.Stind_i1:  case OpCode.Stind_i2:  case OpCode.Stind_i4:  case OpCode.Stind_i8:  case OpCode.Stind_r4:  case OpCode.Stind_r8:  case OpCode.Add:  case OpCode.Sub:  case OpCode.Mul:  case OpCode.Div:  case OpCode.Div_un:  case OpCode.Rem:  case OpCode.Rem_un:  case OpCode.And:  case OpCode.Or:  case OpCode.Xor:  case OpCode.Shl:  case OpCode.Shr:  case OpCode.Shr_un:  case OpCode.Neg:  case OpCode.Not:  case OpCode.Conv_i1:  case OpCode.Conv_i2:  case OpCode.Conv_i4:  case OpCode.Conv_i8:  case OpCode.Conv_r4:  case OpCode.Conv_r8:  case OpCode.Conv_u4:  case OpCode.Conv_u8:  case OpCode.Conv_r_un:  case OpCode.Throw:  case OpCode.Conv_ovf_i1_un:  case OpCode.Conv_ovf_i2_un:  case OpCode.Conv_ovf_i4_un:  case OpCode.Conv_ovf_i8_un:  case OpCode.Conv_ovf_u1_un:  case OpCode.Conv_ovf_u2_un:  case OpCode.Conv_ovf_u4_un:  case OpCode.Conv_ovf_u8_un:  case OpCode.Conv_ovf_i_un:  case OpCode.Conv_ovf_u_un:  case OpCode.Ldlen:  case OpCode.Ldelem_i1:  case OpCode.Ldelem_u1:  case OpCode.Ldelem_i2:  case OpCode.Ldelem_u2:  case OpCode.Ldelem_i4:  case OpCode.Ldelem_u4:  case OpCode.Ldelem_i8:  case OpCode.Ldelem_i:  case OpCode.Ldelem_r4:  case OpCode.Ldelem_r8:  case OpCode.Ldelem_ref:  case OpCode.Stelem_i:  case OpCode.Stelem_i1:  case OpCode.Stelem_i2:  case OpCode.Stelem_i4:  case OpCode.Stelem_i8:  case OpCode.Stelem_r4:  case OpCode.Stelem_r8:  case OpCode.Stelem_ref:  case OpCode.Conv_ovf_i1:  case OpCode.Conv_ovf_u1:  case OpCode.Conv_ovf_i2:  case OpCode.Conv_ovf_u2:  case OpCode.Conv_ovf_i4:  case OpCode.Conv_ovf_u4:  case OpCode.Conv_ovf_i8:  case OpCode.Conv_ovf_u8:  case OpCode.Ckfinite:  case OpCode.Conv_u2:  case OpCode.Conv_u1:  case OpCode.Conv_i:  case OpCode.Conv_ovf_i:  case OpCode.Conv_ovf_u:  case OpCode.Add_ovf:  case OpCode.Add_ovf_un:  case OpCode.Mul_ovf:  case OpCode.Mul_ovf_un:  case OpCode.Sub_ovf:  case OpCode.Sub_ovf_un:  case OpCode.Endfinally:  case OpCode.Stind_i:  case OpCode.Conv_u:  case OpCode.Prefix7:  case OpCode.Prefix6:  case OpCode.Prefix5:  case OpCode.Prefix4:  case OpCode.Prefix3:  case OpCode.Prefix2:  case OpCode.Prefix1:  case OpCode.Prefixref:  case OpCode.Arglist:  case OpCode.Ceq:  case OpCode.Cgt:  case OpCode.Cgt_un:  case OpCode.Clt:  case OpCode.Clt_un:  case OpCode.Localloc:  case OpCode.Endfilter:  case OpCode.Volatile:  case OpCode.Tailcall:  case OpCode.Cpblk:  case OpCode.Initblk:  case OpCode.Rethrow:  case OpCode.Refanytype:  case OpCode.Readonly:  	break;  case OpCode.Br:  case OpCode.Brfalse:  case OpCode.Brtrue:  case OpCode.Beq:  case OpCode.Bge:  case OpCode.Bgt:  case OpCode.Ble:  case OpCode.Blt:  case OpCode.Bne_un:  case OpCode.Bge_un:  case OpCode.Bgt_un:  case OpCode.Ble_un:  case OpCode.Blt_un:  case OpCode.Leave:  	n += 4;  	break;  case OpCode.Br_s:  case OpCode.Brfalse_s:  case OpCode.Brtrue_s:  case OpCode.Beq_s:  case OpCode.Bge_s:  case OpCode.Bgt_s:  case OpCode.Ble_s:  case OpCode.Blt_s:  case OpCode.Bne_un_s:  case OpCode.Bge_un_s:  case OpCode.Bgt_un_s:  case OpCode.Ble_un_s:  case OpCode.Blt_un_s:  case OpCode.Leave_s:  	n++;  	break;  case OpCode.Ldc_i4_s:  	n++;  	break;  case OpCode.Ldarg_s:  case OpCode.Ldarga_s:  case OpCode.Starg_s:  case OpCode.Ldloc_s:  case OpCode.Ldloca_s:  case OpCode.Stloc_s:  case OpCode.Unaligned:  	n++;  	break;  case OpCode.Ldc_i4:  	n += 4;  	break;  case OpCode.Ldarg:  case OpCode.Ldarga:  case OpCode.Starg:  case OpCode.Ldloc:  case OpCode.Ldloca:  case OpCode.Stloc:  	n += 4;  	break;  case OpCode.Ldc_i8:  	n += 8;  	break;  case OpCode.Ldc_r4:  	n += 4;  	break;  case OpCode.Ldc_r8:  	n += 8;  	break;  case OpCode.Ldstr:  	n += 4;  	break;  case OpCode.Switch: {  	var targets = (Seq<int>)Value;  	n += (1 + targets.Count) * 4;  	break;  }  case OpCode.Calli:  case OpCode.Jmp:  case OpCode.Call:  case OpCode.Callvirt:  case OpCode.Newobj:  case OpCode.Ldftn:  case OpCode.Ldvirtftn:  case OpCode.Ldfld:  case OpCode.Ldflda:  case OpCode.Stfld:  case OpCode.Ldsfld:  case OpCode.Ldsflda:  case OpCode.Stsfld:  case OpCode.Ldtoken:  case OpCode.Cpobj:  case OpCode.Ldobj:  case OpCode.Castclass:  case OpCode.Isinst:  case OpCode.Unbox:  case OpCode.Stobj:  case OpCode.Box:  case OpCode.Newarr:  case OpCode.Ldelema:  case OpCode.Ldelem:  case OpCode.Stelem:  case OpCode.Unbox_any:  case OpCode.Refanyval:  case OpCode.Mkrefany:  case OpCode.Initobj:  case OpCode.Constrained:  case OpCode.Sizeof:  	n += 4;  	break;  default:  	throw new PEException ("unrecognised opcode");  }  
Magic Number,Microsoft.LiveLabs.PE,Instruction,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Size,The following statement contains a magic number: switch (OpCode) {  case OpCode.Nop:  case OpCode.Break:  case OpCode.Ldarg_0:  case OpCode.Ldarg_1:  case OpCode.Ldarg_2:  case OpCode.Ldarg_3:  case OpCode.Ldloc_0:  case OpCode.Ldloc_1:  case OpCode.Ldloc_2:  case OpCode.Ldloc_3:  case OpCode.Stloc_0:  case OpCode.Stloc_1:  case OpCode.Stloc_2:  case OpCode.Stloc_3:  case OpCode.Ldnull:  case OpCode.Ldc_i4_m1:  case OpCode.Ldc_i4_0:  case OpCode.Ldc_i4_1:  case OpCode.Ldc_i4_2:  case OpCode.Ldc_i4_3:  case OpCode.Ldc_i4_4:  case OpCode.Ldc_i4_5:  case OpCode.Ldc_i4_6:  case OpCode.Ldc_i4_7:  case OpCode.Ldc_i4_8:  case OpCode.Dup:  case OpCode.Pop:  case OpCode.Ret:  case OpCode.Ldind_i1:  case OpCode.Ldind_u1:  case OpCode.Ldind_i2:  case OpCode.Ldind_u2:  case OpCode.Ldind_i4:  case OpCode.Ldind_u4:  case OpCode.Ldind_i8:  case OpCode.Ldind_i:  case OpCode.Ldind_r4:  case OpCode.Ldind_r8:  case OpCode.Ldind_ref:  case OpCode.Stind_ref:  case OpCode.Stind_i1:  case OpCode.Stind_i2:  case OpCode.Stind_i4:  case OpCode.Stind_i8:  case OpCode.Stind_r4:  case OpCode.Stind_r8:  case OpCode.Add:  case OpCode.Sub:  case OpCode.Mul:  case OpCode.Div:  case OpCode.Div_un:  case OpCode.Rem:  case OpCode.Rem_un:  case OpCode.And:  case OpCode.Or:  case OpCode.Xor:  case OpCode.Shl:  case OpCode.Shr:  case OpCode.Shr_un:  case OpCode.Neg:  case OpCode.Not:  case OpCode.Conv_i1:  case OpCode.Conv_i2:  case OpCode.Conv_i4:  case OpCode.Conv_i8:  case OpCode.Conv_r4:  case OpCode.Conv_r8:  case OpCode.Conv_u4:  case OpCode.Conv_u8:  case OpCode.Conv_r_un:  case OpCode.Throw:  case OpCode.Conv_ovf_i1_un:  case OpCode.Conv_ovf_i2_un:  case OpCode.Conv_ovf_i4_un:  case OpCode.Conv_ovf_i8_un:  case OpCode.Conv_ovf_u1_un:  case OpCode.Conv_ovf_u2_un:  case OpCode.Conv_ovf_u4_un:  case OpCode.Conv_ovf_u8_un:  case OpCode.Conv_ovf_i_un:  case OpCode.Conv_ovf_u_un:  case OpCode.Ldlen:  case OpCode.Ldelem_i1:  case OpCode.Ldelem_u1:  case OpCode.Ldelem_i2:  case OpCode.Ldelem_u2:  case OpCode.Ldelem_i4:  case OpCode.Ldelem_u4:  case OpCode.Ldelem_i8:  case OpCode.Ldelem_i:  case OpCode.Ldelem_r4:  case OpCode.Ldelem_r8:  case OpCode.Ldelem_ref:  case OpCode.Stelem_i:  case OpCode.Stelem_i1:  case OpCode.Stelem_i2:  case OpCode.Stelem_i4:  case OpCode.Stelem_i8:  case OpCode.Stelem_r4:  case OpCode.Stelem_r8:  case OpCode.Stelem_ref:  case OpCode.Conv_ovf_i1:  case OpCode.Conv_ovf_u1:  case OpCode.Conv_ovf_i2:  case OpCode.Conv_ovf_u2:  case OpCode.Conv_ovf_i4:  case OpCode.Conv_ovf_u4:  case OpCode.Conv_ovf_i8:  case OpCode.Conv_ovf_u8:  case OpCode.Ckfinite:  case OpCode.Conv_u2:  case OpCode.Conv_u1:  case OpCode.Conv_i:  case OpCode.Conv_ovf_i:  case OpCode.Conv_ovf_u:  case OpCode.Add_ovf:  case OpCode.Add_ovf_un:  case OpCode.Mul_ovf:  case OpCode.Mul_ovf_un:  case OpCode.Sub_ovf:  case OpCode.Sub_ovf_un:  case OpCode.Endfinally:  case OpCode.Stind_i:  case OpCode.Conv_u:  case OpCode.Prefix7:  case OpCode.Prefix6:  case OpCode.Prefix5:  case OpCode.Prefix4:  case OpCode.Prefix3:  case OpCode.Prefix2:  case OpCode.Prefix1:  case OpCode.Prefixref:  case OpCode.Arglist:  case OpCode.Ceq:  case OpCode.Cgt:  case OpCode.Cgt_un:  case OpCode.Clt:  case OpCode.Clt_un:  case OpCode.Localloc:  case OpCode.Endfilter:  case OpCode.Volatile:  case OpCode.Tailcall:  case OpCode.Cpblk:  case OpCode.Initblk:  case OpCode.Rethrow:  case OpCode.Refanytype:  case OpCode.Readonly:  	break;  case OpCode.Br:  case OpCode.Brfalse:  case OpCode.Brtrue:  case OpCode.Beq:  case OpCode.Bge:  case OpCode.Bgt:  case OpCode.Ble:  case OpCode.Blt:  case OpCode.Bne_un:  case OpCode.Bge_un:  case OpCode.Bgt_un:  case OpCode.Ble_un:  case OpCode.Blt_un:  case OpCode.Leave:  	n += 4;  	break;  case OpCode.Br_s:  case OpCode.Brfalse_s:  case OpCode.Brtrue_s:  case OpCode.Beq_s:  case OpCode.Bge_s:  case OpCode.Bgt_s:  case OpCode.Ble_s:  case OpCode.Blt_s:  case OpCode.Bne_un_s:  case OpCode.Bge_un_s:  case OpCode.Bgt_un_s:  case OpCode.Ble_un_s:  case OpCode.Blt_un_s:  case OpCode.Leave_s:  	n++;  	break;  case OpCode.Ldc_i4_s:  	n++;  	break;  case OpCode.Ldarg_s:  case OpCode.Ldarga_s:  case OpCode.Starg_s:  case OpCode.Ldloc_s:  case OpCode.Ldloca_s:  case OpCode.Stloc_s:  case OpCode.Unaligned:  	n++;  	break;  case OpCode.Ldc_i4:  	n += 4;  	break;  case OpCode.Ldarg:  case OpCode.Ldarga:  case OpCode.Starg:  case OpCode.Ldloc:  case OpCode.Ldloca:  case OpCode.Stloc:  	n += 4;  	break;  case OpCode.Ldc_i8:  	n += 8;  	break;  case OpCode.Ldc_r4:  	n += 4;  	break;  case OpCode.Ldc_r8:  	n += 8;  	break;  case OpCode.Ldstr:  	n += 4;  	break;  case OpCode.Switch: {  	var targets = (Seq<int>)Value;  	n += (1 + targets.Count) * 4;  	break;  }  case OpCode.Calli:  case OpCode.Jmp:  case OpCode.Call:  case OpCode.Callvirt:  case OpCode.Newobj:  case OpCode.Ldftn:  case OpCode.Ldvirtftn:  case OpCode.Ldfld:  case OpCode.Ldflda:  case OpCode.Stfld:  case OpCode.Ldsfld:  case OpCode.Ldsflda:  case OpCode.Stsfld:  case OpCode.Ldtoken:  case OpCode.Cpobj:  case OpCode.Ldobj:  case OpCode.Castclass:  case OpCode.Isinst:  case OpCode.Unbox:  case OpCode.Stobj:  case OpCode.Box:  case OpCode.Newarr:  case OpCode.Ldelema:  case OpCode.Ldelem:  case OpCode.Stelem:  case OpCode.Unbox_any:  case OpCode.Refanyval:  case OpCode.Mkrefany:  case OpCode.Initobj:  case OpCode.Constrained:  case OpCode.Sizeof:  	n += 4;  	break;  default:  	throw new PEException ("unrecognised opcode");  }  
Magic Number,Microsoft.LiveLabs.PE,Instruction,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Size,The following statement contains a magic number: switch (OpCode) {  case OpCode.Nop:  case OpCode.Break:  case OpCode.Ldarg_0:  case OpCode.Ldarg_1:  case OpCode.Ldarg_2:  case OpCode.Ldarg_3:  case OpCode.Ldloc_0:  case OpCode.Ldloc_1:  case OpCode.Ldloc_2:  case OpCode.Ldloc_3:  case OpCode.Stloc_0:  case OpCode.Stloc_1:  case OpCode.Stloc_2:  case OpCode.Stloc_3:  case OpCode.Ldnull:  case OpCode.Ldc_i4_m1:  case OpCode.Ldc_i4_0:  case OpCode.Ldc_i4_1:  case OpCode.Ldc_i4_2:  case OpCode.Ldc_i4_3:  case OpCode.Ldc_i4_4:  case OpCode.Ldc_i4_5:  case OpCode.Ldc_i4_6:  case OpCode.Ldc_i4_7:  case OpCode.Ldc_i4_8:  case OpCode.Dup:  case OpCode.Pop:  case OpCode.Ret:  case OpCode.Ldind_i1:  case OpCode.Ldind_u1:  case OpCode.Ldind_i2:  case OpCode.Ldind_u2:  case OpCode.Ldind_i4:  case OpCode.Ldind_u4:  case OpCode.Ldind_i8:  case OpCode.Ldind_i:  case OpCode.Ldind_r4:  case OpCode.Ldind_r8:  case OpCode.Ldind_ref:  case OpCode.Stind_ref:  case OpCode.Stind_i1:  case OpCode.Stind_i2:  case OpCode.Stind_i4:  case OpCode.Stind_i8:  case OpCode.Stind_r4:  case OpCode.Stind_r8:  case OpCode.Add:  case OpCode.Sub:  case OpCode.Mul:  case OpCode.Div:  case OpCode.Div_un:  case OpCode.Rem:  case OpCode.Rem_un:  case OpCode.And:  case OpCode.Or:  case OpCode.Xor:  case OpCode.Shl:  case OpCode.Shr:  case OpCode.Shr_un:  case OpCode.Neg:  case OpCode.Not:  case OpCode.Conv_i1:  case OpCode.Conv_i2:  case OpCode.Conv_i4:  case OpCode.Conv_i8:  case OpCode.Conv_r4:  case OpCode.Conv_r8:  case OpCode.Conv_u4:  case OpCode.Conv_u8:  case OpCode.Conv_r_un:  case OpCode.Throw:  case OpCode.Conv_ovf_i1_un:  case OpCode.Conv_ovf_i2_un:  case OpCode.Conv_ovf_i4_un:  case OpCode.Conv_ovf_i8_un:  case OpCode.Conv_ovf_u1_un:  case OpCode.Conv_ovf_u2_un:  case OpCode.Conv_ovf_u4_un:  case OpCode.Conv_ovf_u8_un:  case OpCode.Conv_ovf_i_un:  case OpCode.Conv_ovf_u_un:  case OpCode.Ldlen:  case OpCode.Ldelem_i1:  case OpCode.Ldelem_u1:  case OpCode.Ldelem_i2:  case OpCode.Ldelem_u2:  case OpCode.Ldelem_i4:  case OpCode.Ldelem_u4:  case OpCode.Ldelem_i8:  case OpCode.Ldelem_i:  case OpCode.Ldelem_r4:  case OpCode.Ldelem_r8:  case OpCode.Ldelem_ref:  case OpCode.Stelem_i:  case OpCode.Stelem_i1:  case OpCode.Stelem_i2:  case OpCode.Stelem_i4:  case OpCode.Stelem_i8:  case OpCode.Stelem_r4:  case OpCode.Stelem_r8:  case OpCode.Stelem_ref:  case OpCode.Conv_ovf_i1:  case OpCode.Conv_ovf_u1:  case OpCode.Conv_ovf_i2:  case OpCode.Conv_ovf_u2:  case OpCode.Conv_ovf_i4:  case OpCode.Conv_ovf_u4:  case OpCode.Conv_ovf_i8:  case OpCode.Conv_ovf_u8:  case OpCode.Ckfinite:  case OpCode.Conv_u2:  case OpCode.Conv_u1:  case OpCode.Conv_i:  case OpCode.Conv_ovf_i:  case OpCode.Conv_ovf_u:  case OpCode.Add_ovf:  case OpCode.Add_ovf_un:  case OpCode.Mul_ovf:  case OpCode.Mul_ovf_un:  case OpCode.Sub_ovf:  case OpCode.Sub_ovf_un:  case OpCode.Endfinally:  case OpCode.Stind_i:  case OpCode.Conv_u:  case OpCode.Prefix7:  case OpCode.Prefix6:  case OpCode.Prefix5:  case OpCode.Prefix4:  case OpCode.Prefix3:  case OpCode.Prefix2:  case OpCode.Prefix1:  case OpCode.Prefixref:  case OpCode.Arglist:  case OpCode.Ceq:  case OpCode.Cgt:  case OpCode.Cgt_un:  case OpCode.Clt:  case OpCode.Clt_un:  case OpCode.Localloc:  case OpCode.Endfilter:  case OpCode.Volatile:  case OpCode.Tailcall:  case OpCode.Cpblk:  case OpCode.Initblk:  case OpCode.Rethrow:  case OpCode.Refanytype:  case OpCode.Readonly:  	break;  case OpCode.Br:  case OpCode.Brfalse:  case OpCode.Brtrue:  case OpCode.Beq:  case OpCode.Bge:  case OpCode.Bgt:  case OpCode.Ble:  case OpCode.Blt:  case OpCode.Bne_un:  case OpCode.Bge_un:  case OpCode.Bgt_un:  case OpCode.Ble_un:  case OpCode.Blt_un:  case OpCode.Leave:  	n += 4;  	break;  case OpCode.Br_s:  case OpCode.Brfalse_s:  case OpCode.Brtrue_s:  case OpCode.Beq_s:  case OpCode.Bge_s:  case OpCode.Bgt_s:  case OpCode.Ble_s:  case OpCode.Blt_s:  case OpCode.Bne_un_s:  case OpCode.Bge_un_s:  case OpCode.Bgt_un_s:  case OpCode.Ble_un_s:  case OpCode.Blt_un_s:  case OpCode.Leave_s:  	n++;  	break;  case OpCode.Ldc_i4_s:  	n++;  	break;  case OpCode.Ldarg_s:  case OpCode.Ldarga_s:  case OpCode.Starg_s:  case OpCode.Ldloc_s:  case OpCode.Ldloca_s:  case OpCode.Stloc_s:  case OpCode.Unaligned:  	n++;  	break;  case OpCode.Ldc_i4:  	n += 4;  	break;  case OpCode.Ldarg:  case OpCode.Ldarga:  case OpCode.Starg:  case OpCode.Ldloc:  case OpCode.Ldloca:  case OpCode.Stloc:  	n += 4;  	break;  case OpCode.Ldc_i8:  	n += 8;  	break;  case OpCode.Ldc_r4:  	n += 4;  	break;  case OpCode.Ldc_r8:  	n += 8;  	break;  case OpCode.Ldstr:  	n += 4;  	break;  case OpCode.Switch: {  	var targets = (Seq<int>)Value;  	n += (1 + targets.Count) * 4;  	break;  }  case OpCode.Calli:  case OpCode.Jmp:  case OpCode.Call:  case OpCode.Callvirt:  case OpCode.Newobj:  case OpCode.Ldftn:  case OpCode.Ldvirtftn:  case OpCode.Ldfld:  case OpCode.Ldflda:  case OpCode.Stfld:  case OpCode.Ldsfld:  case OpCode.Ldsflda:  case OpCode.Stsfld:  case OpCode.Ldtoken:  case OpCode.Cpobj:  case OpCode.Ldobj:  case OpCode.Castclass:  case OpCode.Isinst:  case OpCode.Unbox:  case OpCode.Stobj:  case OpCode.Box:  case OpCode.Newarr:  case OpCode.Ldelema:  case OpCode.Ldelem:  case OpCode.Stelem:  case OpCode.Unbox_any:  case OpCode.Refanyval:  case OpCode.Mkrefany:  case OpCode.Initobj:  case OpCode.Constrained:  case OpCode.Sizeof:  	n += 4;  	break;  default:  	throw new PEException ("unrecognised opcode");  }  
Magic Number,Microsoft.LiveLabs.PE,Instruction,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Size,The following statement contains a magic number: switch (OpCode) {  case OpCode.Nop:  case OpCode.Break:  case OpCode.Ldarg_0:  case OpCode.Ldarg_1:  case OpCode.Ldarg_2:  case OpCode.Ldarg_3:  case OpCode.Ldloc_0:  case OpCode.Ldloc_1:  case OpCode.Ldloc_2:  case OpCode.Ldloc_3:  case OpCode.Stloc_0:  case OpCode.Stloc_1:  case OpCode.Stloc_2:  case OpCode.Stloc_3:  case OpCode.Ldnull:  case OpCode.Ldc_i4_m1:  case OpCode.Ldc_i4_0:  case OpCode.Ldc_i4_1:  case OpCode.Ldc_i4_2:  case OpCode.Ldc_i4_3:  case OpCode.Ldc_i4_4:  case OpCode.Ldc_i4_5:  case OpCode.Ldc_i4_6:  case OpCode.Ldc_i4_7:  case OpCode.Ldc_i4_8:  case OpCode.Dup:  case OpCode.Pop:  case OpCode.Ret:  case OpCode.Ldind_i1:  case OpCode.Ldind_u1:  case OpCode.Ldind_i2:  case OpCode.Ldind_u2:  case OpCode.Ldind_i4:  case OpCode.Ldind_u4:  case OpCode.Ldind_i8:  case OpCode.Ldind_i:  case OpCode.Ldind_r4:  case OpCode.Ldind_r8:  case OpCode.Ldind_ref:  case OpCode.Stind_ref:  case OpCode.Stind_i1:  case OpCode.Stind_i2:  case OpCode.Stind_i4:  case OpCode.Stind_i8:  case OpCode.Stind_r4:  case OpCode.Stind_r8:  case OpCode.Add:  case OpCode.Sub:  case OpCode.Mul:  case OpCode.Div:  case OpCode.Div_un:  case OpCode.Rem:  case OpCode.Rem_un:  case OpCode.And:  case OpCode.Or:  case OpCode.Xor:  case OpCode.Shl:  case OpCode.Shr:  case OpCode.Shr_un:  case OpCode.Neg:  case OpCode.Not:  case OpCode.Conv_i1:  case OpCode.Conv_i2:  case OpCode.Conv_i4:  case OpCode.Conv_i8:  case OpCode.Conv_r4:  case OpCode.Conv_r8:  case OpCode.Conv_u4:  case OpCode.Conv_u8:  case OpCode.Conv_r_un:  case OpCode.Throw:  case OpCode.Conv_ovf_i1_un:  case OpCode.Conv_ovf_i2_un:  case OpCode.Conv_ovf_i4_un:  case OpCode.Conv_ovf_i8_un:  case OpCode.Conv_ovf_u1_un:  case OpCode.Conv_ovf_u2_un:  case OpCode.Conv_ovf_u4_un:  case OpCode.Conv_ovf_u8_un:  case OpCode.Conv_ovf_i_un:  case OpCode.Conv_ovf_u_un:  case OpCode.Ldlen:  case OpCode.Ldelem_i1:  case OpCode.Ldelem_u1:  case OpCode.Ldelem_i2:  case OpCode.Ldelem_u2:  case OpCode.Ldelem_i4:  case OpCode.Ldelem_u4:  case OpCode.Ldelem_i8:  case OpCode.Ldelem_i:  case OpCode.Ldelem_r4:  case OpCode.Ldelem_r8:  case OpCode.Ldelem_ref:  case OpCode.Stelem_i:  case OpCode.Stelem_i1:  case OpCode.Stelem_i2:  case OpCode.Stelem_i4:  case OpCode.Stelem_i8:  case OpCode.Stelem_r4:  case OpCode.Stelem_r8:  case OpCode.Stelem_ref:  case OpCode.Conv_ovf_i1:  case OpCode.Conv_ovf_u1:  case OpCode.Conv_ovf_i2:  case OpCode.Conv_ovf_u2:  case OpCode.Conv_ovf_i4:  case OpCode.Conv_ovf_u4:  case OpCode.Conv_ovf_i8:  case OpCode.Conv_ovf_u8:  case OpCode.Ckfinite:  case OpCode.Conv_u2:  case OpCode.Conv_u1:  case OpCode.Conv_i:  case OpCode.Conv_ovf_i:  case OpCode.Conv_ovf_u:  case OpCode.Add_ovf:  case OpCode.Add_ovf_un:  case OpCode.Mul_ovf:  case OpCode.Mul_ovf_un:  case OpCode.Sub_ovf:  case OpCode.Sub_ovf_un:  case OpCode.Endfinally:  case OpCode.Stind_i:  case OpCode.Conv_u:  case OpCode.Prefix7:  case OpCode.Prefix6:  case OpCode.Prefix5:  case OpCode.Prefix4:  case OpCode.Prefix3:  case OpCode.Prefix2:  case OpCode.Prefix1:  case OpCode.Prefixref:  case OpCode.Arglist:  case OpCode.Ceq:  case OpCode.Cgt:  case OpCode.Cgt_un:  case OpCode.Clt:  case OpCode.Clt_un:  case OpCode.Localloc:  case OpCode.Endfilter:  case OpCode.Volatile:  case OpCode.Tailcall:  case OpCode.Cpblk:  case OpCode.Initblk:  case OpCode.Rethrow:  case OpCode.Refanytype:  case OpCode.Readonly:  	break;  case OpCode.Br:  case OpCode.Brfalse:  case OpCode.Brtrue:  case OpCode.Beq:  case OpCode.Bge:  case OpCode.Bgt:  case OpCode.Ble:  case OpCode.Blt:  case OpCode.Bne_un:  case OpCode.Bge_un:  case OpCode.Bgt_un:  case OpCode.Ble_un:  case OpCode.Blt_un:  case OpCode.Leave:  	n += 4;  	break;  case OpCode.Br_s:  case OpCode.Brfalse_s:  case OpCode.Brtrue_s:  case OpCode.Beq_s:  case OpCode.Bge_s:  case OpCode.Bgt_s:  case OpCode.Ble_s:  case OpCode.Blt_s:  case OpCode.Bne_un_s:  case OpCode.Bge_un_s:  case OpCode.Bgt_un_s:  case OpCode.Ble_un_s:  case OpCode.Blt_un_s:  case OpCode.Leave_s:  	n++;  	break;  case OpCode.Ldc_i4_s:  	n++;  	break;  case OpCode.Ldarg_s:  case OpCode.Ldarga_s:  case OpCode.Starg_s:  case OpCode.Ldloc_s:  case OpCode.Ldloca_s:  case OpCode.Stloc_s:  case OpCode.Unaligned:  	n++;  	break;  case OpCode.Ldc_i4:  	n += 4;  	break;  case OpCode.Ldarg:  case OpCode.Ldarga:  case OpCode.Starg:  case OpCode.Ldloc:  case OpCode.Ldloca:  case OpCode.Stloc:  	n += 4;  	break;  case OpCode.Ldc_i8:  	n += 8;  	break;  case OpCode.Ldc_r4:  	n += 4;  	break;  case OpCode.Ldc_r8:  	n += 8;  	break;  case OpCode.Ldstr:  	n += 4;  	break;  case OpCode.Switch: {  	var targets = (Seq<int>)Value;  	n += (1 + targets.Count) * 4;  	break;  }  case OpCode.Calli:  case OpCode.Jmp:  case OpCode.Call:  case OpCode.Callvirt:  case OpCode.Newobj:  case OpCode.Ldftn:  case OpCode.Ldvirtftn:  case OpCode.Ldfld:  case OpCode.Ldflda:  case OpCode.Stfld:  case OpCode.Ldsfld:  case OpCode.Ldsflda:  case OpCode.Stsfld:  case OpCode.Ldtoken:  case OpCode.Cpobj:  case OpCode.Ldobj:  case OpCode.Castclass:  case OpCode.Isinst:  case OpCode.Unbox:  case OpCode.Stobj:  case OpCode.Box:  case OpCode.Newarr:  case OpCode.Ldelema:  case OpCode.Ldelem:  case OpCode.Stelem:  case OpCode.Unbox_any:  case OpCode.Refanyval:  case OpCode.Mkrefany:  case OpCode.Initobj:  case OpCode.Constrained:  case OpCode.Sizeof:  	n += 4;  	break;  default:  	throw new PEException ("unrecognised opcode");  }  
Magic Number,Microsoft.LiveLabs.PE,Instruction,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Size,The following statement contains a magic number: switch (OpCode) {  case OpCode.Nop:  case OpCode.Break:  case OpCode.Ldarg_0:  case OpCode.Ldarg_1:  case OpCode.Ldarg_2:  case OpCode.Ldarg_3:  case OpCode.Ldloc_0:  case OpCode.Ldloc_1:  case OpCode.Ldloc_2:  case OpCode.Ldloc_3:  case OpCode.Stloc_0:  case OpCode.Stloc_1:  case OpCode.Stloc_2:  case OpCode.Stloc_3:  case OpCode.Ldnull:  case OpCode.Ldc_i4_m1:  case OpCode.Ldc_i4_0:  case OpCode.Ldc_i4_1:  case OpCode.Ldc_i4_2:  case OpCode.Ldc_i4_3:  case OpCode.Ldc_i4_4:  case OpCode.Ldc_i4_5:  case OpCode.Ldc_i4_6:  case OpCode.Ldc_i4_7:  case OpCode.Ldc_i4_8:  case OpCode.Dup:  case OpCode.Pop:  case OpCode.Ret:  case OpCode.Ldind_i1:  case OpCode.Ldind_u1:  case OpCode.Ldind_i2:  case OpCode.Ldind_u2:  case OpCode.Ldind_i4:  case OpCode.Ldind_u4:  case OpCode.Ldind_i8:  case OpCode.Ldind_i:  case OpCode.Ldind_r4:  case OpCode.Ldind_r8:  case OpCode.Ldind_ref:  case OpCode.Stind_ref:  case OpCode.Stind_i1:  case OpCode.Stind_i2:  case OpCode.Stind_i4:  case OpCode.Stind_i8:  case OpCode.Stind_r4:  case OpCode.Stind_r8:  case OpCode.Add:  case OpCode.Sub:  case OpCode.Mul:  case OpCode.Div:  case OpCode.Div_un:  case OpCode.Rem:  case OpCode.Rem_un:  case OpCode.And:  case OpCode.Or:  case OpCode.Xor:  case OpCode.Shl:  case OpCode.Shr:  case OpCode.Shr_un:  case OpCode.Neg:  case OpCode.Not:  case OpCode.Conv_i1:  case OpCode.Conv_i2:  case OpCode.Conv_i4:  case OpCode.Conv_i8:  case OpCode.Conv_r4:  case OpCode.Conv_r8:  case OpCode.Conv_u4:  case OpCode.Conv_u8:  case OpCode.Conv_r_un:  case OpCode.Throw:  case OpCode.Conv_ovf_i1_un:  case OpCode.Conv_ovf_i2_un:  case OpCode.Conv_ovf_i4_un:  case OpCode.Conv_ovf_i8_un:  case OpCode.Conv_ovf_u1_un:  case OpCode.Conv_ovf_u2_un:  case OpCode.Conv_ovf_u4_un:  case OpCode.Conv_ovf_u8_un:  case OpCode.Conv_ovf_i_un:  case OpCode.Conv_ovf_u_un:  case OpCode.Ldlen:  case OpCode.Ldelem_i1:  case OpCode.Ldelem_u1:  case OpCode.Ldelem_i2:  case OpCode.Ldelem_u2:  case OpCode.Ldelem_i4:  case OpCode.Ldelem_u4:  case OpCode.Ldelem_i8:  case OpCode.Ldelem_i:  case OpCode.Ldelem_r4:  case OpCode.Ldelem_r8:  case OpCode.Ldelem_ref:  case OpCode.Stelem_i:  case OpCode.Stelem_i1:  case OpCode.Stelem_i2:  case OpCode.Stelem_i4:  case OpCode.Stelem_i8:  case OpCode.Stelem_r4:  case OpCode.Stelem_r8:  case OpCode.Stelem_ref:  case OpCode.Conv_ovf_i1:  case OpCode.Conv_ovf_u1:  case OpCode.Conv_ovf_i2:  case OpCode.Conv_ovf_u2:  case OpCode.Conv_ovf_i4:  case OpCode.Conv_ovf_u4:  case OpCode.Conv_ovf_i8:  case OpCode.Conv_ovf_u8:  case OpCode.Ckfinite:  case OpCode.Conv_u2:  case OpCode.Conv_u1:  case OpCode.Conv_i:  case OpCode.Conv_ovf_i:  case OpCode.Conv_ovf_u:  case OpCode.Add_ovf:  case OpCode.Add_ovf_un:  case OpCode.Mul_ovf:  case OpCode.Mul_ovf_un:  case OpCode.Sub_ovf:  case OpCode.Sub_ovf_un:  case OpCode.Endfinally:  case OpCode.Stind_i:  case OpCode.Conv_u:  case OpCode.Prefix7:  case OpCode.Prefix6:  case OpCode.Prefix5:  case OpCode.Prefix4:  case OpCode.Prefix3:  case OpCode.Prefix2:  case OpCode.Prefix1:  case OpCode.Prefixref:  case OpCode.Arglist:  case OpCode.Ceq:  case OpCode.Cgt:  case OpCode.Cgt_un:  case OpCode.Clt:  case OpCode.Clt_un:  case OpCode.Localloc:  case OpCode.Endfilter:  case OpCode.Volatile:  case OpCode.Tailcall:  case OpCode.Cpblk:  case OpCode.Initblk:  case OpCode.Rethrow:  case OpCode.Refanytype:  case OpCode.Readonly:  	break;  case OpCode.Br:  case OpCode.Brfalse:  case OpCode.Brtrue:  case OpCode.Beq:  case OpCode.Bge:  case OpCode.Bgt:  case OpCode.Ble:  case OpCode.Blt:  case OpCode.Bne_un:  case OpCode.Bge_un:  case OpCode.Bgt_un:  case OpCode.Ble_un:  case OpCode.Blt_un:  case OpCode.Leave:  	n += 4;  	break;  case OpCode.Br_s:  case OpCode.Brfalse_s:  case OpCode.Brtrue_s:  case OpCode.Beq_s:  case OpCode.Bge_s:  case OpCode.Bgt_s:  case OpCode.Ble_s:  case OpCode.Blt_s:  case OpCode.Bne_un_s:  case OpCode.Bge_un_s:  case OpCode.Bgt_un_s:  case OpCode.Ble_un_s:  case OpCode.Blt_un_s:  case OpCode.Leave_s:  	n++;  	break;  case OpCode.Ldc_i4_s:  	n++;  	break;  case OpCode.Ldarg_s:  case OpCode.Ldarga_s:  case OpCode.Starg_s:  case OpCode.Ldloc_s:  case OpCode.Ldloca_s:  case OpCode.Stloc_s:  case OpCode.Unaligned:  	n++;  	break;  case OpCode.Ldc_i4:  	n += 4;  	break;  case OpCode.Ldarg:  case OpCode.Ldarga:  case OpCode.Starg:  case OpCode.Ldloc:  case OpCode.Ldloca:  case OpCode.Stloc:  	n += 4;  	break;  case OpCode.Ldc_i8:  	n += 8;  	break;  case OpCode.Ldc_r4:  	n += 4;  	break;  case OpCode.Ldc_r8:  	n += 8;  	break;  case OpCode.Ldstr:  	n += 4;  	break;  case OpCode.Switch: {  	var targets = (Seq<int>)Value;  	n += (1 + targets.Count) * 4;  	break;  }  case OpCode.Calli:  case OpCode.Jmp:  case OpCode.Call:  case OpCode.Callvirt:  case OpCode.Newobj:  case OpCode.Ldftn:  case OpCode.Ldvirtftn:  case OpCode.Ldfld:  case OpCode.Ldflda:  case OpCode.Stfld:  case OpCode.Ldsfld:  case OpCode.Ldsflda:  case OpCode.Stsfld:  case OpCode.Ldtoken:  case OpCode.Cpobj:  case OpCode.Ldobj:  case OpCode.Castclass:  case OpCode.Isinst:  case OpCode.Unbox:  case OpCode.Stobj:  case OpCode.Box:  case OpCode.Newarr:  case OpCode.Ldelema:  case OpCode.Ldelem:  case OpCode.Stelem:  case OpCode.Unbox_any:  case OpCode.Refanyval:  case OpCode.Mkrefany:  case OpCode.Initobj:  case OpCode.Constrained:  case OpCode.Sizeof:  	n += 4;  	break;  default:  	throw new PEException ("unrecognised opcode");  }  
Magic Number,Microsoft.LiveLabs.PE,Instruction,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Size,The following statement contains a magic number: n += 4;  
Magic Number,Microsoft.LiveLabs.PE,Instruction,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Size,The following statement contains a magic number: n += 4;  
Magic Number,Microsoft.LiveLabs.PE,Instruction,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Size,The following statement contains a magic number: n += 4;  
Magic Number,Microsoft.LiveLabs.PE,Instruction,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Size,The following statement contains a magic number: n += 8;  
Magic Number,Microsoft.LiveLabs.PE,Instruction,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Size,The following statement contains a magic number: n += 4;  
Magic Number,Microsoft.LiveLabs.PE,Instruction,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Size,The following statement contains a magic number: n += 8;  
Magic Number,Microsoft.LiveLabs.PE,Instruction,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Size,The following statement contains a magic number: n += 4;  
Magic Number,Microsoft.LiveLabs.PE,Instruction,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Size,The following statement contains a magic number: n += (1 + targets.Count) * 4;  
Magic Number,Microsoft.LiveLabs.PE,Instruction,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Size,The following statement contains a magic number: n += 4;  
Magic Number,Microsoft.LiveLabs.PE,Instruction,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Write,The following statement contains a magic number: switch (OpCode) {  case OpCode.Nop:  case OpCode.Break:  case OpCode.Ldarg_0:  case OpCode.Ldarg_1:  case OpCode.Ldarg_2:  case OpCode.Ldarg_3:  case OpCode.Ldloc_0:  case OpCode.Ldloc_1:  case OpCode.Ldloc_2:  case OpCode.Ldloc_3:  case OpCode.Stloc_0:  case OpCode.Stloc_1:  case OpCode.Stloc_2:  case OpCode.Stloc_3:  case OpCode.Ldnull:  case OpCode.Ldc_i4_m1:  case OpCode.Ldc_i4_0:  case OpCode.Ldc_i4_1:  case OpCode.Ldc_i4_2:  case OpCode.Ldc_i4_3:  case OpCode.Ldc_i4_4:  case OpCode.Ldc_i4_5:  case OpCode.Ldc_i4_6:  case OpCode.Ldc_i4_7:  case OpCode.Ldc_i4_8:  case OpCode.Dup:  case OpCode.Pop:  case OpCode.Ret:  case OpCode.Ldind_i1:  case OpCode.Ldind_u1:  case OpCode.Ldind_i2:  case OpCode.Ldind_u2:  case OpCode.Ldind_i4:  case OpCode.Ldind_u4:  case OpCode.Ldind_i8:  case OpCode.Ldind_i:  case OpCode.Ldind_r4:  case OpCode.Ldind_r8:  case OpCode.Ldind_ref:  case OpCode.Stind_ref:  case OpCode.Stind_i1:  case OpCode.Stind_i2:  case OpCode.Stind_i4:  case OpCode.Stind_i8:  case OpCode.Stind_r4:  case OpCode.Stind_r8:  case OpCode.Add:  case OpCode.Sub:  case OpCode.Mul:  case OpCode.Div:  case OpCode.Div_un:  case OpCode.Rem:  case OpCode.Rem_un:  case OpCode.And:  case OpCode.Or:  case OpCode.Xor:  case OpCode.Shl:  case OpCode.Shr:  case OpCode.Shr_un:  case OpCode.Neg:  case OpCode.Not:  case OpCode.Conv_i1:  case OpCode.Conv_i2:  case OpCode.Conv_i4:  case OpCode.Conv_i8:  case OpCode.Conv_r4:  case OpCode.Conv_r8:  case OpCode.Conv_u4:  case OpCode.Conv_u8:  case OpCode.Conv_r_un:  case OpCode.Throw:  case OpCode.Conv_ovf_i1_un:  case OpCode.Conv_ovf_i2_un:  case OpCode.Conv_ovf_i4_un:  case OpCode.Conv_ovf_i8_un:  case OpCode.Conv_ovf_u1_un:  case OpCode.Conv_ovf_u2_un:  case OpCode.Conv_ovf_u4_un:  case OpCode.Conv_ovf_u8_un:  case OpCode.Conv_ovf_i_un:  case OpCode.Conv_ovf_u_un:  case OpCode.Ldlen:  case OpCode.Ldelem_i1:  case OpCode.Ldelem_u1:  case OpCode.Ldelem_i2:  case OpCode.Ldelem_u2:  case OpCode.Ldelem_i4:  case OpCode.Ldelem_u4:  case OpCode.Ldelem_i8:  case OpCode.Ldelem_i:  case OpCode.Ldelem_r4:  case OpCode.Ldelem_r8:  case OpCode.Ldelem_ref:  case OpCode.Stelem_i:  case OpCode.Stelem_i1:  case OpCode.Stelem_i2:  case OpCode.Stelem_i4:  case OpCode.Stelem_i8:  case OpCode.Stelem_r4:  case OpCode.Stelem_r8:  case OpCode.Stelem_ref:  case OpCode.Conv_ovf_i1:  case OpCode.Conv_ovf_u1:  case OpCode.Conv_ovf_i2:  case OpCode.Conv_ovf_u2:  case OpCode.Conv_ovf_i4:  case OpCode.Conv_ovf_u4:  case OpCode.Conv_ovf_i8:  case OpCode.Conv_ovf_u8:  case OpCode.Ckfinite:  case OpCode.Conv_u2:  case OpCode.Conv_u1:  case OpCode.Conv_i:  case OpCode.Conv_ovf_i:  case OpCode.Conv_ovf_u:  case OpCode.Add_ovf:  case OpCode.Add_ovf_un:  case OpCode.Mul_ovf:  case OpCode.Mul_ovf_un:  case OpCode.Sub_ovf:  case OpCode.Sub_ovf_un:  case OpCode.Endfinally:  case OpCode.Stind_i:  case OpCode.Conv_u:  case OpCode.Prefix7:  case OpCode.Prefix6:  case OpCode.Prefix5:  case OpCode.Prefix4:  case OpCode.Prefix3:  case OpCode.Prefix2:  case OpCode.Prefix1:  case OpCode.Prefixref:  case OpCode.Arglist:  case OpCode.Ceq:  case OpCode.Cgt:  case OpCode.Cgt_un:  case OpCode.Clt:  case OpCode.Clt_un:  case OpCode.Localloc:  case OpCode.Endfilter:  case OpCode.Volatile:  case OpCode.Tailcall:  case OpCode.Cpblk:  case OpCode.Initblk:  case OpCode.Rethrow:  case OpCode.Refanytype:  case OpCode.Readonly:  	break;  case OpCode.Br:  case OpCode.Brfalse:  case OpCode.Brtrue:  case OpCode.Beq:  case OpCode.Bge:  case OpCode.Bgt:  case OpCode.Ble:  case OpCode.Blt:  case OpCode.Bne_un:  case OpCode.Bge_un:  case OpCode.Bgt_un:  case OpCode.Ble_un:  case OpCode.Blt_un:  case OpCode.Leave:  	{  		var target = (int)Value;  		// NOTE: Delta is relatative to start of next instruction  		var delta = (int)beginOffset + target - ((int)writer.Offset + 4);  		writer.WriteInt32 (delta);  	}  	break;  case OpCode.Br_s:  case OpCode.Brfalse_s:  case OpCode.Brtrue_s:  case OpCode.Beq_s:  case OpCode.Bge_s:  case OpCode.Bgt_s:  case OpCode.Ble_s:  case OpCode.Blt_s:  case OpCode.Bne_un_s:  case OpCode.Bge_un_s:  case OpCode.Bgt_un_s:  case OpCode.Ble_un_s:  case OpCode.Blt_un_s:  case OpCode.Leave_s:  	{  		var target = (int)Value;  		// NOTE: Delta is w.r.t. begining of next instruction  		var delta = (int)beginOffset + target - ((int)writer.Offset + 1);  		if (delta > 0xff)  			throw new PEException ("cannot use small form for this instruction");  		writer.WriteSByte ((sbyte)delta);  	}  	break;  case OpCode.Ldc_i4_s:  	writer.WriteSByte ((sbyte)(int)Value);  	break;  case OpCode.Ldarg_s:  case OpCode.Ldarga_s:  case OpCode.Starg_s:  case OpCode.Ldloc_s:  case OpCode.Ldloca_s:  case OpCode.Stloc_s:  case OpCode.Unaligned:  	writer.WriteByte ((byte)(int)Value);  	break;  case OpCode.Ldc_i4:  	writer.WriteInt32 ((int)Value);  	break;  case OpCode.Ldarg:  case OpCode.Ldarga:  case OpCode.Starg:  case OpCode.Ldloc:  case OpCode.Ldloca:  case OpCode.Stloc:  	writer.WriteUInt32 ((uint)(int)Value);  	break;  case OpCode.Ldc_i8:  	writer.WriteInt64 ((long)Value);  	break;  case OpCode.Ldc_r4:  	writer.WriteSingle ((float)Value);  	break;  case OpCode.Ldc_r8:  	writer.WriteDouble ((double)Value);  	break;  case OpCode.Ldstr:  	WriteUserString (ctxt' writer' (string)Value);  	break;  case OpCode.Switch:  	{  		var targets = (Seq<int>)Value;  		writer.WriteUInt32 ((uint)targets.Count);  		// NOTE: Deltas are w.r.t. start of next instruction  		for (var i = 0; i < targets.Count; i++) {  			var delta = (int)beginOffset + targets [i] - ((int)writer.Offset + (targets.Count * 4));  			writer.WriteInt32 (delta);  		}  	}  	break;  case OpCode.Calli:  case OpCode.Jmp:  case OpCode.Call:  case OpCode.Callvirt:  case OpCode.Newobj:  case OpCode.Ldftn:  case OpCode.Ldvirtftn:  case OpCode.Ldfld:  case OpCode.Ldflda:  case OpCode.Stfld:  case OpCode.Ldsfld:  case OpCode.Ldsflda:  case OpCode.Stsfld:  case OpCode.Ldtoken:  case OpCode.Cpobj:  case OpCode.Ldobj:  case OpCode.Castclass:  case OpCode.Isinst:  case OpCode.Unbox:  case OpCode.Stobj:  case OpCode.Box:  case OpCode.Newarr:  case OpCode.Ldelema:  case OpCode.Ldelem:  case OpCode.Stelem:  case OpCode.Unbox_any:  case OpCode.Refanyval:  case OpCode.Mkrefany:  case OpCode.Initobj:  case OpCode.Constrained:  case OpCode.Sizeof:  	WriteToken (ctxt' writer' findRow (OpCode' Value));  	break;  default:  	throw new PEException ("unrecognised opcode");  }  
Magic Number,Microsoft.LiveLabs.PE,Instruction,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Write,The following statement contains a magic number: switch (OpCode) {  case OpCode.Nop:  case OpCode.Break:  case OpCode.Ldarg_0:  case OpCode.Ldarg_1:  case OpCode.Ldarg_2:  case OpCode.Ldarg_3:  case OpCode.Ldloc_0:  case OpCode.Ldloc_1:  case OpCode.Ldloc_2:  case OpCode.Ldloc_3:  case OpCode.Stloc_0:  case OpCode.Stloc_1:  case OpCode.Stloc_2:  case OpCode.Stloc_3:  case OpCode.Ldnull:  case OpCode.Ldc_i4_m1:  case OpCode.Ldc_i4_0:  case OpCode.Ldc_i4_1:  case OpCode.Ldc_i4_2:  case OpCode.Ldc_i4_3:  case OpCode.Ldc_i4_4:  case OpCode.Ldc_i4_5:  case OpCode.Ldc_i4_6:  case OpCode.Ldc_i4_7:  case OpCode.Ldc_i4_8:  case OpCode.Dup:  case OpCode.Pop:  case OpCode.Ret:  case OpCode.Ldind_i1:  case OpCode.Ldind_u1:  case OpCode.Ldind_i2:  case OpCode.Ldind_u2:  case OpCode.Ldind_i4:  case OpCode.Ldind_u4:  case OpCode.Ldind_i8:  case OpCode.Ldind_i:  case OpCode.Ldind_r4:  case OpCode.Ldind_r8:  case OpCode.Ldind_ref:  case OpCode.Stind_ref:  case OpCode.Stind_i1:  case OpCode.Stind_i2:  case OpCode.Stind_i4:  case OpCode.Stind_i8:  case OpCode.Stind_r4:  case OpCode.Stind_r8:  case OpCode.Add:  case OpCode.Sub:  case OpCode.Mul:  case OpCode.Div:  case OpCode.Div_un:  case OpCode.Rem:  case OpCode.Rem_un:  case OpCode.And:  case OpCode.Or:  case OpCode.Xor:  case OpCode.Shl:  case OpCode.Shr:  case OpCode.Shr_un:  case OpCode.Neg:  case OpCode.Not:  case OpCode.Conv_i1:  case OpCode.Conv_i2:  case OpCode.Conv_i4:  case OpCode.Conv_i8:  case OpCode.Conv_r4:  case OpCode.Conv_r8:  case OpCode.Conv_u4:  case OpCode.Conv_u8:  case OpCode.Conv_r_un:  case OpCode.Throw:  case OpCode.Conv_ovf_i1_un:  case OpCode.Conv_ovf_i2_un:  case OpCode.Conv_ovf_i4_un:  case OpCode.Conv_ovf_i8_un:  case OpCode.Conv_ovf_u1_un:  case OpCode.Conv_ovf_u2_un:  case OpCode.Conv_ovf_u4_un:  case OpCode.Conv_ovf_u8_un:  case OpCode.Conv_ovf_i_un:  case OpCode.Conv_ovf_u_un:  case OpCode.Ldlen:  case OpCode.Ldelem_i1:  case OpCode.Ldelem_u1:  case OpCode.Ldelem_i2:  case OpCode.Ldelem_u2:  case OpCode.Ldelem_i4:  case OpCode.Ldelem_u4:  case OpCode.Ldelem_i8:  case OpCode.Ldelem_i:  case OpCode.Ldelem_r4:  case OpCode.Ldelem_r8:  case OpCode.Ldelem_ref:  case OpCode.Stelem_i:  case OpCode.Stelem_i1:  case OpCode.Stelem_i2:  case OpCode.Stelem_i4:  case OpCode.Stelem_i8:  case OpCode.Stelem_r4:  case OpCode.Stelem_r8:  case OpCode.Stelem_ref:  case OpCode.Conv_ovf_i1:  case OpCode.Conv_ovf_u1:  case OpCode.Conv_ovf_i2:  case OpCode.Conv_ovf_u2:  case OpCode.Conv_ovf_i4:  case OpCode.Conv_ovf_u4:  case OpCode.Conv_ovf_i8:  case OpCode.Conv_ovf_u8:  case OpCode.Ckfinite:  case OpCode.Conv_u2:  case OpCode.Conv_u1:  case OpCode.Conv_i:  case OpCode.Conv_ovf_i:  case OpCode.Conv_ovf_u:  case OpCode.Add_ovf:  case OpCode.Add_ovf_un:  case OpCode.Mul_ovf:  case OpCode.Mul_ovf_un:  case OpCode.Sub_ovf:  case OpCode.Sub_ovf_un:  case OpCode.Endfinally:  case OpCode.Stind_i:  case OpCode.Conv_u:  case OpCode.Prefix7:  case OpCode.Prefix6:  case OpCode.Prefix5:  case OpCode.Prefix4:  case OpCode.Prefix3:  case OpCode.Prefix2:  case OpCode.Prefix1:  case OpCode.Prefixref:  case OpCode.Arglist:  case OpCode.Ceq:  case OpCode.Cgt:  case OpCode.Cgt_un:  case OpCode.Clt:  case OpCode.Clt_un:  case OpCode.Localloc:  case OpCode.Endfilter:  case OpCode.Volatile:  case OpCode.Tailcall:  case OpCode.Cpblk:  case OpCode.Initblk:  case OpCode.Rethrow:  case OpCode.Refanytype:  case OpCode.Readonly:  	break;  case OpCode.Br:  case OpCode.Brfalse:  case OpCode.Brtrue:  case OpCode.Beq:  case OpCode.Bge:  case OpCode.Bgt:  case OpCode.Ble:  case OpCode.Blt:  case OpCode.Bne_un:  case OpCode.Bge_un:  case OpCode.Bgt_un:  case OpCode.Ble_un:  case OpCode.Blt_un:  case OpCode.Leave:  	{  		var target = (int)Value;  		// NOTE: Delta is relatative to start of next instruction  		var delta = (int)beginOffset + target - ((int)writer.Offset + 4);  		writer.WriteInt32 (delta);  	}  	break;  case OpCode.Br_s:  case OpCode.Brfalse_s:  case OpCode.Brtrue_s:  case OpCode.Beq_s:  case OpCode.Bge_s:  case OpCode.Bgt_s:  case OpCode.Ble_s:  case OpCode.Blt_s:  case OpCode.Bne_un_s:  case OpCode.Bge_un_s:  case OpCode.Bgt_un_s:  case OpCode.Ble_un_s:  case OpCode.Blt_un_s:  case OpCode.Leave_s:  	{  		var target = (int)Value;  		// NOTE: Delta is w.r.t. begining of next instruction  		var delta = (int)beginOffset + target - ((int)writer.Offset + 1);  		if (delta > 0xff)  			throw new PEException ("cannot use small form for this instruction");  		writer.WriteSByte ((sbyte)delta);  	}  	break;  case OpCode.Ldc_i4_s:  	writer.WriteSByte ((sbyte)(int)Value);  	break;  case OpCode.Ldarg_s:  case OpCode.Ldarga_s:  case OpCode.Starg_s:  case OpCode.Ldloc_s:  case OpCode.Ldloca_s:  case OpCode.Stloc_s:  case OpCode.Unaligned:  	writer.WriteByte ((byte)(int)Value);  	break;  case OpCode.Ldc_i4:  	writer.WriteInt32 ((int)Value);  	break;  case OpCode.Ldarg:  case OpCode.Ldarga:  case OpCode.Starg:  case OpCode.Ldloc:  case OpCode.Ldloca:  case OpCode.Stloc:  	writer.WriteUInt32 ((uint)(int)Value);  	break;  case OpCode.Ldc_i8:  	writer.WriteInt64 ((long)Value);  	break;  case OpCode.Ldc_r4:  	writer.WriteSingle ((float)Value);  	break;  case OpCode.Ldc_r8:  	writer.WriteDouble ((double)Value);  	break;  case OpCode.Ldstr:  	WriteUserString (ctxt' writer' (string)Value);  	break;  case OpCode.Switch:  	{  		var targets = (Seq<int>)Value;  		writer.WriteUInt32 ((uint)targets.Count);  		// NOTE: Deltas are w.r.t. start of next instruction  		for (var i = 0; i < targets.Count; i++) {  			var delta = (int)beginOffset + targets [i] - ((int)writer.Offset + (targets.Count * 4));  			writer.WriteInt32 (delta);  		}  	}  	break;  case OpCode.Calli:  case OpCode.Jmp:  case OpCode.Call:  case OpCode.Callvirt:  case OpCode.Newobj:  case OpCode.Ldftn:  case OpCode.Ldvirtftn:  case OpCode.Ldfld:  case OpCode.Ldflda:  case OpCode.Stfld:  case OpCode.Ldsfld:  case OpCode.Ldsflda:  case OpCode.Stsfld:  case OpCode.Ldtoken:  case OpCode.Cpobj:  case OpCode.Ldobj:  case OpCode.Castclass:  case OpCode.Isinst:  case OpCode.Unbox:  case OpCode.Stobj:  case OpCode.Box:  case OpCode.Newarr:  case OpCode.Ldelema:  case OpCode.Ldelem:  case OpCode.Stelem:  case OpCode.Unbox_any:  case OpCode.Refanyval:  case OpCode.Mkrefany:  case OpCode.Initobj:  case OpCode.Constrained:  case OpCode.Sizeof:  	WriteToken (ctxt' writer' findRow (OpCode' Value));  	break;  default:  	throw new PEException ("unrecognised opcode");  }  
Magic Number,Microsoft.LiveLabs.PE,Instruction,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Write,The following statement contains a magic number: for (var i = 0; i < targets.Count; i++) {  	var delta = (int)beginOffset + targets [i] - ((int)writer.Offset + (targets.Count * 4));  	writer.WriteInt32 (delta);  }  
Magic Number,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Read,The following statement contains a magic number: switch (formatKind) {  case CorILMethod.TinyFormat: {  	MaxStack = 8;  	bodySize = (uint)(firstByte >> 2);  	break;  }  case CorILMethod.FatFormat: {  	var secondByte = reader.ReadByte ();  	var flags = (CorILMethod)(((ushort)(secondByte & 0x7) << 8) | (ushort)firstByte);  	IsInitLocals = (flags & CorILMethod.InitLocals) != 0;  	var headerSize = (secondByte >> 4) & 0x7;  	if (headerSize != 3)  		throw new PEException ("unexpected method body header size");  	MaxStack = (int)reader.ReadUInt16 ();  	bodySize = reader.ReadUInt32 ();  	LocalVarRef.Read (ctxt' reader);  	LocalVarRef.ResolveIndexes (ctxt);  	more = (flags & CorILMethod.MoreSects) != 0;  	break;  }  default:  	throw new InvalidOperationException ("invalid method body format");  }  
Magic Number,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Read,The following statement contains a magic number: switch (formatKind) {  case CorILMethod.TinyFormat: {  	MaxStack = 8;  	bodySize = (uint)(firstByte >> 2);  	break;  }  case CorILMethod.FatFormat: {  	var secondByte = reader.ReadByte ();  	var flags = (CorILMethod)(((ushort)(secondByte & 0x7) << 8) | (ushort)firstByte);  	IsInitLocals = (flags & CorILMethod.InitLocals) != 0;  	var headerSize = (secondByte >> 4) & 0x7;  	if (headerSize != 3)  		throw new PEException ("unexpected method body header size");  	MaxStack = (int)reader.ReadUInt16 ();  	bodySize = reader.ReadUInt32 ();  	LocalVarRef.Read (ctxt' reader);  	LocalVarRef.ResolveIndexes (ctxt);  	more = (flags & CorILMethod.MoreSects) != 0;  	break;  }  default:  	throw new InvalidOperationException ("invalid method body format");  }  
Magic Number,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Read,The following statement contains a magic number: switch (formatKind) {  case CorILMethod.TinyFormat: {  	MaxStack = 8;  	bodySize = (uint)(firstByte >> 2);  	break;  }  case CorILMethod.FatFormat: {  	var secondByte = reader.ReadByte ();  	var flags = (CorILMethod)(((ushort)(secondByte & 0x7) << 8) | (ushort)firstByte);  	IsInitLocals = (flags & CorILMethod.InitLocals) != 0;  	var headerSize = (secondByte >> 4) & 0x7;  	if (headerSize != 3)  		throw new PEException ("unexpected method body header size");  	MaxStack = (int)reader.ReadUInt16 ();  	bodySize = reader.ReadUInt32 ();  	LocalVarRef.Read (ctxt' reader);  	LocalVarRef.ResolveIndexes (ctxt);  	more = (flags & CorILMethod.MoreSects) != 0;  	break;  }  default:  	throw new InvalidOperationException ("invalid method body format");  }  
Magic Number,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Read,The following statement contains a magic number: switch (formatKind) {  case CorILMethod.TinyFormat: {  	MaxStack = 8;  	bodySize = (uint)(firstByte >> 2);  	break;  }  case CorILMethod.FatFormat: {  	var secondByte = reader.ReadByte ();  	var flags = (CorILMethod)(((ushort)(secondByte & 0x7) << 8) | (ushort)firstByte);  	IsInitLocals = (flags & CorILMethod.InitLocals) != 0;  	var headerSize = (secondByte >> 4) & 0x7;  	if (headerSize != 3)  		throw new PEException ("unexpected method body header size");  	MaxStack = (int)reader.ReadUInt16 ();  	bodySize = reader.ReadUInt32 ();  	LocalVarRef.Read (ctxt' reader);  	LocalVarRef.ResolveIndexes (ctxt);  	more = (flags & CorILMethod.MoreSects) != 0;  	break;  }  default:  	throw new InvalidOperationException ("invalid method body format");  }  
Magic Number,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Read,The following statement contains a magic number: switch (formatKind) {  case CorILMethod.TinyFormat: {  	MaxStack = 8;  	bodySize = (uint)(firstByte >> 2);  	break;  }  case CorILMethod.FatFormat: {  	var secondByte = reader.ReadByte ();  	var flags = (CorILMethod)(((ushort)(secondByte & 0x7) << 8) | (ushort)firstByte);  	IsInitLocals = (flags & CorILMethod.InitLocals) != 0;  	var headerSize = (secondByte >> 4) & 0x7;  	if (headerSize != 3)  		throw new PEException ("unexpected method body header size");  	MaxStack = (int)reader.ReadUInt16 ();  	bodySize = reader.ReadUInt32 ();  	LocalVarRef.Read (ctxt' reader);  	LocalVarRef.ResolveIndexes (ctxt);  	more = (flags & CorILMethod.MoreSects) != 0;  	break;  }  default:  	throw new InvalidOperationException ("invalid method body format");  }  
Magic Number,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Read,The following statement contains a magic number: MaxStack = 8;  
Magic Number,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Read,The following statement contains a magic number: bodySize = (uint)(firstByte >> 2);  
Magic Number,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Read,The following statement contains a magic number: if (headerSize != 3)  	throw new PEException ("unexpected method body header size");  
Magic Number,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,ReadMethodDataSection,The following statement contains a magic number: reader.Align (4);  
Magic Number,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,ReadMethodDataSection,The following statement contains a magic number: if (isFat) {  	var size = reader.ReadUInt24 ();  	if (size < 4 || (size - 4) % 24 != 0)  		throw new InvalidOperationException ("invalid method data section");  	count = (size - 4) / 24;  }  else {  	var size = (uint)reader.ReadByte ();  	// NOTE: Looks live VB emits size without including the 4 byte header...  	if (size < 4 || (size - 4) % 12 != 0)  		throw new InvalidOperationException ("invalid method data section");  	var padding = reader.ReadUInt16 ();  	if (padding != 0)  		throw new PEException ("unexpected data");  	count = (size - 4) / 12;  }  
Magic Number,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,ReadMethodDataSection,The following statement contains a magic number: if (isFat) {  	var size = reader.ReadUInt24 ();  	if (size < 4 || (size - 4) % 24 != 0)  		throw new InvalidOperationException ("invalid method data section");  	count = (size - 4) / 24;  }  else {  	var size = (uint)reader.ReadByte ();  	// NOTE: Looks live VB emits size without including the 4 byte header...  	if (size < 4 || (size - 4) % 12 != 0)  		throw new InvalidOperationException ("invalid method data section");  	var padding = reader.ReadUInt16 ();  	if (padding != 0)  		throw new PEException ("unexpected data");  	count = (size - 4) / 12;  }  
Magic Number,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,ReadMethodDataSection,The following statement contains a magic number: if (isFat) {  	var size = reader.ReadUInt24 ();  	if (size < 4 || (size - 4) % 24 != 0)  		throw new InvalidOperationException ("invalid method data section");  	count = (size - 4) / 24;  }  else {  	var size = (uint)reader.ReadByte ();  	// NOTE: Looks live VB emits size without including the 4 byte header...  	if (size < 4 || (size - 4) % 12 != 0)  		throw new InvalidOperationException ("invalid method data section");  	var padding = reader.ReadUInt16 ();  	if (padding != 0)  		throw new PEException ("unexpected data");  	count = (size - 4) / 12;  }  
Magic Number,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,ReadMethodDataSection,The following statement contains a magic number: if (isFat) {  	var size = reader.ReadUInt24 ();  	if (size < 4 || (size - 4) % 24 != 0)  		throw new InvalidOperationException ("invalid method data section");  	count = (size - 4) / 24;  }  else {  	var size = (uint)reader.ReadByte ();  	// NOTE: Looks live VB emits size without including the 4 byte header...  	if (size < 4 || (size - 4) % 12 != 0)  		throw new InvalidOperationException ("invalid method data section");  	var padding = reader.ReadUInt16 ();  	if (padding != 0)  		throw new PEException ("unexpected data");  	count = (size - 4) / 12;  }  
Magic Number,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,ReadMethodDataSection,The following statement contains a magic number: if (isFat) {  	var size = reader.ReadUInt24 ();  	if (size < 4 || (size - 4) % 24 != 0)  		throw new InvalidOperationException ("invalid method data section");  	count = (size - 4) / 24;  }  else {  	var size = (uint)reader.ReadByte ();  	// NOTE: Looks live VB emits size without including the 4 byte header...  	if (size < 4 || (size - 4) % 12 != 0)  		throw new InvalidOperationException ("invalid method data section");  	var padding = reader.ReadUInt16 ();  	if (padding != 0)  		throw new PEException ("unexpected data");  	count = (size - 4) / 12;  }  
Magic Number,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,ReadMethodDataSection,The following statement contains a magic number: if (isFat) {  	var size = reader.ReadUInt24 ();  	if (size < 4 || (size - 4) % 24 != 0)  		throw new InvalidOperationException ("invalid method data section");  	count = (size - 4) / 24;  }  else {  	var size = (uint)reader.ReadByte ();  	// NOTE: Looks live VB emits size without including the 4 byte header...  	if (size < 4 || (size - 4) % 12 != 0)  		throw new InvalidOperationException ("invalid method data section");  	var padding = reader.ReadUInt16 ();  	if (padding != 0)  		throw new PEException ("unexpected data");  	count = (size - 4) / 12;  }  
Magic Number,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,ReadMethodDataSection,The following statement contains a magic number: if (isFat) {  	var size = reader.ReadUInt24 ();  	if (size < 4 || (size - 4) % 24 != 0)  		throw new InvalidOperationException ("invalid method data section");  	count = (size - 4) / 24;  }  else {  	var size = (uint)reader.ReadByte ();  	// NOTE: Looks live VB emits size without including the 4 byte header...  	if (size < 4 || (size - 4) % 12 != 0)  		throw new InvalidOperationException ("invalid method data section");  	var padding = reader.ReadUInt16 ();  	if (padding != 0)  		throw new PEException ("unexpected data");  	count = (size - 4) / 12;  }  
Magic Number,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,ReadMethodDataSection,The following statement contains a magic number: if (isFat) {  	var size = reader.ReadUInt24 ();  	if (size < 4 || (size - 4) % 24 != 0)  		throw new InvalidOperationException ("invalid method data section");  	count = (size - 4) / 24;  }  else {  	var size = (uint)reader.ReadByte ();  	// NOTE: Looks live VB emits size without including the 4 byte header...  	if (size < 4 || (size - 4) % 12 != 0)  		throw new InvalidOperationException ("invalid method data section");  	var padding = reader.ReadUInt16 ();  	if (padding != 0)  		throw new PEException ("unexpected data");  	count = (size - 4) / 12;  }  
Magic Number,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,ReadMethodDataSection,The following statement contains a magic number: if (isFat) {  	var size = reader.ReadUInt24 ();  	if (size < 4 || (size - 4) % 24 != 0)  		throw new InvalidOperationException ("invalid method data section");  	count = (size - 4) / 24;  }  else {  	var size = (uint)reader.ReadByte ();  	// NOTE: Looks live VB emits size without including the 4 byte header...  	if (size < 4 || (size - 4) % 12 != 0)  		throw new InvalidOperationException ("invalid method data section");  	var padding = reader.ReadUInt16 ();  	if (padding != 0)  		throw new PEException ("unexpected data");  	count = (size - 4) / 12;  }  
Magic Number,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,ReadMethodDataSection,The following statement contains a magic number: if (isFat) {  	var size = reader.ReadUInt24 ();  	if (size < 4 || (size - 4) % 24 != 0)  		throw new InvalidOperationException ("invalid method data section");  	count = (size - 4) / 24;  }  else {  	var size = (uint)reader.ReadByte ();  	// NOTE: Looks live VB emits size without including the 4 byte header...  	if (size < 4 || (size - 4) % 12 != 0)  		throw new InvalidOperationException ("invalid method data section");  	var padding = reader.ReadUInt16 ();  	if (padding != 0)  		throw new PEException ("unexpected data");  	count = (size - 4) / 12;  }  
Magic Number,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,ReadMethodDataSection,The following statement contains a magic number: if (size < 4 || (size - 4) % 24 != 0)  	throw new InvalidOperationException ("invalid method data section");  
Magic Number,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,ReadMethodDataSection,The following statement contains a magic number: if (size < 4 || (size - 4) % 24 != 0)  	throw new InvalidOperationException ("invalid method data section");  
Magic Number,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,ReadMethodDataSection,The following statement contains a magic number: if (size < 4 || (size - 4) % 24 != 0)  	throw new InvalidOperationException ("invalid method data section");  
Magic Number,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,ReadMethodDataSection,The following statement contains a magic number: count = (size - 4) / 24;  
Magic Number,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,ReadMethodDataSection,The following statement contains a magic number: count = (size - 4) / 24;  
Magic Number,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,ReadMethodDataSection,The following statement contains a magic number: if (size < 4 || (size - 4) % 12 != 0)  	throw new InvalidOperationException ("invalid method data section");  
Magic Number,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,ReadMethodDataSection,The following statement contains a magic number: if (size < 4 || (size - 4) % 12 != 0)  	throw new InvalidOperationException ("invalid method data section");  
Magic Number,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,ReadMethodDataSection,The following statement contains a magic number: if (size < 4 || (size - 4) % 12 != 0)  	throw new InvalidOperationException ("invalid method data section");  
Magic Number,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,ReadMethodDataSection,The following statement contains a magic number: count = (size - 4) / 12;  
Magic Number,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,ReadMethodDataSection,The following statement contains a magic number: count = (size - 4) / 12;  
Magic Number,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Write,The following statement contains a magic number: if (ExceptionHandlingClauses.Count > 0 || MaxStack > 8)  	isFat = true;  
Magic Number,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Write,The following statement contains a magic number: if (isFat) {  	var flags = CorILMethod.FatFormat;  	if (IsInitLocals)  		flags |= CorILMethod.InitLocals;  	if (ExceptionHandlingClauses.Count > 0)  		flags |= CorILMethod.MoreSects;  	var firstWord = (ushort)((uint)flags | (3 << 12));  	writer.WriteUInt16 (firstWord);  	writer.WriteUInt16 ((ushort)MaxStack);  	writer.WriteUInt32 ((uint)bodySize);  	LocalVarRef.PersistIndexes (ctxt);  	LocalVarRef.Write (ctxt' writer);  }  else {  	var firstByte = (byte)CorILMethod.TinyFormat;  	firstByte |= (byte)(bodySize << 2);  	writer.WriteByte (firstByte);  }  
Magic Number,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Write,The following statement contains a magic number: if (isFat) {  	var flags = CorILMethod.FatFormat;  	if (IsInitLocals)  		flags |= CorILMethod.InitLocals;  	if (ExceptionHandlingClauses.Count > 0)  		flags |= CorILMethod.MoreSects;  	var firstWord = (ushort)((uint)flags | (3 << 12));  	writer.WriteUInt16 (firstWord);  	writer.WriteUInt16 ((ushort)MaxStack);  	writer.WriteUInt32 ((uint)bodySize);  	LocalVarRef.PersistIndexes (ctxt);  	LocalVarRef.Write (ctxt' writer);  }  else {  	var firstByte = (byte)CorILMethod.TinyFormat;  	firstByte |= (byte)(bodySize << 2);  	writer.WriteByte (firstByte);  }  
Magic Number,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Write,The following statement contains a magic number: if (isFat) {  	var flags = CorILMethod.FatFormat;  	if (IsInitLocals)  		flags |= CorILMethod.InitLocals;  	if (ExceptionHandlingClauses.Count > 0)  		flags |= CorILMethod.MoreSects;  	var firstWord = (ushort)((uint)flags | (3 << 12));  	writer.WriteUInt16 (firstWord);  	writer.WriteUInt16 ((ushort)MaxStack);  	writer.WriteUInt32 ((uint)bodySize);  	LocalVarRef.PersistIndexes (ctxt);  	LocalVarRef.Write (ctxt' writer);  }  else {  	var firstByte = (byte)CorILMethod.TinyFormat;  	firstByte |= (byte)(bodySize << 2);  	writer.WriteByte (firstByte);  }  
Magic Number,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,Write,The following statement contains a magic number: firstByte |= (byte)(bodySize << 2);  
Magic Number,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,WriteMethodDataSection,The following statement contains a magic number: writer.Align (4);  
Magic Number,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,WriteMethodDataSection,The following statement contains a magic number: if (isFat) {  	size = ExceptionHandlingClauses.Count * 24 + 4;  	writer.WriteUInt24 ((uint)size);  }  else {  	writer.WriteByte ((byte)size);  	writer.WriteUInt16 (0);  }  
Magic Number,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,WriteMethodDataSection,The following statement contains a magic number: if (isFat) {  	size = ExceptionHandlingClauses.Count * 24 + 4;  	writer.WriteUInt24 ((uint)size);  }  else {  	writer.WriteByte ((byte)size);  	writer.WriteUInt16 (0);  }  
Magic Number,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,WriteMethodDataSection,The following statement contains a magic number: size = ExceptionHandlingClauses.Count * 24 + 4;  
Magic Number,Microsoft.LiveLabs.PE,MethodBody,C:\repos\Reactive-Extensions_IL2JS\PE\MethodBody.cs,WriteMethodDataSection,The following statement contains a magic number: size = ExceptionHandlingClauses.Count * 24 + 4;  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (Offset == 0)  	Value = null;  else {  	var reader = ctxt.GetBlobReader ();  	reader.Offset = Offset;  	Action<int> check = expected =>  {  		var actual = reader.ReadCompressedUInt32 ();  		if (actual != expected)  			throw new PEException ("mismatched constant and type");  	};  	switch (tag) {  	case TypeSigTag.BOOLEAN:  		check (1);  		Value = reader.ReadByte () == 0 ? false : true;  		break;  	case TypeSigTag.CHAR:  		check (2);  		Value = (char)reader.ReadUInt16 ();  		break;  	case TypeSigTag.I1:  		check (1);  		Value = reader.ReadSByte ();  		break;  	case TypeSigTag.U1:  		check (1);  		Value = reader.ReadByte ();  		break;  	case TypeSigTag.I2:  		check (2);  		Value = reader.ReadInt16 ();  		break;  	case TypeSigTag.U2:  		check (2);  		Value = reader.ReadUInt16 ();  		break;  	case TypeSigTag.I4:  		check (4);  		Value = reader.ReadInt32 ();  		break;  	case TypeSigTag.U4:  		check (4);  		Value = reader.ReadUInt32 ();  		break;  	case TypeSigTag.I8:  		check (8);  		Value = reader.ReadInt64 ();  		break;  	case TypeSigTag.U8:  		check (8);  		Value = reader.ReadUInt64 ();  		break;  	case TypeSigTag.R4:  		check (4);  		Value = reader.ReadSingle ();  		break;  	case TypeSigTag.R8:  		check (8);  		Value = reader.ReadDouble ();  		break;  	case TypeSigTag.STRING:  		Value = reader.ReadUTF16SizedString ();  		break;  	case TypeSigTag.CLASS:  		check (4);  		var zero = reader.ReadUInt32 ();  		if (zero != 0)  			throw new PEException ("expected zero for constant of class type");  		Value = null;  		break;  	default:  		throw new PEException ("unexpected constant tag");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (Offset == 0)  	Value = null;  else {  	var reader = ctxt.GetBlobReader ();  	reader.Offset = Offset;  	Action<int> check = expected =>  {  		var actual = reader.ReadCompressedUInt32 ();  		if (actual != expected)  			throw new PEException ("mismatched constant and type");  	};  	switch (tag) {  	case TypeSigTag.BOOLEAN:  		check (1);  		Value = reader.ReadByte () == 0 ? false : true;  		break;  	case TypeSigTag.CHAR:  		check (2);  		Value = (char)reader.ReadUInt16 ();  		break;  	case TypeSigTag.I1:  		check (1);  		Value = reader.ReadSByte ();  		break;  	case TypeSigTag.U1:  		check (1);  		Value = reader.ReadByte ();  		break;  	case TypeSigTag.I2:  		check (2);  		Value = reader.ReadInt16 ();  		break;  	case TypeSigTag.U2:  		check (2);  		Value = reader.ReadUInt16 ();  		break;  	case TypeSigTag.I4:  		check (4);  		Value = reader.ReadInt32 ();  		break;  	case TypeSigTag.U4:  		check (4);  		Value = reader.ReadUInt32 ();  		break;  	case TypeSigTag.I8:  		check (8);  		Value = reader.ReadInt64 ();  		break;  	case TypeSigTag.U8:  		check (8);  		Value = reader.ReadUInt64 ();  		break;  	case TypeSigTag.R4:  		check (4);  		Value = reader.ReadSingle ();  		break;  	case TypeSigTag.R8:  		check (8);  		Value = reader.ReadDouble ();  		break;  	case TypeSigTag.STRING:  		Value = reader.ReadUTF16SizedString ();  		break;  	case TypeSigTag.CLASS:  		check (4);  		var zero = reader.ReadUInt32 ();  		if (zero != 0)  			throw new PEException ("expected zero for constant of class type");  		Value = null;  		break;  	default:  		throw new PEException ("unexpected constant tag");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (Offset == 0)  	Value = null;  else {  	var reader = ctxt.GetBlobReader ();  	reader.Offset = Offset;  	Action<int> check = expected =>  {  		var actual = reader.ReadCompressedUInt32 ();  		if (actual != expected)  			throw new PEException ("mismatched constant and type");  	};  	switch (tag) {  	case TypeSigTag.BOOLEAN:  		check (1);  		Value = reader.ReadByte () == 0 ? false : true;  		break;  	case TypeSigTag.CHAR:  		check (2);  		Value = (char)reader.ReadUInt16 ();  		break;  	case TypeSigTag.I1:  		check (1);  		Value = reader.ReadSByte ();  		break;  	case TypeSigTag.U1:  		check (1);  		Value = reader.ReadByte ();  		break;  	case TypeSigTag.I2:  		check (2);  		Value = reader.ReadInt16 ();  		break;  	case TypeSigTag.U2:  		check (2);  		Value = reader.ReadUInt16 ();  		break;  	case TypeSigTag.I4:  		check (4);  		Value = reader.ReadInt32 ();  		break;  	case TypeSigTag.U4:  		check (4);  		Value = reader.ReadUInt32 ();  		break;  	case TypeSigTag.I8:  		check (8);  		Value = reader.ReadInt64 ();  		break;  	case TypeSigTag.U8:  		check (8);  		Value = reader.ReadUInt64 ();  		break;  	case TypeSigTag.R4:  		check (4);  		Value = reader.ReadSingle ();  		break;  	case TypeSigTag.R8:  		check (8);  		Value = reader.ReadDouble ();  		break;  	case TypeSigTag.STRING:  		Value = reader.ReadUTF16SizedString ();  		break;  	case TypeSigTag.CLASS:  		check (4);  		var zero = reader.ReadUInt32 ();  		if (zero != 0)  			throw new PEException ("expected zero for constant of class type");  		Value = null;  		break;  	default:  		throw new PEException ("unexpected constant tag");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (Offset == 0)  	Value = null;  else {  	var reader = ctxt.GetBlobReader ();  	reader.Offset = Offset;  	Action<int> check = expected =>  {  		var actual = reader.ReadCompressedUInt32 ();  		if (actual != expected)  			throw new PEException ("mismatched constant and type");  	};  	switch (tag) {  	case TypeSigTag.BOOLEAN:  		check (1);  		Value = reader.ReadByte () == 0 ? false : true;  		break;  	case TypeSigTag.CHAR:  		check (2);  		Value = (char)reader.ReadUInt16 ();  		break;  	case TypeSigTag.I1:  		check (1);  		Value = reader.ReadSByte ();  		break;  	case TypeSigTag.U1:  		check (1);  		Value = reader.ReadByte ();  		break;  	case TypeSigTag.I2:  		check (2);  		Value = reader.ReadInt16 ();  		break;  	case TypeSigTag.U2:  		check (2);  		Value = reader.ReadUInt16 ();  		break;  	case TypeSigTag.I4:  		check (4);  		Value = reader.ReadInt32 ();  		break;  	case TypeSigTag.U4:  		check (4);  		Value = reader.ReadUInt32 ();  		break;  	case TypeSigTag.I8:  		check (8);  		Value = reader.ReadInt64 ();  		break;  	case TypeSigTag.U8:  		check (8);  		Value = reader.ReadUInt64 ();  		break;  	case TypeSigTag.R4:  		check (4);  		Value = reader.ReadSingle ();  		break;  	case TypeSigTag.R8:  		check (8);  		Value = reader.ReadDouble ();  		break;  	case TypeSigTag.STRING:  		Value = reader.ReadUTF16SizedString ();  		break;  	case TypeSigTag.CLASS:  		check (4);  		var zero = reader.ReadUInt32 ();  		if (zero != 0)  			throw new PEException ("expected zero for constant of class type");  		Value = null;  		break;  	default:  		throw new PEException ("unexpected constant tag");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (Offset == 0)  	Value = null;  else {  	var reader = ctxt.GetBlobReader ();  	reader.Offset = Offset;  	Action<int> check = expected =>  {  		var actual = reader.ReadCompressedUInt32 ();  		if (actual != expected)  			throw new PEException ("mismatched constant and type");  	};  	switch (tag) {  	case TypeSigTag.BOOLEAN:  		check (1);  		Value = reader.ReadByte () == 0 ? false : true;  		break;  	case TypeSigTag.CHAR:  		check (2);  		Value = (char)reader.ReadUInt16 ();  		break;  	case TypeSigTag.I1:  		check (1);  		Value = reader.ReadSByte ();  		break;  	case TypeSigTag.U1:  		check (1);  		Value = reader.ReadByte ();  		break;  	case TypeSigTag.I2:  		check (2);  		Value = reader.ReadInt16 ();  		break;  	case TypeSigTag.U2:  		check (2);  		Value = reader.ReadUInt16 ();  		break;  	case TypeSigTag.I4:  		check (4);  		Value = reader.ReadInt32 ();  		break;  	case TypeSigTag.U4:  		check (4);  		Value = reader.ReadUInt32 ();  		break;  	case TypeSigTag.I8:  		check (8);  		Value = reader.ReadInt64 ();  		break;  	case TypeSigTag.U8:  		check (8);  		Value = reader.ReadUInt64 ();  		break;  	case TypeSigTag.R4:  		check (4);  		Value = reader.ReadSingle ();  		break;  	case TypeSigTag.R8:  		check (8);  		Value = reader.ReadDouble ();  		break;  	case TypeSigTag.STRING:  		Value = reader.ReadUTF16SizedString ();  		break;  	case TypeSigTag.CLASS:  		check (4);  		var zero = reader.ReadUInt32 ();  		if (zero != 0)  			throw new PEException ("expected zero for constant of class type");  		Value = null;  		break;  	default:  		throw new PEException ("unexpected constant tag");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (Offset == 0)  	Value = null;  else {  	var reader = ctxt.GetBlobReader ();  	reader.Offset = Offset;  	Action<int> check = expected =>  {  		var actual = reader.ReadCompressedUInt32 ();  		if (actual != expected)  			throw new PEException ("mismatched constant and type");  	};  	switch (tag) {  	case TypeSigTag.BOOLEAN:  		check (1);  		Value = reader.ReadByte () == 0 ? false : true;  		break;  	case TypeSigTag.CHAR:  		check (2);  		Value = (char)reader.ReadUInt16 ();  		break;  	case TypeSigTag.I1:  		check (1);  		Value = reader.ReadSByte ();  		break;  	case TypeSigTag.U1:  		check (1);  		Value = reader.ReadByte ();  		break;  	case TypeSigTag.I2:  		check (2);  		Value = reader.ReadInt16 ();  		break;  	case TypeSigTag.U2:  		check (2);  		Value = reader.ReadUInt16 ();  		break;  	case TypeSigTag.I4:  		check (4);  		Value = reader.ReadInt32 ();  		break;  	case TypeSigTag.U4:  		check (4);  		Value = reader.ReadUInt32 ();  		break;  	case TypeSigTag.I8:  		check (8);  		Value = reader.ReadInt64 ();  		break;  	case TypeSigTag.U8:  		check (8);  		Value = reader.ReadUInt64 ();  		break;  	case TypeSigTag.R4:  		check (4);  		Value = reader.ReadSingle ();  		break;  	case TypeSigTag.R8:  		check (8);  		Value = reader.ReadDouble ();  		break;  	case TypeSigTag.STRING:  		Value = reader.ReadUTF16SizedString ();  		break;  	case TypeSigTag.CLASS:  		check (4);  		var zero = reader.ReadUInt32 ();  		if (zero != 0)  			throw new PEException ("expected zero for constant of class type");  		Value = null;  		break;  	default:  		throw new PEException ("unexpected constant tag");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (Offset == 0)  	Value = null;  else {  	var reader = ctxt.GetBlobReader ();  	reader.Offset = Offset;  	Action<int> check = expected =>  {  		var actual = reader.ReadCompressedUInt32 ();  		if (actual != expected)  			throw new PEException ("mismatched constant and type");  	};  	switch (tag) {  	case TypeSigTag.BOOLEAN:  		check (1);  		Value = reader.ReadByte () == 0 ? false : true;  		break;  	case TypeSigTag.CHAR:  		check (2);  		Value = (char)reader.ReadUInt16 ();  		break;  	case TypeSigTag.I1:  		check (1);  		Value = reader.ReadSByte ();  		break;  	case TypeSigTag.U1:  		check (1);  		Value = reader.ReadByte ();  		break;  	case TypeSigTag.I2:  		check (2);  		Value = reader.ReadInt16 ();  		break;  	case TypeSigTag.U2:  		check (2);  		Value = reader.ReadUInt16 ();  		break;  	case TypeSigTag.I4:  		check (4);  		Value = reader.ReadInt32 ();  		break;  	case TypeSigTag.U4:  		check (4);  		Value = reader.ReadUInt32 ();  		break;  	case TypeSigTag.I8:  		check (8);  		Value = reader.ReadInt64 ();  		break;  	case TypeSigTag.U8:  		check (8);  		Value = reader.ReadUInt64 ();  		break;  	case TypeSigTag.R4:  		check (4);  		Value = reader.ReadSingle ();  		break;  	case TypeSigTag.R8:  		check (8);  		Value = reader.ReadDouble ();  		break;  	case TypeSigTag.STRING:  		Value = reader.ReadUTF16SizedString ();  		break;  	case TypeSigTag.CLASS:  		check (4);  		var zero = reader.ReadUInt32 ();  		if (zero != 0)  			throw new PEException ("expected zero for constant of class type");  		Value = null;  		break;  	default:  		throw new PEException ("unexpected constant tag");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (Offset == 0)  	Value = null;  else {  	var reader = ctxt.GetBlobReader ();  	reader.Offset = Offset;  	Action<int> check = expected =>  {  		var actual = reader.ReadCompressedUInt32 ();  		if (actual != expected)  			throw new PEException ("mismatched constant and type");  	};  	switch (tag) {  	case TypeSigTag.BOOLEAN:  		check (1);  		Value = reader.ReadByte () == 0 ? false : true;  		break;  	case TypeSigTag.CHAR:  		check (2);  		Value = (char)reader.ReadUInt16 ();  		break;  	case TypeSigTag.I1:  		check (1);  		Value = reader.ReadSByte ();  		break;  	case TypeSigTag.U1:  		check (1);  		Value = reader.ReadByte ();  		break;  	case TypeSigTag.I2:  		check (2);  		Value = reader.ReadInt16 ();  		break;  	case TypeSigTag.U2:  		check (2);  		Value = reader.ReadUInt16 ();  		break;  	case TypeSigTag.I4:  		check (4);  		Value = reader.ReadInt32 ();  		break;  	case TypeSigTag.U4:  		check (4);  		Value = reader.ReadUInt32 ();  		break;  	case TypeSigTag.I8:  		check (8);  		Value = reader.ReadInt64 ();  		break;  	case TypeSigTag.U8:  		check (8);  		Value = reader.ReadUInt64 ();  		break;  	case TypeSigTag.R4:  		check (4);  		Value = reader.ReadSingle ();  		break;  	case TypeSigTag.R8:  		check (8);  		Value = reader.ReadDouble ();  		break;  	case TypeSigTag.STRING:  		Value = reader.ReadUTF16SizedString ();  		break;  	case TypeSigTag.CLASS:  		check (4);  		var zero = reader.ReadUInt32 ();  		if (zero != 0)  			throw new PEException ("expected zero for constant of class type");  		Value = null;  		break;  	default:  		throw new PEException ("unexpected constant tag");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (Offset == 0)  	Value = null;  else {  	var reader = ctxt.GetBlobReader ();  	reader.Offset = Offset;  	Action<int> check = expected =>  {  		var actual = reader.ReadCompressedUInt32 ();  		if (actual != expected)  			throw new PEException ("mismatched constant and type");  	};  	switch (tag) {  	case TypeSigTag.BOOLEAN:  		check (1);  		Value = reader.ReadByte () == 0 ? false : true;  		break;  	case TypeSigTag.CHAR:  		check (2);  		Value = (char)reader.ReadUInt16 ();  		break;  	case TypeSigTag.I1:  		check (1);  		Value = reader.ReadSByte ();  		break;  	case TypeSigTag.U1:  		check (1);  		Value = reader.ReadByte ();  		break;  	case TypeSigTag.I2:  		check (2);  		Value = reader.ReadInt16 ();  		break;  	case TypeSigTag.U2:  		check (2);  		Value = reader.ReadUInt16 ();  		break;  	case TypeSigTag.I4:  		check (4);  		Value = reader.ReadInt32 ();  		break;  	case TypeSigTag.U4:  		check (4);  		Value = reader.ReadUInt32 ();  		break;  	case TypeSigTag.I8:  		check (8);  		Value = reader.ReadInt64 ();  		break;  	case TypeSigTag.U8:  		check (8);  		Value = reader.ReadUInt64 ();  		break;  	case TypeSigTag.R4:  		check (4);  		Value = reader.ReadSingle ();  		break;  	case TypeSigTag.R8:  		check (8);  		Value = reader.ReadDouble ();  		break;  	case TypeSigTag.STRING:  		Value = reader.ReadUTF16SizedString ();  		break;  	case TypeSigTag.CLASS:  		check (4);  		var zero = reader.ReadUInt32 ();  		if (zero != 0)  			throw new PEException ("expected zero for constant of class type");  		Value = null;  		break;  	default:  		throw new PEException ("unexpected constant tag");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (Offset == 0)  	Value = null;  else {  	var reader = ctxt.GetBlobReader ();  	reader.Offset = Offset;  	Action<int> check = expected =>  {  		var actual = reader.ReadCompressedUInt32 ();  		if (actual != expected)  			throw new PEException ("mismatched constant and type");  	};  	switch (tag) {  	case TypeSigTag.BOOLEAN:  		check (1);  		Value = reader.ReadByte () == 0 ? false : true;  		break;  	case TypeSigTag.CHAR:  		check (2);  		Value = (char)reader.ReadUInt16 ();  		break;  	case TypeSigTag.I1:  		check (1);  		Value = reader.ReadSByte ();  		break;  	case TypeSigTag.U1:  		check (1);  		Value = reader.ReadByte ();  		break;  	case TypeSigTag.I2:  		check (2);  		Value = reader.ReadInt16 ();  		break;  	case TypeSigTag.U2:  		check (2);  		Value = reader.ReadUInt16 ();  		break;  	case TypeSigTag.I4:  		check (4);  		Value = reader.ReadInt32 ();  		break;  	case TypeSigTag.U4:  		check (4);  		Value = reader.ReadUInt32 ();  		break;  	case TypeSigTag.I8:  		check (8);  		Value = reader.ReadInt64 ();  		break;  	case TypeSigTag.U8:  		check (8);  		Value = reader.ReadUInt64 ();  		break;  	case TypeSigTag.R4:  		check (4);  		Value = reader.ReadSingle ();  		break;  	case TypeSigTag.R8:  		check (8);  		Value = reader.ReadDouble ();  		break;  	case TypeSigTag.STRING:  		Value = reader.ReadUTF16SizedString ();  		break;  	case TypeSigTag.CLASS:  		check (4);  		var zero = reader.ReadUInt32 ();  		if (zero != 0)  			throw new PEException ("expected zero for constant of class type");  		Value = null;  		break;  	default:  		throw new PEException ("unexpected constant tag");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: switch (tag) {  case TypeSigTag.BOOLEAN:  	check (1);  	Value = reader.ReadByte () == 0 ? false : true;  	break;  case TypeSigTag.CHAR:  	check (2);  	Value = (char)reader.ReadUInt16 ();  	break;  case TypeSigTag.I1:  	check (1);  	Value = reader.ReadSByte ();  	break;  case TypeSigTag.U1:  	check (1);  	Value = reader.ReadByte ();  	break;  case TypeSigTag.I2:  	check (2);  	Value = reader.ReadInt16 ();  	break;  case TypeSigTag.U2:  	check (2);  	Value = reader.ReadUInt16 ();  	break;  case TypeSigTag.I4:  	check (4);  	Value = reader.ReadInt32 ();  	break;  case TypeSigTag.U4:  	check (4);  	Value = reader.ReadUInt32 ();  	break;  case TypeSigTag.I8:  	check (8);  	Value = reader.ReadInt64 ();  	break;  case TypeSigTag.U8:  	check (8);  	Value = reader.ReadUInt64 ();  	break;  case TypeSigTag.R4:  	check (4);  	Value = reader.ReadSingle ();  	break;  case TypeSigTag.R8:  	check (8);  	Value = reader.ReadDouble ();  	break;  case TypeSigTag.STRING:  	Value = reader.ReadUTF16SizedString ();  	break;  case TypeSigTag.CLASS:  	check (4);  	var zero = reader.ReadUInt32 ();  	if (zero != 0)  		throw new PEException ("expected zero for constant of class type");  	Value = null;  	break;  default:  	throw new PEException ("unexpected constant tag");  }  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: switch (tag) {  case TypeSigTag.BOOLEAN:  	check (1);  	Value = reader.ReadByte () == 0 ? false : true;  	break;  case TypeSigTag.CHAR:  	check (2);  	Value = (char)reader.ReadUInt16 ();  	break;  case TypeSigTag.I1:  	check (1);  	Value = reader.ReadSByte ();  	break;  case TypeSigTag.U1:  	check (1);  	Value = reader.ReadByte ();  	break;  case TypeSigTag.I2:  	check (2);  	Value = reader.ReadInt16 ();  	break;  case TypeSigTag.U2:  	check (2);  	Value = reader.ReadUInt16 ();  	break;  case TypeSigTag.I4:  	check (4);  	Value = reader.ReadInt32 ();  	break;  case TypeSigTag.U4:  	check (4);  	Value = reader.ReadUInt32 ();  	break;  case TypeSigTag.I8:  	check (8);  	Value = reader.ReadInt64 ();  	break;  case TypeSigTag.U8:  	check (8);  	Value = reader.ReadUInt64 ();  	break;  case TypeSigTag.R4:  	check (4);  	Value = reader.ReadSingle ();  	break;  case TypeSigTag.R8:  	check (8);  	Value = reader.ReadDouble ();  	break;  case TypeSigTag.STRING:  	Value = reader.ReadUTF16SizedString ();  	break;  case TypeSigTag.CLASS:  	check (4);  	var zero = reader.ReadUInt32 ();  	if (zero != 0)  		throw new PEException ("expected zero for constant of class type");  	Value = null;  	break;  default:  	throw new PEException ("unexpected constant tag");  }  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: switch (tag) {  case TypeSigTag.BOOLEAN:  	check (1);  	Value = reader.ReadByte () == 0 ? false : true;  	break;  case TypeSigTag.CHAR:  	check (2);  	Value = (char)reader.ReadUInt16 ();  	break;  case TypeSigTag.I1:  	check (1);  	Value = reader.ReadSByte ();  	break;  case TypeSigTag.U1:  	check (1);  	Value = reader.ReadByte ();  	break;  case TypeSigTag.I2:  	check (2);  	Value = reader.ReadInt16 ();  	break;  case TypeSigTag.U2:  	check (2);  	Value = reader.ReadUInt16 ();  	break;  case TypeSigTag.I4:  	check (4);  	Value = reader.ReadInt32 ();  	break;  case TypeSigTag.U4:  	check (4);  	Value = reader.ReadUInt32 ();  	break;  case TypeSigTag.I8:  	check (8);  	Value = reader.ReadInt64 ();  	break;  case TypeSigTag.U8:  	check (8);  	Value = reader.ReadUInt64 ();  	break;  case TypeSigTag.R4:  	check (4);  	Value = reader.ReadSingle ();  	break;  case TypeSigTag.R8:  	check (8);  	Value = reader.ReadDouble ();  	break;  case TypeSigTag.STRING:  	Value = reader.ReadUTF16SizedString ();  	break;  case TypeSigTag.CLASS:  	check (4);  	var zero = reader.ReadUInt32 ();  	if (zero != 0)  		throw new PEException ("expected zero for constant of class type");  	Value = null;  	break;  default:  	throw new PEException ("unexpected constant tag");  }  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: switch (tag) {  case TypeSigTag.BOOLEAN:  	check (1);  	Value = reader.ReadByte () == 0 ? false : true;  	break;  case TypeSigTag.CHAR:  	check (2);  	Value = (char)reader.ReadUInt16 ();  	break;  case TypeSigTag.I1:  	check (1);  	Value = reader.ReadSByte ();  	break;  case TypeSigTag.U1:  	check (1);  	Value = reader.ReadByte ();  	break;  case TypeSigTag.I2:  	check (2);  	Value = reader.ReadInt16 ();  	break;  case TypeSigTag.U2:  	check (2);  	Value = reader.ReadUInt16 ();  	break;  case TypeSigTag.I4:  	check (4);  	Value = reader.ReadInt32 ();  	break;  case TypeSigTag.U4:  	check (4);  	Value = reader.ReadUInt32 ();  	break;  case TypeSigTag.I8:  	check (8);  	Value = reader.ReadInt64 ();  	break;  case TypeSigTag.U8:  	check (8);  	Value = reader.ReadUInt64 ();  	break;  case TypeSigTag.R4:  	check (4);  	Value = reader.ReadSingle ();  	break;  case TypeSigTag.R8:  	check (8);  	Value = reader.ReadDouble ();  	break;  case TypeSigTag.STRING:  	Value = reader.ReadUTF16SizedString ();  	break;  case TypeSigTag.CLASS:  	check (4);  	var zero = reader.ReadUInt32 ();  	if (zero != 0)  		throw new PEException ("expected zero for constant of class type");  	Value = null;  	break;  default:  	throw new PEException ("unexpected constant tag");  }  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: switch (tag) {  case TypeSigTag.BOOLEAN:  	check (1);  	Value = reader.ReadByte () == 0 ? false : true;  	break;  case TypeSigTag.CHAR:  	check (2);  	Value = (char)reader.ReadUInt16 ();  	break;  case TypeSigTag.I1:  	check (1);  	Value = reader.ReadSByte ();  	break;  case TypeSigTag.U1:  	check (1);  	Value = reader.ReadByte ();  	break;  case TypeSigTag.I2:  	check (2);  	Value = reader.ReadInt16 ();  	break;  case TypeSigTag.U2:  	check (2);  	Value = reader.ReadUInt16 ();  	break;  case TypeSigTag.I4:  	check (4);  	Value = reader.ReadInt32 ();  	break;  case TypeSigTag.U4:  	check (4);  	Value = reader.ReadUInt32 ();  	break;  case TypeSigTag.I8:  	check (8);  	Value = reader.ReadInt64 ();  	break;  case TypeSigTag.U8:  	check (8);  	Value = reader.ReadUInt64 ();  	break;  case TypeSigTag.R4:  	check (4);  	Value = reader.ReadSingle ();  	break;  case TypeSigTag.R8:  	check (8);  	Value = reader.ReadDouble ();  	break;  case TypeSigTag.STRING:  	Value = reader.ReadUTF16SizedString ();  	break;  case TypeSigTag.CLASS:  	check (4);  	var zero = reader.ReadUInt32 ();  	if (zero != 0)  		throw new PEException ("expected zero for constant of class type");  	Value = null;  	break;  default:  	throw new PEException ("unexpected constant tag");  }  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: switch (tag) {  case TypeSigTag.BOOLEAN:  	check (1);  	Value = reader.ReadByte () == 0 ? false : true;  	break;  case TypeSigTag.CHAR:  	check (2);  	Value = (char)reader.ReadUInt16 ();  	break;  case TypeSigTag.I1:  	check (1);  	Value = reader.ReadSByte ();  	break;  case TypeSigTag.U1:  	check (1);  	Value = reader.ReadByte ();  	break;  case TypeSigTag.I2:  	check (2);  	Value = reader.ReadInt16 ();  	break;  case TypeSigTag.U2:  	check (2);  	Value = reader.ReadUInt16 ();  	break;  case TypeSigTag.I4:  	check (4);  	Value = reader.ReadInt32 ();  	break;  case TypeSigTag.U4:  	check (4);  	Value = reader.ReadUInt32 ();  	break;  case TypeSigTag.I8:  	check (8);  	Value = reader.ReadInt64 ();  	break;  case TypeSigTag.U8:  	check (8);  	Value = reader.ReadUInt64 ();  	break;  case TypeSigTag.R4:  	check (4);  	Value = reader.ReadSingle ();  	break;  case TypeSigTag.R8:  	check (8);  	Value = reader.ReadDouble ();  	break;  case TypeSigTag.STRING:  	Value = reader.ReadUTF16SizedString ();  	break;  case TypeSigTag.CLASS:  	check (4);  	var zero = reader.ReadUInt32 ();  	if (zero != 0)  		throw new PEException ("expected zero for constant of class type");  	Value = null;  	break;  default:  	throw new PEException ("unexpected constant tag");  }  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: switch (tag) {  case TypeSigTag.BOOLEAN:  	check (1);  	Value = reader.ReadByte () == 0 ? false : true;  	break;  case TypeSigTag.CHAR:  	check (2);  	Value = (char)reader.ReadUInt16 ();  	break;  case TypeSigTag.I1:  	check (1);  	Value = reader.ReadSByte ();  	break;  case TypeSigTag.U1:  	check (1);  	Value = reader.ReadByte ();  	break;  case TypeSigTag.I2:  	check (2);  	Value = reader.ReadInt16 ();  	break;  case TypeSigTag.U2:  	check (2);  	Value = reader.ReadUInt16 ();  	break;  case TypeSigTag.I4:  	check (4);  	Value = reader.ReadInt32 ();  	break;  case TypeSigTag.U4:  	check (4);  	Value = reader.ReadUInt32 ();  	break;  case TypeSigTag.I8:  	check (8);  	Value = reader.ReadInt64 ();  	break;  case TypeSigTag.U8:  	check (8);  	Value = reader.ReadUInt64 ();  	break;  case TypeSigTag.R4:  	check (4);  	Value = reader.ReadSingle ();  	break;  case TypeSigTag.R8:  	check (8);  	Value = reader.ReadDouble ();  	break;  case TypeSigTag.STRING:  	Value = reader.ReadUTF16SizedString ();  	break;  case TypeSigTag.CLASS:  	check (4);  	var zero = reader.ReadUInt32 ();  	if (zero != 0)  		throw new PEException ("expected zero for constant of class type");  	Value = null;  	break;  default:  	throw new PEException ("unexpected constant tag");  }  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: switch (tag) {  case TypeSigTag.BOOLEAN:  	check (1);  	Value = reader.ReadByte () == 0 ? false : true;  	break;  case TypeSigTag.CHAR:  	check (2);  	Value = (char)reader.ReadUInt16 ();  	break;  case TypeSigTag.I1:  	check (1);  	Value = reader.ReadSByte ();  	break;  case TypeSigTag.U1:  	check (1);  	Value = reader.ReadByte ();  	break;  case TypeSigTag.I2:  	check (2);  	Value = reader.ReadInt16 ();  	break;  case TypeSigTag.U2:  	check (2);  	Value = reader.ReadUInt16 ();  	break;  case TypeSigTag.I4:  	check (4);  	Value = reader.ReadInt32 ();  	break;  case TypeSigTag.U4:  	check (4);  	Value = reader.ReadUInt32 ();  	break;  case TypeSigTag.I8:  	check (8);  	Value = reader.ReadInt64 ();  	break;  case TypeSigTag.U8:  	check (8);  	Value = reader.ReadUInt64 ();  	break;  case TypeSigTag.R4:  	check (4);  	Value = reader.ReadSingle ();  	break;  case TypeSigTag.R8:  	check (8);  	Value = reader.ReadDouble ();  	break;  case TypeSigTag.STRING:  	Value = reader.ReadUTF16SizedString ();  	break;  case TypeSigTag.CLASS:  	check (4);  	var zero = reader.ReadUInt32 ();  	if (zero != 0)  		throw new PEException ("expected zero for constant of class type");  	Value = null;  	break;  default:  	throw new PEException ("unexpected constant tag");  }  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: switch (tag) {  case TypeSigTag.BOOLEAN:  	check (1);  	Value = reader.ReadByte () == 0 ? false : true;  	break;  case TypeSigTag.CHAR:  	check (2);  	Value = (char)reader.ReadUInt16 ();  	break;  case TypeSigTag.I1:  	check (1);  	Value = reader.ReadSByte ();  	break;  case TypeSigTag.U1:  	check (1);  	Value = reader.ReadByte ();  	break;  case TypeSigTag.I2:  	check (2);  	Value = reader.ReadInt16 ();  	break;  case TypeSigTag.U2:  	check (2);  	Value = reader.ReadUInt16 ();  	break;  case TypeSigTag.I4:  	check (4);  	Value = reader.ReadInt32 ();  	break;  case TypeSigTag.U4:  	check (4);  	Value = reader.ReadUInt32 ();  	break;  case TypeSigTag.I8:  	check (8);  	Value = reader.ReadInt64 ();  	break;  case TypeSigTag.U8:  	check (8);  	Value = reader.ReadUInt64 ();  	break;  case TypeSigTag.R4:  	check (4);  	Value = reader.ReadSingle ();  	break;  case TypeSigTag.R8:  	check (8);  	Value = reader.ReadDouble ();  	break;  case TypeSigTag.STRING:  	Value = reader.ReadUTF16SizedString ();  	break;  case TypeSigTag.CLASS:  	check (4);  	var zero = reader.ReadUInt32 ();  	if (zero != 0)  		throw new PEException ("expected zero for constant of class type");  	Value = null;  	break;  default:  	throw new PEException ("unexpected constant tag");  }  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: switch (tag) {  case TypeSigTag.BOOLEAN:  	check (1);  	Value = reader.ReadByte () == 0 ? false : true;  	break;  case TypeSigTag.CHAR:  	check (2);  	Value = (char)reader.ReadUInt16 ();  	break;  case TypeSigTag.I1:  	check (1);  	Value = reader.ReadSByte ();  	break;  case TypeSigTag.U1:  	check (1);  	Value = reader.ReadByte ();  	break;  case TypeSigTag.I2:  	check (2);  	Value = reader.ReadInt16 ();  	break;  case TypeSigTag.U2:  	check (2);  	Value = reader.ReadUInt16 ();  	break;  case TypeSigTag.I4:  	check (4);  	Value = reader.ReadInt32 ();  	break;  case TypeSigTag.U4:  	check (4);  	Value = reader.ReadUInt32 ();  	break;  case TypeSigTag.I8:  	check (8);  	Value = reader.ReadInt64 ();  	break;  case TypeSigTag.U8:  	check (8);  	Value = reader.ReadUInt64 ();  	break;  case TypeSigTag.R4:  	check (4);  	Value = reader.ReadSingle ();  	break;  case TypeSigTag.R8:  	check (8);  	Value = reader.ReadDouble ();  	break;  case TypeSigTag.STRING:  	Value = reader.ReadUTF16SizedString ();  	break;  case TypeSigTag.CLASS:  	check (4);  	var zero = reader.ReadUInt32 ();  	if (zero != 0)  		throw new PEException ("expected zero for constant of class type");  	Value = null;  	break;  default:  	throw new PEException ("unexpected constant tag");  }  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: check (2);  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: check (2);  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: check (2);  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: check (4);  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: check (4);  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: check (8);  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: check (8);  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: check (4);  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: check (8);  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: check (4);  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	Offset = 0;  else {  	var writer = ctxt.GetBlobWriter ();  	Offset = writer.Offset;  	switch (tag) {  	case TypeSigTag.BOOLEAN: {  		var b = (bool)Value;  		writer.WriteCompressedUInt32 (1);  		writer.WriteByte (b ? (byte)0 : (byte)1);  		break;  	}  	case TypeSigTag.CHAR: {  		var c = (char)Value;  		writer.WriteCompressedUInt32 (2);  		writer.WriteUInt16 ((ushort)c);  		break;  	}  	case TypeSigTag.I1: {  		var i = (sbyte)Value;  		writer.WriteCompressedUInt32 (1);  		writer.WriteSByte (i);  		break;  	}  	case TypeSigTag.U1: {  		var i = (byte)Value;  		writer.WriteCompressedUInt32 (1);  		writer.WriteByte (i);  		break;  	}  	case TypeSigTag.I2: {  		var i = (short)Value;  		writer.WriteCompressedUInt32 (2);  		writer.WriteInt16 (i);  		break;  	}  	case TypeSigTag.U2: {  		var i = (ushort)Value;  		writer.WriteCompressedUInt32 (2);  		writer.WriteUInt16 (i);  		break;  	}  	case TypeSigTag.I4: {  		var i = (int)Value;  		writer.WriteCompressedUInt32 (4);  		writer.WriteInt32 (i);  		break;  	}  	case TypeSigTag.U4: {  		var i = (uint)Value;  		writer.WriteCompressedUInt32 (4);  		writer.WriteUInt32 (i);  		break;  	}  	case TypeSigTag.I8: {  		var i = (long)Value;  		writer.WriteCompressedUInt32 (8);  		writer.WriteInt64 (i);  		break;  	}  	case TypeSigTag.U8: {  		var i = (ulong)Value;  		writer.WriteCompressedUInt32 (8);  		writer.WriteUInt64 (i);  		break;  	}  	case TypeSigTag.R4: {  		var f = (float)Value;  		writer.WriteCompressedUInt32 (4);  		writer.WriteSingle (f);  		break;  	}  	case TypeSigTag.R8: {  		var d = (double)Value;  		writer.WriteCompressedUInt32 (8);  		writer.WriteDouble (d);  		break;  	}  	case TypeSigTag.STRING: {  		var s = (string)Value;  		writer.WriteUTF16SizedString (s);  		break;  	}  	case TypeSigTag.CLASS: {  		Offset = 0;  		writer.WriteCompressedUInt32 (4);  		writer.WriteUInt32 (0);  		break;  	}  	default:  		throw new PEException ("unexpected constant type");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	Offset = 0;  else {  	var writer = ctxt.GetBlobWriter ();  	Offset = writer.Offset;  	switch (tag) {  	case TypeSigTag.BOOLEAN: {  		var b = (bool)Value;  		writer.WriteCompressedUInt32 (1);  		writer.WriteByte (b ? (byte)0 : (byte)1);  		break;  	}  	case TypeSigTag.CHAR: {  		var c = (char)Value;  		writer.WriteCompressedUInt32 (2);  		writer.WriteUInt16 ((ushort)c);  		break;  	}  	case TypeSigTag.I1: {  		var i = (sbyte)Value;  		writer.WriteCompressedUInt32 (1);  		writer.WriteSByte (i);  		break;  	}  	case TypeSigTag.U1: {  		var i = (byte)Value;  		writer.WriteCompressedUInt32 (1);  		writer.WriteByte (i);  		break;  	}  	case TypeSigTag.I2: {  		var i = (short)Value;  		writer.WriteCompressedUInt32 (2);  		writer.WriteInt16 (i);  		break;  	}  	case TypeSigTag.U2: {  		var i = (ushort)Value;  		writer.WriteCompressedUInt32 (2);  		writer.WriteUInt16 (i);  		break;  	}  	case TypeSigTag.I4: {  		var i = (int)Value;  		writer.WriteCompressedUInt32 (4);  		writer.WriteInt32 (i);  		break;  	}  	case TypeSigTag.U4: {  		var i = (uint)Value;  		writer.WriteCompressedUInt32 (4);  		writer.WriteUInt32 (i);  		break;  	}  	case TypeSigTag.I8: {  		var i = (long)Value;  		writer.WriteCompressedUInt32 (8);  		writer.WriteInt64 (i);  		break;  	}  	case TypeSigTag.U8: {  		var i = (ulong)Value;  		writer.WriteCompressedUInt32 (8);  		writer.WriteUInt64 (i);  		break;  	}  	case TypeSigTag.R4: {  		var f = (float)Value;  		writer.WriteCompressedUInt32 (4);  		writer.WriteSingle (f);  		break;  	}  	case TypeSigTag.R8: {  		var d = (double)Value;  		writer.WriteCompressedUInt32 (8);  		writer.WriteDouble (d);  		break;  	}  	case TypeSigTag.STRING: {  		var s = (string)Value;  		writer.WriteUTF16SizedString (s);  		break;  	}  	case TypeSigTag.CLASS: {  		Offset = 0;  		writer.WriteCompressedUInt32 (4);  		writer.WriteUInt32 (0);  		break;  	}  	default:  		throw new PEException ("unexpected constant type");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	Offset = 0;  else {  	var writer = ctxt.GetBlobWriter ();  	Offset = writer.Offset;  	switch (tag) {  	case TypeSigTag.BOOLEAN: {  		var b = (bool)Value;  		writer.WriteCompressedUInt32 (1);  		writer.WriteByte (b ? (byte)0 : (byte)1);  		break;  	}  	case TypeSigTag.CHAR: {  		var c = (char)Value;  		writer.WriteCompressedUInt32 (2);  		writer.WriteUInt16 ((ushort)c);  		break;  	}  	case TypeSigTag.I1: {  		var i = (sbyte)Value;  		writer.WriteCompressedUInt32 (1);  		writer.WriteSByte (i);  		break;  	}  	case TypeSigTag.U1: {  		var i = (byte)Value;  		writer.WriteCompressedUInt32 (1);  		writer.WriteByte (i);  		break;  	}  	case TypeSigTag.I2: {  		var i = (short)Value;  		writer.WriteCompressedUInt32 (2);  		writer.WriteInt16 (i);  		break;  	}  	case TypeSigTag.U2: {  		var i = (ushort)Value;  		writer.WriteCompressedUInt32 (2);  		writer.WriteUInt16 (i);  		break;  	}  	case TypeSigTag.I4: {  		var i = (int)Value;  		writer.WriteCompressedUInt32 (4);  		writer.WriteInt32 (i);  		break;  	}  	case TypeSigTag.U4: {  		var i = (uint)Value;  		writer.WriteCompressedUInt32 (4);  		writer.WriteUInt32 (i);  		break;  	}  	case TypeSigTag.I8: {  		var i = (long)Value;  		writer.WriteCompressedUInt32 (8);  		writer.WriteInt64 (i);  		break;  	}  	case TypeSigTag.U8: {  		var i = (ulong)Value;  		writer.WriteCompressedUInt32 (8);  		writer.WriteUInt64 (i);  		break;  	}  	case TypeSigTag.R4: {  		var f = (float)Value;  		writer.WriteCompressedUInt32 (4);  		writer.WriteSingle (f);  		break;  	}  	case TypeSigTag.R8: {  		var d = (double)Value;  		writer.WriteCompressedUInt32 (8);  		writer.WriteDouble (d);  		break;  	}  	case TypeSigTag.STRING: {  		var s = (string)Value;  		writer.WriteUTF16SizedString (s);  		break;  	}  	case TypeSigTag.CLASS: {  		Offset = 0;  		writer.WriteCompressedUInt32 (4);  		writer.WriteUInt32 (0);  		break;  	}  	default:  		throw new PEException ("unexpected constant type");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	Offset = 0;  else {  	var writer = ctxt.GetBlobWriter ();  	Offset = writer.Offset;  	switch (tag) {  	case TypeSigTag.BOOLEAN: {  		var b = (bool)Value;  		writer.WriteCompressedUInt32 (1);  		writer.WriteByte (b ? (byte)0 : (byte)1);  		break;  	}  	case TypeSigTag.CHAR: {  		var c = (char)Value;  		writer.WriteCompressedUInt32 (2);  		writer.WriteUInt16 ((ushort)c);  		break;  	}  	case TypeSigTag.I1: {  		var i = (sbyte)Value;  		writer.WriteCompressedUInt32 (1);  		writer.WriteSByte (i);  		break;  	}  	case TypeSigTag.U1: {  		var i = (byte)Value;  		writer.WriteCompressedUInt32 (1);  		writer.WriteByte (i);  		break;  	}  	case TypeSigTag.I2: {  		var i = (short)Value;  		writer.WriteCompressedUInt32 (2);  		writer.WriteInt16 (i);  		break;  	}  	case TypeSigTag.U2: {  		var i = (ushort)Value;  		writer.WriteCompressedUInt32 (2);  		writer.WriteUInt16 (i);  		break;  	}  	case TypeSigTag.I4: {  		var i = (int)Value;  		writer.WriteCompressedUInt32 (4);  		writer.WriteInt32 (i);  		break;  	}  	case TypeSigTag.U4: {  		var i = (uint)Value;  		writer.WriteCompressedUInt32 (4);  		writer.WriteUInt32 (i);  		break;  	}  	case TypeSigTag.I8: {  		var i = (long)Value;  		writer.WriteCompressedUInt32 (8);  		writer.WriteInt64 (i);  		break;  	}  	case TypeSigTag.U8: {  		var i = (ulong)Value;  		writer.WriteCompressedUInt32 (8);  		writer.WriteUInt64 (i);  		break;  	}  	case TypeSigTag.R4: {  		var f = (float)Value;  		writer.WriteCompressedUInt32 (4);  		writer.WriteSingle (f);  		break;  	}  	case TypeSigTag.R8: {  		var d = (double)Value;  		writer.WriteCompressedUInt32 (8);  		writer.WriteDouble (d);  		break;  	}  	case TypeSigTag.STRING: {  		var s = (string)Value;  		writer.WriteUTF16SizedString (s);  		break;  	}  	case TypeSigTag.CLASS: {  		Offset = 0;  		writer.WriteCompressedUInt32 (4);  		writer.WriteUInt32 (0);  		break;  	}  	default:  		throw new PEException ("unexpected constant type");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	Offset = 0;  else {  	var writer = ctxt.GetBlobWriter ();  	Offset = writer.Offset;  	switch (tag) {  	case TypeSigTag.BOOLEAN: {  		var b = (bool)Value;  		writer.WriteCompressedUInt32 (1);  		writer.WriteByte (b ? (byte)0 : (byte)1);  		break;  	}  	case TypeSigTag.CHAR: {  		var c = (char)Value;  		writer.WriteCompressedUInt32 (2);  		writer.WriteUInt16 ((ushort)c);  		break;  	}  	case TypeSigTag.I1: {  		var i = (sbyte)Value;  		writer.WriteCompressedUInt32 (1);  		writer.WriteSByte (i);  		break;  	}  	case TypeSigTag.U1: {  		var i = (byte)Value;  		writer.WriteCompressedUInt32 (1);  		writer.WriteByte (i);  		break;  	}  	case TypeSigTag.I2: {  		var i = (short)Value;  		writer.WriteCompressedUInt32 (2);  		writer.WriteInt16 (i);  		break;  	}  	case TypeSigTag.U2: {  		var i = (ushort)Value;  		writer.WriteCompressedUInt32 (2);  		writer.WriteUInt16 (i);  		break;  	}  	case TypeSigTag.I4: {  		var i = (int)Value;  		writer.WriteCompressedUInt32 (4);  		writer.WriteInt32 (i);  		break;  	}  	case TypeSigTag.U4: {  		var i = (uint)Value;  		writer.WriteCompressedUInt32 (4);  		writer.WriteUInt32 (i);  		break;  	}  	case TypeSigTag.I8: {  		var i = (long)Value;  		writer.WriteCompressedUInt32 (8);  		writer.WriteInt64 (i);  		break;  	}  	case TypeSigTag.U8: {  		var i = (ulong)Value;  		writer.WriteCompressedUInt32 (8);  		writer.WriteUInt64 (i);  		break;  	}  	case TypeSigTag.R4: {  		var f = (float)Value;  		writer.WriteCompressedUInt32 (4);  		writer.WriteSingle (f);  		break;  	}  	case TypeSigTag.R8: {  		var d = (double)Value;  		writer.WriteCompressedUInt32 (8);  		writer.WriteDouble (d);  		break;  	}  	case TypeSigTag.STRING: {  		var s = (string)Value;  		writer.WriteUTF16SizedString (s);  		break;  	}  	case TypeSigTag.CLASS: {  		Offset = 0;  		writer.WriteCompressedUInt32 (4);  		writer.WriteUInt32 (0);  		break;  	}  	default:  		throw new PEException ("unexpected constant type");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	Offset = 0;  else {  	var writer = ctxt.GetBlobWriter ();  	Offset = writer.Offset;  	switch (tag) {  	case TypeSigTag.BOOLEAN: {  		var b = (bool)Value;  		writer.WriteCompressedUInt32 (1);  		writer.WriteByte (b ? (byte)0 : (byte)1);  		break;  	}  	case TypeSigTag.CHAR: {  		var c = (char)Value;  		writer.WriteCompressedUInt32 (2);  		writer.WriteUInt16 ((ushort)c);  		break;  	}  	case TypeSigTag.I1: {  		var i = (sbyte)Value;  		writer.WriteCompressedUInt32 (1);  		writer.WriteSByte (i);  		break;  	}  	case TypeSigTag.U1: {  		var i = (byte)Value;  		writer.WriteCompressedUInt32 (1);  		writer.WriteByte (i);  		break;  	}  	case TypeSigTag.I2: {  		var i = (short)Value;  		writer.WriteCompressedUInt32 (2);  		writer.WriteInt16 (i);  		break;  	}  	case TypeSigTag.U2: {  		var i = (ushort)Value;  		writer.WriteCompressedUInt32 (2);  		writer.WriteUInt16 (i);  		break;  	}  	case TypeSigTag.I4: {  		var i = (int)Value;  		writer.WriteCompressedUInt32 (4);  		writer.WriteInt32 (i);  		break;  	}  	case TypeSigTag.U4: {  		var i = (uint)Value;  		writer.WriteCompressedUInt32 (4);  		writer.WriteUInt32 (i);  		break;  	}  	case TypeSigTag.I8: {  		var i = (long)Value;  		writer.WriteCompressedUInt32 (8);  		writer.WriteInt64 (i);  		break;  	}  	case TypeSigTag.U8: {  		var i = (ulong)Value;  		writer.WriteCompressedUInt32 (8);  		writer.WriteUInt64 (i);  		break;  	}  	case TypeSigTag.R4: {  		var f = (float)Value;  		writer.WriteCompressedUInt32 (4);  		writer.WriteSingle (f);  		break;  	}  	case TypeSigTag.R8: {  		var d = (double)Value;  		writer.WriteCompressedUInt32 (8);  		writer.WriteDouble (d);  		break;  	}  	case TypeSigTag.STRING: {  		var s = (string)Value;  		writer.WriteUTF16SizedString (s);  		break;  	}  	case TypeSigTag.CLASS: {  		Offset = 0;  		writer.WriteCompressedUInt32 (4);  		writer.WriteUInt32 (0);  		break;  	}  	default:  		throw new PEException ("unexpected constant type");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	Offset = 0;  else {  	var writer = ctxt.GetBlobWriter ();  	Offset = writer.Offset;  	switch (tag) {  	case TypeSigTag.BOOLEAN: {  		var b = (bool)Value;  		writer.WriteCompressedUInt32 (1);  		writer.WriteByte (b ? (byte)0 : (byte)1);  		break;  	}  	case TypeSigTag.CHAR: {  		var c = (char)Value;  		writer.WriteCompressedUInt32 (2);  		writer.WriteUInt16 ((ushort)c);  		break;  	}  	case TypeSigTag.I1: {  		var i = (sbyte)Value;  		writer.WriteCompressedUInt32 (1);  		writer.WriteSByte (i);  		break;  	}  	case TypeSigTag.U1: {  		var i = (byte)Value;  		writer.WriteCompressedUInt32 (1);  		writer.WriteByte (i);  		break;  	}  	case TypeSigTag.I2: {  		var i = (short)Value;  		writer.WriteCompressedUInt32 (2);  		writer.WriteInt16 (i);  		break;  	}  	case TypeSigTag.U2: {  		var i = (ushort)Value;  		writer.WriteCompressedUInt32 (2);  		writer.WriteUInt16 (i);  		break;  	}  	case TypeSigTag.I4: {  		var i = (int)Value;  		writer.WriteCompressedUInt32 (4);  		writer.WriteInt32 (i);  		break;  	}  	case TypeSigTag.U4: {  		var i = (uint)Value;  		writer.WriteCompressedUInt32 (4);  		writer.WriteUInt32 (i);  		break;  	}  	case TypeSigTag.I8: {  		var i = (long)Value;  		writer.WriteCompressedUInt32 (8);  		writer.WriteInt64 (i);  		break;  	}  	case TypeSigTag.U8: {  		var i = (ulong)Value;  		writer.WriteCompressedUInt32 (8);  		writer.WriteUInt64 (i);  		break;  	}  	case TypeSigTag.R4: {  		var f = (float)Value;  		writer.WriteCompressedUInt32 (4);  		writer.WriteSingle (f);  		break;  	}  	case TypeSigTag.R8: {  		var d = (double)Value;  		writer.WriteCompressedUInt32 (8);  		writer.WriteDouble (d);  		break;  	}  	case TypeSigTag.STRING: {  		var s = (string)Value;  		writer.WriteUTF16SizedString (s);  		break;  	}  	case TypeSigTag.CLASS: {  		Offset = 0;  		writer.WriteCompressedUInt32 (4);  		writer.WriteUInt32 (0);  		break;  	}  	default:  		throw new PEException ("unexpected constant type");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	Offset = 0;  else {  	var writer = ctxt.GetBlobWriter ();  	Offset = writer.Offset;  	switch (tag) {  	case TypeSigTag.BOOLEAN: {  		var b = (bool)Value;  		writer.WriteCompressedUInt32 (1);  		writer.WriteByte (b ? (byte)0 : (byte)1);  		break;  	}  	case TypeSigTag.CHAR: {  		var c = (char)Value;  		writer.WriteCompressedUInt32 (2);  		writer.WriteUInt16 ((ushort)c);  		break;  	}  	case TypeSigTag.I1: {  		var i = (sbyte)Value;  		writer.WriteCompressedUInt32 (1);  		writer.WriteSByte (i);  		break;  	}  	case TypeSigTag.U1: {  		var i = (byte)Value;  		writer.WriteCompressedUInt32 (1);  		writer.WriteByte (i);  		break;  	}  	case TypeSigTag.I2: {  		var i = (short)Value;  		writer.WriteCompressedUInt32 (2);  		writer.WriteInt16 (i);  		break;  	}  	case TypeSigTag.U2: {  		var i = (ushort)Value;  		writer.WriteCompressedUInt32 (2);  		writer.WriteUInt16 (i);  		break;  	}  	case TypeSigTag.I4: {  		var i = (int)Value;  		writer.WriteCompressedUInt32 (4);  		writer.WriteInt32 (i);  		break;  	}  	case TypeSigTag.U4: {  		var i = (uint)Value;  		writer.WriteCompressedUInt32 (4);  		writer.WriteUInt32 (i);  		break;  	}  	case TypeSigTag.I8: {  		var i = (long)Value;  		writer.WriteCompressedUInt32 (8);  		writer.WriteInt64 (i);  		break;  	}  	case TypeSigTag.U8: {  		var i = (ulong)Value;  		writer.WriteCompressedUInt32 (8);  		writer.WriteUInt64 (i);  		break;  	}  	case TypeSigTag.R4: {  		var f = (float)Value;  		writer.WriteCompressedUInt32 (4);  		writer.WriteSingle (f);  		break;  	}  	case TypeSigTag.R8: {  		var d = (double)Value;  		writer.WriteCompressedUInt32 (8);  		writer.WriteDouble (d);  		break;  	}  	case TypeSigTag.STRING: {  		var s = (string)Value;  		writer.WriteUTF16SizedString (s);  		break;  	}  	case TypeSigTag.CLASS: {  		Offset = 0;  		writer.WriteCompressedUInt32 (4);  		writer.WriteUInt32 (0);  		break;  	}  	default:  		throw new PEException ("unexpected constant type");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	Offset = 0;  else {  	var writer = ctxt.GetBlobWriter ();  	Offset = writer.Offset;  	switch (tag) {  	case TypeSigTag.BOOLEAN: {  		var b = (bool)Value;  		writer.WriteCompressedUInt32 (1);  		writer.WriteByte (b ? (byte)0 : (byte)1);  		break;  	}  	case TypeSigTag.CHAR: {  		var c = (char)Value;  		writer.WriteCompressedUInt32 (2);  		writer.WriteUInt16 ((ushort)c);  		break;  	}  	case TypeSigTag.I1: {  		var i = (sbyte)Value;  		writer.WriteCompressedUInt32 (1);  		writer.WriteSByte (i);  		break;  	}  	case TypeSigTag.U1: {  		var i = (byte)Value;  		writer.WriteCompressedUInt32 (1);  		writer.WriteByte (i);  		break;  	}  	case TypeSigTag.I2: {  		var i = (short)Value;  		writer.WriteCompressedUInt32 (2);  		writer.WriteInt16 (i);  		break;  	}  	case TypeSigTag.U2: {  		var i = (ushort)Value;  		writer.WriteCompressedUInt32 (2);  		writer.WriteUInt16 (i);  		break;  	}  	case TypeSigTag.I4: {  		var i = (int)Value;  		writer.WriteCompressedUInt32 (4);  		writer.WriteInt32 (i);  		break;  	}  	case TypeSigTag.U4: {  		var i = (uint)Value;  		writer.WriteCompressedUInt32 (4);  		writer.WriteUInt32 (i);  		break;  	}  	case TypeSigTag.I8: {  		var i = (long)Value;  		writer.WriteCompressedUInt32 (8);  		writer.WriteInt64 (i);  		break;  	}  	case TypeSigTag.U8: {  		var i = (ulong)Value;  		writer.WriteCompressedUInt32 (8);  		writer.WriteUInt64 (i);  		break;  	}  	case TypeSigTag.R4: {  		var f = (float)Value;  		writer.WriteCompressedUInt32 (4);  		writer.WriteSingle (f);  		break;  	}  	case TypeSigTag.R8: {  		var d = (double)Value;  		writer.WriteCompressedUInt32 (8);  		writer.WriteDouble (d);  		break;  	}  	case TypeSigTag.STRING: {  		var s = (string)Value;  		writer.WriteUTF16SizedString (s);  		break;  	}  	case TypeSigTag.CLASS: {  		Offset = 0;  		writer.WriteCompressedUInt32 (4);  		writer.WriteUInt32 (0);  		break;  	}  	default:  		throw new PEException ("unexpected constant type");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	Offset = 0;  else {  	var writer = ctxt.GetBlobWriter ();  	Offset = writer.Offset;  	switch (tag) {  	case TypeSigTag.BOOLEAN: {  		var b = (bool)Value;  		writer.WriteCompressedUInt32 (1);  		writer.WriteByte (b ? (byte)0 : (byte)1);  		break;  	}  	case TypeSigTag.CHAR: {  		var c = (char)Value;  		writer.WriteCompressedUInt32 (2);  		writer.WriteUInt16 ((ushort)c);  		break;  	}  	case TypeSigTag.I1: {  		var i = (sbyte)Value;  		writer.WriteCompressedUInt32 (1);  		writer.WriteSByte (i);  		break;  	}  	case TypeSigTag.U1: {  		var i = (byte)Value;  		writer.WriteCompressedUInt32 (1);  		writer.WriteByte (i);  		break;  	}  	case TypeSigTag.I2: {  		var i = (short)Value;  		writer.WriteCompressedUInt32 (2);  		writer.WriteInt16 (i);  		break;  	}  	case TypeSigTag.U2: {  		var i = (ushort)Value;  		writer.WriteCompressedUInt32 (2);  		writer.WriteUInt16 (i);  		break;  	}  	case TypeSigTag.I4: {  		var i = (int)Value;  		writer.WriteCompressedUInt32 (4);  		writer.WriteInt32 (i);  		break;  	}  	case TypeSigTag.U4: {  		var i = (uint)Value;  		writer.WriteCompressedUInt32 (4);  		writer.WriteUInt32 (i);  		break;  	}  	case TypeSigTag.I8: {  		var i = (long)Value;  		writer.WriteCompressedUInt32 (8);  		writer.WriteInt64 (i);  		break;  	}  	case TypeSigTag.U8: {  		var i = (ulong)Value;  		writer.WriteCompressedUInt32 (8);  		writer.WriteUInt64 (i);  		break;  	}  	case TypeSigTag.R4: {  		var f = (float)Value;  		writer.WriteCompressedUInt32 (4);  		writer.WriteSingle (f);  		break;  	}  	case TypeSigTag.R8: {  		var d = (double)Value;  		writer.WriteCompressedUInt32 (8);  		writer.WriteDouble (d);  		break;  	}  	case TypeSigTag.STRING: {  		var s = (string)Value;  		writer.WriteUTF16SizedString (s);  		break;  	}  	case TypeSigTag.CLASS: {  		Offset = 0;  		writer.WriteCompressedUInt32 (4);  		writer.WriteUInt32 (0);  		break;  	}  	default:  		throw new PEException ("unexpected constant type");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (tag) {  case TypeSigTag.BOOLEAN: {  	var b = (bool)Value;  	writer.WriteCompressedUInt32 (1);  	writer.WriteByte (b ? (byte)0 : (byte)1);  	break;  }  case TypeSigTag.CHAR: {  	var c = (char)Value;  	writer.WriteCompressedUInt32 (2);  	writer.WriteUInt16 ((ushort)c);  	break;  }  case TypeSigTag.I1: {  	var i = (sbyte)Value;  	writer.WriteCompressedUInt32 (1);  	writer.WriteSByte (i);  	break;  }  case TypeSigTag.U1: {  	var i = (byte)Value;  	writer.WriteCompressedUInt32 (1);  	writer.WriteByte (i);  	break;  }  case TypeSigTag.I2: {  	var i = (short)Value;  	writer.WriteCompressedUInt32 (2);  	writer.WriteInt16 (i);  	break;  }  case TypeSigTag.U2: {  	var i = (ushort)Value;  	writer.WriteCompressedUInt32 (2);  	writer.WriteUInt16 (i);  	break;  }  case TypeSigTag.I4: {  	var i = (int)Value;  	writer.WriteCompressedUInt32 (4);  	writer.WriteInt32 (i);  	break;  }  case TypeSigTag.U4: {  	var i = (uint)Value;  	writer.WriteCompressedUInt32 (4);  	writer.WriteUInt32 (i);  	break;  }  case TypeSigTag.I8: {  	var i = (long)Value;  	writer.WriteCompressedUInt32 (8);  	writer.WriteInt64 (i);  	break;  }  case TypeSigTag.U8: {  	var i = (ulong)Value;  	writer.WriteCompressedUInt32 (8);  	writer.WriteUInt64 (i);  	break;  }  case TypeSigTag.R4: {  	var f = (float)Value;  	writer.WriteCompressedUInt32 (4);  	writer.WriteSingle (f);  	break;  }  case TypeSigTag.R8: {  	var d = (double)Value;  	writer.WriteCompressedUInt32 (8);  	writer.WriteDouble (d);  	break;  }  case TypeSigTag.STRING: {  	var s = (string)Value;  	writer.WriteUTF16SizedString (s);  	break;  }  case TypeSigTag.CLASS: {  	Offset = 0;  	writer.WriteCompressedUInt32 (4);  	writer.WriteUInt32 (0);  	break;  }  default:  	throw new PEException ("unexpected constant type");  }  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (tag) {  case TypeSigTag.BOOLEAN: {  	var b = (bool)Value;  	writer.WriteCompressedUInt32 (1);  	writer.WriteByte (b ? (byte)0 : (byte)1);  	break;  }  case TypeSigTag.CHAR: {  	var c = (char)Value;  	writer.WriteCompressedUInt32 (2);  	writer.WriteUInt16 ((ushort)c);  	break;  }  case TypeSigTag.I1: {  	var i = (sbyte)Value;  	writer.WriteCompressedUInt32 (1);  	writer.WriteSByte (i);  	break;  }  case TypeSigTag.U1: {  	var i = (byte)Value;  	writer.WriteCompressedUInt32 (1);  	writer.WriteByte (i);  	break;  }  case TypeSigTag.I2: {  	var i = (short)Value;  	writer.WriteCompressedUInt32 (2);  	writer.WriteInt16 (i);  	break;  }  case TypeSigTag.U2: {  	var i = (ushort)Value;  	writer.WriteCompressedUInt32 (2);  	writer.WriteUInt16 (i);  	break;  }  case TypeSigTag.I4: {  	var i = (int)Value;  	writer.WriteCompressedUInt32 (4);  	writer.WriteInt32 (i);  	break;  }  case TypeSigTag.U4: {  	var i = (uint)Value;  	writer.WriteCompressedUInt32 (4);  	writer.WriteUInt32 (i);  	break;  }  case TypeSigTag.I8: {  	var i = (long)Value;  	writer.WriteCompressedUInt32 (8);  	writer.WriteInt64 (i);  	break;  }  case TypeSigTag.U8: {  	var i = (ulong)Value;  	writer.WriteCompressedUInt32 (8);  	writer.WriteUInt64 (i);  	break;  }  case TypeSigTag.R4: {  	var f = (float)Value;  	writer.WriteCompressedUInt32 (4);  	writer.WriteSingle (f);  	break;  }  case TypeSigTag.R8: {  	var d = (double)Value;  	writer.WriteCompressedUInt32 (8);  	writer.WriteDouble (d);  	break;  }  case TypeSigTag.STRING: {  	var s = (string)Value;  	writer.WriteUTF16SizedString (s);  	break;  }  case TypeSigTag.CLASS: {  	Offset = 0;  	writer.WriteCompressedUInt32 (4);  	writer.WriteUInt32 (0);  	break;  }  default:  	throw new PEException ("unexpected constant type");  }  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (tag) {  case TypeSigTag.BOOLEAN: {  	var b = (bool)Value;  	writer.WriteCompressedUInt32 (1);  	writer.WriteByte (b ? (byte)0 : (byte)1);  	break;  }  case TypeSigTag.CHAR: {  	var c = (char)Value;  	writer.WriteCompressedUInt32 (2);  	writer.WriteUInt16 ((ushort)c);  	break;  }  case TypeSigTag.I1: {  	var i = (sbyte)Value;  	writer.WriteCompressedUInt32 (1);  	writer.WriteSByte (i);  	break;  }  case TypeSigTag.U1: {  	var i = (byte)Value;  	writer.WriteCompressedUInt32 (1);  	writer.WriteByte (i);  	break;  }  case TypeSigTag.I2: {  	var i = (short)Value;  	writer.WriteCompressedUInt32 (2);  	writer.WriteInt16 (i);  	break;  }  case TypeSigTag.U2: {  	var i = (ushort)Value;  	writer.WriteCompressedUInt32 (2);  	writer.WriteUInt16 (i);  	break;  }  case TypeSigTag.I4: {  	var i = (int)Value;  	writer.WriteCompressedUInt32 (4);  	writer.WriteInt32 (i);  	break;  }  case TypeSigTag.U4: {  	var i = (uint)Value;  	writer.WriteCompressedUInt32 (4);  	writer.WriteUInt32 (i);  	break;  }  case TypeSigTag.I8: {  	var i = (long)Value;  	writer.WriteCompressedUInt32 (8);  	writer.WriteInt64 (i);  	break;  }  case TypeSigTag.U8: {  	var i = (ulong)Value;  	writer.WriteCompressedUInt32 (8);  	writer.WriteUInt64 (i);  	break;  }  case TypeSigTag.R4: {  	var f = (float)Value;  	writer.WriteCompressedUInt32 (4);  	writer.WriteSingle (f);  	break;  }  case TypeSigTag.R8: {  	var d = (double)Value;  	writer.WriteCompressedUInt32 (8);  	writer.WriteDouble (d);  	break;  }  case TypeSigTag.STRING: {  	var s = (string)Value;  	writer.WriteUTF16SizedString (s);  	break;  }  case TypeSigTag.CLASS: {  	Offset = 0;  	writer.WriteCompressedUInt32 (4);  	writer.WriteUInt32 (0);  	break;  }  default:  	throw new PEException ("unexpected constant type");  }  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (tag) {  case TypeSigTag.BOOLEAN: {  	var b = (bool)Value;  	writer.WriteCompressedUInt32 (1);  	writer.WriteByte (b ? (byte)0 : (byte)1);  	break;  }  case TypeSigTag.CHAR: {  	var c = (char)Value;  	writer.WriteCompressedUInt32 (2);  	writer.WriteUInt16 ((ushort)c);  	break;  }  case TypeSigTag.I1: {  	var i = (sbyte)Value;  	writer.WriteCompressedUInt32 (1);  	writer.WriteSByte (i);  	break;  }  case TypeSigTag.U1: {  	var i = (byte)Value;  	writer.WriteCompressedUInt32 (1);  	writer.WriteByte (i);  	break;  }  case TypeSigTag.I2: {  	var i = (short)Value;  	writer.WriteCompressedUInt32 (2);  	writer.WriteInt16 (i);  	break;  }  case TypeSigTag.U2: {  	var i = (ushort)Value;  	writer.WriteCompressedUInt32 (2);  	writer.WriteUInt16 (i);  	break;  }  case TypeSigTag.I4: {  	var i = (int)Value;  	writer.WriteCompressedUInt32 (4);  	writer.WriteInt32 (i);  	break;  }  case TypeSigTag.U4: {  	var i = (uint)Value;  	writer.WriteCompressedUInt32 (4);  	writer.WriteUInt32 (i);  	break;  }  case TypeSigTag.I8: {  	var i = (long)Value;  	writer.WriteCompressedUInt32 (8);  	writer.WriteInt64 (i);  	break;  }  case TypeSigTag.U8: {  	var i = (ulong)Value;  	writer.WriteCompressedUInt32 (8);  	writer.WriteUInt64 (i);  	break;  }  case TypeSigTag.R4: {  	var f = (float)Value;  	writer.WriteCompressedUInt32 (4);  	writer.WriteSingle (f);  	break;  }  case TypeSigTag.R8: {  	var d = (double)Value;  	writer.WriteCompressedUInt32 (8);  	writer.WriteDouble (d);  	break;  }  case TypeSigTag.STRING: {  	var s = (string)Value;  	writer.WriteUTF16SizedString (s);  	break;  }  case TypeSigTag.CLASS: {  	Offset = 0;  	writer.WriteCompressedUInt32 (4);  	writer.WriteUInt32 (0);  	break;  }  default:  	throw new PEException ("unexpected constant type");  }  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (tag) {  case TypeSigTag.BOOLEAN: {  	var b = (bool)Value;  	writer.WriteCompressedUInt32 (1);  	writer.WriteByte (b ? (byte)0 : (byte)1);  	break;  }  case TypeSigTag.CHAR: {  	var c = (char)Value;  	writer.WriteCompressedUInt32 (2);  	writer.WriteUInt16 ((ushort)c);  	break;  }  case TypeSigTag.I1: {  	var i = (sbyte)Value;  	writer.WriteCompressedUInt32 (1);  	writer.WriteSByte (i);  	break;  }  case TypeSigTag.U1: {  	var i = (byte)Value;  	writer.WriteCompressedUInt32 (1);  	writer.WriteByte (i);  	break;  }  case TypeSigTag.I2: {  	var i = (short)Value;  	writer.WriteCompressedUInt32 (2);  	writer.WriteInt16 (i);  	break;  }  case TypeSigTag.U2: {  	var i = (ushort)Value;  	writer.WriteCompressedUInt32 (2);  	writer.WriteUInt16 (i);  	break;  }  case TypeSigTag.I4: {  	var i = (int)Value;  	writer.WriteCompressedUInt32 (4);  	writer.WriteInt32 (i);  	break;  }  case TypeSigTag.U4: {  	var i = (uint)Value;  	writer.WriteCompressedUInt32 (4);  	writer.WriteUInt32 (i);  	break;  }  case TypeSigTag.I8: {  	var i = (long)Value;  	writer.WriteCompressedUInt32 (8);  	writer.WriteInt64 (i);  	break;  }  case TypeSigTag.U8: {  	var i = (ulong)Value;  	writer.WriteCompressedUInt32 (8);  	writer.WriteUInt64 (i);  	break;  }  case TypeSigTag.R4: {  	var f = (float)Value;  	writer.WriteCompressedUInt32 (4);  	writer.WriteSingle (f);  	break;  }  case TypeSigTag.R8: {  	var d = (double)Value;  	writer.WriteCompressedUInt32 (8);  	writer.WriteDouble (d);  	break;  }  case TypeSigTag.STRING: {  	var s = (string)Value;  	writer.WriteUTF16SizedString (s);  	break;  }  case TypeSigTag.CLASS: {  	Offset = 0;  	writer.WriteCompressedUInt32 (4);  	writer.WriteUInt32 (0);  	break;  }  default:  	throw new PEException ("unexpected constant type");  }  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (tag) {  case TypeSigTag.BOOLEAN: {  	var b = (bool)Value;  	writer.WriteCompressedUInt32 (1);  	writer.WriteByte (b ? (byte)0 : (byte)1);  	break;  }  case TypeSigTag.CHAR: {  	var c = (char)Value;  	writer.WriteCompressedUInt32 (2);  	writer.WriteUInt16 ((ushort)c);  	break;  }  case TypeSigTag.I1: {  	var i = (sbyte)Value;  	writer.WriteCompressedUInt32 (1);  	writer.WriteSByte (i);  	break;  }  case TypeSigTag.U1: {  	var i = (byte)Value;  	writer.WriteCompressedUInt32 (1);  	writer.WriteByte (i);  	break;  }  case TypeSigTag.I2: {  	var i = (short)Value;  	writer.WriteCompressedUInt32 (2);  	writer.WriteInt16 (i);  	break;  }  case TypeSigTag.U2: {  	var i = (ushort)Value;  	writer.WriteCompressedUInt32 (2);  	writer.WriteUInt16 (i);  	break;  }  case TypeSigTag.I4: {  	var i = (int)Value;  	writer.WriteCompressedUInt32 (4);  	writer.WriteInt32 (i);  	break;  }  case TypeSigTag.U4: {  	var i = (uint)Value;  	writer.WriteCompressedUInt32 (4);  	writer.WriteUInt32 (i);  	break;  }  case TypeSigTag.I8: {  	var i = (long)Value;  	writer.WriteCompressedUInt32 (8);  	writer.WriteInt64 (i);  	break;  }  case TypeSigTag.U8: {  	var i = (ulong)Value;  	writer.WriteCompressedUInt32 (8);  	writer.WriteUInt64 (i);  	break;  }  case TypeSigTag.R4: {  	var f = (float)Value;  	writer.WriteCompressedUInt32 (4);  	writer.WriteSingle (f);  	break;  }  case TypeSigTag.R8: {  	var d = (double)Value;  	writer.WriteCompressedUInt32 (8);  	writer.WriteDouble (d);  	break;  }  case TypeSigTag.STRING: {  	var s = (string)Value;  	writer.WriteUTF16SizedString (s);  	break;  }  case TypeSigTag.CLASS: {  	Offset = 0;  	writer.WriteCompressedUInt32 (4);  	writer.WriteUInt32 (0);  	break;  }  default:  	throw new PEException ("unexpected constant type");  }  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (tag) {  case TypeSigTag.BOOLEAN: {  	var b = (bool)Value;  	writer.WriteCompressedUInt32 (1);  	writer.WriteByte (b ? (byte)0 : (byte)1);  	break;  }  case TypeSigTag.CHAR: {  	var c = (char)Value;  	writer.WriteCompressedUInt32 (2);  	writer.WriteUInt16 ((ushort)c);  	break;  }  case TypeSigTag.I1: {  	var i = (sbyte)Value;  	writer.WriteCompressedUInt32 (1);  	writer.WriteSByte (i);  	break;  }  case TypeSigTag.U1: {  	var i = (byte)Value;  	writer.WriteCompressedUInt32 (1);  	writer.WriteByte (i);  	break;  }  case TypeSigTag.I2: {  	var i = (short)Value;  	writer.WriteCompressedUInt32 (2);  	writer.WriteInt16 (i);  	break;  }  case TypeSigTag.U2: {  	var i = (ushort)Value;  	writer.WriteCompressedUInt32 (2);  	writer.WriteUInt16 (i);  	break;  }  case TypeSigTag.I4: {  	var i = (int)Value;  	writer.WriteCompressedUInt32 (4);  	writer.WriteInt32 (i);  	break;  }  case TypeSigTag.U4: {  	var i = (uint)Value;  	writer.WriteCompressedUInt32 (4);  	writer.WriteUInt32 (i);  	break;  }  case TypeSigTag.I8: {  	var i = (long)Value;  	writer.WriteCompressedUInt32 (8);  	writer.WriteInt64 (i);  	break;  }  case TypeSigTag.U8: {  	var i = (ulong)Value;  	writer.WriteCompressedUInt32 (8);  	writer.WriteUInt64 (i);  	break;  }  case TypeSigTag.R4: {  	var f = (float)Value;  	writer.WriteCompressedUInt32 (4);  	writer.WriteSingle (f);  	break;  }  case TypeSigTag.R8: {  	var d = (double)Value;  	writer.WriteCompressedUInt32 (8);  	writer.WriteDouble (d);  	break;  }  case TypeSigTag.STRING: {  	var s = (string)Value;  	writer.WriteUTF16SizedString (s);  	break;  }  case TypeSigTag.CLASS: {  	Offset = 0;  	writer.WriteCompressedUInt32 (4);  	writer.WriteUInt32 (0);  	break;  }  default:  	throw new PEException ("unexpected constant type");  }  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (tag) {  case TypeSigTag.BOOLEAN: {  	var b = (bool)Value;  	writer.WriteCompressedUInt32 (1);  	writer.WriteByte (b ? (byte)0 : (byte)1);  	break;  }  case TypeSigTag.CHAR: {  	var c = (char)Value;  	writer.WriteCompressedUInt32 (2);  	writer.WriteUInt16 ((ushort)c);  	break;  }  case TypeSigTag.I1: {  	var i = (sbyte)Value;  	writer.WriteCompressedUInt32 (1);  	writer.WriteSByte (i);  	break;  }  case TypeSigTag.U1: {  	var i = (byte)Value;  	writer.WriteCompressedUInt32 (1);  	writer.WriteByte (i);  	break;  }  case TypeSigTag.I2: {  	var i = (short)Value;  	writer.WriteCompressedUInt32 (2);  	writer.WriteInt16 (i);  	break;  }  case TypeSigTag.U2: {  	var i = (ushort)Value;  	writer.WriteCompressedUInt32 (2);  	writer.WriteUInt16 (i);  	break;  }  case TypeSigTag.I4: {  	var i = (int)Value;  	writer.WriteCompressedUInt32 (4);  	writer.WriteInt32 (i);  	break;  }  case TypeSigTag.U4: {  	var i = (uint)Value;  	writer.WriteCompressedUInt32 (4);  	writer.WriteUInt32 (i);  	break;  }  case TypeSigTag.I8: {  	var i = (long)Value;  	writer.WriteCompressedUInt32 (8);  	writer.WriteInt64 (i);  	break;  }  case TypeSigTag.U8: {  	var i = (ulong)Value;  	writer.WriteCompressedUInt32 (8);  	writer.WriteUInt64 (i);  	break;  }  case TypeSigTag.R4: {  	var f = (float)Value;  	writer.WriteCompressedUInt32 (4);  	writer.WriteSingle (f);  	break;  }  case TypeSigTag.R8: {  	var d = (double)Value;  	writer.WriteCompressedUInt32 (8);  	writer.WriteDouble (d);  	break;  }  case TypeSigTag.STRING: {  	var s = (string)Value;  	writer.WriteUTF16SizedString (s);  	break;  }  case TypeSigTag.CLASS: {  	Offset = 0;  	writer.WriteCompressedUInt32 (4);  	writer.WriteUInt32 (0);  	break;  }  default:  	throw new PEException ("unexpected constant type");  }  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (tag) {  case TypeSigTag.BOOLEAN: {  	var b = (bool)Value;  	writer.WriteCompressedUInt32 (1);  	writer.WriteByte (b ? (byte)0 : (byte)1);  	break;  }  case TypeSigTag.CHAR: {  	var c = (char)Value;  	writer.WriteCompressedUInt32 (2);  	writer.WriteUInt16 ((ushort)c);  	break;  }  case TypeSigTag.I1: {  	var i = (sbyte)Value;  	writer.WriteCompressedUInt32 (1);  	writer.WriteSByte (i);  	break;  }  case TypeSigTag.U1: {  	var i = (byte)Value;  	writer.WriteCompressedUInt32 (1);  	writer.WriteByte (i);  	break;  }  case TypeSigTag.I2: {  	var i = (short)Value;  	writer.WriteCompressedUInt32 (2);  	writer.WriteInt16 (i);  	break;  }  case TypeSigTag.U2: {  	var i = (ushort)Value;  	writer.WriteCompressedUInt32 (2);  	writer.WriteUInt16 (i);  	break;  }  case TypeSigTag.I4: {  	var i = (int)Value;  	writer.WriteCompressedUInt32 (4);  	writer.WriteInt32 (i);  	break;  }  case TypeSigTag.U4: {  	var i = (uint)Value;  	writer.WriteCompressedUInt32 (4);  	writer.WriteUInt32 (i);  	break;  }  case TypeSigTag.I8: {  	var i = (long)Value;  	writer.WriteCompressedUInt32 (8);  	writer.WriteInt64 (i);  	break;  }  case TypeSigTag.U8: {  	var i = (ulong)Value;  	writer.WriteCompressedUInt32 (8);  	writer.WriteUInt64 (i);  	break;  }  case TypeSigTag.R4: {  	var f = (float)Value;  	writer.WriteCompressedUInt32 (4);  	writer.WriteSingle (f);  	break;  }  case TypeSigTag.R8: {  	var d = (double)Value;  	writer.WriteCompressedUInt32 (8);  	writer.WriteDouble (d);  	break;  }  case TypeSigTag.STRING: {  	var s = (string)Value;  	writer.WriteUTF16SizedString (s);  	break;  }  case TypeSigTag.CLASS: {  	Offset = 0;  	writer.WriteCompressedUInt32 (4);  	writer.WriteUInt32 (0);  	break;  }  default:  	throw new PEException ("unexpected constant type");  }  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (tag) {  case TypeSigTag.BOOLEAN: {  	var b = (bool)Value;  	writer.WriteCompressedUInt32 (1);  	writer.WriteByte (b ? (byte)0 : (byte)1);  	break;  }  case TypeSigTag.CHAR: {  	var c = (char)Value;  	writer.WriteCompressedUInt32 (2);  	writer.WriteUInt16 ((ushort)c);  	break;  }  case TypeSigTag.I1: {  	var i = (sbyte)Value;  	writer.WriteCompressedUInt32 (1);  	writer.WriteSByte (i);  	break;  }  case TypeSigTag.U1: {  	var i = (byte)Value;  	writer.WriteCompressedUInt32 (1);  	writer.WriteByte (i);  	break;  }  case TypeSigTag.I2: {  	var i = (short)Value;  	writer.WriteCompressedUInt32 (2);  	writer.WriteInt16 (i);  	break;  }  case TypeSigTag.U2: {  	var i = (ushort)Value;  	writer.WriteCompressedUInt32 (2);  	writer.WriteUInt16 (i);  	break;  }  case TypeSigTag.I4: {  	var i = (int)Value;  	writer.WriteCompressedUInt32 (4);  	writer.WriteInt32 (i);  	break;  }  case TypeSigTag.U4: {  	var i = (uint)Value;  	writer.WriteCompressedUInt32 (4);  	writer.WriteUInt32 (i);  	break;  }  case TypeSigTag.I8: {  	var i = (long)Value;  	writer.WriteCompressedUInt32 (8);  	writer.WriteInt64 (i);  	break;  }  case TypeSigTag.U8: {  	var i = (ulong)Value;  	writer.WriteCompressedUInt32 (8);  	writer.WriteUInt64 (i);  	break;  }  case TypeSigTag.R4: {  	var f = (float)Value;  	writer.WriteCompressedUInt32 (4);  	writer.WriteSingle (f);  	break;  }  case TypeSigTag.R8: {  	var d = (double)Value;  	writer.WriteCompressedUInt32 (8);  	writer.WriteDouble (d);  	break;  }  case TypeSigTag.STRING: {  	var s = (string)Value;  	writer.WriteUTF16SizedString (s);  	break;  }  case TypeSigTag.CLASS: {  	Offset = 0;  	writer.WriteCompressedUInt32 (4);  	writer.WriteUInt32 (0);  	break;  }  default:  	throw new PEException ("unexpected constant type");  }  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: writer.WriteCompressedUInt32 (2);  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: writer.WriteCompressedUInt32 (2);  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: writer.WriteCompressedUInt32 (2);  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: writer.WriteCompressedUInt32 (4);  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: writer.WriteCompressedUInt32 (4);  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: writer.WriteCompressedUInt32 (8);  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: writer.WriteCompressedUInt32 (8);  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: writer.WriteCompressedUInt32 (4);  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: writer.WriteCompressedUInt32 (8);  
Magic Number,Microsoft.LiveLabs.PE,ConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: writer.WriteCompressedUInt32 (4);  
Magic Number,Microsoft.LiveLabs.PE,TypeDefOrRefRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (CodedIndex == 0)  	Value = null;  else {  	var table = CodedIndex & 0x3;  	var index = (int)(CodedIndex >> 2);  	switch (table) {  	case 0:  		Value = ctxt.Tables.TypeDefTable [index];  		break;  	case 1:  		Value = ctxt.Tables.TypeRefTable [index];  		break;  	case 2:  		Value = ctxt.Tables.TypeSpecTable [index];  		break;  	default:  		throw new PEException ("invalid TypeDefOrRef coded index");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,TypeDefOrRefRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (CodedIndex == 0)  	Value = null;  else {  	var table = CodedIndex & 0x3;  	var index = (int)(CodedIndex >> 2);  	switch (table) {  	case 0:  		Value = ctxt.Tables.TypeDefTable [index];  		break;  	case 1:  		Value = ctxt.Tables.TypeRefTable [index];  		break;  	case 2:  		Value = ctxt.Tables.TypeSpecTable [index];  		break;  	default:  		throw new PEException ("invalid TypeDefOrRef coded index");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,TypeDefOrRefRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: switch (table) {  case 0:  	Value = ctxt.Tables.TypeDefTable [index];  	break;  case 1:  	Value = ctxt.Tables.TypeRefTable [index];  	break;  case 2:  	Value = ctxt.Tables.TypeSpecTable [index];  	break;  default:  	throw new PEException ("invalid TypeDefOrRef coded index");  }  
Magic Number,Microsoft.LiveLabs.PE,TypeDefOrRefRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 2;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 2 | 1;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 2 | 2;  		break;  	default:  		throw new PEException ("invalid TypeDefOrRef row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,TypeDefOrRefRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 2;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 2 | 1;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 2 | 2;  		break;  	default:  		throw new PEException ("invalid TypeDefOrRef row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,TypeDefOrRefRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 2;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 2 | 1;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 2 | 2;  		break;  	default:  		throw new PEException ("invalid TypeDefOrRef row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,TypeDefOrRefRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 2;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 2 | 1;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 2 | 2;  		break;  	default:  		throw new PEException ("invalid TypeDefOrRef row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,TypeDefOrRefRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 2;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 2 | 1;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 2 | 2;  	break;  default:  	throw new PEException ("invalid TypeDefOrRef row");  }  
Magic Number,Microsoft.LiveLabs.PE,TypeDefOrRefRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 2;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 2 | 1;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 2 | 2;  	break;  default:  	throw new PEException ("invalid TypeDefOrRef row");  }  
Magic Number,Microsoft.LiveLabs.PE,TypeDefOrRefRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 2;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 2 | 1;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 2 | 2;  	break;  default:  	throw new PEException ("invalid TypeDefOrRef row");  }  
Magic Number,Microsoft.LiveLabs.PE,TypeDefOrRefRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 2;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 2 | 1;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 2 | 2;  	break;  default:  	throw new PEException ("invalid TypeDefOrRef row");  }  
Magic Number,Microsoft.LiveLabs.PE,TypeDefOrRefRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 2;  
Magic Number,Microsoft.LiveLabs.PE,TypeDefOrRefRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 2 | 1;  
Magic Number,Microsoft.LiveLabs.PE,TypeDefOrRefRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 2 | 2;  
Magic Number,Microsoft.LiveLabs.PE,TypeDefOrRefRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 2 | 2;  
Magic Number,Microsoft.LiveLabs.PE,HasConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (CodedIndex == 0)  	Value = null;  else {  	var table = CodedIndex & 0x3;  	var index = (int)(CodedIndex >> 2);  	switch (table) {  	case 0:  		Value = ctxt.Tables.FieldTable [index];  		break;  	case 1:  		Value = ctxt.Tables.ParamTable [index];  		break;  	case 2:  		Value = ctxt.Tables.PropertyTable [index];  		break;  	default:  		throw new PEException ("invalid HasConstant coded index");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (CodedIndex == 0)  	Value = null;  else {  	var table = CodedIndex & 0x3;  	var index = (int)(CodedIndex >> 2);  	switch (table) {  	case 0:  		Value = ctxt.Tables.FieldTable [index];  		break;  	case 1:  		Value = ctxt.Tables.ParamTable [index];  		break;  	case 2:  		Value = ctxt.Tables.PropertyTable [index];  		break;  	default:  		throw new PEException ("invalid HasConstant coded index");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: switch (table) {  case 0:  	Value = ctxt.Tables.FieldTable [index];  	break;  case 1:  	Value = ctxt.Tables.ParamTable [index];  	break;  case 2:  	Value = ctxt.Tables.PropertyTable [index];  	break;  default:  	throw new PEException ("invalid HasConstant coded index");  }  
Magic Number,Microsoft.LiveLabs.PE,HasConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.Field:  		CodedIndex = (uint)Value.Index << 2;  		break;  	case TableTag.Param:  		CodedIndex = (uint)Value.Index << 2 | 1;  		break;  	case TableTag.Property:  		CodedIndex = (uint)Value.Index << 2 | 2;  		break;  	default:  		throw new PEException ("invalid HasConstant row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.Field:  		CodedIndex = (uint)Value.Index << 2;  		break;  	case TableTag.Param:  		CodedIndex = (uint)Value.Index << 2 | 1;  		break;  	case TableTag.Property:  		CodedIndex = (uint)Value.Index << 2 | 2;  		break;  	default:  		throw new PEException ("invalid HasConstant row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.Field:  		CodedIndex = (uint)Value.Index << 2;  		break;  	case TableTag.Param:  		CodedIndex = (uint)Value.Index << 2 | 1;  		break;  	case TableTag.Property:  		CodedIndex = (uint)Value.Index << 2 | 2;  		break;  	default:  		throw new PEException ("invalid HasConstant row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.Field:  		CodedIndex = (uint)Value.Index << 2;  		break;  	case TableTag.Param:  		CodedIndex = (uint)Value.Index << 2 | 1;  		break;  	case TableTag.Property:  		CodedIndex = (uint)Value.Index << 2 | 2;  		break;  	default:  		throw new PEException ("invalid HasConstant row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.Field:  	CodedIndex = (uint)Value.Index << 2;  	break;  case TableTag.Param:  	CodedIndex = (uint)Value.Index << 2 | 1;  	break;  case TableTag.Property:  	CodedIndex = (uint)Value.Index << 2 | 2;  	break;  default:  	throw new PEException ("invalid HasConstant row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.Field:  	CodedIndex = (uint)Value.Index << 2;  	break;  case TableTag.Param:  	CodedIndex = (uint)Value.Index << 2 | 1;  	break;  case TableTag.Property:  	CodedIndex = (uint)Value.Index << 2 | 2;  	break;  default:  	throw new PEException ("invalid HasConstant row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.Field:  	CodedIndex = (uint)Value.Index << 2;  	break;  case TableTag.Param:  	CodedIndex = (uint)Value.Index << 2 | 1;  	break;  case TableTag.Property:  	CodedIndex = (uint)Value.Index << 2 | 2;  	break;  default:  	throw new PEException ("invalid HasConstant row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.Field:  	CodedIndex = (uint)Value.Index << 2;  	break;  case TableTag.Param:  	CodedIndex = (uint)Value.Index << 2 | 1;  	break;  case TableTag.Property:  	CodedIndex = (uint)Value.Index << 2 | 2;  	break;  default:  	throw new PEException ("invalid HasConstant row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 2;  
Magic Number,Microsoft.LiveLabs.PE,HasConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 2 | 1;  
Magic Number,Microsoft.LiveLabs.PE,HasConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 2 | 2;  
Magic Number,Microsoft.LiveLabs.PE,HasConstantRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 2 | 2;  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (CodedIndex == 0)  	Value = null;  else {  	var table = CodedIndex & 0x1f;  	var index = (int)(CodedIndex >> 5);  	switch (table) {  	case 0:  		Value = ctxt.Tables.MethodDefTable [index];  		break;  	case 1:  		Value = ctxt.Tables.FieldTable [index];  		break;  	case 2:  		Value = ctxt.Tables.TypeRefTable [index];  		break;  	case 3:  		Value = ctxt.Tables.TypeDefTable [index];  		break;  	case 4:  		Value = ctxt.Tables.ParamTable [index];  		break;  	case 5:  		Value = ctxt.Tables.InterfaceImplTable [index];  		break;  	case 6:  		Value = ctxt.Tables.MemberRefTable [index];  		break;  	case 7:  		Value = ctxt.Tables.ModuleTable [index];  		break;  	case 8:  		Value = ctxt.Tables.DeclSecurityTable [index];  		break;  	case 9:  		Value = ctxt.Tables.PropertyTable [index];  		break;  	case 10:  		Value = ctxt.Tables.EventTable [index];  		break;  	case 11:  		Value = ctxt.Tables.StandAloneSigTable [index];  		break;  	case 12:  		Value = ctxt.Tables.ModuleRefTable [index];  		break;  	case 13:  		Value = ctxt.Tables.TypeSpecTable [index];  		break;  	case 14:  		Value = ctxt.Tables.AssemblyTable [index];  		break;  	case 15:  		Value = ctxt.Tables.AssemblyRefTable [index];  		break;  	case 16:  		Value = ctxt.Tables.FileTable [index];  		break;  	case 17:  		Value = ctxt.Tables.ExportedTypeTable [index];  		break;  	case 18:  		Value = ctxt.Tables.ManifestResourceTable [index];  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute coded index");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (CodedIndex == 0)  	Value = null;  else {  	var table = CodedIndex & 0x1f;  	var index = (int)(CodedIndex >> 5);  	switch (table) {  	case 0:  		Value = ctxt.Tables.MethodDefTable [index];  		break;  	case 1:  		Value = ctxt.Tables.FieldTable [index];  		break;  	case 2:  		Value = ctxt.Tables.TypeRefTable [index];  		break;  	case 3:  		Value = ctxt.Tables.TypeDefTable [index];  		break;  	case 4:  		Value = ctxt.Tables.ParamTable [index];  		break;  	case 5:  		Value = ctxt.Tables.InterfaceImplTable [index];  		break;  	case 6:  		Value = ctxt.Tables.MemberRefTable [index];  		break;  	case 7:  		Value = ctxt.Tables.ModuleTable [index];  		break;  	case 8:  		Value = ctxt.Tables.DeclSecurityTable [index];  		break;  	case 9:  		Value = ctxt.Tables.PropertyTable [index];  		break;  	case 10:  		Value = ctxt.Tables.EventTable [index];  		break;  	case 11:  		Value = ctxt.Tables.StandAloneSigTable [index];  		break;  	case 12:  		Value = ctxt.Tables.ModuleRefTable [index];  		break;  	case 13:  		Value = ctxt.Tables.TypeSpecTable [index];  		break;  	case 14:  		Value = ctxt.Tables.AssemblyTable [index];  		break;  	case 15:  		Value = ctxt.Tables.AssemblyRefTable [index];  		break;  	case 16:  		Value = ctxt.Tables.FileTable [index];  		break;  	case 17:  		Value = ctxt.Tables.ExportedTypeTable [index];  		break;  	case 18:  		Value = ctxt.Tables.ManifestResourceTable [index];  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute coded index");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (CodedIndex == 0)  	Value = null;  else {  	var table = CodedIndex & 0x1f;  	var index = (int)(CodedIndex >> 5);  	switch (table) {  	case 0:  		Value = ctxt.Tables.MethodDefTable [index];  		break;  	case 1:  		Value = ctxt.Tables.FieldTable [index];  		break;  	case 2:  		Value = ctxt.Tables.TypeRefTable [index];  		break;  	case 3:  		Value = ctxt.Tables.TypeDefTable [index];  		break;  	case 4:  		Value = ctxt.Tables.ParamTable [index];  		break;  	case 5:  		Value = ctxt.Tables.InterfaceImplTable [index];  		break;  	case 6:  		Value = ctxt.Tables.MemberRefTable [index];  		break;  	case 7:  		Value = ctxt.Tables.ModuleTable [index];  		break;  	case 8:  		Value = ctxt.Tables.DeclSecurityTable [index];  		break;  	case 9:  		Value = ctxt.Tables.PropertyTable [index];  		break;  	case 10:  		Value = ctxt.Tables.EventTable [index];  		break;  	case 11:  		Value = ctxt.Tables.StandAloneSigTable [index];  		break;  	case 12:  		Value = ctxt.Tables.ModuleRefTable [index];  		break;  	case 13:  		Value = ctxt.Tables.TypeSpecTable [index];  		break;  	case 14:  		Value = ctxt.Tables.AssemblyTable [index];  		break;  	case 15:  		Value = ctxt.Tables.AssemblyRefTable [index];  		break;  	case 16:  		Value = ctxt.Tables.FileTable [index];  		break;  	case 17:  		Value = ctxt.Tables.ExportedTypeTable [index];  		break;  	case 18:  		Value = ctxt.Tables.ManifestResourceTable [index];  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute coded index");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (CodedIndex == 0)  	Value = null;  else {  	var table = CodedIndex & 0x1f;  	var index = (int)(CodedIndex >> 5);  	switch (table) {  	case 0:  		Value = ctxt.Tables.MethodDefTable [index];  		break;  	case 1:  		Value = ctxt.Tables.FieldTable [index];  		break;  	case 2:  		Value = ctxt.Tables.TypeRefTable [index];  		break;  	case 3:  		Value = ctxt.Tables.TypeDefTable [index];  		break;  	case 4:  		Value = ctxt.Tables.ParamTable [index];  		break;  	case 5:  		Value = ctxt.Tables.InterfaceImplTable [index];  		break;  	case 6:  		Value = ctxt.Tables.MemberRefTable [index];  		break;  	case 7:  		Value = ctxt.Tables.ModuleTable [index];  		break;  	case 8:  		Value = ctxt.Tables.DeclSecurityTable [index];  		break;  	case 9:  		Value = ctxt.Tables.PropertyTable [index];  		break;  	case 10:  		Value = ctxt.Tables.EventTable [index];  		break;  	case 11:  		Value = ctxt.Tables.StandAloneSigTable [index];  		break;  	case 12:  		Value = ctxt.Tables.ModuleRefTable [index];  		break;  	case 13:  		Value = ctxt.Tables.TypeSpecTable [index];  		break;  	case 14:  		Value = ctxt.Tables.AssemblyTable [index];  		break;  	case 15:  		Value = ctxt.Tables.AssemblyRefTable [index];  		break;  	case 16:  		Value = ctxt.Tables.FileTable [index];  		break;  	case 17:  		Value = ctxt.Tables.ExportedTypeTable [index];  		break;  	case 18:  		Value = ctxt.Tables.ManifestResourceTable [index];  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute coded index");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (CodedIndex == 0)  	Value = null;  else {  	var table = CodedIndex & 0x1f;  	var index = (int)(CodedIndex >> 5);  	switch (table) {  	case 0:  		Value = ctxt.Tables.MethodDefTable [index];  		break;  	case 1:  		Value = ctxt.Tables.FieldTable [index];  		break;  	case 2:  		Value = ctxt.Tables.TypeRefTable [index];  		break;  	case 3:  		Value = ctxt.Tables.TypeDefTable [index];  		break;  	case 4:  		Value = ctxt.Tables.ParamTable [index];  		break;  	case 5:  		Value = ctxt.Tables.InterfaceImplTable [index];  		break;  	case 6:  		Value = ctxt.Tables.MemberRefTable [index];  		break;  	case 7:  		Value = ctxt.Tables.ModuleTable [index];  		break;  	case 8:  		Value = ctxt.Tables.DeclSecurityTable [index];  		break;  	case 9:  		Value = ctxt.Tables.PropertyTable [index];  		break;  	case 10:  		Value = ctxt.Tables.EventTable [index];  		break;  	case 11:  		Value = ctxt.Tables.StandAloneSigTable [index];  		break;  	case 12:  		Value = ctxt.Tables.ModuleRefTable [index];  		break;  	case 13:  		Value = ctxt.Tables.TypeSpecTable [index];  		break;  	case 14:  		Value = ctxt.Tables.AssemblyTable [index];  		break;  	case 15:  		Value = ctxt.Tables.AssemblyRefTable [index];  		break;  	case 16:  		Value = ctxt.Tables.FileTable [index];  		break;  	case 17:  		Value = ctxt.Tables.ExportedTypeTable [index];  		break;  	case 18:  		Value = ctxt.Tables.ManifestResourceTable [index];  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute coded index");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (CodedIndex == 0)  	Value = null;  else {  	var table = CodedIndex & 0x1f;  	var index = (int)(CodedIndex >> 5);  	switch (table) {  	case 0:  		Value = ctxt.Tables.MethodDefTable [index];  		break;  	case 1:  		Value = ctxt.Tables.FieldTable [index];  		break;  	case 2:  		Value = ctxt.Tables.TypeRefTable [index];  		break;  	case 3:  		Value = ctxt.Tables.TypeDefTable [index];  		break;  	case 4:  		Value = ctxt.Tables.ParamTable [index];  		break;  	case 5:  		Value = ctxt.Tables.InterfaceImplTable [index];  		break;  	case 6:  		Value = ctxt.Tables.MemberRefTable [index];  		break;  	case 7:  		Value = ctxt.Tables.ModuleTable [index];  		break;  	case 8:  		Value = ctxt.Tables.DeclSecurityTable [index];  		break;  	case 9:  		Value = ctxt.Tables.PropertyTable [index];  		break;  	case 10:  		Value = ctxt.Tables.EventTable [index];  		break;  	case 11:  		Value = ctxt.Tables.StandAloneSigTable [index];  		break;  	case 12:  		Value = ctxt.Tables.ModuleRefTable [index];  		break;  	case 13:  		Value = ctxt.Tables.TypeSpecTable [index];  		break;  	case 14:  		Value = ctxt.Tables.AssemblyTable [index];  		break;  	case 15:  		Value = ctxt.Tables.AssemblyRefTable [index];  		break;  	case 16:  		Value = ctxt.Tables.FileTable [index];  		break;  	case 17:  		Value = ctxt.Tables.ExportedTypeTable [index];  		break;  	case 18:  		Value = ctxt.Tables.ManifestResourceTable [index];  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute coded index");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (CodedIndex == 0)  	Value = null;  else {  	var table = CodedIndex & 0x1f;  	var index = (int)(CodedIndex >> 5);  	switch (table) {  	case 0:  		Value = ctxt.Tables.MethodDefTable [index];  		break;  	case 1:  		Value = ctxt.Tables.FieldTable [index];  		break;  	case 2:  		Value = ctxt.Tables.TypeRefTable [index];  		break;  	case 3:  		Value = ctxt.Tables.TypeDefTable [index];  		break;  	case 4:  		Value = ctxt.Tables.ParamTable [index];  		break;  	case 5:  		Value = ctxt.Tables.InterfaceImplTable [index];  		break;  	case 6:  		Value = ctxt.Tables.MemberRefTable [index];  		break;  	case 7:  		Value = ctxt.Tables.ModuleTable [index];  		break;  	case 8:  		Value = ctxt.Tables.DeclSecurityTable [index];  		break;  	case 9:  		Value = ctxt.Tables.PropertyTable [index];  		break;  	case 10:  		Value = ctxt.Tables.EventTable [index];  		break;  	case 11:  		Value = ctxt.Tables.StandAloneSigTable [index];  		break;  	case 12:  		Value = ctxt.Tables.ModuleRefTable [index];  		break;  	case 13:  		Value = ctxt.Tables.TypeSpecTable [index];  		break;  	case 14:  		Value = ctxt.Tables.AssemblyTable [index];  		break;  	case 15:  		Value = ctxt.Tables.AssemblyRefTable [index];  		break;  	case 16:  		Value = ctxt.Tables.FileTable [index];  		break;  	case 17:  		Value = ctxt.Tables.ExportedTypeTable [index];  		break;  	case 18:  		Value = ctxt.Tables.ManifestResourceTable [index];  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute coded index");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (CodedIndex == 0)  	Value = null;  else {  	var table = CodedIndex & 0x1f;  	var index = (int)(CodedIndex >> 5);  	switch (table) {  	case 0:  		Value = ctxt.Tables.MethodDefTable [index];  		break;  	case 1:  		Value = ctxt.Tables.FieldTable [index];  		break;  	case 2:  		Value = ctxt.Tables.TypeRefTable [index];  		break;  	case 3:  		Value = ctxt.Tables.TypeDefTable [index];  		break;  	case 4:  		Value = ctxt.Tables.ParamTable [index];  		break;  	case 5:  		Value = ctxt.Tables.InterfaceImplTable [index];  		break;  	case 6:  		Value = ctxt.Tables.MemberRefTable [index];  		break;  	case 7:  		Value = ctxt.Tables.ModuleTable [index];  		break;  	case 8:  		Value = ctxt.Tables.DeclSecurityTable [index];  		break;  	case 9:  		Value = ctxt.Tables.PropertyTable [index];  		break;  	case 10:  		Value = ctxt.Tables.EventTable [index];  		break;  	case 11:  		Value = ctxt.Tables.StandAloneSigTable [index];  		break;  	case 12:  		Value = ctxt.Tables.ModuleRefTable [index];  		break;  	case 13:  		Value = ctxt.Tables.TypeSpecTable [index];  		break;  	case 14:  		Value = ctxt.Tables.AssemblyTable [index];  		break;  	case 15:  		Value = ctxt.Tables.AssemblyRefTable [index];  		break;  	case 16:  		Value = ctxt.Tables.FileTable [index];  		break;  	case 17:  		Value = ctxt.Tables.ExportedTypeTable [index];  		break;  	case 18:  		Value = ctxt.Tables.ManifestResourceTable [index];  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute coded index");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (CodedIndex == 0)  	Value = null;  else {  	var table = CodedIndex & 0x1f;  	var index = (int)(CodedIndex >> 5);  	switch (table) {  	case 0:  		Value = ctxt.Tables.MethodDefTable [index];  		break;  	case 1:  		Value = ctxt.Tables.FieldTable [index];  		break;  	case 2:  		Value = ctxt.Tables.TypeRefTable [index];  		break;  	case 3:  		Value = ctxt.Tables.TypeDefTable [index];  		break;  	case 4:  		Value = ctxt.Tables.ParamTable [index];  		break;  	case 5:  		Value = ctxt.Tables.InterfaceImplTable [index];  		break;  	case 6:  		Value = ctxt.Tables.MemberRefTable [index];  		break;  	case 7:  		Value = ctxt.Tables.ModuleTable [index];  		break;  	case 8:  		Value = ctxt.Tables.DeclSecurityTable [index];  		break;  	case 9:  		Value = ctxt.Tables.PropertyTable [index];  		break;  	case 10:  		Value = ctxt.Tables.EventTable [index];  		break;  	case 11:  		Value = ctxt.Tables.StandAloneSigTable [index];  		break;  	case 12:  		Value = ctxt.Tables.ModuleRefTable [index];  		break;  	case 13:  		Value = ctxt.Tables.TypeSpecTable [index];  		break;  	case 14:  		Value = ctxt.Tables.AssemblyTable [index];  		break;  	case 15:  		Value = ctxt.Tables.AssemblyRefTable [index];  		break;  	case 16:  		Value = ctxt.Tables.FileTable [index];  		break;  	case 17:  		Value = ctxt.Tables.ExportedTypeTable [index];  		break;  	case 18:  		Value = ctxt.Tables.ManifestResourceTable [index];  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute coded index");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (CodedIndex == 0)  	Value = null;  else {  	var table = CodedIndex & 0x1f;  	var index = (int)(CodedIndex >> 5);  	switch (table) {  	case 0:  		Value = ctxt.Tables.MethodDefTable [index];  		break;  	case 1:  		Value = ctxt.Tables.FieldTable [index];  		break;  	case 2:  		Value = ctxt.Tables.TypeRefTable [index];  		break;  	case 3:  		Value = ctxt.Tables.TypeDefTable [index];  		break;  	case 4:  		Value = ctxt.Tables.ParamTable [index];  		break;  	case 5:  		Value = ctxt.Tables.InterfaceImplTable [index];  		break;  	case 6:  		Value = ctxt.Tables.MemberRefTable [index];  		break;  	case 7:  		Value = ctxt.Tables.ModuleTable [index];  		break;  	case 8:  		Value = ctxt.Tables.DeclSecurityTable [index];  		break;  	case 9:  		Value = ctxt.Tables.PropertyTable [index];  		break;  	case 10:  		Value = ctxt.Tables.EventTable [index];  		break;  	case 11:  		Value = ctxt.Tables.StandAloneSigTable [index];  		break;  	case 12:  		Value = ctxt.Tables.ModuleRefTable [index];  		break;  	case 13:  		Value = ctxt.Tables.TypeSpecTable [index];  		break;  	case 14:  		Value = ctxt.Tables.AssemblyTable [index];  		break;  	case 15:  		Value = ctxt.Tables.AssemblyRefTable [index];  		break;  	case 16:  		Value = ctxt.Tables.FileTable [index];  		break;  	case 17:  		Value = ctxt.Tables.ExportedTypeTable [index];  		break;  	case 18:  		Value = ctxt.Tables.ManifestResourceTable [index];  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute coded index");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (CodedIndex == 0)  	Value = null;  else {  	var table = CodedIndex & 0x1f;  	var index = (int)(CodedIndex >> 5);  	switch (table) {  	case 0:  		Value = ctxt.Tables.MethodDefTable [index];  		break;  	case 1:  		Value = ctxt.Tables.FieldTable [index];  		break;  	case 2:  		Value = ctxt.Tables.TypeRefTable [index];  		break;  	case 3:  		Value = ctxt.Tables.TypeDefTable [index];  		break;  	case 4:  		Value = ctxt.Tables.ParamTable [index];  		break;  	case 5:  		Value = ctxt.Tables.InterfaceImplTable [index];  		break;  	case 6:  		Value = ctxt.Tables.MemberRefTable [index];  		break;  	case 7:  		Value = ctxt.Tables.ModuleTable [index];  		break;  	case 8:  		Value = ctxt.Tables.DeclSecurityTable [index];  		break;  	case 9:  		Value = ctxt.Tables.PropertyTable [index];  		break;  	case 10:  		Value = ctxt.Tables.EventTable [index];  		break;  	case 11:  		Value = ctxt.Tables.StandAloneSigTable [index];  		break;  	case 12:  		Value = ctxt.Tables.ModuleRefTable [index];  		break;  	case 13:  		Value = ctxt.Tables.TypeSpecTable [index];  		break;  	case 14:  		Value = ctxt.Tables.AssemblyTable [index];  		break;  	case 15:  		Value = ctxt.Tables.AssemblyRefTable [index];  		break;  	case 16:  		Value = ctxt.Tables.FileTable [index];  		break;  	case 17:  		Value = ctxt.Tables.ExportedTypeTable [index];  		break;  	case 18:  		Value = ctxt.Tables.ManifestResourceTable [index];  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute coded index");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (CodedIndex == 0)  	Value = null;  else {  	var table = CodedIndex & 0x1f;  	var index = (int)(CodedIndex >> 5);  	switch (table) {  	case 0:  		Value = ctxt.Tables.MethodDefTable [index];  		break;  	case 1:  		Value = ctxt.Tables.FieldTable [index];  		break;  	case 2:  		Value = ctxt.Tables.TypeRefTable [index];  		break;  	case 3:  		Value = ctxt.Tables.TypeDefTable [index];  		break;  	case 4:  		Value = ctxt.Tables.ParamTable [index];  		break;  	case 5:  		Value = ctxt.Tables.InterfaceImplTable [index];  		break;  	case 6:  		Value = ctxt.Tables.MemberRefTable [index];  		break;  	case 7:  		Value = ctxt.Tables.ModuleTable [index];  		break;  	case 8:  		Value = ctxt.Tables.DeclSecurityTable [index];  		break;  	case 9:  		Value = ctxt.Tables.PropertyTable [index];  		break;  	case 10:  		Value = ctxt.Tables.EventTable [index];  		break;  	case 11:  		Value = ctxt.Tables.StandAloneSigTable [index];  		break;  	case 12:  		Value = ctxt.Tables.ModuleRefTable [index];  		break;  	case 13:  		Value = ctxt.Tables.TypeSpecTable [index];  		break;  	case 14:  		Value = ctxt.Tables.AssemblyTable [index];  		break;  	case 15:  		Value = ctxt.Tables.AssemblyRefTable [index];  		break;  	case 16:  		Value = ctxt.Tables.FileTable [index];  		break;  	case 17:  		Value = ctxt.Tables.ExportedTypeTable [index];  		break;  	case 18:  		Value = ctxt.Tables.ManifestResourceTable [index];  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute coded index");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (CodedIndex == 0)  	Value = null;  else {  	var table = CodedIndex & 0x1f;  	var index = (int)(CodedIndex >> 5);  	switch (table) {  	case 0:  		Value = ctxt.Tables.MethodDefTable [index];  		break;  	case 1:  		Value = ctxt.Tables.FieldTable [index];  		break;  	case 2:  		Value = ctxt.Tables.TypeRefTable [index];  		break;  	case 3:  		Value = ctxt.Tables.TypeDefTable [index];  		break;  	case 4:  		Value = ctxt.Tables.ParamTable [index];  		break;  	case 5:  		Value = ctxt.Tables.InterfaceImplTable [index];  		break;  	case 6:  		Value = ctxt.Tables.MemberRefTable [index];  		break;  	case 7:  		Value = ctxt.Tables.ModuleTable [index];  		break;  	case 8:  		Value = ctxt.Tables.DeclSecurityTable [index];  		break;  	case 9:  		Value = ctxt.Tables.PropertyTable [index];  		break;  	case 10:  		Value = ctxt.Tables.EventTable [index];  		break;  	case 11:  		Value = ctxt.Tables.StandAloneSigTable [index];  		break;  	case 12:  		Value = ctxt.Tables.ModuleRefTable [index];  		break;  	case 13:  		Value = ctxt.Tables.TypeSpecTable [index];  		break;  	case 14:  		Value = ctxt.Tables.AssemblyTable [index];  		break;  	case 15:  		Value = ctxt.Tables.AssemblyRefTable [index];  		break;  	case 16:  		Value = ctxt.Tables.FileTable [index];  		break;  	case 17:  		Value = ctxt.Tables.ExportedTypeTable [index];  		break;  	case 18:  		Value = ctxt.Tables.ManifestResourceTable [index];  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute coded index");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (CodedIndex == 0)  	Value = null;  else {  	var table = CodedIndex & 0x1f;  	var index = (int)(CodedIndex >> 5);  	switch (table) {  	case 0:  		Value = ctxt.Tables.MethodDefTable [index];  		break;  	case 1:  		Value = ctxt.Tables.FieldTable [index];  		break;  	case 2:  		Value = ctxt.Tables.TypeRefTable [index];  		break;  	case 3:  		Value = ctxt.Tables.TypeDefTable [index];  		break;  	case 4:  		Value = ctxt.Tables.ParamTable [index];  		break;  	case 5:  		Value = ctxt.Tables.InterfaceImplTable [index];  		break;  	case 6:  		Value = ctxt.Tables.MemberRefTable [index];  		break;  	case 7:  		Value = ctxt.Tables.ModuleTable [index];  		break;  	case 8:  		Value = ctxt.Tables.DeclSecurityTable [index];  		break;  	case 9:  		Value = ctxt.Tables.PropertyTable [index];  		break;  	case 10:  		Value = ctxt.Tables.EventTable [index];  		break;  	case 11:  		Value = ctxt.Tables.StandAloneSigTable [index];  		break;  	case 12:  		Value = ctxt.Tables.ModuleRefTable [index];  		break;  	case 13:  		Value = ctxt.Tables.TypeSpecTable [index];  		break;  	case 14:  		Value = ctxt.Tables.AssemblyTable [index];  		break;  	case 15:  		Value = ctxt.Tables.AssemblyRefTable [index];  		break;  	case 16:  		Value = ctxt.Tables.FileTable [index];  		break;  	case 17:  		Value = ctxt.Tables.ExportedTypeTable [index];  		break;  	case 18:  		Value = ctxt.Tables.ManifestResourceTable [index];  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute coded index");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (CodedIndex == 0)  	Value = null;  else {  	var table = CodedIndex & 0x1f;  	var index = (int)(CodedIndex >> 5);  	switch (table) {  	case 0:  		Value = ctxt.Tables.MethodDefTable [index];  		break;  	case 1:  		Value = ctxt.Tables.FieldTable [index];  		break;  	case 2:  		Value = ctxt.Tables.TypeRefTable [index];  		break;  	case 3:  		Value = ctxt.Tables.TypeDefTable [index];  		break;  	case 4:  		Value = ctxt.Tables.ParamTable [index];  		break;  	case 5:  		Value = ctxt.Tables.InterfaceImplTable [index];  		break;  	case 6:  		Value = ctxt.Tables.MemberRefTable [index];  		break;  	case 7:  		Value = ctxt.Tables.ModuleTable [index];  		break;  	case 8:  		Value = ctxt.Tables.DeclSecurityTable [index];  		break;  	case 9:  		Value = ctxt.Tables.PropertyTable [index];  		break;  	case 10:  		Value = ctxt.Tables.EventTable [index];  		break;  	case 11:  		Value = ctxt.Tables.StandAloneSigTable [index];  		break;  	case 12:  		Value = ctxt.Tables.ModuleRefTable [index];  		break;  	case 13:  		Value = ctxt.Tables.TypeSpecTable [index];  		break;  	case 14:  		Value = ctxt.Tables.AssemblyTable [index];  		break;  	case 15:  		Value = ctxt.Tables.AssemblyRefTable [index];  		break;  	case 16:  		Value = ctxt.Tables.FileTable [index];  		break;  	case 17:  		Value = ctxt.Tables.ExportedTypeTable [index];  		break;  	case 18:  		Value = ctxt.Tables.ManifestResourceTable [index];  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute coded index");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (CodedIndex == 0)  	Value = null;  else {  	var table = CodedIndex & 0x1f;  	var index = (int)(CodedIndex >> 5);  	switch (table) {  	case 0:  		Value = ctxt.Tables.MethodDefTable [index];  		break;  	case 1:  		Value = ctxt.Tables.FieldTable [index];  		break;  	case 2:  		Value = ctxt.Tables.TypeRefTable [index];  		break;  	case 3:  		Value = ctxt.Tables.TypeDefTable [index];  		break;  	case 4:  		Value = ctxt.Tables.ParamTable [index];  		break;  	case 5:  		Value = ctxt.Tables.InterfaceImplTable [index];  		break;  	case 6:  		Value = ctxt.Tables.MemberRefTable [index];  		break;  	case 7:  		Value = ctxt.Tables.ModuleTable [index];  		break;  	case 8:  		Value = ctxt.Tables.DeclSecurityTable [index];  		break;  	case 9:  		Value = ctxt.Tables.PropertyTable [index];  		break;  	case 10:  		Value = ctxt.Tables.EventTable [index];  		break;  	case 11:  		Value = ctxt.Tables.StandAloneSigTable [index];  		break;  	case 12:  		Value = ctxt.Tables.ModuleRefTable [index];  		break;  	case 13:  		Value = ctxt.Tables.TypeSpecTable [index];  		break;  	case 14:  		Value = ctxt.Tables.AssemblyTable [index];  		break;  	case 15:  		Value = ctxt.Tables.AssemblyRefTable [index];  		break;  	case 16:  		Value = ctxt.Tables.FileTable [index];  		break;  	case 17:  		Value = ctxt.Tables.ExportedTypeTable [index];  		break;  	case 18:  		Value = ctxt.Tables.ManifestResourceTable [index];  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute coded index");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (CodedIndex == 0)  	Value = null;  else {  	var table = CodedIndex & 0x1f;  	var index = (int)(CodedIndex >> 5);  	switch (table) {  	case 0:  		Value = ctxt.Tables.MethodDefTable [index];  		break;  	case 1:  		Value = ctxt.Tables.FieldTable [index];  		break;  	case 2:  		Value = ctxt.Tables.TypeRefTable [index];  		break;  	case 3:  		Value = ctxt.Tables.TypeDefTable [index];  		break;  	case 4:  		Value = ctxt.Tables.ParamTable [index];  		break;  	case 5:  		Value = ctxt.Tables.InterfaceImplTable [index];  		break;  	case 6:  		Value = ctxt.Tables.MemberRefTable [index];  		break;  	case 7:  		Value = ctxt.Tables.ModuleTable [index];  		break;  	case 8:  		Value = ctxt.Tables.DeclSecurityTable [index];  		break;  	case 9:  		Value = ctxt.Tables.PropertyTable [index];  		break;  	case 10:  		Value = ctxt.Tables.EventTable [index];  		break;  	case 11:  		Value = ctxt.Tables.StandAloneSigTable [index];  		break;  	case 12:  		Value = ctxt.Tables.ModuleRefTable [index];  		break;  	case 13:  		Value = ctxt.Tables.TypeSpecTable [index];  		break;  	case 14:  		Value = ctxt.Tables.AssemblyTable [index];  		break;  	case 15:  		Value = ctxt.Tables.AssemblyRefTable [index];  		break;  	case 16:  		Value = ctxt.Tables.FileTable [index];  		break;  	case 17:  		Value = ctxt.Tables.ExportedTypeTable [index];  		break;  	case 18:  		Value = ctxt.Tables.ManifestResourceTable [index];  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute coded index");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (CodedIndex == 0)  	Value = null;  else {  	var table = CodedIndex & 0x1f;  	var index = (int)(CodedIndex >> 5);  	switch (table) {  	case 0:  		Value = ctxt.Tables.MethodDefTable [index];  		break;  	case 1:  		Value = ctxt.Tables.FieldTable [index];  		break;  	case 2:  		Value = ctxt.Tables.TypeRefTable [index];  		break;  	case 3:  		Value = ctxt.Tables.TypeDefTable [index];  		break;  	case 4:  		Value = ctxt.Tables.ParamTable [index];  		break;  	case 5:  		Value = ctxt.Tables.InterfaceImplTable [index];  		break;  	case 6:  		Value = ctxt.Tables.MemberRefTable [index];  		break;  	case 7:  		Value = ctxt.Tables.ModuleTable [index];  		break;  	case 8:  		Value = ctxt.Tables.DeclSecurityTable [index];  		break;  	case 9:  		Value = ctxt.Tables.PropertyTable [index];  		break;  	case 10:  		Value = ctxt.Tables.EventTable [index];  		break;  	case 11:  		Value = ctxt.Tables.StandAloneSigTable [index];  		break;  	case 12:  		Value = ctxt.Tables.ModuleRefTable [index];  		break;  	case 13:  		Value = ctxt.Tables.TypeSpecTable [index];  		break;  	case 14:  		Value = ctxt.Tables.AssemblyTable [index];  		break;  	case 15:  		Value = ctxt.Tables.AssemblyRefTable [index];  		break;  	case 16:  		Value = ctxt.Tables.FileTable [index];  		break;  	case 17:  		Value = ctxt.Tables.ExportedTypeTable [index];  		break;  	case 18:  		Value = ctxt.Tables.ManifestResourceTable [index];  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute coded index");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: switch (table) {  case 0:  	Value = ctxt.Tables.MethodDefTable [index];  	break;  case 1:  	Value = ctxt.Tables.FieldTable [index];  	break;  case 2:  	Value = ctxt.Tables.TypeRefTable [index];  	break;  case 3:  	Value = ctxt.Tables.TypeDefTable [index];  	break;  case 4:  	Value = ctxt.Tables.ParamTable [index];  	break;  case 5:  	Value = ctxt.Tables.InterfaceImplTable [index];  	break;  case 6:  	Value = ctxt.Tables.MemberRefTable [index];  	break;  case 7:  	Value = ctxt.Tables.ModuleTable [index];  	break;  case 8:  	Value = ctxt.Tables.DeclSecurityTable [index];  	break;  case 9:  	Value = ctxt.Tables.PropertyTable [index];  	break;  case 10:  	Value = ctxt.Tables.EventTable [index];  	break;  case 11:  	Value = ctxt.Tables.StandAloneSigTable [index];  	break;  case 12:  	Value = ctxt.Tables.ModuleRefTable [index];  	break;  case 13:  	Value = ctxt.Tables.TypeSpecTable [index];  	break;  case 14:  	Value = ctxt.Tables.AssemblyTable [index];  	break;  case 15:  	Value = ctxt.Tables.AssemblyRefTable [index];  	break;  case 16:  	Value = ctxt.Tables.FileTable [index];  	break;  case 17:  	Value = ctxt.Tables.ExportedTypeTable [index];  	break;  case 18:  	Value = ctxt.Tables.ManifestResourceTable [index];  	break;  default:  	throw new PEException ("invalid HasCustomAttribute coded index");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: switch (table) {  case 0:  	Value = ctxt.Tables.MethodDefTable [index];  	break;  case 1:  	Value = ctxt.Tables.FieldTable [index];  	break;  case 2:  	Value = ctxt.Tables.TypeRefTable [index];  	break;  case 3:  	Value = ctxt.Tables.TypeDefTable [index];  	break;  case 4:  	Value = ctxt.Tables.ParamTable [index];  	break;  case 5:  	Value = ctxt.Tables.InterfaceImplTable [index];  	break;  case 6:  	Value = ctxt.Tables.MemberRefTable [index];  	break;  case 7:  	Value = ctxt.Tables.ModuleTable [index];  	break;  case 8:  	Value = ctxt.Tables.DeclSecurityTable [index];  	break;  case 9:  	Value = ctxt.Tables.PropertyTable [index];  	break;  case 10:  	Value = ctxt.Tables.EventTable [index];  	break;  case 11:  	Value = ctxt.Tables.StandAloneSigTable [index];  	break;  case 12:  	Value = ctxt.Tables.ModuleRefTable [index];  	break;  case 13:  	Value = ctxt.Tables.TypeSpecTable [index];  	break;  case 14:  	Value = ctxt.Tables.AssemblyTable [index];  	break;  case 15:  	Value = ctxt.Tables.AssemblyRefTable [index];  	break;  case 16:  	Value = ctxt.Tables.FileTable [index];  	break;  case 17:  	Value = ctxt.Tables.ExportedTypeTable [index];  	break;  case 18:  	Value = ctxt.Tables.ManifestResourceTable [index];  	break;  default:  	throw new PEException ("invalid HasCustomAttribute coded index");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: switch (table) {  case 0:  	Value = ctxt.Tables.MethodDefTable [index];  	break;  case 1:  	Value = ctxt.Tables.FieldTable [index];  	break;  case 2:  	Value = ctxt.Tables.TypeRefTable [index];  	break;  case 3:  	Value = ctxt.Tables.TypeDefTable [index];  	break;  case 4:  	Value = ctxt.Tables.ParamTable [index];  	break;  case 5:  	Value = ctxt.Tables.InterfaceImplTable [index];  	break;  case 6:  	Value = ctxt.Tables.MemberRefTable [index];  	break;  case 7:  	Value = ctxt.Tables.ModuleTable [index];  	break;  case 8:  	Value = ctxt.Tables.DeclSecurityTable [index];  	break;  case 9:  	Value = ctxt.Tables.PropertyTable [index];  	break;  case 10:  	Value = ctxt.Tables.EventTable [index];  	break;  case 11:  	Value = ctxt.Tables.StandAloneSigTable [index];  	break;  case 12:  	Value = ctxt.Tables.ModuleRefTable [index];  	break;  case 13:  	Value = ctxt.Tables.TypeSpecTable [index];  	break;  case 14:  	Value = ctxt.Tables.AssemblyTable [index];  	break;  case 15:  	Value = ctxt.Tables.AssemblyRefTable [index];  	break;  case 16:  	Value = ctxt.Tables.FileTable [index];  	break;  case 17:  	Value = ctxt.Tables.ExportedTypeTable [index];  	break;  case 18:  	Value = ctxt.Tables.ManifestResourceTable [index];  	break;  default:  	throw new PEException ("invalid HasCustomAttribute coded index");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: switch (table) {  case 0:  	Value = ctxt.Tables.MethodDefTable [index];  	break;  case 1:  	Value = ctxt.Tables.FieldTable [index];  	break;  case 2:  	Value = ctxt.Tables.TypeRefTable [index];  	break;  case 3:  	Value = ctxt.Tables.TypeDefTable [index];  	break;  case 4:  	Value = ctxt.Tables.ParamTable [index];  	break;  case 5:  	Value = ctxt.Tables.InterfaceImplTable [index];  	break;  case 6:  	Value = ctxt.Tables.MemberRefTable [index];  	break;  case 7:  	Value = ctxt.Tables.ModuleTable [index];  	break;  case 8:  	Value = ctxt.Tables.DeclSecurityTable [index];  	break;  case 9:  	Value = ctxt.Tables.PropertyTable [index];  	break;  case 10:  	Value = ctxt.Tables.EventTable [index];  	break;  case 11:  	Value = ctxt.Tables.StandAloneSigTable [index];  	break;  case 12:  	Value = ctxt.Tables.ModuleRefTable [index];  	break;  case 13:  	Value = ctxt.Tables.TypeSpecTable [index];  	break;  case 14:  	Value = ctxt.Tables.AssemblyTable [index];  	break;  case 15:  	Value = ctxt.Tables.AssemblyRefTable [index];  	break;  case 16:  	Value = ctxt.Tables.FileTable [index];  	break;  case 17:  	Value = ctxt.Tables.ExportedTypeTable [index];  	break;  case 18:  	Value = ctxt.Tables.ManifestResourceTable [index];  	break;  default:  	throw new PEException ("invalid HasCustomAttribute coded index");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: switch (table) {  case 0:  	Value = ctxt.Tables.MethodDefTable [index];  	break;  case 1:  	Value = ctxt.Tables.FieldTable [index];  	break;  case 2:  	Value = ctxt.Tables.TypeRefTable [index];  	break;  case 3:  	Value = ctxt.Tables.TypeDefTable [index];  	break;  case 4:  	Value = ctxt.Tables.ParamTable [index];  	break;  case 5:  	Value = ctxt.Tables.InterfaceImplTable [index];  	break;  case 6:  	Value = ctxt.Tables.MemberRefTable [index];  	break;  case 7:  	Value = ctxt.Tables.ModuleTable [index];  	break;  case 8:  	Value = ctxt.Tables.DeclSecurityTable [index];  	break;  case 9:  	Value = ctxt.Tables.PropertyTable [index];  	break;  case 10:  	Value = ctxt.Tables.EventTable [index];  	break;  case 11:  	Value = ctxt.Tables.StandAloneSigTable [index];  	break;  case 12:  	Value = ctxt.Tables.ModuleRefTable [index];  	break;  case 13:  	Value = ctxt.Tables.TypeSpecTable [index];  	break;  case 14:  	Value = ctxt.Tables.AssemblyTable [index];  	break;  case 15:  	Value = ctxt.Tables.AssemblyRefTable [index];  	break;  case 16:  	Value = ctxt.Tables.FileTable [index];  	break;  case 17:  	Value = ctxt.Tables.ExportedTypeTable [index];  	break;  case 18:  	Value = ctxt.Tables.ManifestResourceTable [index];  	break;  default:  	throw new PEException ("invalid HasCustomAttribute coded index");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: switch (table) {  case 0:  	Value = ctxt.Tables.MethodDefTable [index];  	break;  case 1:  	Value = ctxt.Tables.FieldTable [index];  	break;  case 2:  	Value = ctxt.Tables.TypeRefTable [index];  	break;  case 3:  	Value = ctxt.Tables.TypeDefTable [index];  	break;  case 4:  	Value = ctxt.Tables.ParamTable [index];  	break;  case 5:  	Value = ctxt.Tables.InterfaceImplTable [index];  	break;  case 6:  	Value = ctxt.Tables.MemberRefTable [index];  	break;  case 7:  	Value = ctxt.Tables.ModuleTable [index];  	break;  case 8:  	Value = ctxt.Tables.DeclSecurityTable [index];  	break;  case 9:  	Value = ctxt.Tables.PropertyTable [index];  	break;  case 10:  	Value = ctxt.Tables.EventTable [index];  	break;  case 11:  	Value = ctxt.Tables.StandAloneSigTable [index];  	break;  case 12:  	Value = ctxt.Tables.ModuleRefTable [index];  	break;  case 13:  	Value = ctxt.Tables.TypeSpecTable [index];  	break;  case 14:  	Value = ctxt.Tables.AssemblyTable [index];  	break;  case 15:  	Value = ctxt.Tables.AssemblyRefTable [index];  	break;  case 16:  	Value = ctxt.Tables.FileTable [index];  	break;  case 17:  	Value = ctxt.Tables.ExportedTypeTable [index];  	break;  case 18:  	Value = ctxt.Tables.ManifestResourceTable [index];  	break;  default:  	throw new PEException ("invalid HasCustomAttribute coded index");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: switch (table) {  case 0:  	Value = ctxt.Tables.MethodDefTable [index];  	break;  case 1:  	Value = ctxt.Tables.FieldTable [index];  	break;  case 2:  	Value = ctxt.Tables.TypeRefTable [index];  	break;  case 3:  	Value = ctxt.Tables.TypeDefTable [index];  	break;  case 4:  	Value = ctxt.Tables.ParamTable [index];  	break;  case 5:  	Value = ctxt.Tables.InterfaceImplTable [index];  	break;  case 6:  	Value = ctxt.Tables.MemberRefTable [index];  	break;  case 7:  	Value = ctxt.Tables.ModuleTable [index];  	break;  case 8:  	Value = ctxt.Tables.DeclSecurityTable [index];  	break;  case 9:  	Value = ctxt.Tables.PropertyTable [index];  	break;  case 10:  	Value = ctxt.Tables.EventTable [index];  	break;  case 11:  	Value = ctxt.Tables.StandAloneSigTable [index];  	break;  case 12:  	Value = ctxt.Tables.ModuleRefTable [index];  	break;  case 13:  	Value = ctxt.Tables.TypeSpecTable [index];  	break;  case 14:  	Value = ctxt.Tables.AssemblyTable [index];  	break;  case 15:  	Value = ctxt.Tables.AssemblyRefTable [index];  	break;  case 16:  	Value = ctxt.Tables.FileTable [index];  	break;  case 17:  	Value = ctxt.Tables.ExportedTypeTable [index];  	break;  case 18:  	Value = ctxt.Tables.ManifestResourceTable [index];  	break;  default:  	throw new PEException ("invalid HasCustomAttribute coded index");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: switch (table) {  case 0:  	Value = ctxt.Tables.MethodDefTable [index];  	break;  case 1:  	Value = ctxt.Tables.FieldTable [index];  	break;  case 2:  	Value = ctxt.Tables.TypeRefTable [index];  	break;  case 3:  	Value = ctxt.Tables.TypeDefTable [index];  	break;  case 4:  	Value = ctxt.Tables.ParamTable [index];  	break;  case 5:  	Value = ctxt.Tables.InterfaceImplTable [index];  	break;  case 6:  	Value = ctxt.Tables.MemberRefTable [index];  	break;  case 7:  	Value = ctxt.Tables.ModuleTable [index];  	break;  case 8:  	Value = ctxt.Tables.DeclSecurityTable [index];  	break;  case 9:  	Value = ctxt.Tables.PropertyTable [index];  	break;  case 10:  	Value = ctxt.Tables.EventTable [index];  	break;  case 11:  	Value = ctxt.Tables.StandAloneSigTable [index];  	break;  case 12:  	Value = ctxt.Tables.ModuleRefTable [index];  	break;  case 13:  	Value = ctxt.Tables.TypeSpecTable [index];  	break;  case 14:  	Value = ctxt.Tables.AssemblyTable [index];  	break;  case 15:  	Value = ctxt.Tables.AssemblyRefTable [index];  	break;  case 16:  	Value = ctxt.Tables.FileTable [index];  	break;  case 17:  	Value = ctxt.Tables.ExportedTypeTable [index];  	break;  case 18:  	Value = ctxt.Tables.ManifestResourceTable [index];  	break;  default:  	throw new PEException ("invalid HasCustomAttribute coded index");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: switch (table) {  case 0:  	Value = ctxt.Tables.MethodDefTable [index];  	break;  case 1:  	Value = ctxt.Tables.FieldTable [index];  	break;  case 2:  	Value = ctxt.Tables.TypeRefTable [index];  	break;  case 3:  	Value = ctxt.Tables.TypeDefTable [index];  	break;  case 4:  	Value = ctxt.Tables.ParamTable [index];  	break;  case 5:  	Value = ctxt.Tables.InterfaceImplTable [index];  	break;  case 6:  	Value = ctxt.Tables.MemberRefTable [index];  	break;  case 7:  	Value = ctxt.Tables.ModuleTable [index];  	break;  case 8:  	Value = ctxt.Tables.DeclSecurityTable [index];  	break;  case 9:  	Value = ctxt.Tables.PropertyTable [index];  	break;  case 10:  	Value = ctxt.Tables.EventTable [index];  	break;  case 11:  	Value = ctxt.Tables.StandAloneSigTable [index];  	break;  case 12:  	Value = ctxt.Tables.ModuleRefTable [index];  	break;  case 13:  	Value = ctxt.Tables.TypeSpecTable [index];  	break;  case 14:  	Value = ctxt.Tables.AssemblyTable [index];  	break;  case 15:  	Value = ctxt.Tables.AssemblyRefTable [index];  	break;  case 16:  	Value = ctxt.Tables.FileTable [index];  	break;  case 17:  	Value = ctxt.Tables.ExportedTypeTable [index];  	break;  case 18:  	Value = ctxt.Tables.ManifestResourceTable [index];  	break;  default:  	throw new PEException ("invalid HasCustomAttribute coded index");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: switch (table) {  case 0:  	Value = ctxt.Tables.MethodDefTable [index];  	break;  case 1:  	Value = ctxt.Tables.FieldTable [index];  	break;  case 2:  	Value = ctxt.Tables.TypeRefTable [index];  	break;  case 3:  	Value = ctxt.Tables.TypeDefTable [index];  	break;  case 4:  	Value = ctxt.Tables.ParamTable [index];  	break;  case 5:  	Value = ctxt.Tables.InterfaceImplTable [index];  	break;  case 6:  	Value = ctxt.Tables.MemberRefTable [index];  	break;  case 7:  	Value = ctxt.Tables.ModuleTable [index];  	break;  case 8:  	Value = ctxt.Tables.DeclSecurityTable [index];  	break;  case 9:  	Value = ctxt.Tables.PropertyTable [index];  	break;  case 10:  	Value = ctxt.Tables.EventTable [index];  	break;  case 11:  	Value = ctxt.Tables.StandAloneSigTable [index];  	break;  case 12:  	Value = ctxt.Tables.ModuleRefTable [index];  	break;  case 13:  	Value = ctxt.Tables.TypeSpecTable [index];  	break;  case 14:  	Value = ctxt.Tables.AssemblyTable [index];  	break;  case 15:  	Value = ctxt.Tables.AssemblyRefTable [index];  	break;  case 16:  	Value = ctxt.Tables.FileTable [index];  	break;  case 17:  	Value = ctxt.Tables.ExportedTypeTable [index];  	break;  case 18:  	Value = ctxt.Tables.ManifestResourceTable [index];  	break;  default:  	throw new PEException ("invalid HasCustomAttribute coded index");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: switch (table) {  case 0:  	Value = ctxt.Tables.MethodDefTable [index];  	break;  case 1:  	Value = ctxt.Tables.FieldTable [index];  	break;  case 2:  	Value = ctxt.Tables.TypeRefTable [index];  	break;  case 3:  	Value = ctxt.Tables.TypeDefTable [index];  	break;  case 4:  	Value = ctxt.Tables.ParamTable [index];  	break;  case 5:  	Value = ctxt.Tables.InterfaceImplTable [index];  	break;  case 6:  	Value = ctxt.Tables.MemberRefTable [index];  	break;  case 7:  	Value = ctxt.Tables.ModuleTable [index];  	break;  case 8:  	Value = ctxt.Tables.DeclSecurityTable [index];  	break;  case 9:  	Value = ctxt.Tables.PropertyTable [index];  	break;  case 10:  	Value = ctxt.Tables.EventTable [index];  	break;  case 11:  	Value = ctxt.Tables.StandAloneSigTable [index];  	break;  case 12:  	Value = ctxt.Tables.ModuleRefTable [index];  	break;  case 13:  	Value = ctxt.Tables.TypeSpecTable [index];  	break;  case 14:  	Value = ctxt.Tables.AssemblyTable [index];  	break;  case 15:  	Value = ctxt.Tables.AssemblyRefTable [index];  	break;  case 16:  	Value = ctxt.Tables.FileTable [index];  	break;  case 17:  	Value = ctxt.Tables.ExportedTypeTable [index];  	break;  case 18:  	Value = ctxt.Tables.ManifestResourceTable [index];  	break;  default:  	throw new PEException ("invalid HasCustomAttribute coded index");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: switch (table) {  case 0:  	Value = ctxt.Tables.MethodDefTable [index];  	break;  case 1:  	Value = ctxt.Tables.FieldTable [index];  	break;  case 2:  	Value = ctxt.Tables.TypeRefTable [index];  	break;  case 3:  	Value = ctxt.Tables.TypeDefTable [index];  	break;  case 4:  	Value = ctxt.Tables.ParamTable [index];  	break;  case 5:  	Value = ctxt.Tables.InterfaceImplTable [index];  	break;  case 6:  	Value = ctxt.Tables.MemberRefTable [index];  	break;  case 7:  	Value = ctxt.Tables.ModuleTable [index];  	break;  case 8:  	Value = ctxt.Tables.DeclSecurityTable [index];  	break;  case 9:  	Value = ctxt.Tables.PropertyTable [index];  	break;  case 10:  	Value = ctxt.Tables.EventTable [index];  	break;  case 11:  	Value = ctxt.Tables.StandAloneSigTable [index];  	break;  case 12:  	Value = ctxt.Tables.ModuleRefTable [index];  	break;  case 13:  	Value = ctxt.Tables.TypeSpecTable [index];  	break;  case 14:  	Value = ctxt.Tables.AssemblyTable [index];  	break;  case 15:  	Value = ctxt.Tables.AssemblyRefTable [index];  	break;  case 16:  	Value = ctxt.Tables.FileTable [index];  	break;  case 17:  	Value = ctxt.Tables.ExportedTypeTable [index];  	break;  case 18:  	Value = ctxt.Tables.ManifestResourceTable [index];  	break;  default:  	throw new PEException ("invalid HasCustomAttribute coded index");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: switch (table) {  case 0:  	Value = ctxt.Tables.MethodDefTable [index];  	break;  case 1:  	Value = ctxt.Tables.FieldTable [index];  	break;  case 2:  	Value = ctxt.Tables.TypeRefTable [index];  	break;  case 3:  	Value = ctxt.Tables.TypeDefTable [index];  	break;  case 4:  	Value = ctxt.Tables.ParamTable [index];  	break;  case 5:  	Value = ctxt.Tables.InterfaceImplTable [index];  	break;  case 6:  	Value = ctxt.Tables.MemberRefTable [index];  	break;  case 7:  	Value = ctxt.Tables.ModuleTable [index];  	break;  case 8:  	Value = ctxt.Tables.DeclSecurityTable [index];  	break;  case 9:  	Value = ctxt.Tables.PropertyTable [index];  	break;  case 10:  	Value = ctxt.Tables.EventTable [index];  	break;  case 11:  	Value = ctxt.Tables.StandAloneSigTable [index];  	break;  case 12:  	Value = ctxt.Tables.ModuleRefTable [index];  	break;  case 13:  	Value = ctxt.Tables.TypeSpecTable [index];  	break;  case 14:  	Value = ctxt.Tables.AssemblyTable [index];  	break;  case 15:  	Value = ctxt.Tables.AssemblyRefTable [index];  	break;  case 16:  	Value = ctxt.Tables.FileTable [index];  	break;  case 17:  	Value = ctxt.Tables.ExportedTypeTable [index];  	break;  case 18:  	Value = ctxt.Tables.ManifestResourceTable [index];  	break;  default:  	throw new PEException ("invalid HasCustomAttribute coded index");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: switch (table) {  case 0:  	Value = ctxt.Tables.MethodDefTable [index];  	break;  case 1:  	Value = ctxt.Tables.FieldTable [index];  	break;  case 2:  	Value = ctxt.Tables.TypeRefTable [index];  	break;  case 3:  	Value = ctxt.Tables.TypeDefTable [index];  	break;  case 4:  	Value = ctxt.Tables.ParamTable [index];  	break;  case 5:  	Value = ctxt.Tables.InterfaceImplTable [index];  	break;  case 6:  	Value = ctxt.Tables.MemberRefTable [index];  	break;  case 7:  	Value = ctxt.Tables.ModuleTable [index];  	break;  case 8:  	Value = ctxt.Tables.DeclSecurityTable [index];  	break;  case 9:  	Value = ctxt.Tables.PropertyTable [index];  	break;  case 10:  	Value = ctxt.Tables.EventTable [index];  	break;  case 11:  	Value = ctxt.Tables.StandAloneSigTable [index];  	break;  case 12:  	Value = ctxt.Tables.ModuleRefTable [index];  	break;  case 13:  	Value = ctxt.Tables.TypeSpecTable [index];  	break;  case 14:  	Value = ctxt.Tables.AssemblyTable [index];  	break;  case 15:  	Value = ctxt.Tables.AssemblyRefTable [index];  	break;  case 16:  	Value = ctxt.Tables.FileTable [index];  	break;  case 17:  	Value = ctxt.Tables.ExportedTypeTable [index];  	break;  case 18:  	Value = ctxt.Tables.ManifestResourceTable [index];  	break;  default:  	throw new PEException ("invalid HasCustomAttribute coded index");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: switch (table) {  case 0:  	Value = ctxt.Tables.MethodDefTable [index];  	break;  case 1:  	Value = ctxt.Tables.FieldTable [index];  	break;  case 2:  	Value = ctxt.Tables.TypeRefTable [index];  	break;  case 3:  	Value = ctxt.Tables.TypeDefTable [index];  	break;  case 4:  	Value = ctxt.Tables.ParamTable [index];  	break;  case 5:  	Value = ctxt.Tables.InterfaceImplTable [index];  	break;  case 6:  	Value = ctxt.Tables.MemberRefTable [index];  	break;  case 7:  	Value = ctxt.Tables.ModuleTable [index];  	break;  case 8:  	Value = ctxt.Tables.DeclSecurityTable [index];  	break;  case 9:  	Value = ctxt.Tables.PropertyTable [index];  	break;  case 10:  	Value = ctxt.Tables.EventTable [index];  	break;  case 11:  	Value = ctxt.Tables.StandAloneSigTable [index];  	break;  case 12:  	Value = ctxt.Tables.ModuleRefTable [index];  	break;  case 13:  	Value = ctxt.Tables.TypeSpecTable [index];  	break;  case 14:  	Value = ctxt.Tables.AssemblyTable [index];  	break;  case 15:  	Value = ctxt.Tables.AssemblyRefTable [index];  	break;  case 16:  	Value = ctxt.Tables.FileTable [index];  	break;  case 17:  	Value = ctxt.Tables.ExportedTypeTable [index];  	break;  case 18:  	Value = ctxt.Tables.ManifestResourceTable [index];  	break;  default:  	throw new PEException ("invalid HasCustomAttribute coded index");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: switch (table) {  case 0:  	Value = ctxt.Tables.MethodDefTable [index];  	break;  case 1:  	Value = ctxt.Tables.FieldTable [index];  	break;  case 2:  	Value = ctxt.Tables.TypeRefTable [index];  	break;  case 3:  	Value = ctxt.Tables.TypeDefTable [index];  	break;  case 4:  	Value = ctxt.Tables.ParamTable [index];  	break;  case 5:  	Value = ctxt.Tables.InterfaceImplTable [index];  	break;  case 6:  	Value = ctxt.Tables.MemberRefTable [index];  	break;  case 7:  	Value = ctxt.Tables.ModuleTable [index];  	break;  case 8:  	Value = ctxt.Tables.DeclSecurityTable [index];  	break;  case 9:  	Value = ctxt.Tables.PropertyTable [index];  	break;  case 10:  	Value = ctxt.Tables.EventTable [index];  	break;  case 11:  	Value = ctxt.Tables.StandAloneSigTable [index];  	break;  case 12:  	Value = ctxt.Tables.ModuleRefTable [index];  	break;  case 13:  	Value = ctxt.Tables.TypeSpecTable [index];  	break;  case 14:  	Value = ctxt.Tables.AssemblyTable [index];  	break;  case 15:  	Value = ctxt.Tables.AssemblyRefTable [index];  	break;  case 16:  	Value = ctxt.Tables.FileTable [index];  	break;  case 17:  	Value = ctxt.Tables.ExportedTypeTable [index];  	break;  case 18:  	Value = ctxt.Tables.ManifestResourceTable [index];  	break;  default:  	throw new PEException ("invalid HasCustomAttribute coded index");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: switch (table) {  case 0:  	Value = ctxt.Tables.MethodDefTable [index];  	break;  case 1:  	Value = ctxt.Tables.FieldTable [index];  	break;  case 2:  	Value = ctxt.Tables.TypeRefTable [index];  	break;  case 3:  	Value = ctxt.Tables.TypeDefTable [index];  	break;  case 4:  	Value = ctxt.Tables.ParamTable [index];  	break;  case 5:  	Value = ctxt.Tables.InterfaceImplTable [index];  	break;  case 6:  	Value = ctxt.Tables.MemberRefTable [index];  	break;  case 7:  	Value = ctxt.Tables.ModuleTable [index];  	break;  case 8:  	Value = ctxt.Tables.DeclSecurityTable [index];  	break;  case 9:  	Value = ctxt.Tables.PropertyTable [index];  	break;  case 10:  	Value = ctxt.Tables.EventTable [index];  	break;  case 11:  	Value = ctxt.Tables.StandAloneSigTable [index];  	break;  case 12:  	Value = ctxt.Tables.ModuleRefTable [index];  	break;  case 13:  	Value = ctxt.Tables.TypeSpecTable [index];  	break;  case 14:  	Value = ctxt.Tables.AssemblyTable [index];  	break;  case 15:  	Value = ctxt.Tables.AssemblyRefTable [index];  	break;  case 16:  	Value = ctxt.Tables.FileTable [index];  	break;  case 17:  	Value = ctxt.Tables.ExportedTypeTable [index];  	break;  case 18:  	Value = ctxt.Tables.ManifestResourceTable [index];  	break;  default:  	throw new PEException ("invalid HasCustomAttribute coded index");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 5;  		break;  	case TableTag.Field:  		CodedIndex = (uint)Value.Index << 5 | 1;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 5 | 2;  		break;  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 5 | 3;  		break;  	case TableTag.Param:  		CodedIndex = (uint)Value.Index << 5 | 4;  		break;  	case TableTag.InterfaceImpl:  		CodedIndex = (uint)Value.Index << 5 | 5;  		break;  	case TableTag.MemberRef:  		CodedIndex = (uint)Value.Index << 5 | 6;  		break;  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 5 | 7;  		break;  	case TableTag.DeclSecurity:  		CodedIndex = (uint)Value.Index << 5 | 8;  		break;  	case TableTag.Property:  		CodedIndex = (uint)Value.Index << 5 | 9;  		break;  	case TableTag.Event:  		CodedIndex = (uint)Value.Index << 5 | 10;  		break;  	case TableTag.StandAloneSig:  		CodedIndex = (uint)Value.Index << 5 | 11;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 5 | 12;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 5 | 13;  		break;  	case TableTag.Assembly:  		CodedIndex = (uint)Value.Index << 5 | 14;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 5 | 15;  		break;  	case TableTag.File:  		CodedIndex = (uint)Value.Index << 5 | 16;  		break;  	case TableTag.ExportedType:  		CodedIndex = (uint)Value.Index << 5 | 17;  		break;  	case TableTag.ManifestResource:  		CodedIndex = (uint)Value.Index << 5 | 18;  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 5;  		break;  	case TableTag.Field:  		CodedIndex = (uint)Value.Index << 5 | 1;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 5 | 2;  		break;  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 5 | 3;  		break;  	case TableTag.Param:  		CodedIndex = (uint)Value.Index << 5 | 4;  		break;  	case TableTag.InterfaceImpl:  		CodedIndex = (uint)Value.Index << 5 | 5;  		break;  	case TableTag.MemberRef:  		CodedIndex = (uint)Value.Index << 5 | 6;  		break;  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 5 | 7;  		break;  	case TableTag.DeclSecurity:  		CodedIndex = (uint)Value.Index << 5 | 8;  		break;  	case TableTag.Property:  		CodedIndex = (uint)Value.Index << 5 | 9;  		break;  	case TableTag.Event:  		CodedIndex = (uint)Value.Index << 5 | 10;  		break;  	case TableTag.StandAloneSig:  		CodedIndex = (uint)Value.Index << 5 | 11;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 5 | 12;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 5 | 13;  		break;  	case TableTag.Assembly:  		CodedIndex = (uint)Value.Index << 5 | 14;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 5 | 15;  		break;  	case TableTag.File:  		CodedIndex = (uint)Value.Index << 5 | 16;  		break;  	case TableTag.ExportedType:  		CodedIndex = (uint)Value.Index << 5 | 17;  		break;  	case TableTag.ManifestResource:  		CodedIndex = (uint)Value.Index << 5 | 18;  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 5;  		break;  	case TableTag.Field:  		CodedIndex = (uint)Value.Index << 5 | 1;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 5 | 2;  		break;  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 5 | 3;  		break;  	case TableTag.Param:  		CodedIndex = (uint)Value.Index << 5 | 4;  		break;  	case TableTag.InterfaceImpl:  		CodedIndex = (uint)Value.Index << 5 | 5;  		break;  	case TableTag.MemberRef:  		CodedIndex = (uint)Value.Index << 5 | 6;  		break;  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 5 | 7;  		break;  	case TableTag.DeclSecurity:  		CodedIndex = (uint)Value.Index << 5 | 8;  		break;  	case TableTag.Property:  		CodedIndex = (uint)Value.Index << 5 | 9;  		break;  	case TableTag.Event:  		CodedIndex = (uint)Value.Index << 5 | 10;  		break;  	case TableTag.StandAloneSig:  		CodedIndex = (uint)Value.Index << 5 | 11;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 5 | 12;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 5 | 13;  		break;  	case TableTag.Assembly:  		CodedIndex = (uint)Value.Index << 5 | 14;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 5 | 15;  		break;  	case TableTag.File:  		CodedIndex = (uint)Value.Index << 5 | 16;  		break;  	case TableTag.ExportedType:  		CodedIndex = (uint)Value.Index << 5 | 17;  		break;  	case TableTag.ManifestResource:  		CodedIndex = (uint)Value.Index << 5 | 18;  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 5;  		break;  	case TableTag.Field:  		CodedIndex = (uint)Value.Index << 5 | 1;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 5 | 2;  		break;  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 5 | 3;  		break;  	case TableTag.Param:  		CodedIndex = (uint)Value.Index << 5 | 4;  		break;  	case TableTag.InterfaceImpl:  		CodedIndex = (uint)Value.Index << 5 | 5;  		break;  	case TableTag.MemberRef:  		CodedIndex = (uint)Value.Index << 5 | 6;  		break;  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 5 | 7;  		break;  	case TableTag.DeclSecurity:  		CodedIndex = (uint)Value.Index << 5 | 8;  		break;  	case TableTag.Property:  		CodedIndex = (uint)Value.Index << 5 | 9;  		break;  	case TableTag.Event:  		CodedIndex = (uint)Value.Index << 5 | 10;  		break;  	case TableTag.StandAloneSig:  		CodedIndex = (uint)Value.Index << 5 | 11;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 5 | 12;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 5 | 13;  		break;  	case TableTag.Assembly:  		CodedIndex = (uint)Value.Index << 5 | 14;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 5 | 15;  		break;  	case TableTag.File:  		CodedIndex = (uint)Value.Index << 5 | 16;  		break;  	case TableTag.ExportedType:  		CodedIndex = (uint)Value.Index << 5 | 17;  		break;  	case TableTag.ManifestResource:  		CodedIndex = (uint)Value.Index << 5 | 18;  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 5;  		break;  	case TableTag.Field:  		CodedIndex = (uint)Value.Index << 5 | 1;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 5 | 2;  		break;  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 5 | 3;  		break;  	case TableTag.Param:  		CodedIndex = (uint)Value.Index << 5 | 4;  		break;  	case TableTag.InterfaceImpl:  		CodedIndex = (uint)Value.Index << 5 | 5;  		break;  	case TableTag.MemberRef:  		CodedIndex = (uint)Value.Index << 5 | 6;  		break;  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 5 | 7;  		break;  	case TableTag.DeclSecurity:  		CodedIndex = (uint)Value.Index << 5 | 8;  		break;  	case TableTag.Property:  		CodedIndex = (uint)Value.Index << 5 | 9;  		break;  	case TableTag.Event:  		CodedIndex = (uint)Value.Index << 5 | 10;  		break;  	case TableTag.StandAloneSig:  		CodedIndex = (uint)Value.Index << 5 | 11;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 5 | 12;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 5 | 13;  		break;  	case TableTag.Assembly:  		CodedIndex = (uint)Value.Index << 5 | 14;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 5 | 15;  		break;  	case TableTag.File:  		CodedIndex = (uint)Value.Index << 5 | 16;  		break;  	case TableTag.ExportedType:  		CodedIndex = (uint)Value.Index << 5 | 17;  		break;  	case TableTag.ManifestResource:  		CodedIndex = (uint)Value.Index << 5 | 18;  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 5;  		break;  	case TableTag.Field:  		CodedIndex = (uint)Value.Index << 5 | 1;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 5 | 2;  		break;  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 5 | 3;  		break;  	case TableTag.Param:  		CodedIndex = (uint)Value.Index << 5 | 4;  		break;  	case TableTag.InterfaceImpl:  		CodedIndex = (uint)Value.Index << 5 | 5;  		break;  	case TableTag.MemberRef:  		CodedIndex = (uint)Value.Index << 5 | 6;  		break;  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 5 | 7;  		break;  	case TableTag.DeclSecurity:  		CodedIndex = (uint)Value.Index << 5 | 8;  		break;  	case TableTag.Property:  		CodedIndex = (uint)Value.Index << 5 | 9;  		break;  	case TableTag.Event:  		CodedIndex = (uint)Value.Index << 5 | 10;  		break;  	case TableTag.StandAloneSig:  		CodedIndex = (uint)Value.Index << 5 | 11;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 5 | 12;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 5 | 13;  		break;  	case TableTag.Assembly:  		CodedIndex = (uint)Value.Index << 5 | 14;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 5 | 15;  		break;  	case TableTag.File:  		CodedIndex = (uint)Value.Index << 5 | 16;  		break;  	case TableTag.ExportedType:  		CodedIndex = (uint)Value.Index << 5 | 17;  		break;  	case TableTag.ManifestResource:  		CodedIndex = (uint)Value.Index << 5 | 18;  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 5;  		break;  	case TableTag.Field:  		CodedIndex = (uint)Value.Index << 5 | 1;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 5 | 2;  		break;  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 5 | 3;  		break;  	case TableTag.Param:  		CodedIndex = (uint)Value.Index << 5 | 4;  		break;  	case TableTag.InterfaceImpl:  		CodedIndex = (uint)Value.Index << 5 | 5;  		break;  	case TableTag.MemberRef:  		CodedIndex = (uint)Value.Index << 5 | 6;  		break;  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 5 | 7;  		break;  	case TableTag.DeclSecurity:  		CodedIndex = (uint)Value.Index << 5 | 8;  		break;  	case TableTag.Property:  		CodedIndex = (uint)Value.Index << 5 | 9;  		break;  	case TableTag.Event:  		CodedIndex = (uint)Value.Index << 5 | 10;  		break;  	case TableTag.StandAloneSig:  		CodedIndex = (uint)Value.Index << 5 | 11;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 5 | 12;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 5 | 13;  		break;  	case TableTag.Assembly:  		CodedIndex = (uint)Value.Index << 5 | 14;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 5 | 15;  		break;  	case TableTag.File:  		CodedIndex = (uint)Value.Index << 5 | 16;  		break;  	case TableTag.ExportedType:  		CodedIndex = (uint)Value.Index << 5 | 17;  		break;  	case TableTag.ManifestResource:  		CodedIndex = (uint)Value.Index << 5 | 18;  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 5;  		break;  	case TableTag.Field:  		CodedIndex = (uint)Value.Index << 5 | 1;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 5 | 2;  		break;  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 5 | 3;  		break;  	case TableTag.Param:  		CodedIndex = (uint)Value.Index << 5 | 4;  		break;  	case TableTag.InterfaceImpl:  		CodedIndex = (uint)Value.Index << 5 | 5;  		break;  	case TableTag.MemberRef:  		CodedIndex = (uint)Value.Index << 5 | 6;  		break;  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 5 | 7;  		break;  	case TableTag.DeclSecurity:  		CodedIndex = (uint)Value.Index << 5 | 8;  		break;  	case TableTag.Property:  		CodedIndex = (uint)Value.Index << 5 | 9;  		break;  	case TableTag.Event:  		CodedIndex = (uint)Value.Index << 5 | 10;  		break;  	case TableTag.StandAloneSig:  		CodedIndex = (uint)Value.Index << 5 | 11;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 5 | 12;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 5 | 13;  		break;  	case TableTag.Assembly:  		CodedIndex = (uint)Value.Index << 5 | 14;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 5 | 15;  		break;  	case TableTag.File:  		CodedIndex = (uint)Value.Index << 5 | 16;  		break;  	case TableTag.ExportedType:  		CodedIndex = (uint)Value.Index << 5 | 17;  		break;  	case TableTag.ManifestResource:  		CodedIndex = (uint)Value.Index << 5 | 18;  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 5;  		break;  	case TableTag.Field:  		CodedIndex = (uint)Value.Index << 5 | 1;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 5 | 2;  		break;  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 5 | 3;  		break;  	case TableTag.Param:  		CodedIndex = (uint)Value.Index << 5 | 4;  		break;  	case TableTag.InterfaceImpl:  		CodedIndex = (uint)Value.Index << 5 | 5;  		break;  	case TableTag.MemberRef:  		CodedIndex = (uint)Value.Index << 5 | 6;  		break;  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 5 | 7;  		break;  	case TableTag.DeclSecurity:  		CodedIndex = (uint)Value.Index << 5 | 8;  		break;  	case TableTag.Property:  		CodedIndex = (uint)Value.Index << 5 | 9;  		break;  	case TableTag.Event:  		CodedIndex = (uint)Value.Index << 5 | 10;  		break;  	case TableTag.StandAloneSig:  		CodedIndex = (uint)Value.Index << 5 | 11;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 5 | 12;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 5 | 13;  		break;  	case TableTag.Assembly:  		CodedIndex = (uint)Value.Index << 5 | 14;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 5 | 15;  		break;  	case TableTag.File:  		CodedIndex = (uint)Value.Index << 5 | 16;  		break;  	case TableTag.ExportedType:  		CodedIndex = (uint)Value.Index << 5 | 17;  		break;  	case TableTag.ManifestResource:  		CodedIndex = (uint)Value.Index << 5 | 18;  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 5;  		break;  	case TableTag.Field:  		CodedIndex = (uint)Value.Index << 5 | 1;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 5 | 2;  		break;  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 5 | 3;  		break;  	case TableTag.Param:  		CodedIndex = (uint)Value.Index << 5 | 4;  		break;  	case TableTag.InterfaceImpl:  		CodedIndex = (uint)Value.Index << 5 | 5;  		break;  	case TableTag.MemberRef:  		CodedIndex = (uint)Value.Index << 5 | 6;  		break;  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 5 | 7;  		break;  	case TableTag.DeclSecurity:  		CodedIndex = (uint)Value.Index << 5 | 8;  		break;  	case TableTag.Property:  		CodedIndex = (uint)Value.Index << 5 | 9;  		break;  	case TableTag.Event:  		CodedIndex = (uint)Value.Index << 5 | 10;  		break;  	case TableTag.StandAloneSig:  		CodedIndex = (uint)Value.Index << 5 | 11;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 5 | 12;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 5 | 13;  		break;  	case TableTag.Assembly:  		CodedIndex = (uint)Value.Index << 5 | 14;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 5 | 15;  		break;  	case TableTag.File:  		CodedIndex = (uint)Value.Index << 5 | 16;  		break;  	case TableTag.ExportedType:  		CodedIndex = (uint)Value.Index << 5 | 17;  		break;  	case TableTag.ManifestResource:  		CodedIndex = (uint)Value.Index << 5 | 18;  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 5;  		break;  	case TableTag.Field:  		CodedIndex = (uint)Value.Index << 5 | 1;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 5 | 2;  		break;  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 5 | 3;  		break;  	case TableTag.Param:  		CodedIndex = (uint)Value.Index << 5 | 4;  		break;  	case TableTag.InterfaceImpl:  		CodedIndex = (uint)Value.Index << 5 | 5;  		break;  	case TableTag.MemberRef:  		CodedIndex = (uint)Value.Index << 5 | 6;  		break;  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 5 | 7;  		break;  	case TableTag.DeclSecurity:  		CodedIndex = (uint)Value.Index << 5 | 8;  		break;  	case TableTag.Property:  		CodedIndex = (uint)Value.Index << 5 | 9;  		break;  	case TableTag.Event:  		CodedIndex = (uint)Value.Index << 5 | 10;  		break;  	case TableTag.StandAloneSig:  		CodedIndex = (uint)Value.Index << 5 | 11;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 5 | 12;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 5 | 13;  		break;  	case TableTag.Assembly:  		CodedIndex = (uint)Value.Index << 5 | 14;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 5 | 15;  		break;  	case TableTag.File:  		CodedIndex = (uint)Value.Index << 5 | 16;  		break;  	case TableTag.ExportedType:  		CodedIndex = (uint)Value.Index << 5 | 17;  		break;  	case TableTag.ManifestResource:  		CodedIndex = (uint)Value.Index << 5 | 18;  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 5;  		break;  	case TableTag.Field:  		CodedIndex = (uint)Value.Index << 5 | 1;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 5 | 2;  		break;  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 5 | 3;  		break;  	case TableTag.Param:  		CodedIndex = (uint)Value.Index << 5 | 4;  		break;  	case TableTag.InterfaceImpl:  		CodedIndex = (uint)Value.Index << 5 | 5;  		break;  	case TableTag.MemberRef:  		CodedIndex = (uint)Value.Index << 5 | 6;  		break;  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 5 | 7;  		break;  	case TableTag.DeclSecurity:  		CodedIndex = (uint)Value.Index << 5 | 8;  		break;  	case TableTag.Property:  		CodedIndex = (uint)Value.Index << 5 | 9;  		break;  	case TableTag.Event:  		CodedIndex = (uint)Value.Index << 5 | 10;  		break;  	case TableTag.StandAloneSig:  		CodedIndex = (uint)Value.Index << 5 | 11;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 5 | 12;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 5 | 13;  		break;  	case TableTag.Assembly:  		CodedIndex = (uint)Value.Index << 5 | 14;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 5 | 15;  		break;  	case TableTag.File:  		CodedIndex = (uint)Value.Index << 5 | 16;  		break;  	case TableTag.ExportedType:  		CodedIndex = (uint)Value.Index << 5 | 17;  		break;  	case TableTag.ManifestResource:  		CodedIndex = (uint)Value.Index << 5 | 18;  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 5;  		break;  	case TableTag.Field:  		CodedIndex = (uint)Value.Index << 5 | 1;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 5 | 2;  		break;  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 5 | 3;  		break;  	case TableTag.Param:  		CodedIndex = (uint)Value.Index << 5 | 4;  		break;  	case TableTag.InterfaceImpl:  		CodedIndex = (uint)Value.Index << 5 | 5;  		break;  	case TableTag.MemberRef:  		CodedIndex = (uint)Value.Index << 5 | 6;  		break;  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 5 | 7;  		break;  	case TableTag.DeclSecurity:  		CodedIndex = (uint)Value.Index << 5 | 8;  		break;  	case TableTag.Property:  		CodedIndex = (uint)Value.Index << 5 | 9;  		break;  	case TableTag.Event:  		CodedIndex = (uint)Value.Index << 5 | 10;  		break;  	case TableTag.StandAloneSig:  		CodedIndex = (uint)Value.Index << 5 | 11;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 5 | 12;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 5 | 13;  		break;  	case TableTag.Assembly:  		CodedIndex = (uint)Value.Index << 5 | 14;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 5 | 15;  		break;  	case TableTag.File:  		CodedIndex = (uint)Value.Index << 5 | 16;  		break;  	case TableTag.ExportedType:  		CodedIndex = (uint)Value.Index << 5 | 17;  		break;  	case TableTag.ManifestResource:  		CodedIndex = (uint)Value.Index << 5 | 18;  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 5;  		break;  	case TableTag.Field:  		CodedIndex = (uint)Value.Index << 5 | 1;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 5 | 2;  		break;  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 5 | 3;  		break;  	case TableTag.Param:  		CodedIndex = (uint)Value.Index << 5 | 4;  		break;  	case TableTag.InterfaceImpl:  		CodedIndex = (uint)Value.Index << 5 | 5;  		break;  	case TableTag.MemberRef:  		CodedIndex = (uint)Value.Index << 5 | 6;  		break;  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 5 | 7;  		break;  	case TableTag.DeclSecurity:  		CodedIndex = (uint)Value.Index << 5 | 8;  		break;  	case TableTag.Property:  		CodedIndex = (uint)Value.Index << 5 | 9;  		break;  	case TableTag.Event:  		CodedIndex = (uint)Value.Index << 5 | 10;  		break;  	case TableTag.StandAloneSig:  		CodedIndex = (uint)Value.Index << 5 | 11;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 5 | 12;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 5 | 13;  		break;  	case TableTag.Assembly:  		CodedIndex = (uint)Value.Index << 5 | 14;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 5 | 15;  		break;  	case TableTag.File:  		CodedIndex = (uint)Value.Index << 5 | 16;  		break;  	case TableTag.ExportedType:  		CodedIndex = (uint)Value.Index << 5 | 17;  		break;  	case TableTag.ManifestResource:  		CodedIndex = (uint)Value.Index << 5 | 18;  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 5;  		break;  	case TableTag.Field:  		CodedIndex = (uint)Value.Index << 5 | 1;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 5 | 2;  		break;  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 5 | 3;  		break;  	case TableTag.Param:  		CodedIndex = (uint)Value.Index << 5 | 4;  		break;  	case TableTag.InterfaceImpl:  		CodedIndex = (uint)Value.Index << 5 | 5;  		break;  	case TableTag.MemberRef:  		CodedIndex = (uint)Value.Index << 5 | 6;  		break;  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 5 | 7;  		break;  	case TableTag.DeclSecurity:  		CodedIndex = (uint)Value.Index << 5 | 8;  		break;  	case TableTag.Property:  		CodedIndex = (uint)Value.Index << 5 | 9;  		break;  	case TableTag.Event:  		CodedIndex = (uint)Value.Index << 5 | 10;  		break;  	case TableTag.StandAloneSig:  		CodedIndex = (uint)Value.Index << 5 | 11;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 5 | 12;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 5 | 13;  		break;  	case TableTag.Assembly:  		CodedIndex = (uint)Value.Index << 5 | 14;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 5 | 15;  		break;  	case TableTag.File:  		CodedIndex = (uint)Value.Index << 5 | 16;  		break;  	case TableTag.ExportedType:  		CodedIndex = (uint)Value.Index << 5 | 17;  		break;  	case TableTag.ManifestResource:  		CodedIndex = (uint)Value.Index << 5 | 18;  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 5;  		break;  	case TableTag.Field:  		CodedIndex = (uint)Value.Index << 5 | 1;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 5 | 2;  		break;  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 5 | 3;  		break;  	case TableTag.Param:  		CodedIndex = (uint)Value.Index << 5 | 4;  		break;  	case TableTag.InterfaceImpl:  		CodedIndex = (uint)Value.Index << 5 | 5;  		break;  	case TableTag.MemberRef:  		CodedIndex = (uint)Value.Index << 5 | 6;  		break;  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 5 | 7;  		break;  	case TableTag.DeclSecurity:  		CodedIndex = (uint)Value.Index << 5 | 8;  		break;  	case TableTag.Property:  		CodedIndex = (uint)Value.Index << 5 | 9;  		break;  	case TableTag.Event:  		CodedIndex = (uint)Value.Index << 5 | 10;  		break;  	case TableTag.StandAloneSig:  		CodedIndex = (uint)Value.Index << 5 | 11;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 5 | 12;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 5 | 13;  		break;  	case TableTag.Assembly:  		CodedIndex = (uint)Value.Index << 5 | 14;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 5 | 15;  		break;  	case TableTag.File:  		CodedIndex = (uint)Value.Index << 5 | 16;  		break;  	case TableTag.ExportedType:  		CodedIndex = (uint)Value.Index << 5 | 17;  		break;  	case TableTag.ManifestResource:  		CodedIndex = (uint)Value.Index << 5 | 18;  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 5;  		break;  	case TableTag.Field:  		CodedIndex = (uint)Value.Index << 5 | 1;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 5 | 2;  		break;  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 5 | 3;  		break;  	case TableTag.Param:  		CodedIndex = (uint)Value.Index << 5 | 4;  		break;  	case TableTag.InterfaceImpl:  		CodedIndex = (uint)Value.Index << 5 | 5;  		break;  	case TableTag.MemberRef:  		CodedIndex = (uint)Value.Index << 5 | 6;  		break;  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 5 | 7;  		break;  	case TableTag.DeclSecurity:  		CodedIndex = (uint)Value.Index << 5 | 8;  		break;  	case TableTag.Property:  		CodedIndex = (uint)Value.Index << 5 | 9;  		break;  	case TableTag.Event:  		CodedIndex = (uint)Value.Index << 5 | 10;  		break;  	case TableTag.StandAloneSig:  		CodedIndex = (uint)Value.Index << 5 | 11;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 5 | 12;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 5 | 13;  		break;  	case TableTag.Assembly:  		CodedIndex = (uint)Value.Index << 5 | 14;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 5 | 15;  		break;  	case TableTag.File:  		CodedIndex = (uint)Value.Index << 5 | 16;  		break;  	case TableTag.ExportedType:  		CodedIndex = (uint)Value.Index << 5 | 17;  		break;  	case TableTag.ManifestResource:  		CodedIndex = (uint)Value.Index << 5 | 18;  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 5;  		break;  	case TableTag.Field:  		CodedIndex = (uint)Value.Index << 5 | 1;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 5 | 2;  		break;  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 5 | 3;  		break;  	case TableTag.Param:  		CodedIndex = (uint)Value.Index << 5 | 4;  		break;  	case TableTag.InterfaceImpl:  		CodedIndex = (uint)Value.Index << 5 | 5;  		break;  	case TableTag.MemberRef:  		CodedIndex = (uint)Value.Index << 5 | 6;  		break;  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 5 | 7;  		break;  	case TableTag.DeclSecurity:  		CodedIndex = (uint)Value.Index << 5 | 8;  		break;  	case TableTag.Property:  		CodedIndex = (uint)Value.Index << 5 | 9;  		break;  	case TableTag.Event:  		CodedIndex = (uint)Value.Index << 5 | 10;  		break;  	case TableTag.StandAloneSig:  		CodedIndex = (uint)Value.Index << 5 | 11;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 5 | 12;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 5 | 13;  		break;  	case TableTag.Assembly:  		CodedIndex = (uint)Value.Index << 5 | 14;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 5 | 15;  		break;  	case TableTag.File:  		CodedIndex = (uint)Value.Index << 5 | 16;  		break;  	case TableTag.ExportedType:  		CodedIndex = (uint)Value.Index << 5 | 17;  		break;  	case TableTag.ManifestResource:  		CodedIndex = (uint)Value.Index << 5 | 18;  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 5;  		break;  	case TableTag.Field:  		CodedIndex = (uint)Value.Index << 5 | 1;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 5 | 2;  		break;  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 5 | 3;  		break;  	case TableTag.Param:  		CodedIndex = (uint)Value.Index << 5 | 4;  		break;  	case TableTag.InterfaceImpl:  		CodedIndex = (uint)Value.Index << 5 | 5;  		break;  	case TableTag.MemberRef:  		CodedIndex = (uint)Value.Index << 5 | 6;  		break;  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 5 | 7;  		break;  	case TableTag.DeclSecurity:  		CodedIndex = (uint)Value.Index << 5 | 8;  		break;  	case TableTag.Property:  		CodedIndex = (uint)Value.Index << 5 | 9;  		break;  	case TableTag.Event:  		CodedIndex = (uint)Value.Index << 5 | 10;  		break;  	case TableTag.StandAloneSig:  		CodedIndex = (uint)Value.Index << 5 | 11;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 5 | 12;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 5 | 13;  		break;  	case TableTag.Assembly:  		CodedIndex = (uint)Value.Index << 5 | 14;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 5 | 15;  		break;  	case TableTag.File:  		CodedIndex = (uint)Value.Index << 5 | 16;  		break;  	case TableTag.ExportedType:  		CodedIndex = (uint)Value.Index << 5 | 17;  		break;  	case TableTag.ManifestResource:  		CodedIndex = (uint)Value.Index << 5 | 18;  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 5;  		break;  	case TableTag.Field:  		CodedIndex = (uint)Value.Index << 5 | 1;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 5 | 2;  		break;  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 5 | 3;  		break;  	case TableTag.Param:  		CodedIndex = (uint)Value.Index << 5 | 4;  		break;  	case TableTag.InterfaceImpl:  		CodedIndex = (uint)Value.Index << 5 | 5;  		break;  	case TableTag.MemberRef:  		CodedIndex = (uint)Value.Index << 5 | 6;  		break;  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 5 | 7;  		break;  	case TableTag.DeclSecurity:  		CodedIndex = (uint)Value.Index << 5 | 8;  		break;  	case TableTag.Property:  		CodedIndex = (uint)Value.Index << 5 | 9;  		break;  	case TableTag.Event:  		CodedIndex = (uint)Value.Index << 5 | 10;  		break;  	case TableTag.StandAloneSig:  		CodedIndex = (uint)Value.Index << 5 | 11;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 5 | 12;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 5 | 13;  		break;  	case TableTag.Assembly:  		CodedIndex = (uint)Value.Index << 5 | 14;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 5 | 15;  		break;  	case TableTag.File:  		CodedIndex = (uint)Value.Index << 5 | 16;  		break;  	case TableTag.ExportedType:  		CodedIndex = (uint)Value.Index << 5 | 17;  		break;  	case TableTag.ManifestResource:  		CodedIndex = (uint)Value.Index << 5 | 18;  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 5;  		break;  	case TableTag.Field:  		CodedIndex = (uint)Value.Index << 5 | 1;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 5 | 2;  		break;  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 5 | 3;  		break;  	case TableTag.Param:  		CodedIndex = (uint)Value.Index << 5 | 4;  		break;  	case TableTag.InterfaceImpl:  		CodedIndex = (uint)Value.Index << 5 | 5;  		break;  	case TableTag.MemberRef:  		CodedIndex = (uint)Value.Index << 5 | 6;  		break;  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 5 | 7;  		break;  	case TableTag.DeclSecurity:  		CodedIndex = (uint)Value.Index << 5 | 8;  		break;  	case TableTag.Property:  		CodedIndex = (uint)Value.Index << 5 | 9;  		break;  	case TableTag.Event:  		CodedIndex = (uint)Value.Index << 5 | 10;  		break;  	case TableTag.StandAloneSig:  		CodedIndex = (uint)Value.Index << 5 | 11;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 5 | 12;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 5 | 13;  		break;  	case TableTag.Assembly:  		CodedIndex = (uint)Value.Index << 5 | 14;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 5 | 15;  		break;  	case TableTag.File:  		CodedIndex = (uint)Value.Index << 5 | 16;  		break;  	case TableTag.ExportedType:  		CodedIndex = (uint)Value.Index << 5 | 17;  		break;  	case TableTag.ManifestResource:  		CodedIndex = (uint)Value.Index << 5 | 18;  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 5;  		break;  	case TableTag.Field:  		CodedIndex = (uint)Value.Index << 5 | 1;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 5 | 2;  		break;  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 5 | 3;  		break;  	case TableTag.Param:  		CodedIndex = (uint)Value.Index << 5 | 4;  		break;  	case TableTag.InterfaceImpl:  		CodedIndex = (uint)Value.Index << 5 | 5;  		break;  	case TableTag.MemberRef:  		CodedIndex = (uint)Value.Index << 5 | 6;  		break;  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 5 | 7;  		break;  	case TableTag.DeclSecurity:  		CodedIndex = (uint)Value.Index << 5 | 8;  		break;  	case TableTag.Property:  		CodedIndex = (uint)Value.Index << 5 | 9;  		break;  	case TableTag.Event:  		CodedIndex = (uint)Value.Index << 5 | 10;  		break;  	case TableTag.StandAloneSig:  		CodedIndex = (uint)Value.Index << 5 | 11;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 5 | 12;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 5 | 13;  		break;  	case TableTag.Assembly:  		CodedIndex = (uint)Value.Index << 5 | 14;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 5 | 15;  		break;  	case TableTag.File:  		CodedIndex = (uint)Value.Index << 5 | 16;  		break;  	case TableTag.ExportedType:  		CodedIndex = (uint)Value.Index << 5 | 17;  		break;  	case TableTag.ManifestResource:  		CodedIndex = (uint)Value.Index << 5 | 18;  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 5;  		break;  	case TableTag.Field:  		CodedIndex = (uint)Value.Index << 5 | 1;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 5 | 2;  		break;  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 5 | 3;  		break;  	case TableTag.Param:  		CodedIndex = (uint)Value.Index << 5 | 4;  		break;  	case TableTag.InterfaceImpl:  		CodedIndex = (uint)Value.Index << 5 | 5;  		break;  	case TableTag.MemberRef:  		CodedIndex = (uint)Value.Index << 5 | 6;  		break;  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 5 | 7;  		break;  	case TableTag.DeclSecurity:  		CodedIndex = (uint)Value.Index << 5 | 8;  		break;  	case TableTag.Property:  		CodedIndex = (uint)Value.Index << 5 | 9;  		break;  	case TableTag.Event:  		CodedIndex = (uint)Value.Index << 5 | 10;  		break;  	case TableTag.StandAloneSig:  		CodedIndex = (uint)Value.Index << 5 | 11;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 5 | 12;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 5 | 13;  		break;  	case TableTag.Assembly:  		CodedIndex = (uint)Value.Index << 5 | 14;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 5 | 15;  		break;  	case TableTag.File:  		CodedIndex = (uint)Value.Index << 5 | 16;  		break;  	case TableTag.ExportedType:  		CodedIndex = (uint)Value.Index << 5 | 17;  		break;  	case TableTag.ManifestResource:  		CodedIndex = (uint)Value.Index << 5 | 18;  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 5;  		break;  	case TableTag.Field:  		CodedIndex = (uint)Value.Index << 5 | 1;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 5 | 2;  		break;  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 5 | 3;  		break;  	case TableTag.Param:  		CodedIndex = (uint)Value.Index << 5 | 4;  		break;  	case TableTag.InterfaceImpl:  		CodedIndex = (uint)Value.Index << 5 | 5;  		break;  	case TableTag.MemberRef:  		CodedIndex = (uint)Value.Index << 5 | 6;  		break;  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 5 | 7;  		break;  	case TableTag.DeclSecurity:  		CodedIndex = (uint)Value.Index << 5 | 8;  		break;  	case TableTag.Property:  		CodedIndex = (uint)Value.Index << 5 | 9;  		break;  	case TableTag.Event:  		CodedIndex = (uint)Value.Index << 5 | 10;  		break;  	case TableTag.StandAloneSig:  		CodedIndex = (uint)Value.Index << 5 | 11;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 5 | 12;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 5 | 13;  		break;  	case TableTag.Assembly:  		CodedIndex = (uint)Value.Index << 5 | 14;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 5 | 15;  		break;  	case TableTag.File:  		CodedIndex = (uint)Value.Index << 5 | 16;  		break;  	case TableTag.ExportedType:  		CodedIndex = (uint)Value.Index << 5 | 17;  		break;  	case TableTag.ManifestResource:  		CodedIndex = (uint)Value.Index << 5 | 18;  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 5;  		break;  	case TableTag.Field:  		CodedIndex = (uint)Value.Index << 5 | 1;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 5 | 2;  		break;  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 5 | 3;  		break;  	case TableTag.Param:  		CodedIndex = (uint)Value.Index << 5 | 4;  		break;  	case TableTag.InterfaceImpl:  		CodedIndex = (uint)Value.Index << 5 | 5;  		break;  	case TableTag.MemberRef:  		CodedIndex = (uint)Value.Index << 5 | 6;  		break;  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 5 | 7;  		break;  	case TableTag.DeclSecurity:  		CodedIndex = (uint)Value.Index << 5 | 8;  		break;  	case TableTag.Property:  		CodedIndex = (uint)Value.Index << 5 | 9;  		break;  	case TableTag.Event:  		CodedIndex = (uint)Value.Index << 5 | 10;  		break;  	case TableTag.StandAloneSig:  		CodedIndex = (uint)Value.Index << 5 | 11;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 5 | 12;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 5 | 13;  		break;  	case TableTag.Assembly:  		CodedIndex = (uint)Value.Index << 5 | 14;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 5 | 15;  		break;  	case TableTag.File:  		CodedIndex = (uint)Value.Index << 5 | 16;  		break;  	case TableTag.ExportedType:  		CodedIndex = (uint)Value.Index << 5 | 17;  		break;  	case TableTag.ManifestResource:  		CodedIndex = (uint)Value.Index << 5 | 18;  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 5;  		break;  	case TableTag.Field:  		CodedIndex = (uint)Value.Index << 5 | 1;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 5 | 2;  		break;  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 5 | 3;  		break;  	case TableTag.Param:  		CodedIndex = (uint)Value.Index << 5 | 4;  		break;  	case TableTag.InterfaceImpl:  		CodedIndex = (uint)Value.Index << 5 | 5;  		break;  	case TableTag.MemberRef:  		CodedIndex = (uint)Value.Index << 5 | 6;  		break;  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 5 | 7;  		break;  	case TableTag.DeclSecurity:  		CodedIndex = (uint)Value.Index << 5 | 8;  		break;  	case TableTag.Property:  		CodedIndex = (uint)Value.Index << 5 | 9;  		break;  	case TableTag.Event:  		CodedIndex = (uint)Value.Index << 5 | 10;  		break;  	case TableTag.StandAloneSig:  		CodedIndex = (uint)Value.Index << 5 | 11;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 5 | 12;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 5 | 13;  		break;  	case TableTag.Assembly:  		CodedIndex = (uint)Value.Index << 5 | 14;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 5 | 15;  		break;  	case TableTag.File:  		CodedIndex = (uint)Value.Index << 5 | 16;  		break;  	case TableTag.ExportedType:  		CodedIndex = (uint)Value.Index << 5 | 17;  		break;  	case TableTag.ManifestResource:  		CodedIndex = (uint)Value.Index << 5 | 18;  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 5;  		break;  	case TableTag.Field:  		CodedIndex = (uint)Value.Index << 5 | 1;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 5 | 2;  		break;  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 5 | 3;  		break;  	case TableTag.Param:  		CodedIndex = (uint)Value.Index << 5 | 4;  		break;  	case TableTag.InterfaceImpl:  		CodedIndex = (uint)Value.Index << 5 | 5;  		break;  	case TableTag.MemberRef:  		CodedIndex = (uint)Value.Index << 5 | 6;  		break;  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 5 | 7;  		break;  	case TableTag.DeclSecurity:  		CodedIndex = (uint)Value.Index << 5 | 8;  		break;  	case TableTag.Property:  		CodedIndex = (uint)Value.Index << 5 | 9;  		break;  	case TableTag.Event:  		CodedIndex = (uint)Value.Index << 5 | 10;  		break;  	case TableTag.StandAloneSig:  		CodedIndex = (uint)Value.Index << 5 | 11;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 5 | 12;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 5 | 13;  		break;  	case TableTag.Assembly:  		CodedIndex = (uint)Value.Index << 5 | 14;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 5 | 15;  		break;  	case TableTag.File:  		CodedIndex = (uint)Value.Index << 5 | 16;  		break;  	case TableTag.ExportedType:  		CodedIndex = (uint)Value.Index << 5 | 17;  		break;  	case TableTag.ManifestResource:  		CodedIndex = (uint)Value.Index << 5 | 18;  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 5;  		break;  	case TableTag.Field:  		CodedIndex = (uint)Value.Index << 5 | 1;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 5 | 2;  		break;  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 5 | 3;  		break;  	case TableTag.Param:  		CodedIndex = (uint)Value.Index << 5 | 4;  		break;  	case TableTag.InterfaceImpl:  		CodedIndex = (uint)Value.Index << 5 | 5;  		break;  	case TableTag.MemberRef:  		CodedIndex = (uint)Value.Index << 5 | 6;  		break;  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 5 | 7;  		break;  	case TableTag.DeclSecurity:  		CodedIndex = (uint)Value.Index << 5 | 8;  		break;  	case TableTag.Property:  		CodedIndex = (uint)Value.Index << 5 | 9;  		break;  	case TableTag.Event:  		CodedIndex = (uint)Value.Index << 5 | 10;  		break;  	case TableTag.StandAloneSig:  		CodedIndex = (uint)Value.Index << 5 | 11;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 5 | 12;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 5 | 13;  		break;  	case TableTag.Assembly:  		CodedIndex = (uint)Value.Index << 5 | 14;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 5 | 15;  		break;  	case TableTag.File:  		CodedIndex = (uint)Value.Index << 5 | 16;  		break;  	case TableTag.ExportedType:  		CodedIndex = (uint)Value.Index << 5 | 17;  		break;  	case TableTag.ManifestResource:  		CodedIndex = (uint)Value.Index << 5 | 18;  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 5;  		break;  	case TableTag.Field:  		CodedIndex = (uint)Value.Index << 5 | 1;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 5 | 2;  		break;  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 5 | 3;  		break;  	case TableTag.Param:  		CodedIndex = (uint)Value.Index << 5 | 4;  		break;  	case TableTag.InterfaceImpl:  		CodedIndex = (uint)Value.Index << 5 | 5;  		break;  	case TableTag.MemberRef:  		CodedIndex = (uint)Value.Index << 5 | 6;  		break;  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 5 | 7;  		break;  	case TableTag.DeclSecurity:  		CodedIndex = (uint)Value.Index << 5 | 8;  		break;  	case TableTag.Property:  		CodedIndex = (uint)Value.Index << 5 | 9;  		break;  	case TableTag.Event:  		CodedIndex = (uint)Value.Index << 5 | 10;  		break;  	case TableTag.StandAloneSig:  		CodedIndex = (uint)Value.Index << 5 | 11;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 5 | 12;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 5 | 13;  		break;  	case TableTag.Assembly:  		CodedIndex = (uint)Value.Index << 5 | 14;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 5 | 15;  		break;  	case TableTag.File:  		CodedIndex = (uint)Value.Index << 5 | 16;  		break;  	case TableTag.ExportedType:  		CodedIndex = (uint)Value.Index << 5 | 17;  		break;  	case TableTag.ManifestResource:  		CodedIndex = (uint)Value.Index << 5 | 18;  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 5;  		break;  	case TableTag.Field:  		CodedIndex = (uint)Value.Index << 5 | 1;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 5 | 2;  		break;  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 5 | 3;  		break;  	case TableTag.Param:  		CodedIndex = (uint)Value.Index << 5 | 4;  		break;  	case TableTag.InterfaceImpl:  		CodedIndex = (uint)Value.Index << 5 | 5;  		break;  	case TableTag.MemberRef:  		CodedIndex = (uint)Value.Index << 5 | 6;  		break;  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 5 | 7;  		break;  	case TableTag.DeclSecurity:  		CodedIndex = (uint)Value.Index << 5 | 8;  		break;  	case TableTag.Property:  		CodedIndex = (uint)Value.Index << 5 | 9;  		break;  	case TableTag.Event:  		CodedIndex = (uint)Value.Index << 5 | 10;  		break;  	case TableTag.StandAloneSig:  		CodedIndex = (uint)Value.Index << 5 | 11;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 5 | 12;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 5 | 13;  		break;  	case TableTag.Assembly:  		CodedIndex = (uint)Value.Index << 5 | 14;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 5 | 15;  		break;  	case TableTag.File:  		CodedIndex = (uint)Value.Index << 5 | 16;  		break;  	case TableTag.ExportedType:  		CodedIndex = (uint)Value.Index << 5 | 17;  		break;  	case TableTag.ManifestResource:  		CodedIndex = (uint)Value.Index << 5 | 18;  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 5;  		break;  	case TableTag.Field:  		CodedIndex = (uint)Value.Index << 5 | 1;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 5 | 2;  		break;  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 5 | 3;  		break;  	case TableTag.Param:  		CodedIndex = (uint)Value.Index << 5 | 4;  		break;  	case TableTag.InterfaceImpl:  		CodedIndex = (uint)Value.Index << 5 | 5;  		break;  	case TableTag.MemberRef:  		CodedIndex = (uint)Value.Index << 5 | 6;  		break;  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 5 | 7;  		break;  	case TableTag.DeclSecurity:  		CodedIndex = (uint)Value.Index << 5 | 8;  		break;  	case TableTag.Property:  		CodedIndex = (uint)Value.Index << 5 | 9;  		break;  	case TableTag.Event:  		CodedIndex = (uint)Value.Index << 5 | 10;  		break;  	case TableTag.StandAloneSig:  		CodedIndex = (uint)Value.Index << 5 | 11;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 5 | 12;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 5 | 13;  		break;  	case TableTag.Assembly:  		CodedIndex = (uint)Value.Index << 5 | 14;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 5 | 15;  		break;  	case TableTag.File:  		CodedIndex = (uint)Value.Index << 5 | 16;  		break;  	case TableTag.ExportedType:  		CodedIndex = (uint)Value.Index << 5 | 17;  		break;  	case TableTag.ManifestResource:  		CodedIndex = (uint)Value.Index << 5 | 18;  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 5;  		break;  	case TableTag.Field:  		CodedIndex = (uint)Value.Index << 5 | 1;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 5 | 2;  		break;  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 5 | 3;  		break;  	case TableTag.Param:  		CodedIndex = (uint)Value.Index << 5 | 4;  		break;  	case TableTag.InterfaceImpl:  		CodedIndex = (uint)Value.Index << 5 | 5;  		break;  	case TableTag.MemberRef:  		CodedIndex = (uint)Value.Index << 5 | 6;  		break;  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 5 | 7;  		break;  	case TableTag.DeclSecurity:  		CodedIndex = (uint)Value.Index << 5 | 8;  		break;  	case TableTag.Property:  		CodedIndex = (uint)Value.Index << 5 | 9;  		break;  	case TableTag.Event:  		CodedIndex = (uint)Value.Index << 5 | 10;  		break;  	case TableTag.StandAloneSig:  		CodedIndex = (uint)Value.Index << 5 | 11;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 5 | 12;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 5 | 13;  		break;  	case TableTag.Assembly:  		CodedIndex = (uint)Value.Index << 5 | 14;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 5 | 15;  		break;  	case TableTag.File:  		CodedIndex = (uint)Value.Index << 5 | 16;  		break;  	case TableTag.ExportedType:  		CodedIndex = (uint)Value.Index << 5 | 17;  		break;  	case TableTag.ManifestResource:  		CodedIndex = (uint)Value.Index << 5 | 18;  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 5;  		break;  	case TableTag.Field:  		CodedIndex = (uint)Value.Index << 5 | 1;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 5 | 2;  		break;  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 5 | 3;  		break;  	case TableTag.Param:  		CodedIndex = (uint)Value.Index << 5 | 4;  		break;  	case TableTag.InterfaceImpl:  		CodedIndex = (uint)Value.Index << 5 | 5;  		break;  	case TableTag.MemberRef:  		CodedIndex = (uint)Value.Index << 5 | 6;  		break;  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 5 | 7;  		break;  	case TableTag.DeclSecurity:  		CodedIndex = (uint)Value.Index << 5 | 8;  		break;  	case TableTag.Property:  		CodedIndex = (uint)Value.Index << 5 | 9;  		break;  	case TableTag.Event:  		CodedIndex = (uint)Value.Index << 5 | 10;  		break;  	case TableTag.StandAloneSig:  		CodedIndex = (uint)Value.Index << 5 | 11;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 5 | 12;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 5 | 13;  		break;  	case TableTag.Assembly:  		CodedIndex = (uint)Value.Index << 5 | 14;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 5 | 15;  		break;  	case TableTag.File:  		CodedIndex = (uint)Value.Index << 5 | 16;  		break;  	case TableTag.ExportedType:  		CodedIndex = (uint)Value.Index << 5 | 17;  		break;  	case TableTag.ManifestResource:  		CodedIndex = (uint)Value.Index << 5 | 18;  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 5;  		break;  	case TableTag.Field:  		CodedIndex = (uint)Value.Index << 5 | 1;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 5 | 2;  		break;  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 5 | 3;  		break;  	case TableTag.Param:  		CodedIndex = (uint)Value.Index << 5 | 4;  		break;  	case TableTag.InterfaceImpl:  		CodedIndex = (uint)Value.Index << 5 | 5;  		break;  	case TableTag.MemberRef:  		CodedIndex = (uint)Value.Index << 5 | 6;  		break;  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 5 | 7;  		break;  	case TableTag.DeclSecurity:  		CodedIndex = (uint)Value.Index << 5 | 8;  		break;  	case TableTag.Property:  		CodedIndex = (uint)Value.Index << 5 | 9;  		break;  	case TableTag.Event:  		CodedIndex = (uint)Value.Index << 5 | 10;  		break;  	case TableTag.StandAloneSig:  		CodedIndex = (uint)Value.Index << 5 | 11;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 5 | 12;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 5 | 13;  		break;  	case TableTag.Assembly:  		CodedIndex = (uint)Value.Index << 5 | 14;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 5 | 15;  		break;  	case TableTag.File:  		CodedIndex = (uint)Value.Index << 5 | 16;  		break;  	case TableTag.ExportedType:  		CodedIndex = (uint)Value.Index << 5 | 17;  		break;  	case TableTag.ManifestResource:  		CodedIndex = (uint)Value.Index << 5 | 18;  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 5;  		break;  	case TableTag.Field:  		CodedIndex = (uint)Value.Index << 5 | 1;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 5 | 2;  		break;  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 5 | 3;  		break;  	case TableTag.Param:  		CodedIndex = (uint)Value.Index << 5 | 4;  		break;  	case TableTag.InterfaceImpl:  		CodedIndex = (uint)Value.Index << 5 | 5;  		break;  	case TableTag.MemberRef:  		CodedIndex = (uint)Value.Index << 5 | 6;  		break;  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 5 | 7;  		break;  	case TableTag.DeclSecurity:  		CodedIndex = (uint)Value.Index << 5 | 8;  		break;  	case TableTag.Property:  		CodedIndex = (uint)Value.Index << 5 | 9;  		break;  	case TableTag.Event:  		CodedIndex = (uint)Value.Index << 5 | 10;  		break;  	case TableTag.StandAloneSig:  		CodedIndex = (uint)Value.Index << 5 | 11;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 5 | 12;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 5 | 13;  		break;  	case TableTag.Assembly:  		CodedIndex = (uint)Value.Index << 5 | 14;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 5 | 15;  		break;  	case TableTag.File:  		CodedIndex = (uint)Value.Index << 5 | 16;  		break;  	case TableTag.ExportedType:  		CodedIndex = (uint)Value.Index << 5 | 17;  		break;  	case TableTag.ManifestResource:  		CodedIndex = (uint)Value.Index << 5 | 18;  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 5;  		break;  	case TableTag.Field:  		CodedIndex = (uint)Value.Index << 5 | 1;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 5 | 2;  		break;  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 5 | 3;  		break;  	case TableTag.Param:  		CodedIndex = (uint)Value.Index << 5 | 4;  		break;  	case TableTag.InterfaceImpl:  		CodedIndex = (uint)Value.Index << 5 | 5;  		break;  	case TableTag.MemberRef:  		CodedIndex = (uint)Value.Index << 5 | 6;  		break;  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 5 | 7;  		break;  	case TableTag.DeclSecurity:  		CodedIndex = (uint)Value.Index << 5 | 8;  		break;  	case TableTag.Property:  		CodedIndex = (uint)Value.Index << 5 | 9;  		break;  	case TableTag.Event:  		CodedIndex = (uint)Value.Index << 5 | 10;  		break;  	case TableTag.StandAloneSig:  		CodedIndex = (uint)Value.Index << 5 | 11;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 5 | 12;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 5 | 13;  		break;  	case TableTag.Assembly:  		CodedIndex = (uint)Value.Index << 5 | 14;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 5 | 15;  		break;  	case TableTag.File:  		CodedIndex = (uint)Value.Index << 5 | 16;  		break;  	case TableTag.ExportedType:  		CodedIndex = (uint)Value.Index << 5 | 17;  		break;  	case TableTag.ManifestResource:  		CodedIndex = (uint)Value.Index << 5 | 18;  		break;  	default:  		throw new PEException ("invalid HasCustomAttribute row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 5;  	break;  case TableTag.Field:  	CodedIndex = (uint)Value.Index << 5 | 1;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 5 | 2;  	break;  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 5 | 3;  	break;  case TableTag.Param:  	CodedIndex = (uint)Value.Index << 5 | 4;  	break;  case TableTag.InterfaceImpl:  	CodedIndex = (uint)Value.Index << 5 | 5;  	break;  case TableTag.MemberRef:  	CodedIndex = (uint)Value.Index << 5 | 6;  	break;  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 5 | 7;  	break;  case TableTag.DeclSecurity:  	CodedIndex = (uint)Value.Index << 5 | 8;  	break;  case TableTag.Property:  	CodedIndex = (uint)Value.Index << 5 | 9;  	break;  case TableTag.Event:  	CodedIndex = (uint)Value.Index << 5 | 10;  	break;  case TableTag.StandAloneSig:  	CodedIndex = (uint)Value.Index << 5 | 11;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 5 | 12;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 5 | 13;  	break;  case TableTag.Assembly:  	CodedIndex = (uint)Value.Index << 5 | 14;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 5 | 15;  	break;  case TableTag.File:  	CodedIndex = (uint)Value.Index << 5 | 16;  	break;  case TableTag.ExportedType:  	CodedIndex = (uint)Value.Index << 5 | 17;  	break;  case TableTag.ManifestResource:  	CodedIndex = (uint)Value.Index << 5 | 18;  	break;  default:  	throw new PEException ("invalid HasCustomAttribute row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 5;  	break;  case TableTag.Field:  	CodedIndex = (uint)Value.Index << 5 | 1;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 5 | 2;  	break;  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 5 | 3;  	break;  case TableTag.Param:  	CodedIndex = (uint)Value.Index << 5 | 4;  	break;  case TableTag.InterfaceImpl:  	CodedIndex = (uint)Value.Index << 5 | 5;  	break;  case TableTag.MemberRef:  	CodedIndex = (uint)Value.Index << 5 | 6;  	break;  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 5 | 7;  	break;  case TableTag.DeclSecurity:  	CodedIndex = (uint)Value.Index << 5 | 8;  	break;  case TableTag.Property:  	CodedIndex = (uint)Value.Index << 5 | 9;  	break;  case TableTag.Event:  	CodedIndex = (uint)Value.Index << 5 | 10;  	break;  case TableTag.StandAloneSig:  	CodedIndex = (uint)Value.Index << 5 | 11;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 5 | 12;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 5 | 13;  	break;  case TableTag.Assembly:  	CodedIndex = (uint)Value.Index << 5 | 14;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 5 | 15;  	break;  case TableTag.File:  	CodedIndex = (uint)Value.Index << 5 | 16;  	break;  case TableTag.ExportedType:  	CodedIndex = (uint)Value.Index << 5 | 17;  	break;  case TableTag.ManifestResource:  	CodedIndex = (uint)Value.Index << 5 | 18;  	break;  default:  	throw new PEException ("invalid HasCustomAttribute row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 5;  	break;  case TableTag.Field:  	CodedIndex = (uint)Value.Index << 5 | 1;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 5 | 2;  	break;  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 5 | 3;  	break;  case TableTag.Param:  	CodedIndex = (uint)Value.Index << 5 | 4;  	break;  case TableTag.InterfaceImpl:  	CodedIndex = (uint)Value.Index << 5 | 5;  	break;  case TableTag.MemberRef:  	CodedIndex = (uint)Value.Index << 5 | 6;  	break;  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 5 | 7;  	break;  case TableTag.DeclSecurity:  	CodedIndex = (uint)Value.Index << 5 | 8;  	break;  case TableTag.Property:  	CodedIndex = (uint)Value.Index << 5 | 9;  	break;  case TableTag.Event:  	CodedIndex = (uint)Value.Index << 5 | 10;  	break;  case TableTag.StandAloneSig:  	CodedIndex = (uint)Value.Index << 5 | 11;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 5 | 12;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 5 | 13;  	break;  case TableTag.Assembly:  	CodedIndex = (uint)Value.Index << 5 | 14;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 5 | 15;  	break;  case TableTag.File:  	CodedIndex = (uint)Value.Index << 5 | 16;  	break;  case TableTag.ExportedType:  	CodedIndex = (uint)Value.Index << 5 | 17;  	break;  case TableTag.ManifestResource:  	CodedIndex = (uint)Value.Index << 5 | 18;  	break;  default:  	throw new PEException ("invalid HasCustomAttribute row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 5;  	break;  case TableTag.Field:  	CodedIndex = (uint)Value.Index << 5 | 1;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 5 | 2;  	break;  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 5 | 3;  	break;  case TableTag.Param:  	CodedIndex = (uint)Value.Index << 5 | 4;  	break;  case TableTag.InterfaceImpl:  	CodedIndex = (uint)Value.Index << 5 | 5;  	break;  case TableTag.MemberRef:  	CodedIndex = (uint)Value.Index << 5 | 6;  	break;  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 5 | 7;  	break;  case TableTag.DeclSecurity:  	CodedIndex = (uint)Value.Index << 5 | 8;  	break;  case TableTag.Property:  	CodedIndex = (uint)Value.Index << 5 | 9;  	break;  case TableTag.Event:  	CodedIndex = (uint)Value.Index << 5 | 10;  	break;  case TableTag.StandAloneSig:  	CodedIndex = (uint)Value.Index << 5 | 11;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 5 | 12;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 5 | 13;  	break;  case TableTag.Assembly:  	CodedIndex = (uint)Value.Index << 5 | 14;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 5 | 15;  	break;  case TableTag.File:  	CodedIndex = (uint)Value.Index << 5 | 16;  	break;  case TableTag.ExportedType:  	CodedIndex = (uint)Value.Index << 5 | 17;  	break;  case TableTag.ManifestResource:  	CodedIndex = (uint)Value.Index << 5 | 18;  	break;  default:  	throw new PEException ("invalid HasCustomAttribute row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 5;  	break;  case TableTag.Field:  	CodedIndex = (uint)Value.Index << 5 | 1;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 5 | 2;  	break;  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 5 | 3;  	break;  case TableTag.Param:  	CodedIndex = (uint)Value.Index << 5 | 4;  	break;  case TableTag.InterfaceImpl:  	CodedIndex = (uint)Value.Index << 5 | 5;  	break;  case TableTag.MemberRef:  	CodedIndex = (uint)Value.Index << 5 | 6;  	break;  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 5 | 7;  	break;  case TableTag.DeclSecurity:  	CodedIndex = (uint)Value.Index << 5 | 8;  	break;  case TableTag.Property:  	CodedIndex = (uint)Value.Index << 5 | 9;  	break;  case TableTag.Event:  	CodedIndex = (uint)Value.Index << 5 | 10;  	break;  case TableTag.StandAloneSig:  	CodedIndex = (uint)Value.Index << 5 | 11;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 5 | 12;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 5 | 13;  	break;  case TableTag.Assembly:  	CodedIndex = (uint)Value.Index << 5 | 14;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 5 | 15;  	break;  case TableTag.File:  	CodedIndex = (uint)Value.Index << 5 | 16;  	break;  case TableTag.ExportedType:  	CodedIndex = (uint)Value.Index << 5 | 17;  	break;  case TableTag.ManifestResource:  	CodedIndex = (uint)Value.Index << 5 | 18;  	break;  default:  	throw new PEException ("invalid HasCustomAttribute row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 5;  	break;  case TableTag.Field:  	CodedIndex = (uint)Value.Index << 5 | 1;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 5 | 2;  	break;  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 5 | 3;  	break;  case TableTag.Param:  	CodedIndex = (uint)Value.Index << 5 | 4;  	break;  case TableTag.InterfaceImpl:  	CodedIndex = (uint)Value.Index << 5 | 5;  	break;  case TableTag.MemberRef:  	CodedIndex = (uint)Value.Index << 5 | 6;  	break;  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 5 | 7;  	break;  case TableTag.DeclSecurity:  	CodedIndex = (uint)Value.Index << 5 | 8;  	break;  case TableTag.Property:  	CodedIndex = (uint)Value.Index << 5 | 9;  	break;  case TableTag.Event:  	CodedIndex = (uint)Value.Index << 5 | 10;  	break;  case TableTag.StandAloneSig:  	CodedIndex = (uint)Value.Index << 5 | 11;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 5 | 12;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 5 | 13;  	break;  case TableTag.Assembly:  	CodedIndex = (uint)Value.Index << 5 | 14;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 5 | 15;  	break;  case TableTag.File:  	CodedIndex = (uint)Value.Index << 5 | 16;  	break;  case TableTag.ExportedType:  	CodedIndex = (uint)Value.Index << 5 | 17;  	break;  case TableTag.ManifestResource:  	CodedIndex = (uint)Value.Index << 5 | 18;  	break;  default:  	throw new PEException ("invalid HasCustomAttribute row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 5;  	break;  case TableTag.Field:  	CodedIndex = (uint)Value.Index << 5 | 1;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 5 | 2;  	break;  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 5 | 3;  	break;  case TableTag.Param:  	CodedIndex = (uint)Value.Index << 5 | 4;  	break;  case TableTag.InterfaceImpl:  	CodedIndex = (uint)Value.Index << 5 | 5;  	break;  case TableTag.MemberRef:  	CodedIndex = (uint)Value.Index << 5 | 6;  	break;  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 5 | 7;  	break;  case TableTag.DeclSecurity:  	CodedIndex = (uint)Value.Index << 5 | 8;  	break;  case TableTag.Property:  	CodedIndex = (uint)Value.Index << 5 | 9;  	break;  case TableTag.Event:  	CodedIndex = (uint)Value.Index << 5 | 10;  	break;  case TableTag.StandAloneSig:  	CodedIndex = (uint)Value.Index << 5 | 11;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 5 | 12;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 5 | 13;  	break;  case TableTag.Assembly:  	CodedIndex = (uint)Value.Index << 5 | 14;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 5 | 15;  	break;  case TableTag.File:  	CodedIndex = (uint)Value.Index << 5 | 16;  	break;  case TableTag.ExportedType:  	CodedIndex = (uint)Value.Index << 5 | 17;  	break;  case TableTag.ManifestResource:  	CodedIndex = (uint)Value.Index << 5 | 18;  	break;  default:  	throw new PEException ("invalid HasCustomAttribute row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 5;  	break;  case TableTag.Field:  	CodedIndex = (uint)Value.Index << 5 | 1;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 5 | 2;  	break;  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 5 | 3;  	break;  case TableTag.Param:  	CodedIndex = (uint)Value.Index << 5 | 4;  	break;  case TableTag.InterfaceImpl:  	CodedIndex = (uint)Value.Index << 5 | 5;  	break;  case TableTag.MemberRef:  	CodedIndex = (uint)Value.Index << 5 | 6;  	break;  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 5 | 7;  	break;  case TableTag.DeclSecurity:  	CodedIndex = (uint)Value.Index << 5 | 8;  	break;  case TableTag.Property:  	CodedIndex = (uint)Value.Index << 5 | 9;  	break;  case TableTag.Event:  	CodedIndex = (uint)Value.Index << 5 | 10;  	break;  case TableTag.StandAloneSig:  	CodedIndex = (uint)Value.Index << 5 | 11;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 5 | 12;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 5 | 13;  	break;  case TableTag.Assembly:  	CodedIndex = (uint)Value.Index << 5 | 14;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 5 | 15;  	break;  case TableTag.File:  	CodedIndex = (uint)Value.Index << 5 | 16;  	break;  case TableTag.ExportedType:  	CodedIndex = (uint)Value.Index << 5 | 17;  	break;  case TableTag.ManifestResource:  	CodedIndex = (uint)Value.Index << 5 | 18;  	break;  default:  	throw new PEException ("invalid HasCustomAttribute row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 5;  	break;  case TableTag.Field:  	CodedIndex = (uint)Value.Index << 5 | 1;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 5 | 2;  	break;  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 5 | 3;  	break;  case TableTag.Param:  	CodedIndex = (uint)Value.Index << 5 | 4;  	break;  case TableTag.InterfaceImpl:  	CodedIndex = (uint)Value.Index << 5 | 5;  	break;  case TableTag.MemberRef:  	CodedIndex = (uint)Value.Index << 5 | 6;  	break;  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 5 | 7;  	break;  case TableTag.DeclSecurity:  	CodedIndex = (uint)Value.Index << 5 | 8;  	break;  case TableTag.Property:  	CodedIndex = (uint)Value.Index << 5 | 9;  	break;  case TableTag.Event:  	CodedIndex = (uint)Value.Index << 5 | 10;  	break;  case TableTag.StandAloneSig:  	CodedIndex = (uint)Value.Index << 5 | 11;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 5 | 12;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 5 | 13;  	break;  case TableTag.Assembly:  	CodedIndex = (uint)Value.Index << 5 | 14;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 5 | 15;  	break;  case TableTag.File:  	CodedIndex = (uint)Value.Index << 5 | 16;  	break;  case TableTag.ExportedType:  	CodedIndex = (uint)Value.Index << 5 | 17;  	break;  case TableTag.ManifestResource:  	CodedIndex = (uint)Value.Index << 5 | 18;  	break;  default:  	throw new PEException ("invalid HasCustomAttribute row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 5;  	break;  case TableTag.Field:  	CodedIndex = (uint)Value.Index << 5 | 1;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 5 | 2;  	break;  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 5 | 3;  	break;  case TableTag.Param:  	CodedIndex = (uint)Value.Index << 5 | 4;  	break;  case TableTag.InterfaceImpl:  	CodedIndex = (uint)Value.Index << 5 | 5;  	break;  case TableTag.MemberRef:  	CodedIndex = (uint)Value.Index << 5 | 6;  	break;  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 5 | 7;  	break;  case TableTag.DeclSecurity:  	CodedIndex = (uint)Value.Index << 5 | 8;  	break;  case TableTag.Property:  	CodedIndex = (uint)Value.Index << 5 | 9;  	break;  case TableTag.Event:  	CodedIndex = (uint)Value.Index << 5 | 10;  	break;  case TableTag.StandAloneSig:  	CodedIndex = (uint)Value.Index << 5 | 11;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 5 | 12;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 5 | 13;  	break;  case TableTag.Assembly:  	CodedIndex = (uint)Value.Index << 5 | 14;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 5 | 15;  	break;  case TableTag.File:  	CodedIndex = (uint)Value.Index << 5 | 16;  	break;  case TableTag.ExportedType:  	CodedIndex = (uint)Value.Index << 5 | 17;  	break;  case TableTag.ManifestResource:  	CodedIndex = (uint)Value.Index << 5 | 18;  	break;  default:  	throw new PEException ("invalid HasCustomAttribute row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 5;  	break;  case TableTag.Field:  	CodedIndex = (uint)Value.Index << 5 | 1;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 5 | 2;  	break;  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 5 | 3;  	break;  case TableTag.Param:  	CodedIndex = (uint)Value.Index << 5 | 4;  	break;  case TableTag.InterfaceImpl:  	CodedIndex = (uint)Value.Index << 5 | 5;  	break;  case TableTag.MemberRef:  	CodedIndex = (uint)Value.Index << 5 | 6;  	break;  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 5 | 7;  	break;  case TableTag.DeclSecurity:  	CodedIndex = (uint)Value.Index << 5 | 8;  	break;  case TableTag.Property:  	CodedIndex = (uint)Value.Index << 5 | 9;  	break;  case TableTag.Event:  	CodedIndex = (uint)Value.Index << 5 | 10;  	break;  case TableTag.StandAloneSig:  	CodedIndex = (uint)Value.Index << 5 | 11;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 5 | 12;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 5 | 13;  	break;  case TableTag.Assembly:  	CodedIndex = (uint)Value.Index << 5 | 14;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 5 | 15;  	break;  case TableTag.File:  	CodedIndex = (uint)Value.Index << 5 | 16;  	break;  case TableTag.ExportedType:  	CodedIndex = (uint)Value.Index << 5 | 17;  	break;  case TableTag.ManifestResource:  	CodedIndex = (uint)Value.Index << 5 | 18;  	break;  default:  	throw new PEException ("invalid HasCustomAttribute row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 5;  	break;  case TableTag.Field:  	CodedIndex = (uint)Value.Index << 5 | 1;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 5 | 2;  	break;  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 5 | 3;  	break;  case TableTag.Param:  	CodedIndex = (uint)Value.Index << 5 | 4;  	break;  case TableTag.InterfaceImpl:  	CodedIndex = (uint)Value.Index << 5 | 5;  	break;  case TableTag.MemberRef:  	CodedIndex = (uint)Value.Index << 5 | 6;  	break;  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 5 | 7;  	break;  case TableTag.DeclSecurity:  	CodedIndex = (uint)Value.Index << 5 | 8;  	break;  case TableTag.Property:  	CodedIndex = (uint)Value.Index << 5 | 9;  	break;  case TableTag.Event:  	CodedIndex = (uint)Value.Index << 5 | 10;  	break;  case TableTag.StandAloneSig:  	CodedIndex = (uint)Value.Index << 5 | 11;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 5 | 12;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 5 | 13;  	break;  case TableTag.Assembly:  	CodedIndex = (uint)Value.Index << 5 | 14;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 5 | 15;  	break;  case TableTag.File:  	CodedIndex = (uint)Value.Index << 5 | 16;  	break;  case TableTag.ExportedType:  	CodedIndex = (uint)Value.Index << 5 | 17;  	break;  case TableTag.ManifestResource:  	CodedIndex = (uint)Value.Index << 5 | 18;  	break;  default:  	throw new PEException ("invalid HasCustomAttribute row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 5;  	break;  case TableTag.Field:  	CodedIndex = (uint)Value.Index << 5 | 1;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 5 | 2;  	break;  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 5 | 3;  	break;  case TableTag.Param:  	CodedIndex = (uint)Value.Index << 5 | 4;  	break;  case TableTag.InterfaceImpl:  	CodedIndex = (uint)Value.Index << 5 | 5;  	break;  case TableTag.MemberRef:  	CodedIndex = (uint)Value.Index << 5 | 6;  	break;  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 5 | 7;  	break;  case TableTag.DeclSecurity:  	CodedIndex = (uint)Value.Index << 5 | 8;  	break;  case TableTag.Property:  	CodedIndex = (uint)Value.Index << 5 | 9;  	break;  case TableTag.Event:  	CodedIndex = (uint)Value.Index << 5 | 10;  	break;  case TableTag.StandAloneSig:  	CodedIndex = (uint)Value.Index << 5 | 11;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 5 | 12;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 5 | 13;  	break;  case TableTag.Assembly:  	CodedIndex = (uint)Value.Index << 5 | 14;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 5 | 15;  	break;  case TableTag.File:  	CodedIndex = (uint)Value.Index << 5 | 16;  	break;  case TableTag.ExportedType:  	CodedIndex = (uint)Value.Index << 5 | 17;  	break;  case TableTag.ManifestResource:  	CodedIndex = (uint)Value.Index << 5 | 18;  	break;  default:  	throw new PEException ("invalid HasCustomAttribute row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 5;  	break;  case TableTag.Field:  	CodedIndex = (uint)Value.Index << 5 | 1;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 5 | 2;  	break;  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 5 | 3;  	break;  case TableTag.Param:  	CodedIndex = (uint)Value.Index << 5 | 4;  	break;  case TableTag.InterfaceImpl:  	CodedIndex = (uint)Value.Index << 5 | 5;  	break;  case TableTag.MemberRef:  	CodedIndex = (uint)Value.Index << 5 | 6;  	break;  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 5 | 7;  	break;  case TableTag.DeclSecurity:  	CodedIndex = (uint)Value.Index << 5 | 8;  	break;  case TableTag.Property:  	CodedIndex = (uint)Value.Index << 5 | 9;  	break;  case TableTag.Event:  	CodedIndex = (uint)Value.Index << 5 | 10;  	break;  case TableTag.StandAloneSig:  	CodedIndex = (uint)Value.Index << 5 | 11;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 5 | 12;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 5 | 13;  	break;  case TableTag.Assembly:  	CodedIndex = (uint)Value.Index << 5 | 14;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 5 | 15;  	break;  case TableTag.File:  	CodedIndex = (uint)Value.Index << 5 | 16;  	break;  case TableTag.ExportedType:  	CodedIndex = (uint)Value.Index << 5 | 17;  	break;  case TableTag.ManifestResource:  	CodedIndex = (uint)Value.Index << 5 | 18;  	break;  default:  	throw new PEException ("invalid HasCustomAttribute row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 5;  	break;  case TableTag.Field:  	CodedIndex = (uint)Value.Index << 5 | 1;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 5 | 2;  	break;  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 5 | 3;  	break;  case TableTag.Param:  	CodedIndex = (uint)Value.Index << 5 | 4;  	break;  case TableTag.InterfaceImpl:  	CodedIndex = (uint)Value.Index << 5 | 5;  	break;  case TableTag.MemberRef:  	CodedIndex = (uint)Value.Index << 5 | 6;  	break;  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 5 | 7;  	break;  case TableTag.DeclSecurity:  	CodedIndex = (uint)Value.Index << 5 | 8;  	break;  case TableTag.Property:  	CodedIndex = (uint)Value.Index << 5 | 9;  	break;  case TableTag.Event:  	CodedIndex = (uint)Value.Index << 5 | 10;  	break;  case TableTag.StandAloneSig:  	CodedIndex = (uint)Value.Index << 5 | 11;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 5 | 12;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 5 | 13;  	break;  case TableTag.Assembly:  	CodedIndex = (uint)Value.Index << 5 | 14;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 5 | 15;  	break;  case TableTag.File:  	CodedIndex = (uint)Value.Index << 5 | 16;  	break;  case TableTag.ExportedType:  	CodedIndex = (uint)Value.Index << 5 | 17;  	break;  case TableTag.ManifestResource:  	CodedIndex = (uint)Value.Index << 5 | 18;  	break;  default:  	throw new PEException ("invalid HasCustomAttribute row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 5;  	break;  case TableTag.Field:  	CodedIndex = (uint)Value.Index << 5 | 1;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 5 | 2;  	break;  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 5 | 3;  	break;  case TableTag.Param:  	CodedIndex = (uint)Value.Index << 5 | 4;  	break;  case TableTag.InterfaceImpl:  	CodedIndex = (uint)Value.Index << 5 | 5;  	break;  case TableTag.MemberRef:  	CodedIndex = (uint)Value.Index << 5 | 6;  	break;  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 5 | 7;  	break;  case TableTag.DeclSecurity:  	CodedIndex = (uint)Value.Index << 5 | 8;  	break;  case TableTag.Property:  	CodedIndex = (uint)Value.Index << 5 | 9;  	break;  case TableTag.Event:  	CodedIndex = (uint)Value.Index << 5 | 10;  	break;  case TableTag.StandAloneSig:  	CodedIndex = (uint)Value.Index << 5 | 11;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 5 | 12;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 5 | 13;  	break;  case TableTag.Assembly:  	CodedIndex = (uint)Value.Index << 5 | 14;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 5 | 15;  	break;  case TableTag.File:  	CodedIndex = (uint)Value.Index << 5 | 16;  	break;  case TableTag.ExportedType:  	CodedIndex = (uint)Value.Index << 5 | 17;  	break;  case TableTag.ManifestResource:  	CodedIndex = (uint)Value.Index << 5 | 18;  	break;  default:  	throw new PEException ("invalid HasCustomAttribute row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 5;  	break;  case TableTag.Field:  	CodedIndex = (uint)Value.Index << 5 | 1;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 5 | 2;  	break;  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 5 | 3;  	break;  case TableTag.Param:  	CodedIndex = (uint)Value.Index << 5 | 4;  	break;  case TableTag.InterfaceImpl:  	CodedIndex = (uint)Value.Index << 5 | 5;  	break;  case TableTag.MemberRef:  	CodedIndex = (uint)Value.Index << 5 | 6;  	break;  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 5 | 7;  	break;  case TableTag.DeclSecurity:  	CodedIndex = (uint)Value.Index << 5 | 8;  	break;  case TableTag.Property:  	CodedIndex = (uint)Value.Index << 5 | 9;  	break;  case TableTag.Event:  	CodedIndex = (uint)Value.Index << 5 | 10;  	break;  case TableTag.StandAloneSig:  	CodedIndex = (uint)Value.Index << 5 | 11;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 5 | 12;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 5 | 13;  	break;  case TableTag.Assembly:  	CodedIndex = (uint)Value.Index << 5 | 14;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 5 | 15;  	break;  case TableTag.File:  	CodedIndex = (uint)Value.Index << 5 | 16;  	break;  case TableTag.ExportedType:  	CodedIndex = (uint)Value.Index << 5 | 17;  	break;  case TableTag.ManifestResource:  	CodedIndex = (uint)Value.Index << 5 | 18;  	break;  default:  	throw new PEException ("invalid HasCustomAttribute row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 5;  	break;  case TableTag.Field:  	CodedIndex = (uint)Value.Index << 5 | 1;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 5 | 2;  	break;  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 5 | 3;  	break;  case TableTag.Param:  	CodedIndex = (uint)Value.Index << 5 | 4;  	break;  case TableTag.InterfaceImpl:  	CodedIndex = (uint)Value.Index << 5 | 5;  	break;  case TableTag.MemberRef:  	CodedIndex = (uint)Value.Index << 5 | 6;  	break;  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 5 | 7;  	break;  case TableTag.DeclSecurity:  	CodedIndex = (uint)Value.Index << 5 | 8;  	break;  case TableTag.Property:  	CodedIndex = (uint)Value.Index << 5 | 9;  	break;  case TableTag.Event:  	CodedIndex = (uint)Value.Index << 5 | 10;  	break;  case TableTag.StandAloneSig:  	CodedIndex = (uint)Value.Index << 5 | 11;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 5 | 12;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 5 | 13;  	break;  case TableTag.Assembly:  	CodedIndex = (uint)Value.Index << 5 | 14;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 5 | 15;  	break;  case TableTag.File:  	CodedIndex = (uint)Value.Index << 5 | 16;  	break;  case TableTag.ExportedType:  	CodedIndex = (uint)Value.Index << 5 | 17;  	break;  case TableTag.ManifestResource:  	CodedIndex = (uint)Value.Index << 5 | 18;  	break;  default:  	throw new PEException ("invalid HasCustomAttribute row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 5;  	break;  case TableTag.Field:  	CodedIndex = (uint)Value.Index << 5 | 1;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 5 | 2;  	break;  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 5 | 3;  	break;  case TableTag.Param:  	CodedIndex = (uint)Value.Index << 5 | 4;  	break;  case TableTag.InterfaceImpl:  	CodedIndex = (uint)Value.Index << 5 | 5;  	break;  case TableTag.MemberRef:  	CodedIndex = (uint)Value.Index << 5 | 6;  	break;  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 5 | 7;  	break;  case TableTag.DeclSecurity:  	CodedIndex = (uint)Value.Index << 5 | 8;  	break;  case TableTag.Property:  	CodedIndex = (uint)Value.Index << 5 | 9;  	break;  case TableTag.Event:  	CodedIndex = (uint)Value.Index << 5 | 10;  	break;  case TableTag.StandAloneSig:  	CodedIndex = (uint)Value.Index << 5 | 11;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 5 | 12;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 5 | 13;  	break;  case TableTag.Assembly:  	CodedIndex = (uint)Value.Index << 5 | 14;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 5 | 15;  	break;  case TableTag.File:  	CodedIndex = (uint)Value.Index << 5 | 16;  	break;  case TableTag.ExportedType:  	CodedIndex = (uint)Value.Index << 5 | 17;  	break;  case TableTag.ManifestResource:  	CodedIndex = (uint)Value.Index << 5 | 18;  	break;  default:  	throw new PEException ("invalid HasCustomAttribute row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 5;  	break;  case TableTag.Field:  	CodedIndex = (uint)Value.Index << 5 | 1;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 5 | 2;  	break;  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 5 | 3;  	break;  case TableTag.Param:  	CodedIndex = (uint)Value.Index << 5 | 4;  	break;  case TableTag.InterfaceImpl:  	CodedIndex = (uint)Value.Index << 5 | 5;  	break;  case TableTag.MemberRef:  	CodedIndex = (uint)Value.Index << 5 | 6;  	break;  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 5 | 7;  	break;  case TableTag.DeclSecurity:  	CodedIndex = (uint)Value.Index << 5 | 8;  	break;  case TableTag.Property:  	CodedIndex = (uint)Value.Index << 5 | 9;  	break;  case TableTag.Event:  	CodedIndex = (uint)Value.Index << 5 | 10;  	break;  case TableTag.StandAloneSig:  	CodedIndex = (uint)Value.Index << 5 | 11;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 5 | 12;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 5 | 13;  	break;  case TableTag.Assembly:  	CodedIndex = (uint)Value.Index << 5 | 14;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 5 | 15;  	break;  case TableTag.File:  	CodedIndex = (uint)Value.Index << 5 | 16;  	break;  case TableTag.ExportedType:  	CodedIndex = (uint)Value.Index << 5 | 17;  	break;  case TableTag.ManifestResource:  	CodedIndex = (uint)Value.Index << 5 | 18;  	break;  default:  	throw new PEException ("invalid HasCustomAttribute row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 5;  	break;  case TableTag.Field:  	CodedIndex = (uint)Value.Index << 5 | 1;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 5 | 2;  	break;  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 5 | 3;  	break;  case TableTag.Param:  	CodedIndex = (uint)Value.Index << 5 | 4;  	break;  case TableTag.InterfaceImpl:  	CodedIndex = (uint)Value.Index << 5 | 5;  	break;  case TableTag.MemberRef:  	CodedIndex = (uint)Value.Index << 5 | 6;  	break;  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 5 | 7;  	break;  case TableTag.DeclSecurity:  	CodedIndex = (uint)Value.Index << 5 | 8;  	break;  case TableTag.Property:  	CodedIndex = (uint)Value.Index << 5 | 9;  	break;  case TableTag.Event:  	CodedIndex = (uint)Value.Index << 5 | 10;  	break;  case TableTag.StandAloneSig:  	CodedIndex = (uint)Value.Index << 5 | 11;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 5 | 12;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 5 | 13;  	break;  case TableTag.Assembly:  	CodedIndex = (uint)Value.Index << 5 | 14;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 5 | 15;  	break;  case TableTag.File:  	CodedIndex = (uint)Value.Index << 5 | 16;  	break;  case TableTag.ExportedType:  	CodedIndex = (uint)Value.Index << 5 | 17;  	break;  case TableTag.ManifestResource:  	CodedIndex = (uint)Value.Index << 5 | 18;  	break;  default:  	throw new PEException ("invalid HasCustomAttribute row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 5;  	break;  case TableTag.Field:  	CodedIndex = (uint)Value.Index << 5 | 1;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 5 | 2;  	break;  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 5 | 3;  	break;  case TableTag.Param:  	CodedIndex = (uint)Value.Index << 5 | 4;  	break;  case TableTag.InterfaceImpl:  	CodedIndex = (uint)Value.Index << 5 | 5;  	break;  case TableTag.MemberRef:  	CodedIndex = (uint)Value.Index << 5 | 6;  	break;  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 5 | 7;  	break;  case TableTag.DeclSecurity:  	CodedIndex = (uint)Value.Index << 5 | 8;  	break;  case TableTag.Property:  	CodedIndex = (uint)Value.Index << 5 | 9;  	break;  case TableTag.Event:  	CodedIndex = (uint)Value.Index << 5 | 10;  	break;  case TableTag.StandAloneSig:  	CodedIndex = (uint)Value.Index << 5 | 11;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 5 | 12;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 5 | 13;  	break;  case TableTag.Assembly:  	CodedIndex = (uint)Value.Index << 5 | 14;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 5 | 15;  	break;  case TableTag.File:  	CodedIndex = (uint)Value.Index << 5 | 16;  	break;  case TableTag.ExportedType:  	CodedIndex = (uint)Value.Index << 5 | 17;  	break;  case TableTag.ManifestResource:  	CodedIndex = (uint)Value.Index << 5 | 18;  	break;  default:  	throw new PEException ("invalid HasCustomAttribute row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 5;  	break;  case TableTag.Field:  	CodedIndex = (uint)Value.Index << 5 | 1;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 5 | 2;  	break;  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 5 | 3;  	break;  case TableTag.Param:  	CodedIndex = (uint)Value.Index << 5 | 4;  	break;  case TableTag.InterfaceImpl:  	CodedIndex = (uint)Value.Index << 5 | 5;  	break;  case TableTag.MemberRef:  	CodedIndex = (uint)Value.Index << 5 | 6;  	break;  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 5 | 7;  	break;  case TableTag.DeclSecurity:  	CodedIndex = (uint)Value.Index << 5 | 8;  	break;  case TableTag.Property:  	CodedIndex = (uint)Value.Index << 5 | 9;  	break;  case TableTag.Event:  	CodedIndex = (uint)Value.Index << 5 | 10;  	break;  case TableTag.StandAloneSig:  	CodedIndex = (uint)Value.Index << 5 | 11;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 5 | 12;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 5 | 13;  	break;  case TableTag.Assembly:  	CodedIndex = (uint)Value.Index << 5 | 14;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 5 | 15;  	break;  case TableTag.File:  	CodedIndex = (uint)Value.Index << 5 | 16;  	break;  case TableTag.ExportedType:  	CodedIndex = (uint)Value.Index << 5 | 17;  	break;  case TableTag.ManifestResource:  	CodedIndex = (uint)Value.Index << 5 | 18;  	break;  default:  	throw new PEException ("invalid HasCustomAttribute row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 5;  	break;  case TableTag.Field:  	CodedIndex = (uint)Value.Index << 5 | 1;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 5 | 2;  	break;  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 5 | 3;  	break;  case TableTag.Param:  	CodedIndex = (uint)Value.Index << 5 | 4;  	break;  case TableTag.InterfaceImpl:  	CodedIndex = (uint)Value.Index << 5 | 5;  	break;  case TableTag.MemberRef:  	CodedIndex = (uint)Value.Index << 5 | 6;  	break;  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 5 | 7;  	break;  case TableTag.DeclSecurity:  	CodedIndex = (uint)Value.Index << 5 | 8;  	break;  case TableTag.Property:  	CodedIndex = (uint)Value.Index << 5 | 9;  	break;  case TableTag.Event:  	CodedIndex = (uint)Value.Index << 5 | 10;  	break;  case TableTag.StandAloneSig:  	CodedIndex = (uint)Value.Index << 5 | 11;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 5 | 12;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 5 | 13;  	break;  case TableTag.Assembly:  	CodedIndex = (uint)Value.Index << 5 | 14;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 5 | 15;  	break;  case TableTag.File:  	CodedIndex = (uint)Value.Index << 5 | 16;  	break;  case TableTag.ExportedType:  	CodedIndex = (uint)Value.Index << 5 | 17;  	break;  case TableTag.ManifestResource:  	CodedIndex = (uint)Value.Index << 5 | 18;  	break;  default:  	throw new PEException ("invalid HasCustomAttribute row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 5;  	break;  case TableTag.Field:  	CodedIndex = (uint)Value.Index << 5 | 1;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 5 | 2;  	break;  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 5 | 3;  	break;  case TableTag.Param:  	CodedIndex = (uint)Value.Index << 5 | 4;  	break;  case TableTag.InterfaceImpl:  	CodedIndex = (uint)Value.Index << 5 | 5;  	break;  case TableTag.MemberRef:  	CodedIndex = (uint)Value.Index << 5 | 6;  	break;  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 5 | 7;  	break;  case TableTag.DeclSecurity:  	CodedIndex = (uint)Value.Index << 5 | 8;  	break;  case TableTag.Property:  	CodedIndex = (uint)Value.Index << 5 | 9;  	break;  case TableTag.Event:  	CodedIndex = (uint)Value.Index << 5 | 10;  	break;  case TableTag.StandAloneSig:  	CodedIndex = (uint)Value.Index << 5 | 11;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 5 | 12;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 5 | 13;  	break;  case TableTag.Assembly:  	CodedIndex = (uint)Value.Index << 5 | 14;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 5 | 15;  	break;  case TableTag.File:  	CodedIndex = (uint)Value.Index << 5 | 16;  	break;  case TableTag.ExportedType:  	CodedIndex = (uint)Value.Index << 5 | 17;  	break;  case TableTag.ManifestResource:  	CodedIndex = (uint)Value.Index << 5 | 18;  	break;  default:  	throw new PEException ("invalid HasCustomAttribute row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 5;  	break;  case TableTag.Field:  	CodedIndex = (uint)Value.Index << 5 | 1;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 5 | 2;  	break;  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 5 | 3;  	break;  case TableTag.Param:  	CodedIndex = (uint)Value.Index << 5 | 4;  	break;  case TableTag.InterfaceImpl:  	CodedIndex = (uint)Value.Index << 5 | 5;  	break;  case TableTag.MemberRef:  	CodedIndex = (uint)Value.Index << 5 | 6;  	break;  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 5 | 7;  	break;  case TableTag.DeclSecurity:  	CodedIndex = (uint)Value.Index << 5 | 8;  	break;  case TableTag.Property:  	CodedIndex = (uint)Value.Index << 5 | 9;  	break;  case TableTag.Event:  	CodedIndex = (uint)Value.Index << 5 | 10;  	break;  case TableTag.StandAloneSig:  	CodedIndex = (uint)Value.Index << 5 | 11;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 5 | 12;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 5 | 13;  	break;  case TableTag.Assembly:  	CodedIndex = (uint)Value.Index << 5 | 14;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 5 | 15;  	break;  case TableTag.File:  	CodedIndex = (uint)Value.Index << 5 | 16;  	break;  case TableTag.ExportedType:  	CodedIndex = (uint)Value.Index << 5 | 17;  	break;  case TableTag.ManifestResource:  	CodedIndex = (uint)Value.Index << 5 | 18;  	break;  default:  	throw new PEException ("invalid HasCustomAttribute row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 5;  	break;  case TableTag.Field:  	CodedIndex = (uint)Value.Index << 5 | 1;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 5 | 2;  	break;  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 5 | 3;  	break;  case TableTag.Param:  	CodedIndex = (uint)Value.Index << 5 | 4;  	break;  case TableTag.InterfaceImpl:  	CodedIndex = (uint)Value.Index << 5 | 5;  	break;  case TableTag.MemberRef:  	CodedIndex = (uint)Value.Index << 5 | 6;  	break;  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 5 | 7;  	break;  case TableTag.DeclSecurity:  	CodedIndex = (uint)Value.Index << 5 | 8;  	break;  case TableTag.Property:  	CodedIndex = (uint)Value.Index << 5 | 9;  	break;  case TableTag.Event:  	CodedIndex = (uint)Value.Index << 5 | 10;  	break;  case TableTag.StandAloneSig:  	CodedIndex = (uint)Value.Index << 5 | 11;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 5 | 12;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 5 | 13;  	break;  case TableTag.Assembly:  	CodedIndex = (uint)Value.Index << 5 | 14;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 5 | 15;  	break;  case TableTag.File:  	CodedIndex = (uint)Value.Index << 5 | 16;  	break;  case TableTag.ExportedType:  	CodedIndex = (uint)Value.Index << 5 | 17;  	break;  case TableTag.ManifestResource:  	CodedIndex = (uint)Value.Index << 5 | 18;  	break;  default:  	throw new PEException ("invalid HasCustomAttribute row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 5;  	break;  case TableTag.Field:  	CodedIndex = (uint)Value.Index << 5 | 1;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 5 | 2;  	break;  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 5 | 3;  	break;  case TableTag.Param:  	CodedIndex = (uint)Value.Index << 5 | 4;  	break;  case TableTag.InterfaceImpl:  	CodedIndex = (uint)Value.Index << 5 | 5;  	break;  case TableTag.MemberRef:  	CodedIndex = (uint)Value.Index << 5 | 6;  	break;  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 5 | 7;  	break;  case TableTag.DeclSecurity:  	CodedIndex = (uint)Value.Index << 5 | 8;  	break;  case TableTag.Property:  	CodedIndex = (uint)Value.Index << 5 | 9;  	break;  case TableTag.Event:  	CodedIndex = (uint)Value.Index << 5 | 10;  	break;  case TableTag.StandAloneSig:  	CodedIndex = (uint)Value.Index << 5 | 11;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 5 | 12;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 5 | 13;  	break;  case TableTag.Assembly:  	CodedIndex = (uint)Value.Index << 5 | 14;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 5 | 15;  	break;  case TableTag.File:  	CodedIndex = (uint)Value.Index << 5 | 16;  	break;  case TableTag.ExportedType:  	CodedIndex = (uint)Value.Index << 5 | 17;  	break;  case TableTag.ManifestResource:  	CodedIndex = (uint)Value.Index << 5 | 18;  	break;  default:  	throw new PEException ("invalid HasCustomAttribute row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 5;  	break;  case TableTag.Field:  	CodedIndex = (uint)Value.Index << 5 | 1;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 5 | 2;  	break;  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 5 | 3;  	break;  case TableTag.Param:  	CodedIndex = (uint)Value.Index << 5 | 4;  	break;  case TableTag.InterfaceImpl:  	CodedIndex = (uint)Value.Index << 5 | 5;  	break;  case TableTag.MemberRef:  	CodedIndex = (uint)Value.Index << 5 | 6;  	break;  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 5 | 7;  	break;  case TableTag.DeclSecurity:  	CodedIndex = (uint)Value.Index << 5 | 8;  	break;  case TableTag.Property:  	CodedIndex = (uint)Value.Index << 5 | 9;  	break;  case TableTag.Event:  	CodedIndex = (uint)Value.Index << 5 | 10;  	break;  case TableTag.StandAloneSig:  	CodedIndex = (uint)Value.Index << 5 | 11;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 5 | 12;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 5 | 13;  	break;  case TableTag.Assembly:  	CodedIndex = (uint)Value.Index << 5 | 14;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 5 | 15;  	break;  case TableTag.File:  	CodedIndex = (uint)Value.Index << 5 | 16;  	break;  case TableTag.ExportedType:  	CodedIndex = (uint)Value.Index << 5 | 17;  	break;  case TableTag.ManifestResource:  	CodedIndex = (uint)Value.Index << 5 | 18;  	break;  default:  	throw new PEException ("invalid HasCustomAttribute row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 5;  	break;  case TableTag.Field:  	CodedIndex = (uint)Value.Index << 5 | 1;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 5 | 2;  	break;  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 5 | 3;  	break;  case TableTag.Param:  	CodedIndex = (uint)Value.Index << 5 | 4;  	break;  case TableTag.InterfaceImpl:  	CodedIndex = (uint)Value.Index << 5 | 5;  	break;  case TableTag.MemberRef:  	CodedIndex = (uint)Value.Index << 5 | 6;  	break;  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 5 | 7;  	break;  case TableTag.DeclSecurity:  	CodedIndex = (uint)Value.Index << 5 | 8;  	break;  case TableTag.Property:  	CodedIndex = (uint)Value.Index << 5 | 9;  	break;  case TableTag.Event:  	CodedIndex = (uint)Value.Index << 5 | 10;  	break;  case TableTag.StandAloneSig:  	CodedIndex = (uint)Value.Index << 5 | 11;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 5 | 12;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 5 | 13;  	break;  case TableTag.Assembly:  	CodedIndex = (uint)Value.Index << 5 | 14;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 5 | 15;  	break;  case TableTag.File:  	CodedIndex = (uint)Value.Index << 5 | 16;  	break;  case TableTag.ExportedType:  	CodedIndex = (uint)Value.Index << 5 | 17;  	break;  case TableTag.ManifestResource:  	CodedIndex = (uint)Value.Index << 5 | 18;  	break;  default:  	throw new PEException ("invalid HasCustomAttribute row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 5;  	break;  case TableTag.Field:  	CodedIndex = (uint)Value.Index << 5 | 1;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 5 | 2;  	break;  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 5 | 3;  	break;  case TableTag.Param:  	CodedIndex = (uint)Value.Index << 5 | 4;  	break;  case TableTag.InterfaceImpl:  	CodedIndex = (uint)Value.Index << 5 | 5;  	break;  case TableTag.MemberRef:  	CodedIndex = (uint)Value.Index << 5 | 6;  	break;  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 5 | 7;  	break;  case TableTag.DeclSecurity:  	CodedIndex = (uint)Value.Index << 5 | 8;  	break;  case TableTag.Property:  	CodedIndex = (uint)Value.Index << 5 | 9;  	break;  case TableTag.Event:  	CodedIndex = (uint)Value.Index << 5 | 10;  	break;  case TableTag.StandAloneSig:  	CodedIndex = (uint)Value.Index << 5 | 11;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 5 | 12;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 5 | 13;  	break;  case TableTag.Assembly:  	CodedIndex = (uint)Value.Index << 5 | 14;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 5 | 15;  	break;  case TableTag.File:  	CodedIndex = (uint)Value.Index << 5 | 16;  	break;  case TableTag.ExportedType:  	CodedIndex = (uint)Value.Index << 5 | 17;  	break;  case TableTag.ManifestResource:  	CodedIndex = (uint)Value.Index << 5 | 18;  	break;  default:  	throw new PEException ("invalid HasCustomAttribute row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 5;  	break;  case TableTag.Field:  	CodedIndex = (uint)Value.Index << 5 | 1;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 5 | 2;  	break;  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 5 | 3;  	break;  case TableTag.Param:  	CodedIndex = (uint)Value.Index << 5 | 4;  	break;  case TableTag.InterfaceImpl:  	CodedIndex = (uint)Value.Index << 5 | 5;  	break;  case TableTag.MemberRef:  	CodedIndex = (uint)Value.Index << 5 | 6;  	break;  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 5 | 7;  	break;  case TableTag.DeclSecurity:  	CodedIndex = (uint)Value.Index << 5 | 8;  	break;  case TableTag.Property:  	CodedIndex = (uint)Value.Index << 5 | 9;  	break;  case TableTag.Event:  	CodedIndex = (uint)Value.Index << 5 | 10;  	break;  case TableTag.StandAloneSig:  	CodedIndex = (uint)Value.Index << 5 | 11;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 5 | 12;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 5 | 13;  	break;  case TableTag.Assembly:  	CodedIndex = (uint)Value.Index << 5 | 14;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 5 | 15;  	break;  case TableTag.File:  	CodedIndex = (uint)Value.Index << 5 | 16;  	break;  case TableTag.ExportedType:  	CodedIndex = (uint)Value.Index << 5 | 17;  	break;  case TableTag.ManifestResource:  	CodedIndex = (uint)Value.Index << 5 | 18;  	break;  default:  	throw new PEException ("invalid HasCustomAttribute row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 5;  	break;  case TableTag.Field:  	CodedIndex = (uint)Value.Index << 5 | 1;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 5 | 2;  	break;  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 5 | 3;  	break;  case TableTag.Param:  	CodedIndex = (uint)Value.Index << 5 | 4;  	break;  case TableTag.InterfaceImpl:  	CodedIndex = (uint)Value.Index << 5 | 5;  	break;  case TableTag.MemberRef:  	CodedIndex = (uint)Value.Index << 5 | 6;  	break;  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 5 | 7;  	break;  case TableTag.DeclSecurity:  	CodedIndex = (uint)Value.Index << 5 | 8;  	break;  case TableTag.Property:  	CodedIndex = (uint)Value.Index << 5 | 9;  	break;  case TableTag.Event:  	CodedIndex = (uint)Value.Index << 5 | 10;  	break;  case TableTag.StandAloneSig:  	CodedIndex = (uint)Value.Index << 5 | 11;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 5 | 12;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 5 | 13;  	break;  case TableTag.Assembly:  	CodedIndex = (uint)Value.Index << 5 | 14;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 5 | 15;  	break;  case TableTag.File:  	CodedIndex = (uint)Value.Index << 5 | 16;  	break;  case TableTag.ExportedType:  	CodedIndex = (uint)Value.Index << 5 | 17;  	break;  case TableTag.ManifestResource:  	CodedIndex = (uint)Value.Index << 5 | 18;  	break;  default:  	throw new PEException ("invalid HasCustomAttribute row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 5;  	break;  case TableTag.Field:  	CodedIndex = (uint)Value.Index << 5 | 1;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 5 | 2;  	break;  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 5 | 3;  	break;  case TableTag.Param:  	CodedIndex = (uint)Value.Index << 5 | 4;  	break;  case TableTag.InterfaceImpl:  	CodedIndex = (uint)Value.Index << 5 | 5;  	break;  case TableTag.MemberRef:  	CodedIndex = (uint)Value.Index << 5 | 6;  	break;  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 5 | 7;  	break;  case TableTag.DeclSecurity:  	CodedIndex = (uint)Value.Index << 5 | 8;  	break;  case TableTag.Property:  	CodedIndex = (uint)Value.Index << 5 | 9;  	break;  case TableTag.Event:  	CodedIndex = (uint)Value.Index << 5 | 10;  	break;  case TableTag.StandAloneSig:  	CodedIndex = (uint)Value.Index << 5 | 11;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 5 | 12;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 5 | 13;  	break;  case TableTag.Assembly:  	CodedIndex = (uint)Value.Index << 5 | 14;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 5 | 15;  	break;  case TableTag.File:  	CodedIndex = (uint)Value.Index << 5 | 16;  	break;  case TableTag.ExportedType:  	CodedIndex = (uint)Value.Index << 5 | 17;  	break;  case TableTag.ManifestResource:  	CodedIndex = (uint)Value.Index << 5 | 18;  	break;  default:  	throw new PEException ("invalid HasCustomAttribute row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 5;  	break;  case TableTag.Field:  	CodedIndex = (uint)Value.Index << 5 | 1;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 5 | 2;  	break;  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 5 | 3;  	break;  case TableTag.Param:  	CodedIndex = (uint)Value.Index << 5 | 4;  	break;  case TableTag.InterfaceImpl:  	CodedIndex = (uint)Value.Index << 5 | 5;  	break;  case TableTag.MemberRef:  	CodedIndex = (uint)Value.Index << 5 | 6;  	break;  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 5 | 7;  	break;  case TableTag.DeclSecurity:  	CodedIndex = (uint)Value.Index << 5 | 8;  	break;  case TableTag.Property:  	CodedIndex = (uint)Value.Index << 5 | 9;  	break;  case TableTag.Event:  	CodedIndex = (uint)Value.Index << 5 | 10;  	break;  case TableTag.StandAloneSig:  	CodedIndex = (uint)Value.Index << 5 | 11;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 5 | 12;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 5 | 13;  	break;  case TableTag.Assembly:  	CodedIndex = (uint)Value.Index << 5 | 14;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 5 | 15;  	break;  case TableTag.File:  	CodedIndex = (uint)Value.Index << 5 | 16;  	break;  case TableTag.ExportedType:  	CodedIndex = (uint)Value.Index << 5 | 17;  	break;  case TableTag.ManifestResource:  	CodedIndex = (uint)Value.Index << 5 | 18;  	break;  default:  	throw new PEException ("invalid HasCustomAttribute row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 5;  	break;  case TableTag.Field:  	CodedIndex = (uint)Value.Index << 5 | 1;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 5 | 2;  	break;  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 5 | 3;  	break;  case TableTag.Param:  	CodedIndex = (uint)Value.Index << 5 | 4;  	break;  case TableTag.InterfaceImpl:  	CodedIndex = (uint)Value.Index << 5 | 5;  	break;  case TableTag.MemberRef:  	CodedIndex = (uint)Value.Index << 5 | 6;  	break;  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 5 | 7;  	break;  case TableTag.DeclSecurity:  	CodedIndex = (uint)Value.Index << 5 | 8;  	break;  case TableTag.Property:  	CodedIndex = (uint)Value.Index << 5 | 9;  	break;  case TableTag.Event:  	CodedIndex = (uint)Value.Index << 5 | 10;  	break;  case TableTag.StandAloneSig:  	CodedIndex = (uint)Value.Index << 5 | 11;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 5 | 12;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 5 | 13;  	break;  case TableTag.Assembly:  	CodedIndex = (uint)Value.Index << 5 | 14;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 5 | 15;  	break;  case TableTag.File:  	CodedIndex = (uint)Value.Index << 5 | 16;  	break;  case TableTag.ExportedType:  	CodedIndex = (uint)Value.Index << 5 | 17;  	break;  case TableTag.ManifestResource:  	CodedIndex = (uint)Value.Index << 5 | 18;  	break;  default:  	throw new PEException ("invalid HasCustomAttribute row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 5;  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 5 | 1;  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 5 | 2;  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 5 | 2;  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 5 | 3;  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 5 | 3;  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 5 | 4;  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 5 | 4;  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 5 | 5;  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 5 | 5;  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 5 | 6;  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 5 | 6;  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 5 | 7;  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 5 | 7;  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 5 | 8;  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 5 | 8;  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 5 | 9;  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 5 | 9;  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 5 | 10;  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 5 | 10;  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 5 | 11;  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 5 | 11;  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 5 | 12;  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 5 | 12;  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 5 | 13;  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 5 | 13;  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 5 | 14;  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 5 | 14;  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 5 | 15;  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 5 | 15;  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 5 | 16;  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 5 | 16;  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 5 | 17;  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 5 | 17;  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 5 | 18;  
Magic Number,Microsoft.LiveLabs.PE,HasCustomAttributeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 5 | 18;  
Magic Number,Microsoft.LiveLabs.PE,HasDeclSecurityRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (CodedIndex == 0)  	Value = null;  else {  	var table = CodedIndex & 0x3;  	var index = (int)(CodedIndex >> 2);  	switch (table) {  	case 0:  		Value = ctxt.Tables.TypeDefTable [index];  		break;  	case 1:  		Value = ctxt.Tables.MethodDefTable [index];  		break;  	case 2:  		Value = ctxt.Tables.AssemblyTable [index];  		break;  	default:  		throw new PEException ("invalid HasDeclSecurity coded index");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasDeclSecurityRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (CodedIndex == 0)  	Value = null;  else {  	var table = CodedIndex & 0x3;  	var index = (int)(CodedIndex >> 2);  	switch (table) {  	case 0:  		Value = ctxt.Tables.TypeDefTable [index];  		break;  	case 1:  		Value = ctxt.Tables.MethodDefTable [index];  		break;  	case 2:  		Value = ctxt.Tables.AssemblyTable [index];  		break;  	default:  		throw new PEException ("invalid HasDeclSecurity coded index");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasDeclSecurityRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: switch (table) {  case 0:  	Value = ctxt.Tables.TypeDefTable [index];  	break;  case 1:  	Value = ctxt.Tables.MethodDefTable [index];  	break;  case 2:  	Value = ctxt.Tables.AssemblyTable [index];  	break;  default:  	throw new PEException ("invalid HasDeclSecurity coded index");  }  
Magic Number,Microsoft.LiveLabs.PE,HasDeclSecurityRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 2;  		break;  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 2 | 1;  		break;  	case TableTag.Assembly:  		CodedIndex = (uint)Value.Index << 2 | 2;  		break;  	default:  		throw new PEException ("Invalid HasDeclSecurity row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasDeclSecurityRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 2;  		break;  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 2 | 1;  		break;  	case TableTag.Assembly:  		CodedIndex = (uint)Value.Index << 2 | 2;  		break;  	default:  		throw new PEException ("Invalid HasDeclSecurity row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasDeclSecurityRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 2;  		break;  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 2 | 1;  		break;  	case TableTag.Assembly:  		CodedIndex = (uint)Value.Index << 2 | 2;  		break;  	default:  		throw new PEException ("Invalid HasDeclSecurity row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasDeclSecurityRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 2;  		break;  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 2 | 1;  		break;  	case TableTag.Assembly:  		CodedIndex = (uint)Value.Index << 2 | 2;  		break;  	default:  		throw new PEException ("Invalid HasDeclSecurity row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,HasDeclSecurityRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 2;  	break;  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 2 | 1;  	break;  case TableTag.Assembly:  	CodedIndex = (uint)Value.Index << 2 | 2;  	break;  default:  	throw new PEException ("Invalid HasDeclSecurity row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasDeclSecurityRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 2;  	break;  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 2 | 1;  	break;  case TableTag.Assembly:  	CodedIndex = (uint)Value.Index << 2 | 2;  	break;  default:  	throw new PEException ("Invalid HasDeclSecurity row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasDeclSecurityRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 2;  	break;  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 2 | 1;  	break;  case TableTag.Assembly:  	CodedIndex = (uint)Value.Index << 2 | 2;  	break;  default:  	throw new PEException ("Invalid HasDeclSecurity row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasDeclSecurityRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 2;  	break;  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 2 | 1;  	break;  case TableTag.Assembly:  	CodedIndex = (uint)Value.Index << 2 | 2;  	break;  default:  	throw new PEException ("Invalid HasDeclSecurity row");  }  
Magic Number,Microsoft.LiveLabs.PE,HasDeclSecurityRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 2;  
Magic Number,Microsoft.LiveLabs.PE,HasDeclSecurityRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 2 | 1;  
Magic Number,Microsoft.LiveLabs.PE,HasDeclSecurityRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 2 | 2;  
Magic Number,Microsoft.LiveLabs.PE,HasDeclSecurityRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 2 | 2;  
Magic Number,Microsoft.LiveLabs.PE,MemberRefParentRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (CodedIndex == 0)  	Value = null;  else {  	var table = CodedIndex & 0x7;  	var index = (int)(CodedIndex >> 3);  	switch (table) {  	case 0:  		Value = ctxt.Tables.TypeDefTable [index];  		break;  	case 1:  		Value = ctxt.Tables.TypeRefTable [index];  		break;  	case 2:  		Value = ctxt.Tables.ModuleRefTable [index];  		break;  	case 3:  		Value = ctxt.Tables.MethodDefTable [index];  		break;  	case 4:  		Value = ctxt.Tables.TypeSpecTable [index];  		break;  	default:  		throw new PEException ("invalid MemberRefParent coded index");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,MemberRefParentRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (CodedIndex == 0)  	Value = null;  else {  	var table = CodedIndex & 0x7;  	var index = (int)(CodedIndex >> 3);  	switch (table) {  	case 0:  		Value = ctxt.Tables.TypeDefTable [index];  		break;  	case 1:  		Value = ctxt.Tables.TypeRefTable [index];  		break;  	case 2:  		Value = ctxt.Tables.ModuleRefTable [index];  		break;  	case 3:  		Value = ctxt.Tables.MethodDefTable [index];  		break;  	case 4:  		Value = ctxt.Tables.TypeSpecTable [index];  		break;  	default:  		throw new PEException ("invalid MemberRefParent coded index");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,MemberRefParentRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (CodedIndex == 0)  	Value = null;  else {  	var table = CodedIndex & 0x7;  	var index = (int)(CodedIndex >> 3);  	switch (table) {  	case 0:  		Value = ctxt.Tables.TypeDefTable [index];  		break;  	case 1:  		Value = ctxt.Tables.TypeRefTable [index];  		break;  	case 2:  		Value = ctxt.Tables.ModuleRefTable [index];  		break;  	case 3:  		Value = ctxt.Tables.MethodDefTable [index];  		break;  	case 4:  		Value = ctxt.Tables.TypeSpecTable [index];  		break;  	default:  		throw new PEException ("invalid MemberRefParent coded index");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,MemberRefParentRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (CodedIndex == 0)  	Value = null;  else {  	var table = CodedIndex & 0x7;  	var index = (int)(CodedIndex >> 3);  	switch (table) {  	case 0:  		Value = ctxt.Tables.TypeDefTable [index];  		break;  	case 1:  		Value = ctxt.Tables.TypeRefTable [index];  		break;  	case 2:  		Value = ctxt.Tables.ModuleRefTable [index];  		break;  	case 3:  		Value = ctxt.Tables.MethodDefTable [index];  		break;  	case 4:  		Value = ctxt.Tables.TypeSpecTable [index];  		break;  	default:  		throw new PEException ("invalid MemberRefParent coded index");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,MemberRefParentRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: switch (table) {  case 0:  	Value = ctxt.Tables.TypeDefTable [index];  	break;  case 1:  	Value = ctxt.Tables.TypeRefTable [index];  	break;  case 2:  	Value = ctxt.Tables.ModuleRefTable [index];  	break;  case 3:  	Value = ctxt.Tables.MethodDefTable [index];  	break;  case 4:  	Value = ctxt.Tables.TypeSpecTable [index];  	break;  default:  	throw new PEException ("invalid MemberRefParent coded index");  }  
Magic Number,Microsoft.LiveLabs.PE,MemberRefParentRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: switch (table) {  case 0:  	Value = ctxt.Tables.TypeDefTable [index];  	break;  case 1:  	Value = ctxt.Tables.TypeRefTable [index];  	break;  case 2:  	Value = ctxt.Tables.ModuleRefTable [index];  	break;  case 3:  	Value = ctxt.Tables.MethodDefTable [index];  	break;  case 4:  	Value = ctxt.Tables.TypeSpecTable [index];  	break;  default:  	throw new PEException ("invalid MemberRefParent coded index");  }  
Magic Number,Microsoft.LiveLabs.PE,MemberRefParentRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: switch (table) {  case 0:  	Value = ctxt.Tables.TypeDefTable [index];  	break;  case 1:  	Value = ctxt.Tables.TypeRefTable [index];  	break;  case 2:  	Value = ctxt.Tables.ModuleRefTable [index];  	break;  case 3:  	Value = ctxt.Tables.MethodDefTable [index];  	break;  case 4:  	Value = ctxt.Tables.TypeSpecTable [index];  	break;  default:  	throw new PEException ("invalid MemberRefParent coded index");  }  
Magic Number,Microsoft.LiveLabs.PE,MemberRefParentRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 3;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 3 | 1;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 3 | 2;  		break;  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 3 | 3;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 3 | 4;  		break;  	default:  		throw new PEException ("Invalid MemberRefParent row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,MemberRefParentRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 3;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 3 | 1;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 3 | 2;  		break;  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 3 | 3;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 3 | 4;  		break;  	default:  		throw new PEException ("Invalid MemberRefParent row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,MemberRefParentRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 3;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 3 | 1;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 3 | 2;  		break;  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 3 | 3;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 3 | 4;  		break;  	default:  		throw new PEException ("Invalid MemberRefParent row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,MemberRefParentRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 3;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 3 | 1;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 3 | 2;  		break;  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 3 | 3;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 3 | 4;  		break;  	default:  		throw new PEException ("Invalid MemberRefParent row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,MemberRefParentRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 3;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 3 | 1;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 3 | 2;  		break;  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 3 | 3;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 3 | 4;  		break;  	default:  		throw new PEException ("Invalid MemberRefParent row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,MemberRefParentRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 3;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 3 | 1;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 3 | 2;  		break;  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 3 | 3;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 3 | 4;  		break;  	default:  		throw new PEException ("Invalid MemberRefParent row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,MemberRefParentRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 3;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 3 | 1;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 3 | 2;  		break;  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 3 | 3;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 3 | 4;  		break;  	default:  		throw new PEException ("Invalid MemberRefParent row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,MemberRefParentRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.TypeDef:  		CodedIndex = (uint)Value.Index << 3;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 3 | 1;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 3 | 2;  		break;  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 3 | 3;  		break;  	case TableTag.TypeSpec:  		CodedIndex = (uint)Value.Index << 3 | 4;  		break;  	default:  		throw new PEException ("Invalid MemberRefParent row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,MemberRefParentRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 3;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 3 | 1;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 3 | 2;  	break;  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 3 | 3;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 3 | 4;  	break;  default:  	throw new PEException ("Invalid MemberRefParent row");  }  
Magic Number,Microsoft.LiveLabs.PE,MemberRefParentRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 3;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 3 | 1;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 3 | 2;  	break;  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 3 | 3;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 3 | 4;  	break;  default:  	throw new PEException ("Invalid MemberRefParent row");  }  
Magic Number,Microsoft.LiveLabs.PE,MemberRefParentRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 3;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 3 | 1;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 3 | 2;  	break;  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 3 | 3;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 3 | 4;  	break;  default:  	throw new PEException ("Invalid MemberRefParent row");  }  
Magic Number,Microsoft.LiveLabs.PE,MemberRefParentRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 3;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 3 | 1;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 3 | 2;  	break;  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 3 | 3;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 3 | 4;  	break;  default:  	throw new PEException ("Invalid MemberRefParent row");  }  
Magic Number,Microsoft.LiveLabs.PE,MemberRefParentRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 3;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 3 | 1;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 3 | 2;  	break;  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 3 | 3;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 3 | 4;  	break;  default:  	throw new PEException ("Invalid MemberRefParent row");  }  
Magic Number,Microsoft.LiveLabs.PE,MemberRefParentRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 3;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 3 | 1;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 3 | 2;  	break;  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 3 | 3;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 3 | 4;  	break;  default:  	throw new PEException ("Invalid MemberRefParent row");  }  
Magic Number,Microsoft.LiveLabs.PE,MemberRefParentRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 3;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 3 | 1;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 3 | 2;  	break;  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 3 | 3;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 3 | 4;  	break;  default:  	throw new PEException ("Invalid MemberRefParent row");  }  
Magic Number,Microsoft.LiveLabs.PE,MemberRefParentRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.TypeDef:  	CodedIndex = (uint)Value.Index << 3;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 3 | 1;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 3 | 2;  	break;  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 3 | 3;  	break;  case TableTag.TypeSpec:  	CodedIndex = (uint)Value.Index << 3 | 4;  	break;  default:  	throw new PEException ("Invalid MemberRefParent row");  }  
Magic Number,Microsoft.LiveLabs.PE,MemberRefParentRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 3;  
Magic Number,Microsoft.LiveLabs.PE,MemberRefParentRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 3 | 1;  
Magic Number,Microsoft.LiveLabs.PE,MemberRefParentRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 3 | 2;  
Magic Number,Microsoft.LiveLabs.PE,MemberRefParentRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 3 | 2;  
Magic Number,Microsoft.LiveLabs.PE,MemberRefParentRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 3 | 3;  
Magic Number,Microsoft.LiveLabs.PE,MemberRefParentRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 3 | 3;  
Magic Number,Microsoft.LiveLabs.PE,MemberRefParentRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 3 | 4;  
Magic Number,Microsoft.LiveLabs.PE,MemberRefParentRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 3 | 4;  
Magic Number,Microsoft.LiveLabs.PE,ImplementationRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (CodedIndex == 0)  	Value = null;  else {  	var table = CodedIndex & 0x3;  	var index = (int)(CodedIndex >> 2);  	switch (table) {  	case 0:  		Value = ctxt.Tables.FileTable [index];  		break;  	case 1:  		Value = ctxt.Tables.AssemblyRefTable [index];  		break;  	case 2:  		Value = ctxt.Tables.ExportedTypeTable [index];  		break;  	default:  		throw new PEException ("invalid Implementation coded index");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,ImplementationRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (CodedIndex == 0)  	Value = null;  else {  	var table = CodedIndex & 0x3;  	var index = (int)(CodedIndex >> 2);  	switch (table) {  	case 0:  		Value = ctxt.Tables.FileTable [index];  		break;  	case 1:  		Value = ctxt.Tables.AssemblyRefTable [index];  		break;  	case 2:  		Value = ctxt.Tables.ExportedTypeTable [index];  		break;  	default:  		throw new PEException ("invalid Implementation coded index");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,ImplementationRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: switch (table) {  case 0:  	Value = ctxt.Tables.FileTable [index];  	break;  case 1:  	Value = ctxt.Tables.AssemblyRefTable [index];  	break;  case 2:  	Value = ctxt.Tables.ExportedTypeTable [index];  	break;  default:  	throw new PEException ("invalid Implementation coded index");  }  
Magic Number,Microsoft.LiveLabs.PE,ImplementationRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.File:  		CodedIndex = (uint)Value.Index << 2;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 2 | 1;  		break;  	case TableTag.ExportedType:  		CodedIndex = (uint)Value.Index << 2 | 2;  		break;  	default:  		throw new PEException ("invalid Implementation row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,ImplementationRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.File:  		CodedIndex = (uint)Value.Index << 2;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 2 | 1;  		break;  	case TableTag.ExportedType:  		CodedIndex = (uint)Value.Index << 2 | 2;  		break;  	default:  		throw new PEException ("invalid Implementation row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,ImplementationRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.File:  		CodedIndex = (uint)Value.Index << 2;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 2 | 1;  		break;  	case TableTag.ExportedType:  		CodedIndex = (uint)Value.Index << 2 | 2;  		break;  	default:  		throw new PEException ("invalid Implementation row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,ImplementationRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.File:  		CodedIndex = (uint)Value.Index << 2;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 2 | 1;  		break;  	case TableTag.ExportedType:  		CodedIndex = (uint)Value.Index << 2 | 2;  		break;  	default:  		throw new PEException ("invalid Implementation row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,ImplementationRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.File:  	CodedIndex = (uint)Value.Index << 2;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 2 | 1;  	break;  case TableTag.ExportedType:  	CodedIndex = (uint)Value.Index << 2 | 2;  	break;  default:  	throw new PEException ("invalid Implementation row");  }  
Magic Number,Microsoft.LiveLabs.PE,ImplementationRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.File:  	CodedIndex = (uint)Value.Index << 2;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 2 | 1;  	break;  case TableTag.ExportedType:  	CodedIndex = (uint)Value.Index << 2 | 2;  	break;  default:  	throw new PEException ("invalid Implementation row");  }  
Magic Number,Microsoft.LiveLabs.PE,ImplementationRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.File:  	CodedIndex = (uint)Value.Index << 2;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 2 | 1;  	break;  case TableTag.ExportedType:  	CodedIndex = (uint)Value.Index << 2 | 2;  	break;  default:  	throw new PEException ("invalid Implementation row");  }  
Magic Number,Microsoft.LiveLabs.PE,ImplementationRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.File:  	CodedIndex = (uint)Value.Index << 2;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 2 | 1;  	break;  case TableTag.ExportedType:  	CodedIndex = (uint)Value.Index << 2 | 2;  	break;  default:  	throw new PEException ("invalid Implementation row");  }  
Magic Number,Microsoft.LiveLabs.PE,ImplementationRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 2;  
Magic Number,Microsoft.LiveLabs.PE,ImplementationRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 2 | 1;  
Magic Number,Microsoft.LiveLabs.PE,ImplementationRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 2 | 2;  
Magic Number,Microsoft.LiveLabs.PE,ImplementationRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 2 | 2;  
Magic Number,Microsoft.LiveLabs.PE,CustomAttributeTypeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (CodedIndex == 0)  	Value = null;  else {  	var table = CodedIndex & 0x7;  	var index = (int)(CodedIndex >> 3);  	switch (table) {  	case 0:  	case 1:  	case 4:  		throw new PEException ("unused CustomAttributeType coded index");  	case 2:  		Value = ctxt.Tables.MethodDefTable [index];  		break;  	case 3:  		Value = ctxt.Tables.MemberRefTable [index];  		break;  	default:  		throw new PEException ("invalid CustomAttributeType coded index");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,CustomAttributeTypeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (CodedIndex == 0)  	Value = null;  else {  	var table = CodedIndex & 0x7;  	var index = (int)(CodedIndex >> 3);  	switch (table) {  	case 0:  	case 1:  	case 4:  		throw new PEException ("unused CustomAttributeType coded index");  	case 2:  		Value = ctxt.Tables.MethodDefTable [index];  		break;  	case 3:  		Value = ctxt.Tables.MemberRefTable [index];  		break;  	default:  		throw new PEException ("invalid CustomAttributeType coded index");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,CustomAttributeTypeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (CodedIndex == 0)  	Value = null;  else {  	var table = CodedIndex & 0x7;  	var index = (int)(CodedIndex >> 3);  	switch (table) {  	case 0:  	case 1:  	case 4:  		throw new PEException ("unused CustomAttributeType coded index");  	case 2:  		Value = ctxt.Tables.MethodDefTable [index];  		break;  	case 3:  		Value = ctxt.Tables.MemberRefTable [index];  		break;  	default:  		throw new PEException ("invalid CustomAttributeType coded index");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,CustomAttributeTypeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (CodedIndex == 0)  	Value = null;  else {  	var table = CodedIndex & 0x7;  	var index = (int)(CodedIndex >> 3);  	switch (table) {  	case 0:  	case 1:  	case 4:  		throw new PEException ("unused CustomAttributeType coded index");  	case 2:  		Value = ctxt.Tables.MethodDefTable [index];  		break;  	case 3:  		Value = ctxt.Tables.MemberRefTable [index];  		break;  	default:  		throw new PEException ("invalid CustomAttributeType coded index");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,CustomAttributeTypeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: switch (table) {  case 0:  case 1:  case 4:  	throw new PEException ("unused CustomAttributeType coded index");  case 2:  	Value = ctxt.Tables.MethodDefTable [index];  	break;  case 3:  	Value = ctxt.Tables.MemberRefTable [index];  	break;  default:  	throw new PEException ("invalid CustomAttributeType coded index");  }  
Magic Number,Microsoft.LiveLabs.PE,CustomAttributeTypeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: switch (table) {  case 0:  case 1:  case 4:  	throw new PEException ("unused CustomAttributeType coded index");  case 2:  	Value = ctxt.Tables.MethodDefTable [index];  	break;  case 3:  	Value = ctxt.Tables.MemberRefTable [index];  	break;  default:  	throw new PEException ("invalid CustomAttributeType coded index");  }  
Magic Number,Microsoft.LiveLabs.PE,CustomAttributeTypeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: switch (table) {  case 0:  case 1:  case 4:  	throw new PEException ("unused CustomAttributeType coded index");  case 2:  	Value = ctxt.Tables.MethodDefTable [index];  	break;  case 3:  	Value = ctxt.Tables.MemberRefTable [index];  	break;  default:  	throw new PEException ("invalid CustomAttributeType coded index");  }  
Magic Number,Microsoft.LiveLabs.PE,CustomAttributeTypeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 3 | 2;  		break;  	case TableTag.MemberRef:  		CodedIndex = (uint)Value.Index << 3 | 3;  		break;  	default:  		throw new PEException ("invalid CustomAttributeType row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,CustomAttributeTypeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 3 | 2;  		break;  	case TableTag.MemberRef:  		CodedIndex = (uint)Value.Index << 3 | 3;  		break;  	default:  		throw new PEException ("invalid CustomAttributeType row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,CustomAttributeTypeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 3 | 2;  		break;  	case TableTag.MemberRef:  		CodedIndex = (uint)Value.Index << 3 | 3;  		break;  	default:  		throw new PEException ("invalid CustomAttributeType row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,CustomAttributeTypeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.MethodDef:  		CodedIndex = (uint)Value.Index << 3 | 2;  		break;  	case TableTag.MemberRef:  		CodedIndex = (uint)Value.Index << 3 | 3;  		break;  	default:  		throw new PEException ("invalid CustomAttributeType row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,CustomAttributeTypeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 3 | 2;  	break;  case TableTag.MemberRef:  	CodedIndex = (uint)Value.Index << 3 | 3;  	break;  default:  	throw new PEException ("invalid CustomAttributeType row");  }  
Magic Number,Microsoft.LiveLabs.PE,CustomAttributeTypeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 3 | 2;  	break;  case TableTag.MemberRef:  	CodedIndex = (uint)Value.Index << 3 | 3;  	break;  default:  	throw new PEException ("invalid CustomAttributeType row");  }  
Magic Number,Microsoft.LiveLabs.PE,CustomAttributeTypeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 3 | 2;  	break;  case TableTag.MemberRef:  	CodedIndex = (uint)Value.Index << 3 | 3;  	break;  default:  	throw new PEException ("invalid CustomAttributeType row");  }  
Magic Number,Microsoft.LiveLabs.PE,CustomAttributeTypeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.MethodDef:  	CodedIndex = (uint)Value.Index << 3 | 2;  	break;  case TableTag.MemberRef:  	CodedIndex = (uint)Value.Index << 3 | 3;  	break;  default:  	throw new PEException ("invalid CustomAttributeType row");  }  
Magic Number,Microsoft.LiveLabs.PE,CustomAttributeTypeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 3 | 2;  
Magic Number,Microsoft.LiveLabs.PE,CustomAttributeTypeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 3 | 2;  
Magic Number,Microsoft.LiveLabs.PE,CustomAttributeTypeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 3 | 3;  
Magic Number,Microsoft.LiveLabs.PE,CustomAttributeTypeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 3 | 3;  
Magic Number,Microsoft.LiveLabs.PE,ResolutionScopeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (CodedIndex == 0)  	Value = null;  else {  	var table = CodedIndex & 0x3;  	var index = (int)(CodedIndex >> 2);  	switch (table) {  	case 0:  		Value = ctxt.Tables.ModuleTable [index];  		break;  	case 1:  		Value = ctxt.Tables.ModuleRefTable [index];  		break;  	case 2:  		Value = ctxt.Tables.AssemblyRefTable [index];  		break;  	case 3:  		Value = ctxt.Tables.TypeRefTable [index];  		break;  	default:  		throw new PEException ("invalid ResolutionScope coded index tag");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,ResolutionScopeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (CodedIndex == 0)  	Value = null;  else {  	var table = CodedIndex & 0x3;  	var index = (int)(CodedIndex >> 2);  	switch (table) {  	case 0:  		Value = ctxt.Tables.ModuleTable [index];  		break;  	case 1:  		Value = ctxt.Tables.ModuleRefTable [index];  		break;  	case 2:  		Value = ctxt.Tables.AssemblyRefTable [index];  		break;  	case 3:  		Value = ctxt.Tables.TypeRefTable [index];  		break;  	default:  		throw new PEException ("invalid ResolutionScope coded index tag");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,ResolutionScopeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (CodedIndex == 0)  	Value = null;  else {  	var table = CodedIndex & 0x3;  	var index = (int)(CodedIndex >> 2);  	switch (table) {  	case 0:  		Value = ctxt.Tables.ModuleTable [index];  		break;  	case 1:  		Value = ctxt.Tables.ModuleRefTable [index];  		break;  	case 2:  		Value = ctxt.Tables.AssemblyRefTable [index];  		break;  	case 3:  		Value = ctxt.Tables.TypeRefTable [index];  		break;  	default:  		throw new PEException ("invalid ResolutionScope coded index tag");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,ResolutionScopeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: switch (table) {  case 0:  	Value = ctxt.Tables.ModuleTable [index];  	break;  case 1:  	Value = ctxt.Tables.ModuleRefTable [index];  	break;  case 2:  	Value = ctxt.Tables.AssemblyRefTable [index];  	break;  case 3:  	Value = ctxt.Tables.TypeRefTable [index];  	break;  default:  	throw new PEException ("invalid ResolutionScope coded index tag");  }  
Magic Number,Microsoft.LiveLabs.PE,ResolutionScopeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: switch (table) {  case 0:  	Value = ctxt.Tables.ModuleTable [index];  	break;  case 1:  	Value = ctxt.Tables.ModuleRefTable [index];  	break;  case 2:  	Value = ctxt.Tables.AssemblyRefTable [index];  	break;  case 3:  	Value = ctxt.Tables.TypeRefTable [index];  	break;  default:  	throw new PEException ("invalid ResolutionScope coded index tag");  }  
Magic Number,Microsoft.LiveLabs.PE,ResolutionScopeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 2;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 2 | 1;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 2 | 2;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 2 | 3;  		break;  	default:  		throw new PEException ("invalid ResolutionScope row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,ResolutionScopeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 2;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 2 | 1;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 2 | 2;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 2 | 3;  		break;  	default:  		throw new PEException ("invalid ResolutionScope row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,ResolutionScopeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 2;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 2 | 1;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 2 | 2;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 2 | 3;  		break;  	default:  		throw new PEException ("invalid ResolutionScope row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,ResolutionScopeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 2;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 2 | 1;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 2 | 2;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 2 | 3;  		break;  	default:  		throw new PEException ("invalid ResolutionScope row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,ResolutionScopeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 2;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 2 | 1;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 2 | 2;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 2 | 3;  		break;  	default:  		throw new PEException ("invalid ResolutionScope row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,ResolutionScopeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	switch (Value.Tag) {  	case TableTag.Module:  		CodedIndex = (uint)Value.Index << 2;  		break;  	case TableTag.ModuleRef:  		CodedIndex = (uint)Value.Index << 2 | 1;  		break;  	case TableTag.AssemblyRef:  		CodedIndex = (uint)Value.Index << 2 | 2;  		break;  	case TableTag.TypeRef:  		CodedIndex = (uint)Value.Index << 2 | 3;  		break;  	default:  		throw new PEException ("invalid ResolutionScope row");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,ResolutionScopeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 2;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 2 | 1;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 2 | 2;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 2 | 3;  	break;  default:  	throw new PEException ("invalid ResolutionScope row");  }  
Magic Number,Microsoft.LiveLabs.PE,ResolutionScopeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 2;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 2 | 1;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 2 | 2;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 2 | 3;  	break;  default:  	throw new PEException ("invalid ResolutionScope row");  }  
Magic Number,Microsoft.LiveLabs.PE,ResolutionScopeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 2;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 2 | 1;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 2 | 2;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 2 | 3;  	break;  default:  	throw new PEException ("invalid ResolutionScope row");  }  
Magic Number,Microsoft.LiveLabs.PE,ResolutionScopeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 2;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 2 | 1;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 2 | 2;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 2 | 3;  	break;  default:  	throw new PEException ("invalid ResolutionScope row");  }  
Magic Number,Microsoft.LiveLabs.PE,ResolutionScopeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 2;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 2 | 1;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 2 | 2;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 2 | 3;  	break;  default:  	throw new PEException ("invalid ResolutionScope row");  }  
Magic Number,Microsoft.LiveLabs.PE,ResolutionScopeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: switch (Value.Tag) {  case TableTag.Module:  	CodedIndex = (uint)Value.Index << 2;  	break;  case TableTag.ModuleRef:  	CodedIndex = (uint)Value.Index << 2 | 1;  	break;  case TableTag.AssemblyRef:  	CodedIndex = (uint)Value.Index << 2 | 2;  	break;  case TableTag.TypeRef:  	CodedIndex = (uint)Value.Index << 2 | 3;  	break;  default:  	throw new PEException ("invalid ResolutionScope row");  }  
Magic Number,Microsoft.LiveLabs.PE,ResolutionScopeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 2;  
Magic Number,Microsoft.LiveLabs.PE,ResolutionScopeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 2 | 1;  
Magic Number,Microsoft.LiveLabs.PE,ResolutionScopeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 2 | 2;  
Magic Number,Microsoft.LiveLabs.PE,ResolutionScopeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 2 | 2;  
Magic Number,Microsoft.LiveLabs.PE,ResolutionScopeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 2 | 3;  
Magic Number,Microsoft.LiveLabs.PE,ResolutionScopeRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = (uint)Value.Index << 2 | 3;  
Magic Number,Microsoft.LiveLabs.PE,TokenRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (CodedIndex == 0)  	Value = null;  else {  	var table = (TableTag)(CodedIndex >> 24);  	var index = (int)(CodedIndex & 0xffffff);  	switch (table) {  	case TableTag.Assembly:  		Value = ctxt.Tables.AssemblyTable [index];  		break;  	case TableTag.AssemblyOS:  		Value = ctxt.Tables.AssemblyOSTable [index];  		break;  	case TableTag.AssemblyProcessor:  		Value = ctxt.Tables.AssemblyProcessorTable [index];  		break;  	case TableTag.AssemblyRef:  		Value = ctxt.Tables.AssemblyRefTable [index];  		break;  	case TableTag.AssemblyRefOS:  		Value = ctxt.Tables.AssemblyRefOSTable [index];  		break;  	case TableTag.AssemblyRefProcessor:  		Value = ctxt.Tables.AssemblyRefProcessorTable [index];  		break;  	case TableTag.ClassLayout:  		Value = ctxt.Tables.ClassLayoutTable [index];  		break;  	case TableTag.Constant:  		Value = ctxt.Tables.ConstantTable [index];  		break;  	case TableTag.CustomAttribute:  		Value = ctxt.Tables.CustomAttributeTable [index];  		break;  	case TableTag.DeclSecurity:  		Value = ctxt.Tables.DeclSecurityTable [index];  		break;  	case TableTag.EventMap:  		Value = ctxt.Tables.EventMapTable [index];  		break;  	case TableTag.Event:  		Value = ctxt.Tables.EventTable [index];  		break;  	case TableTag.ExportedType:  		Value = ctxt.Tables.ExportedTypeTable [index];  		break;  	case TableTag.Field:  		Value = ctxt.Tables.FieldTable [index];  		break;  	case TableTag.FieldLayout:  		Value = ctxt.Tables.FieldLayoutTable [index];  		break;  	case TableTag.FieldMarshal:  		Value = ctxt.Tables.FieldMarshalTable [index];  		break;  	case TableTag.FieldRVA:  		Value = ctxt.Tables.FieldRVATable [index];  		break;  	case TableTag.File:  		Value = ctxt.Tables.FileTable [index];  		break;  	case TableTag.GenericParam:  		Value = ctxt.Tables.GenericParamTable [index];  		break;  	case TableTag.GenericParamConstraint:  		Value = ctxt.Tables.GenericParamConstraintTable [index];  		break;  	case TableTag.ImplMap:  		Value = ctxt.Tables.ImplMapTable [index];  		break;  	case TableTag.InterfaceImpl:  		Value = ctxt.Tables.InterfaceImplTable [index];  		break;  	case TableTag.ManifestResource:  		Value = ctxt.Tables.ManifestResourceTable [index];  		break;  	case TableTag.MemberRef:  		Value = ctxt.Tables.MemberRefTable [index];  		break;  	case TableTag.MethodDef:  		Value = ctxt.Tables.MethodDefTable [index];  		break;  	case TableTag.MethodImpl:  		Value = ctxt.Tables.MethodImplTable [index];  		break;  	case TableTag.MethodSemantics:  		Value = ctxt.Tables.MethodSemanticsTable [index];  		break;  	case TableTag.MethodSpec:  		Value = ctxt.Tables.MethodSpecTable [index];  		break;  	case TableTag.Module:  		Value = ctxt.Tables.ModuleTable [index];  		break;  	case TableTag.ModuleRef:  		Value = ctxt.Tables.ModuleRefTable [index];  		break;  	case TableTag.NestedClass:  		Value = ctxt.Tables.NestedClassTable [index];  		break;  	case TableTag.Param:  		Value = ctxt.Tables.ParamTable [index];  		break;  	case TableTag.Property:  		Value = ctxt.Tables.PropertyTable [index];  		break;  	case TableTag.PropertyMap:  		Value = ctxt.Tables.PropertyMapTable [index];  		break;  	case TableTag.StandAloneSig:  		Value = ctxt.Tables.StandAloneSigTable [index];  		break;  	case TableTag.TypeDef:  		Value = ctxt.Tables.TypeDefTable [index];  		break;  	case TableTag.TypeRef:  		Value = ctxt.Tables.TypeRefTable [index];  		break;  	case TableTag.TypeSpec:  		Value = ctxt.Tables.TypeSpecTable [index];  		break;  	default:  		throw new PEException ("invalid metadata token table");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,TokenRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: if (Value == null)  	CodedIndex = 0;  else {  	var table = (uint)Value.Tag;  	var index = (uint)Value.Index;  	CodedIndex = table << 24 | (index & 0xffffff);  }  
Magic Number,Microsoft.LiveLabs.PE,TokenRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,PersistIndexes,The following statement contains a magic number: CodedIndex = table << 24 | (index & 0xffffff);  
Magic Number,Microsoft.LiveLabs.PE,TypeDefOrRefVarLenRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (CodedIndex == 0)  	Value = null;  else {  	var table = CodedIndex & 0x3;  	var index = (int)(CodedIndex >> 2);  	switch (table) {  	case 0:  		Value = ctxt.Tables.TypeDefTable [index];  		break;  	case 1:  		Value = ctxt.Tables.TypeRefTable [index];  		break;  	case 2:  		Value = ctxt.Tables.TypeSpecTable [index];  		break;  	default:  		throw new PEException ("invalid TypeDefOrRef coded index");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,TypeDefOrRefVarLenRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: if (CodedIndex == 0)  	Value = null;  else {  	var table = CodedIndex & 0x3;  	var index = (int)(CodedIndex >> 2);  	switch (table) {  	case 0:  		Value = ctxt.Tables.TypeDefTable [index];  		break;  	case 1:  		Value = ctxt.Tables.TypeRefTable [index];  		break;  	case 2:  		Value = ctxt.Tables.TypeSpecTable [index];  		break;  	default:  		throw new PEException ("invalid TypeDefOrRef coded index");  	}  }  
Magic Number,Microsoft.LiveLabs.PE,TypeDefOrRefVarLenRef,C:\repos\Reactive-Extensions_IL2JS\PE\Refs.cs,ResolveIndexes,The following statement contains a magic number: switch (table) {  case 0:  	Value = ctxt.Tables.TypeDefTable [index];  	break;  case 1:  	Value = ctxt.Tables.TypeRefTable [index];  	break;  case 2:  	Value = ctxt.Tables.TypeSpecTable [index];  	break;  default:  	throw new PEException ("invalid TypeDefOrRef coded index");  }  
Magic Number,Microsoft.LiveLabs.PE,PrimitiveTypeSig,C:\repos\Reactive-Extensions_IL2JS\PE\Signature.cs,ByteSize,The following statement contains a magic number: switch (PrimitiveType) {  case PrimitiveType.Boolean:  case PrimitiveType.Int8:  case PrimitiveType.UInt8:  	return 1;  case PrimitiveType.Char:  case PrimitiveType.Int16:  case PrimitiveType.UInt16:  	return 2;  case PrimitiveType.Int32:  case PrimitiveType.UInt32:  case PrimitiveType.Single:  	return 4;  case PrimitiveType.Int64:  case PrimitiveType.UInt64:  case PrimitiveType.Double:  	return 8;  case PrimitiveType.Void:  	throw new PEException ("void type does not have a size");  case PrimitiveType.IntNative:  case PrimitiveType.UIntNative:  case PrimitiveType.String:  case PrimitiveType.TypedRef:  case PrimitiveType.Type:  case PrimitiveType.Object:  	throw new PEException ("cannot determine size of type");  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.PE,PrimitiveTypeSig,C:\repos\Reactive-Extensions_IL2JS\PE\Signature.cs,ByteSize,The following statement contains a magic number: switch (PrimitiveType) {  case PrimitiveType.Boolean:  case PrimitiveType.Int8:  case PrimitiveType.UInt8:  	return 1;  case PrimitiveType.Char:  case PrimitiveType.Int16:  case PrimitiveType.UInt16:  	return 2;  case PrimitiveType.Int32:  case PrimitiveType.UInt32:  case PrimitiveType.Single:  	return 4;  case PrimitiveType.Int64:  case PrimitiveType.UInt64:  case PrimitiveType.Double:  	return 8;  case PrimitiveType.Void:  	throw new PEException ("void type does not have a size");  case PrimitiveType.IntNative:  case PrimitiveType.UIntNative:  case PrimitiveType.String:  case PrimitiveType.TypedRef:  case PrimitiveType.Type:  case PrimitiveType.Object:  	throw new PEException ("cannot determine size of type");  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.PE,PrimitiveTypeSig,C:\repos\Reactive-Extensions_IL2JS\PE\Signature.cs,ByteSize,The following statement contains a magic number: switch (PrimitiveType) {  case PrimitiveType.Boolean:  case PrimitiveType.Int8:  case PrimitiveType.UInt8:  	return 1;  case PrimitiveType.Char:  case PrimitiveType.Int16:  case PrimitiveType.UInt16:  	return 2;  case PrimitiveType.Int32:  case PrimitiveType.UInt32:  case PrimitiveType.Single:  	return 4;  case PrimitiveType.Int64:  case PrimitiveType.UInt64:  case PrimitiveType.Double:  	return 8;  case PrimitiveType.Void:  	throw new PEException ("void type does not have a size");  case PrimitiveType.IntNative:  case PrimitiveType.UIntNative:  case PrimitiveType.String:  case PrimitiveType.TypedRef:  case PrimitiveType.Type:  case PrimitiveType.Object:  	throw new PEException ("cannot determine size of type");  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.PE,PrimitiveTypeSig,C:\repos\Reactive-Extensions_IL2JS\PE\Signature.cs,ByteSize,The following statement contains a magic number: return 2;  
Magic Number,Microsoft.LiveLabs.PE,PrimitiveTypeSig,C:\repos\Reactive-Extensions_IL2JS\PE\Signature.cs,ByteSize,The following statement contains a magic number: return 4;  
Magic Number,Microsoft.LiveLabs.PE,PrimitiveTypeSig,C:\repos\Reactive-Extensions_IL2JS\PE\Signature.cs,ByteSize,The following statement contains a magic number: return 8;  
Magic Number,Microsoft.LiveLabs.PE,PEHeaderStandardFields,C:\repos\Reactive-Extensions_IL2JS\PE\Structures.cs,Deref,The following statement contains a magic number: EntryPoint.Value = EntryPoint.GetReaderNonNull (ctxt).ReadBytes (6);  
Magic Number,Microsoft.LiveLabs.PE,SectionHeader,C:\repos\Reactive-Extensions_IL2JS\PE\Structures.cs,Write,The following statement contains a magic number: writer.WriteAsciiZeroPaddedString (name' 8);  
Magic Number,Microsoft.LiveLabs.PE,ImportLookupOrAddressTable,C:\repos\Reactive-Extensions_IL2JS\PE\Structures.cs,Read,The following statement contains a magic number: if (HintNameTable.Address >> 31 != 0)  	throw new PEException ("invalid ImportLookupTable/ImportAddressTable.HintNameTable");  
Magic Number,Microsoft.LiveLabs.PE,FixupEntry,C:\repos\Reactive-Extensions_IL2JS\PE\Structures.cs,Read,The following statement contains a magic number: Type = (ImageRelocation)(word >> 12);  
Magic Number,Microsoft.LiveLabs.PE,FixupBlock,C:\repos\Reactive-Extensions_IL2JS\PE\Structures.cs,Skip,The following statement contains a magic number: reader.Offset += 4;  
Magic Number,Microsoft.LiveLabs.PE,FixupBlock,C:\repos\Reactive-Extensions_IL2JS\PE\Structures.cs,Skip,The following statement contains a magic number: reader.Offset += blockSize - 8;  
Magic Number,Microsoft.LiveLabs.PE,FixupBlock,C:\repos\Reactive-Extensions_IL2JS\PE\Structures.cs,Read,The following statement contains a magic number: reader.Align (4);  
Magic Number,Microsoft.LiveLabs.PE,FixupBlock,C:\repos\Reactive-Extensions_IL2JS\PE\Structures.cs,Write,The following statement contains a magic number: writer.Align (4);  
Magic Number,Microsoft.LiveLabs.PE,StreamHeader,C:\repos\Reactive-Extensions_IL2JS\PE\Structures.cs,Read,The following statement contains a magic number: Name = reader.ReadAsciiZeroTerminatedString (4);  
Magic Number,Microsoft.LiveLabs.PE,StreamHeader,C:\repos\Reactive-Extensions_IL2JS\PE\Structures.cs,Write,The following statement contains a magic number: writer.WriteAsciiZeroTerminatedString (Name' 4);  
Magic Number,Microsoft.LiveLabs.PE,MetadataHeader,C:\repos\Reactive-Extensions_IL2JS\PE\Structures.cs,Read,The following statement contains a magic number: Version = reader.ReadUTF8SizedZeroPaddedString (4);  
Magic Number,Microsoft.LiveLabs.PE,MetadataHeader,C:\repos\Reactive-Extensions_IL2JS\PE\Structures.cs,Write,The following statement contains a magic number: writer.WriteUTF8SizedZeroPaddedString (Version' 4);  
Magic Number,Microsoft.LiveLabs.PE,Row,C:\repos\Reactive-Extensions_IL2JS\PE\Tables.cs,GetHashCode,The following statement contains a magic number: res ^= (uint)Index >> 7;  
Magic Number,Microsoft.LiveLabs.PE,Row,C:\repos\Reactive-Extensions_IL2JS\PE\Tables.cs,GetHashCode,The following statement contains a magic number: res ^= (uint)Index << 25;  
